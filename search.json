[{"title":"Flutter调试debug或者打包release帧率只有60的原因","path":"/2024/08/25/flutter_60hz/","content":"问题描述最近发现Flutter中引入像素较大的静态图片或者字体导致调试或者打包之后在高刷手机上帧率只有60的问题。 测试设备为小米13，可在开发者选项中直接打开帧率显示， 也可使用statsfl插件显示帧率 StatsFl( maxFps: 120, // Support custom FPS target (default is 60) align: Alignment.bottomCenter, //Alignment of statsbox child: MyApp(),), 解决方案小米手机 &#x3D;&gt; 设置 &#x3D;&gt; 电量和性能 &#x3D;&gt; 清除所有数据。 通过上述步骤APP即可回到120Hz。但是在DEBUG模式下，还是会回到60Hz。不过在打Release包之后，使用上述步骤可让APP回到120Hz，且不会掉60Hz。大家在开发的时候不用过于担心，Flutter是支持120Hz的 其他问题大图片问题可以适当缩小图片分辨率以及压缩图片。 1、PS中先将图片转换为智能对象，然后调整图像大小（按像素），之后保存图片。这样做可以最大限度保留清晰度。 Photopea | Online Photo Editor 【在线PS】PS软件网页版_ps在线图片处理工具photopea-江下科技在线应用 (onlinedo.cn) 【在线PS】PS软件网页版，ps在线图片处理工具photopea-稿定设计PS (gaoding.com) 2、图片压缩网站推荐 https://www.bejson.com/ui/compress_img/ Caesium Image Compressor - Online 字体问题不能通过静态字体方式，可以将网络字体下载到本地，然后动态加载。 1、字体初始化工具类 import &#x27;dart:io&#x27;;import &#x27;package:flutter/services.dart&#x27;;import &#x27;package:muen_edu_app/network/dio/dio_instance.dart&#x27;;import &#x27;package:muen_edu_app/utils/file_utils.dart&#x27;;class FontUtils &#123; static FontUtils? _instan; final Map&lt;String, String&gt; fontFamilies = &#123; &quot;JiangCheng&quot;: &quot;https://xxx.ttf&quot;, &quot;SegoeUI&quot;: &quot;https://xxx.ttf&quot;, &#125;; final String fontFloder = &quot;fonts&quot;; FontUtils._(); static FontUtils get instan =&gt; _instan ??= FontUtils._(); Future initiaFont() async &#123; String jiangCheng = await FileUtils.ins.getLocalDocumentFile(fontFloder, &quot;JiangCheng.ttf&quot;); String segoeUI = await FileUtils.ins.getLocalDocumentFile(fontFloder, &quot;SegoeUI.ttf&quot;); await loadFont(File(jiangCheng), &quot;JiangCheng&quot;); await loadFont(File(segoeUI), &quot;SegoeUI&quot;); &#125; /// 加载字体 Future loadFont(File fontFile, String fontFamily) async &#123; if (!fontFile.existsSync()) &#123; // 没有字体，去下载 await downloadFont(fontFamilies[fontFamily]!, fontFamily); &#125; Future&lt;ByteData&gt; readFont() async &#123; ByteData byteData = (await fontFile.readAsBytes()).buffer.asByteData(); return byteData; &#125; FontLoader loader = FontLoader(fontFamily); loader.addFont(readFont()); await loader.load(); &#125; Future&lt;String&gt; downloadFont(String url, String fontFamily) async &#123; String savePath = await FileUtils.ins.getLocalDocumentFile(fontFloder, &#x27;$fontFamily.ttf&#x27;); await DioInstance.instan.download(url, savePath); return savePath; &#125;&#125; 2、文件工具类 import &#x27;dart:io&#x27;;import &#x27;package:muen_edu_app/network/dio/dio_instance.dart&#x27;;import &#x27;package:path_provider/path_provider.dart&#x27;;class FileUtils &#123; static FileUtils? _ins; FileUtils._(); static FileUtils get ins &#123; return _ins ??= FileUtils._(); &#125; /// 获取文档目录文件 Future&lt;String&gt; getLocalDocumentFile(String folder, String filename) async &#123; final dir = await getApplicationDocumentsDirectory(); return &#x27;$&#123;dir.path&#125;/$folder/$filename&#x27;; &#125; /// 获取临时目录文件 Future&lt;String&gt; getLocalTemporaryFile(String folder, String filename) async &#123; final dir = await getTemporaryDirectory(); return &#x27;$&#123;dir.path&#125;/$folder/$filename&#x27;; &#125; /// 获取应用程序目录文件 Future&lt;String&gt; getLocalSupportFile(String folder, String filename) async &#123; final dir = await getApplicationSupportDirectory(); return &#x27;$&#123;dir.path&#125;/$folder/$filename&#x27;; &#125;&#125; 3、dio下载 Future&lt;Response&gt; download( String url, String savePath, &#123; CancelToken? cancelToken, Options? options, void Function(int, int)? onReceiveProgress,&#125;) async &#123; return await _dio.download( url, savePath, onReceiveProgress: onReceiveProgress, options: options ?? Options( method: HttpMethods.get, responseType: ResponseType.bytes, receiveTimeout: _defaultTime, sendTimeout: _defaultTime, ), );&#125; 4、调用初始化方法 FontUtils.instan.initiaFont(); 5、设置全局默认字体 ThemeData(fontFamily: &#x27;JiangCheng&#x27;);","tags":["Flutter"],"categories":["前端开发"]},{"title":"使用策略模式设计Elasticsearch数据初始化接口","path":"/2023/11/05/使用策略模式设计Elasticsearch数据初始化接口/","content":"接口要求： 使用策略模式，请求携带不同参数，接口执行不同数据的初始化方法 接口只能使用一次，即初始化完成之后，接口无法再调用 策略类创建策略类，QueryObject 为查询参数，clazz为ES文档类，用于类型转换 EsDataInitStrategy@Getter@Setterstatic class EsDataInitStrategy &#123; private Function&lt;QueryObject, R&lt;List&lt;Object&gt;&gt;&gt; function; private Class&lt;?&gt; clazz; public EsDataInitStrategy(Function&lt;QueryObject, R&lt;List&lt;Object&gt;&gt;&gt; function, Class&lt;?&gt; clazz) &#123; this.function = function; this.clazz = clazz; &#125;&#125; 查询参数 QueryObject QueryObject@Getter@Setter@NoArgsConstructorpublic class QueryObject &#123; private String keyword; private Integer current = 1; private Integer size = 10; public QueryObject(Integer current, Integer size) &#123; this.current = current; this.size = size; &#125; public Integer getOffset() &#123; return (current - 1) * size; &#125;&#125; 响应参数 R R@Setter@Getter@NoArgsConstructorpublic class R&lt;T&gt; &#123; public static final int CODE_SUCCESS = 200; public static final String MSG_SUCCESS = &quot;操作成功&quot;; public static final int CODE_NOLOGIN = 401; public static final String MSG_NOLOGIN = &quot;请先登陆&quot;; public static final int CODE_ERROR = 500; public static final int CODE_REGISTER_ERROR = 500; public static final String MSG_ERROR = &quot;系统异常，请联系管理员&quot;; public static final int CODE_ERROR_PARAM = 501; private int code; private String msg; private T data; public R(int code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125; public static &lt;T&gt; R&lt;T&gt; ok(T data) &#123; return new R&lt;&gt;(CODE_SUCCESS, MSG_SUCCESS, data); &#125; public static &lt;T&gt; R&lt;T&gt; ok() &#123; return new R&lt;&gt;(CODE_SUCCESS, MSG_SUCCESS, null); &#125; public static &lt;T&gt; R&lt;T&gt; error(int code, String msg, T data) &#123; return new R&lt;&gt;(code, msg, data); &#125; public static &lt;T&gt; R&lt;T&gt; error(int code, String msg) &#123; return new R&lt;&gt;(code, msg, null); &#125; public static &lt;T&gt; R&lt;T&gt; defaultError() &#123; return new R&lt;&gt;(CODE_ERROR, MSG_ERROR, null); &#125; public static &lt;T&gt; R&lt;T&gt; noLogin() &#123; return new R&lt;&gt;(CODE_NOLOGIN, MSG_NOLOGIN, null); &#125; public static &lt;T&gt; R&lt;T&gt; noPermission() &#123; return new R&lt;&gt;(403, &quot;非法访问&quot;, null); &#125; public T checkAndGet() &#123; if (this.code != CODE_SUCCESS) &#123; throw new BizException(code, msg); &#125; return data; &#125;&#125; 远程调用初始化接口所在微服务可能与需要初始化的数据不在不同，所用数据库不同。为此需要使用Feign远程调用获取数据 用户服务以获取用户信息为案例，远程调用用户微服务user-service，分页拉取用户数据 注意，因为使用策略模式，这里的返回结果为Object，也因此 Feign 会将返回的 JSON 结构转换为 LinkedHashMap 对象 UserInfoFeignService@FeignClient(&quot;user-service&quot;)public interface UserInfoFeignService &#123; /** * 如果 Feign 发起远程调用后，接收的类型没有明确具体类型是什么 * Feign 会将返回的 JSON 结构转换为 LinkedHashMap 对象 */ @GetMapping(&quot;/users/&quot;) R&lt;List&lt;Object&gt;&gt; findList(@RequestParam Integer current, @RequestParam Integer limit);&#125; 文章微服务以获取文章信息为案例，远程调用文章微服务user-service，分页拉取文章数据 使用Post请求，同时添加 @RequestBody 注解，QueryObject 中包含分页参数。 @FeignClient(&quot;article-service&quot;)public interface ArticleFeignService &#123; @PostMapping(&quot;/articles/search&quot;) public R&lt;List&lt;Object&gt;&gt; articleSearch(@RequestBody QueryObject qo);&#125; Redis服务接口被设计为只能访问一次，如果项目中使用了Redis，可以将该状态保存到Redis中，同时保证接口幂等性，即并发访问初始化接口，也只能初始化一次。 RedisService@Componentpublic class RedisService &#123; @Autowired public RedisTemplate redisTemplate; public Boolean setnx(String key, String value) &#123; return redisTemplate.opsForValue().setIfAbsent(key, value); &#125;&#125; 为了防止接口滥用，可以在配置文件中配置一个随机接口地址： es: init: key: hg345f67gfdh5yth34g56 Elasticsearch服务直接使用 ElasticsearchRestTemplate 的批量保存方法 ElasticsearchServicepublic interface ElasticsearchService &#123; /** * 批量新增方法 * @param iterable ES 实体对象集合 */ public void save(Iterable&lt;?&gt; iterable);&#125; 实现方法 ElasticsearchServiceImpl@Servicepublic class ElasticsearchServiceImpl implements ElasticsearchService &#123; @Autowired private ElasticsearchRestTemplate template; @Override public void save(Iterable&lt;?&gt; iterable) &#123; template.save(iterable); &#125;&#125; 接口设计@Slf4j@RestController@RequestMapping(&quot;/init&quot;)@RefreshScopepublic class ElasticsearchDataInitController &#123; public static final String INIT_USER = &quot;user&quot;; public static final String INIT_ARTICLE = &quot;article&quot;; public static final Integer BATCH_COUNT = 200; private final Map&lt;String, EsDataInitStrategy&gt; DATA_HANDLER_STRATEGY_MAP = new HashMap&lt;&gt;(); @Value(&quot;$&#123;es.init.key&#125;&quot;) private String initKey; private final RedisService redisService; private final UserInfoFeignService userInfoFeignService; private final ArticleFeignService articleFeignService; private final ElasticsearchService elasticsearchService; public ElasticsearchDataInitController(RedisService redisService, UserInfoFeignService userInfoFeignService, ArticleFeignService articleFeignService, ElasticsearchService elasticsearchService) &#123; this.redisService = redisService; this.userInfoFeignService = userInfoFeignService; this.articleFeignService = articleFeignService; this.elasticsearchService = elasticsearchService; &#125; @PostConstruct public void postConstruct() &#123; // 用户初始化 EsDataInitStrategy userInit = new EsDataInitStrategy((qo) -&gt; userInfoFeignService.findList(qo.getCurrent(), qo.getSize()), UserInfoEs.class); DATA_HANDLER_STRATEGY_MAP.put(INIT_USER, userInit); // 文章初始化 EsDataInitStrategy articleInit = new EsDataInitStrategy(articleFeignService::articleSearch, ArticleEs.class); DATA_HANDLER_STRATEGY_MAP.put(INIT_ARTICLE, articleInit); &#125; @GetMapping(&quot;/&#123;key&#125;/&#123;type&#125;&quot;) public ResponseEntity&lt;?&gt; init(@PathVariable(&quot;key&quot;) String key, @PathVariable(&quot;type&quot;) String type) &#123; log.info(&quot;[ES 数据初始化] -------------------- 数据初始化开始 --------------------&quot;); if (StringUtils.isEmpty(key) || !initKey.equals(key)) &#123; log.warn(&quot;[ES 数据初始化] 非法操作，请求参数有误 key=&#123;&#125;, type=&#123;&#125;, initKey=&#123;&#125;&quot;, key, type, initKey); return ResponseEntity.status(HttpStatus.FORBIDDEN).build(); &#125; // 用户访问过，就不允许再访问了 String redisKey = &quot;es:init:&quot; + key + type; Boolean ret = redisService.setnx(redisKey, &quot;initialized&quot;); if (ret == null || !ret) &#123; log.warn(&quot;[ES 数据初始化] 非法操作，已初始化过, redisKey=&#123;&#125;, ret=&#123;&#125;&quot;, redisKey, ret); return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); &#125; // 开始初始化数据 this.doInit(type); log.info(&quot;[ES 数据初始化] -------------------- 数据初始化完成 --------------------&quot;); return ResponseEntity.ok().body(&quot;init success&quot;); &#125; private void doInit(String type) &#123; int current = 1; do &#123; List&lt;Object&gt; list = handleRemoteDataList(current++, type); if (list == null || list.isEmpty()) &#123; log.info(&quot;[ES 数据初始化] 数据初始化完成.&quot;); return; &#125; elasticsearchService.save(list); &#125; while (true); &#125; /** * 获取并处理远程数据 */ private List&lt;Object&gt; handleRemoteDataList(Integer current, String type) &#123; EsDataInitStrategy strategy = DATA_HANDLER_STRATEGY_MAP.get(type); if (strategy == null) &#123; throw new BizException(&quot;初始化参数类型错误&quot;); &#125; R&lt;List&lt;Object&gt;&gt; ret = strategy.getFunction().apply(new QueryObject(current, BATCH_COUNT)); log.info(&quot;[ES 数据初始化] 初始化开始，查询&#123;&#125;数据 data=&#123;&#125;&quot;, type, JSON.toJSONString(ret)); List&lt;Object&gt; list = ret.checkAndGet(); if (list == null || list.isEmpty()) &#123; return list; &#125; List&lt;Object&gt; dataList = new ArrayList&lt;&gt;(list.size()); try &#123; Class&lt;?&gt; clazz = strategy.getClazz(); for (Object dto : list) &#123; Object es = clazz.getDeclaredConstructor().newInstance(); BeanUtils.copyProperties(es, dto); dataList.add(es); &#125; return dataList; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 食用教程初始化用户数据 curl --request GET \\ --url http://localhost:9000/search/init/hg345f67gfdh5yth34g56/user 初始化文章数据 curl --request GET \\ --url http://localhost:9000/search/init/hg345f67gfdh5yth34g56/article","tags":["Elasticsearch","数据初始化"],"categories":["后端开发"]},{"title":"多线程并发执行任务（自定义线程池）","path":"/2023/11/05/多线程执行任务（自定义线程池）/","content":"配置线程池创建线程池的方式： 1、使用 Executors 创建，不推荐， 默认创建的工作队列，使用的是 LinkedBlockingDeque 队列，且默认容量为 Integer 的最大值，工作队列的容量过大，会导致核心线程工作过载，对垒中任务数过多，且非核心线程无法参与处理，最终导致内存溢出 2、直接new ThreadPoolExecutor 对象，推荐 @Configurationpublic class AppConfig &#123; @Bean public ThreadPoolExecutor bizThreadPoolExecutor() &#123; return new ThreadPoolExecutor(10, 50, 10, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(100)); &#125;&#125; 参数说明： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;&#125; corePoolSize:指定了线程池中的线程数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到workQueue任务队列中去； maximumPoolSize:指定了线程池中的最大线程数量，这个参数会根据你使用的workQueue任务队列的类型，决定线程池会开辟的最大线程数量； keepAliveTime:当线程池中空闲线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁； unit:keepAliveTime的单位 workQueue:任务队列，被添加到线程池中，但尚未被执行的任务；它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列几种； threadFactory:线程工厂，用于创建线程，一般用默认即可； handler:拒绝策略；当任务太多来不及处理时，如何拒绝任务； 多线程执行任务使用一个 Mybatis Plus 项目举例：使用多线程发起查询请求，获取当前区域的子区域，例如广东省的子区域广州、深圳等 @Servicepublic class DestinationServiceImpl extends ServiceImpl&lt;DestinationMapper, Destination&gt; implements DestinationService &#123; private final ThreadPoolExecutor bizThreadPoolExecutor; public DestinationServiceImpl(ThreadPoolExecutor bizThreadPoolExecutor) &#123; this.bizThreadPoolExecutor = bizThreadPoolExecutor; &#125; /** * 使用代码循环方式，有N+1问题 * 使用多线程，同时发查询请求 * * @param rid 区域ID * @return 热门目的地 */ public List&lt;Destination&gt; findHostListThread(Long rid) &#123; List&lt;Destination&gt; destinations = null; LambdaQueryWrapper&lt;Destination&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); destinations = list(wrapper.eq(Destination::getParentId, 1)); // 如何等待所有异步线程结束，主线程再执行 CountDownLatch latch = new CountDownLatch(destinations.size()); for (Destination destination : destinations) &#123; // submit有返回值，且支持Callable，execute没有返回值，只支持Runnable bizThreadPoolExecutor.execute(() -&gt; &#123; List&lt;Destination&gt; children = list(Wrappers.&lt;Destination&gt;lambdaQuery().eq(Destination::getParentId, destination.getId()).last(&quot;limit 10&quot;)); destination.setChildren(children); // 倒计时数量-1 latch.countDown(); &#125;); &#125; // 返回结果前阻塞等待 try &#123; latch.await(10, TimeUnit.MINUTES); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return destinations; &#125;&#125;","tags":["Spring Boot","Java","多线程"],"categories":["后端开发"]},{"title":"Seata实现分布式事务","path":"/2023/08/23/Seata实现分布式事务/","content":"本文基于Seata 1.7.0搭建分布式事务Demo，实现简单的转账业务。使用Nacos作为配置中心和注册中心，使用Feign远程调用微服务。 本Demo工程的Git地址为：https://gitee.com/SX-Code/dtx-seata-demo 业务流程转账流程 Seata执行流程","tags":["Seata","Nacos"],"categories":["后端开发"]},{"title":"如何使用百度云内容审核","path":"/2023/08/17/如何使用百度云内容审核/","content":"截止2023年8月10号，使用百度云的内容审核只需要身份认证即可，且可领取免费的测试资源。 应用场景 用户评论过滤：对网站用户的评论信息进行检测，审核出涉及色情、暴恐、恶意推广等内容，保证良好的用户体验 注册信息筛查：对用户的注册信息进行筛查，避免黑产通过用户名实现违规信息的推广 文章内容审核：对UGC文章内容进行多个维度的审核，避免因内容违规导致的APP下架等损失 领取资源百度云的内容审核各服务均提供一定额度的免费测试资源供测试使用，免费测试资源使用完毕后，可选择付费使用。 各接口免费测试资源可见免费测试资源文档介绍。 进入领取页面，根据情况选择领取接口，左下角0元领取 个人认证： 内容审核平台-文本：一次性赠送50,000次，2 QPS，有效期 365天； 内容审核平台-图像：一次性赠送10,000次，2 QPS，有效期 365天。 创建应用列表调用百度AI服务需要Access_token，获取Access_token则需要通过应用的 API Key和 Secret Key，我们需要创建一个应用 创建完成之后，我们就得到了 API Key 和 Secret Key 获取AccessToken鉴权认证的主要目的是获取Access_token。Access_token是用户的访问令牌，承载了用户的身份、权限等信息。 使用我提供的工具类获取： 依赖： &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt;&lt;/dependency&gt; AuthUtil/** * 百度云鉴权认证工具 */public class AuthUtil &#123; private static Calendar expireDate; private static boolean flag = false; private static String accessToken; static final OkHttpClient HTTP_CLIENT = new OkHttpClient().newBuilder().build(); private static Boolean needAuth() &#123; Calendar c = Calendar.getInstance(); c.add(Calendar.DATE, 1); return !flag || c.after(expireDate); &#125; /** * 获取权限token * @return access_token */ public static String getAccessToken(String clientId, String clientSecret) throws Exception &#123; if (needAuth()) &#123; flag = true; JSONObject auth = getAuth(clientId, clientSecret); accessToken = auth.getString(&quot;access_token&quot;); expireDate = Calendar.getInstance(); expireDate.add(Calendar.SECOND, auth.getIntValue(&quot;expires_in&quot;)); &#125; return accessToken; &#125; /** * 从用户的AK，SK生成鉴权签名（Access Token） * * @return 鉴权签名（Access Token） * @throws IOException IO异常 */ private static JSONObject getAuth(String clientId, String clientSecret) throws Exception &#123; MediaType mediaType = MediaType.parse(&quot;application/json&quot;); RequestBody body = RequestBody.create(mediaType, &quot;&quot;); Request request = new Request.Builder() .url(String.format(URLConstants.BAIDU_AUTH_TOKEN, clientId, clientSecret)) .method(&quot;POST&quot;, body) .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .addHeader(&quot;Accept&quot;, &quot;application/json&quot;) .build(); Response response = HTTP_CLIENT.newCall(request).execute(); if (response.code() != HttpStatus.OK.value()) &#123; throw new RuntimeException(&quot;百度云AccessToken获取失败&quot;); &#125; return JSONObject.parseObject(response.body().string()); &#125;&#125; 内容审核服务内容审核平台-文本接口地址：https://aip.baidubce.com/rest/2.0/solution/v1/text_censor/v2/user_defined请求方式：POST接口名称：内容审核平台-文本 内容审核平台-图像接口地址：https://aip.baidubce.com/rest/2.0/solution/v1/img_censor/v2/user_defined请求方式：POST接口名称：内容审核平台-图像 返回参数说明： 参数名称 数据类型 是否必须 备注 log_id Long Y 请求唯一id error_code Long N 错误提示码，失败才返回，成功不返回 error_msg String N 错误提示信息，失败才返回，成功不返回 conclusion String N 审核结果，可取值：合规、不合规、疑似、审核失败 conclusionType Integer N 审核结果类型，可取值1.合规，2.不合规，3.疑似，4.审核失败 成功响应案例 &#123;\t&quot;log_id&quot;: 15556561295920002,\t&quot;conclusion&quot;: &quot;合规&quot;,\t&quot;conclusionType&quot;: 1&#125; 失败响应示例 &#123; &quot;log_id&quot;: 149319909347709, &quot;error_code&quot;: 0, &quot;error_msg&quot;:&quot;configId error&quot;&#125; 代码实现 依赖： &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; ContentCensor@Getter@Setter@Slf4j@Component@ConfigurationProperties(prefix = &quot;baiduyun&quot;)public class ContentCensor &#123; private String clientId; private String clientSecret; /** * 文本审核 * * @param text 待审核文本 * @return 审核结果 &#123; log_id, conclusion, conclusionType &#125; * @throws Exception 审核异常 */ public Map&lt;String, Object&gt; textCensor(String text) throws Exception &#123; String accessToken = AuthUtil.getAccessToken(clientId, clientSecret); FormBody formBody = new FormBody.Builder().add(&quot;text&quot;, text).build(); Request request = new Request.Builder() .url(String.format(URLConstants.BAIDU_TEXT_CENSOR, accessToken)) .method(&quot;POST&quot;, formBody) .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) .addHeader(&quot;Accept&quot;, &quot;application/json&quot;) .build(); Response response = AuthUtil.HTTP_CLIENT.newCall(request).execute(); String strBody = response.body().string(); if (response.code() != HttpStatus.OK.value()) &#123; JSONObject errObj = JSONObject.parseObject(strBody); log.error(&quot;百度文本审核接口调用失败：error_code: &#123;&#125;, error_msg: &#123;&#125;&quot;, errObj.getString(&quot;error_code&quot;), errObj.getString(&quot;error_msg&quot;)); throw new RuntimeException(&quot;百度文本审核接口调用失败&quot;); &#125; JSONObject resultObj = JSONObject.parseObject(strBody); Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put(&quot;log_id&quot;, resultObj.getString(&quot;log_id&quot;)); result.put(&quot;conclusion&quot;, resultObj.getString(&quot;conclusion&quot;)); result.put(&quot;conclusionType&quot;, resultObj.getShortValue(&quot;conclusionType&quot;)); return result; &#125; /** * 图像审核 * * @param imgParams 待审核图像列表 Base64字符串列表 * @return 审核结果 &#123; log_id, conclusion, conclusionType &#125; * @throws Exception 审核异常 */ public Map&lt;String, Object&gt; imgCensor(List&lt;String&gt; imgParams) throws Exception &#123; String accessToken = AuthUtil.getAccessToken(clientId, clientSecret); Request.Builder builder = new Request.Builder() .url(String.format(URLConstants.BAIDU_IMG_CENSOR, accessToken)) .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) .addHeader(&quot;Accept&quot;, &quot;application/json&quot;); Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); for (String imgParam : imgParams) &#123; FormBody formBody = new FormBody.Builder().add(&quot;image&quot;, imgParam).build(); Request request = builder.method(&quot;POST&quot;, formBody).build(); Response response = AuthUtil.HTTP_CLIENT.newCall(request).execute(); String strBody = response.body().string(); if (response.code() != HttpStatus.OK.value()) &#123; JSONObject errObj = JSONObject.parseObject(strBody); log.error(&quot;百度图像审核接口调用失败：error_code: &#123;&#125;, error_msg: &#123;&#125;&quot;, errObj.getString(&quot;error_code&quot;), errObj.getString(&quot;error_msg&quot;)); throw new RuntimeException(&quot;百度文本审核接口调用失败&quot;); &#125; JSONObject resultObj = JSONObject.parseObject(strBody); Short conclusionType = resultObj.getShort(&quot;conclusionType&quot;); // 审核不是通过 if (!Objects.equals(conclusionType, TextCensorResultEnum.COMPLIANCE.type())) &#123; result.put(&quot;log_id&quot;, resultObj.getString(&quot;log_id&quot;)); result.put(&quot;conclusion&quot;, resultObj.getString(&quot;conclusion&quot;)); result.put(&quot;conclusionType&quot;, resultObj.getShortValue(&quot;conclusionType&quot;)); return result; &#125; &#125; result.put(&quot;conclusionType&quot;, TextCensorResultEnum.COMPLIANCE.type()); return result; &#125;&#125; 常量的定义如下： URLConstantspublic class URLConstants &#123; public static final String BAIDU_AUTH_TOKEN = &quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s&quot;; public static final String BAIDU_TEXT_CENSOR = &quot;https://aip.baidubce.com/rest/2.0/solution/v1/text_censor/v2/user_defined?access_token=%s&quot;; public static final String BAIDU_IMG_CENSOR = &quot;https://aip.baidubce.com/rest/2.0/solution/v1/img_censor/v2/user_defined?access_token=%s&quot;;&#125; 枚举类的定义如下： public enum TextCensorResultEnum &#123; COMPLIANCE((short) 1, &quot;合规&quot;), NON_COMPLIANCE((short) 2, &quot;不合规&quot;), SUSPECTED((short) 3, &quot;疑似&quot;), AUDIT_FAILED((short) 4, &quot;审核失败&quot;); private final Short type; private final String desc; TextCensorResultEnum(Short type, String desc) &#123; this.type = type; this.desc = desc; &#125; public Short type() &#123; return type; &#125; public String desc() &#123; return desc; &#125;&#125; 自动装配 如果代码放在其他模块中，请使用该部分实现自动装配 在resources目录下创建META-INF/spring.factories，内容如下： spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.swx.common.baiduyun.ContentCensor 项目集成以上内容可以放在工具模块或者公共模块中，在服务模块中食用方式如下： 引入依赖（非服务模块）： pom.xml&lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;test-common&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 applicaton.yamlbaiduyun: client-id: xxxxxxxxxxxxxxxxxxxx client-secret: xxxxxxxxxxxxxxxxxxxxxxx 填入上述步骤获取的 API Key（client-id） 和 Secret Key（client-secret） 使用文本审核 /** * 审核文本内容 * * @param text 文本内容 * @return 是否审核通过 */private boolean handleTextScan(String text) &#123; try &#123; Map&lt;String, Object&gt; map = contentCensor.textCensor(text); Short type = (Short) map.get(&quot;conclusionType&quot;); if (type.equals(TextCensorResultEnum.NON_COMPLIANCE.type())) &#123; // 当前文本中存在违规内容 &#125; if (type.equals(TextCensorResultEnum.SUSPECTED.type())) &#123; // 当前文本中存在不确定性内容 &#125; if (type.equals(TextCensorResultEnum.AUDIT_FAILED.type())) &#123; // 自动审核失败，转人工审核 &#125; return type.equals(TextCensorResultEnum.COMPLIANCE.type()); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125;&#125; 使用图像审核 关于接口需要数据有两种格式： Base64字符串，需要编码之后的（本文使用） 图片URL地址 /** * 审核图片内容 * * @param images 图片地址列表 * @return 是否审核通过 */private boolean handleImageScan(List&lt;String&gt; images) &#123; List&lt;String&gt; imgParams = new ArrayList&lt;&gt;(); // 图片去重 images = images.stream().distinct().collect(Collectors.toList()); for (String image : images) &#123; // 下载图片，从url中获取为字节数据 byte[] imgData = downLoadFile(image); // 转为Base64，百度云接口要求 String imgStr = Base64Util.encode(imgData); String imgParam = URLEncoder.encode(imgStr, StandardCharsets.UTF_8); imgParams.add(imgParam); &#125; try &#123; Map&lt;String, Object&gt; map = contentCensor.imgCensor(imgParams); Short type = (Short) map.get(&quot;conclusionType&quot;); if (type.equals(TextCensorResultEnum.NON_COMPLIANCE.type())) &#123; // 存在违规内容 &#125; if (type.equals(TextCensorResultEnum.SUSPECTED.type())) &#123; // 图片疑似有违规内容 &#125; if (type.equals(TextCensorResultEnum.AUDIT_FAILED.type())) &#123; // 自动审核失败，转人工审核 &#125; return type.equals(TextCensorResultEnum.COMPLIANCE.type()); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125;&#125; Base64转换工具 Base64Util/** * Base64 工具类 */public class Base64Util &#123; private static final char last2byte = (char) Integer.parseInt(&quot;00000011&quot;, 2); private static final char last4byte = (char) Integer.parseInt(&quot;00001111&quot;, 2); private static final char last6byte = (char) Integer.parseInt(&quot;00111111&quot;, 2); private static final char lead6byte = (char) Integer.parseInt(&quot;11111100&quot;, 2); private static final char lead4byte = (char) Integer.parseInt(&quot;11110000&quot;, 2); private static final char lead2byte = (char) Integer.parseInt(&quot;11000000&quot;, 2); private static final char[] encodeTable = new char[]&#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;+&#x27;, &#x27;/&#x27;&#125;; public Base64Util() &#123; &#125; public static String encode(byte[] from) &#123; StringBuilder to = new StringBuilder((int) ((double) from.length * 1.34D) + 3); int num = 0; char currentByte = 0; int i; for (i = 0; i &lt; from.length; ++i) &#123; for (num %= 8; num &lt; 8; num += 6) &#123; switch (num) &#123; case 0: currentByte = (char) (from[i] &amp; lead6byte); currentByte = (char) (currentByte &gt;&gt;&gt; 2); case 1: case 3: case 5: default: break; case 2: currentByte = (char) (from[i] &amp; last6byte); break; case 4: currentByte = (char) (from[i] &amp; last4byte); currentByte = (char) (currentByte &lt;&lt; 2); if (i + 1 &lt; from.length) &#123; currentByte = (char) (currentByte | (from[i + 1] &amp; lead2byte) &gt;&gt;&gt; 6); &#125; break; case 6: currentByte = (char) (from[i] &amp; last2byte); currentByte = (char) (currentByte &lt;&lt; 4); if (i + 1 &lt; from.length) &#123; currentByte = (char) (currentByte | (from[i + 1] &amp; lead4byte) &gt;&gt;&gt; 4); &#125; &#125; to.append(encodeTable[currentByte]); &#125; &#125; if (to.length() % 4 != 0) &#123; for (i = 4 - to.length() % 4; i &gt; 0; --i) &#123; to.append(&quot;=&quot;); &#125; &#125; return to.toString(); &#125;&#125; 自维护敏感词汇可以使用DFA算法，使用确定有穷自动计机（一种数据结构）。","tags":["Java","文本审核","图片审核"],"categories":["后端开发"]},{"title":"使用Docker将Vite Vue项目部署到Nginx二级目录","path":"/2023/08/17/Vite-Vue项目部署到Nginx二级目录/","content":"使用Dockerfile构建Nginx的Docker镜像，并将vite项目拷贝到镜像中的Nginx目录下，在配置文件中配置Vite项目的二级映射目录。 Vue项目配置使用Vite创建一个Vue项目，点我查看如何创建 配置打包路径 在Nginx中如果是二级目录，例如/web时，需要设置线上的打包路径 在项目跟路径下创建两个文件：.env.production、.env.development，写入一下内容： .env.production##生产环境NODE_ENV = &#x27;production&#x27;VITE_BASE_PATH = /form-designer/.env.development##开发环境NODE_ENV = &#x27;development&#x27;VITE_BASE_PATH = &#x27;/&#x27; 在vite.config.js中配置base属性，打开配置文件： vite.config.jsimport &#123; defineConfig, loadEnv &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;// https://vitejs.dev/config/export default defineConfig((&#123; mode &#125;) =&gt;&#123; // 获取 .env 环境配置文件 const env = loadEnv(mode, process.cwd()); return &#123; base: env.VITE_BASE_PATH, plugins: [vue()], &#125;&#125;) 修改package.json，添加build命令： &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build --mode production&quot;, &quot;preview&quot;: &quot;vite preview&quot;&#125;, 配置路由打包项目使用下面命令打包 npm run build 压缩文件夹，方便上传到服务器进行打包部署 tar -zcvf dist.tar.gz dist/ Docker配置工作系统中需要安装Docker环境，打包镜像用。这里以CentOS为例安装Docker 使用下面命令安装： curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 出现命令提示，即为安装成功： [root@swcode docker]# dockerUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersCommon Commands: run Create and run a new container from an image exec Execute a command in a running container ps List containers build Build an image from a Dockerfile pull Download an image from a registry push Upload an image to a registry images List images login Log in to a registry logout Log out from a registry search Search Docker Hub for images version Show the Docker version information info Display system-wide information 配置Docker镜像源： 进入下面目录： cd /etc/docker/ 创建daemon.json，写入下面内容: daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;,&quot;https://docker.mirrors.ustc.edu.cn&quot;,&quot;https://mirror.baidubce.com&quot;,&quot;https://registry.docker-cn.com&quot;]&#125; 阿里云的镜像加速很好用的，点我获取加速地址 使配置生效 systemctl daemon-reloadsystemctl restart docker 制作镜像将文件上传到服务器上进行打包和发布，Dockerfile和要打包的文件需要在同一个目录下，确保服务器上已经安装Docker环境。 Dockerfile# Docker image for vue application# VERSION 1.0.0# Author: swcode### 基础镜像，使用nginx镜像FROM nginx#作者MAINTAINER swcode &lt;2627311935@qq.com&gt;#应用构建成功后的文件被复制到镜像内COPY dist /usr/share/nginx/html/form-designer/#拷贝.conf文件到镜像下，替换掉原有的nginx.confCOPY nginx.conf /etc/nginx/nginx.conf#启动容器时的进程ENTRYPOINT nginx -g &quot;daemon off;&quot; Nginx配置创建nginx.conf配置文件，基于location实现二级访问目录，修改配置信息： nginx.confworker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/json; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; location /form-designer &#123; alias /usr/share/nginx/html/form-designer; index index.html index.htm; try_files $uri $uri/ /form-designer/index.html; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; include servers/*;&#125; 注意！配置了root之后，其他的二级目录需要使用alias 上传文件将dist.tar.gz上传到服务器，使用下面命令解压 tar -zxvf dist.tar.gz 确保下面三个文件在同一目录 Dockerfilenginx.confdist/ build镜像使用下面命令，build镜像 docker build -t form-designer . form-designer：表示镜像名 ‘.’：表示当前目录 ngnix没有指定版本会自动拉取最新版，等待镜像build。。。 [root@swcode dockerfile]# docker build -t form-designer .[+] Building 0.1s (8/8) FINISHED =&gt; [internal] load build definition from Dockerfile 0.0s =&gt; =&gt; transferring dockerfile: 469B 0.0s =&gt; [internal] load .dockerignore 0.0s =&gt; =&gt; transferring context: 2B 0.0s =&gt; [internal] load metadata for docker.io/library/nginx:latest 0.0s =&gt; [1/3] FROM docker.io/library/nginx 0.0s =&gt; [internal] load build context 0.0s =&gt; =&gt; transferring context: 1.15kB 0.0s =&gt; CACHED [2/3] COPY dist /usr/share/nginx/html/form-designer/ 0.0s =&gt; [3/3] COPY nginx.conf /etc/nginx/nginx.conf 0.0s =&gt; exporting to image 0.0s =&gt; =&gt; exporting layers 0.0s =&gt; =&gt; writing image sha256:3212e45813e7d278aa33982cc7373e55418b9a3ed65c0249b8fd55c70bf6ee32 0.0s =&gt; =&gt; naming to docker.io/library/form-designer 使用docker命令查看镜像 [root@swcode dockerfile]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEform-designer latest 372e067b2c6a 48 minutes ago 190MB 运行容器使用下面命令运行容器： docker run --name form-designer-web -p 81:80 -d form-designer form-designer-web：是容器名 form-designer：是镜像名 -p 81:80：表示服务器端口(外部)81映射到容器内部端口80 使用docker命令查看容器 [root@swcode dockerfile]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES65f0979310a1 form-designer &quot;/bin/sh -c &#x27;nginx -…&quot; 48 minutes ago Up 48 minutes 0.0.0.0:81-&gt;80/tcp form-designer-web 访问网站访问网址：http://ip:81/form-designer 其他命令删除镜像docker rmi [镜像名 ｜ 镜像ID] 删除容器docker rm -f [容器名 ｜ 容器ID]","tags":["Vite","Vue","Docker"],"categories":["前端开发"]},{"title":"使用Jenkins部署Git仓库微服务项目","path":"/2023/08/17/使用Jenkins部署Git仓库微服务项目/","content":"Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具。本文使用Jenkins自动构建git仓库中的微服务项目，包括Jenkins的安装，插件的安装；系统环境的配置；docker镜像构建的远程SSH命令；部署到指定的机器等。 部署Jenkins安装JenkinsJenkins的官方安装文档地址： Linux上安装Jenkinshttps://www.jenkins.io/doc/book/installing/linux/#red-hat-centos 下面以CentOS为例演示安装过程： 使用下面命令，Jenkins添加仓库 sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key 如果已经导入过key，rpm --import可能会报错，忽略，继续下面命令： yum install fontconfig java-11-openjdkyum install jenkins 配置Jenkins使用下面命令编辑服务 vim /usr/lib/systemd/system/jenkins.service 修改用户为root User=rootGroup=root 修改启动端口 Environment=&quot;JENKINS_PORT=16060&quot; 修改完成后使用下面命令应用： systemctl daemon-reload 启动Jenkins使用以下命令启用Jenkins服务在启动时启动： sudo systemctl enable jenkins 使用以下命令启动Jenkins服务： sudo systemctl start jenkins 使用命令检查Jenkins服务的状态： sudo systemctl status jenkins 如果你启动报错： Job for jenkins.service failed because a timeout was exceeded. See &quot;systemctl status jenkins.service&quot; and &quot;journalctl -xe&quot; for details. 可使用下面方式： 方式一： d /etc/init.d# 启动 ./jenkins start # 停止 ./jenkins stop # 状态 ./jenkins status 方式二： 修改配置文件中的用户名为root # 老版本vim /etc/sysconfig/jenkinsJENKINS_USER=&quot;root&quot;# 新版本vim /usr/lib/systemd/system/jenkins.service修改为： User=rootGroup=root 更多解决方案见： https://zhuanlan.zhihu.com/p/609882788 解锁Jenkins当您首次访问新的Jenkins实例时，系统会要求您使用自动生成的密码来解锁它。 浏览器访问：http://ip:16060（自己配置的端口），等到解锁Jenkins页面出现 从Jenkins控制台日志输出中，复制自动生成的字母数字密码（在2组星号之间)。 cat /var/lib/jenkins/secrets/initialAdminPassword 后续初始化解锁Jenkins之后，可以选择安装Jenkins的插件，根据需要选择 安装建议的插件 选择插件去安装 之后，创建管理员用户。 我这里直接跳过了上述步骤，如果你和我一样，请使用下面账户登陆 账户：admin 密码：cat /var/lib/jenkins/secrets/initialAdminPassword 更改密码 进入控制面板后，坐上角点击账户名进入Configure，找到Password，修改之后Save即可。 安装所需插件在面板页面点击Manage Jenkins，在System Configuration下点击Plugins 在插件页面，左侧选择Available plugins 为了方便自动部署仓库中的微服务项目，请安装如下插件： **Localization: Chinese (Simplified)**：中文汉化插件 Docker：Docker集成插件（可不安装应该） GitLab Plugin：GitLab集成插件 Publish Over SSH：远程发布插件 SSH2 Easy：远程脚本执行插件 安装后需要重启Jenkins 系统配置在CentOS中还需要安装如下： JDK环境 Maven环境 Docker环境 安装JDK本次安装的JDK版本为11.0.20和自己项目的JDK版本保持一致最合适 JDK下载地址：https://www.oracle.com/cn/java/technologies/downloads/#java11 下载之后解压到服务器的/usr/java/目录下，重命名为jdk-11.0.20 tar -zxvf jdk-11.0.20_linux-x64_bin.tar.gz 添加配置信息 vim /etc/profile 添加如下内容： JAVA_HOME=/usr/java/jdk-11.0.20PATH=$PATH:$JAVA_HOME/binCLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH 保存之后，使用下面命令应用： source /etc/profile 使用下面命令验证安装 java -version 安装MavenMaven下载地址：https://maven.apache.org/download.cgi 下载到/usr/local/maven/，目录下并解压： tar -zxvf apache-maven-x.x.x-bin.tar.gz 添加阿里云镜像地址 vim /usr/local/maven/apache-maven-3.9.3/conf/settings.xml 找到mirrors，添加镜像地址 &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 添加配置信息 vim /etc/profile 修改为如下内容： JAVA_HOME=/usr/java/jdk-11.0.20MAVEN_HOME=/usr/local/maven/apache-maven-3.9.3PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/binCLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH MAVEN_HOME 保存之后，使用下面命令应用： source /etc/profile 使用下面命令验证安装 mvn -v 安装DockerDocker官方安装文档：https://docs.docker.com/engine/install/centos/ 安装yum工具 yum install -y yum-utils 更新本地镜像源 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposed -i &#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repoyum makecache fast 安装Docker yum install -y docker-ce 启动docker sudo systemctl start docker 使用下面命令验证安装 docker -v 配置Docker镜像加速 阿里云镜像加速配置文档： https://help.aliyun.com/zh/acr/user-guide/accelerate-the-pulls-of-docker-official-images 安装Git使用下面命令安装即可 yum install -y git 配置Jenkins配置Jenkins的Tool，在面板页面点击Manage Jenkins 配置SSH在System Configuration下点击System，找到Server Group Center新增一个Group 新增一个Server 配置JDK在System Configuration下点击Tools，找到JDK，勾掉Install automatically，选择系统安装的JDK 配置Git勾掉Install automatically，选择系统安装的Git 配置Maven勾掉Install automatically，选择系统安装的Maven 配置Docker勾掉Install automatically，选择系统安装的Docker 配置完成后点击Save保存即可！ 部署微服务推送微服务推送微服务到仓库中，使用Gitee新建仓库，并将微服务父工程及其子模块全部推送到Gitee仓库 修改项目配置在有src目录但是没有启动类的子模块的pom文件中加入一下内容： pom.xml&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;none&lt;/mainClass&gt; &lt;classifier&gt;execute&lt;/classifier&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 在需要构建镜像的服务子模块的pom中加入如下内容，注意修改jar文件名，和服务名保持一致 pom.xml&lt;properties&gt; &lt;docker.image&gt;docker_storage&lt;/docker.image&gt;&lt;/properties&gt;&lt;build&gt; &lt;!-- 打包的jar包文件名 --&gt; &lt;finalName&gt;leadnews-article&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;$&#123;docker.image&#125;/$&#123;project.artifactId&#125;&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/$&#123;project.build.finalName&#125;.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 在需要构建镜像的服务子模块的根目录（和src以及target同级）创建Dockerfile文件 FROM openjdk:11VOLUME /tmpARG JAR_FILECOPY $&#123;JAR_FILE&#125; app.jarENV JAVA_OPTS=&quot;\\-server \\-Xms256m \\-Xmx512m \\-XX:MetaspaceSize=256m \\-XX:MaxMetaspaceSize=512m&quot;# 空参数，方便创建内容时传参ENV PARAMS=&quot;&quot;ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java -jar $&#123;JAVA_OPTS&#125; /app.jar $&#123;PARAMS&#125;&quot;] JAR_FILE是构建参数，在pom文件中有定义 修改yaml配置信息（可不修改） spring: profiles: active: prod 修改完成后，重新推送到仓库中！！ 修改Nacos配置如果使用了Nacos作为配置中心，还需要进行如下修改 将配置名改为leadnews-user-dev.yml和leadnews-user-prod.yml各一份 leadnews-user-dev.yml：为开发配置 leadnews-user-prod.yml：为生产配置 leadnews-user：为微服务的spring.application.name 安装模块到Maven在微服务分模块开发中，这步是必不可少的。为了保证所有模块的依赖正确性，需要提前将所有模块安装到Maven仓库中。 创建Jenkins任务，在首页右侧点击新建任务，选择构建一个自由风格的软件项目，点击确定； 在配置页面的源码管理部分，添加一个Git仓库，Credentials为Git仓库的用户名和密码 注意修改分支 在Build Steps中新增一个构建步骤，选择调用顶层 Maven 目标 版本选择自己配置的Maven，目标中填入install命令 clean install -Dmaven.test.skip=true 完成后点击保存即可，在新页面点击右侧立即构建 [INFO] ------------------------------------------------------------------------[INFO] Reactor Summary for lead-news 0.0.1-SNAPSHOT:[INFO] [INFO] lead-news .......................................... SUCCESS [ 1.347 s][INFO] leadnews-model ..................................... SUCCESS [ 5.066 s][INFO] leadnews-utils ..................................... SUCCESS [ 0.576 s][INFO] leadnews-common .................................... SUCCESS [ 2.494 s][INFO] leadnews-feign-api ................................. SUCCESS [ 0.982 s][INFO] leadnews-gateway ................................... SUCCESS [ 0.318 s][INFO] leadnews-app-gateway ............................... SUCCESS [ 0.641 s][INFO] leadnews-wemedia-gateway ........................... SUCCESS [ 0.665 s][INFO] leadnews-service ................................... SUCCESS [ 0.141 s][INFO] leadnews-user ...................................... SUCCESS [ 1.374 s][INFO] leadnews-basic ..................................... SUCCESS [ 0.016 s][INFO] leadnews-file-starter .............................. SUCCESS [ 0.787 s][INFO] leadnews-article ................................... SUCCESS [ 2.475 s][INFO] leadnews-wemedia ................................... SUCCESS [ 2.404 s][INFO] leadnews-schedule .................................. SUCCESS [ 1.330 s][INFO] leadnews-search .................................... SUCCESS [ 2.417 s][INFO] leadnews-behavior .................................. SUCCESS [ 1.913 s][INFO] leadnews-test ...................................... SUCCESS [ 0.057 s][INFO] es-init ............................................ SUCCESS [ 0.619 s][INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 26.854 s[INFO] Finished at: 2023-08-15T13:50:30+08:00[INFO] ------------------------------------------------------------------------Finished: SUCCESS 构建Docker镜像这一步是将提供服务的微服务模块构建为Docker镜像，确保该模块的pom文件配置了构建命令，且根目录下有Dockerfile文件；否则参考修改项目配置 1、同样创建一个自由风格的Jenkins任务，Git仓库配置同上 2、在Build Steps中添加调用顶层 Maven 目标，目标中填入如下命令： clean install -Dmaven.test.skip=true dockerfile:build -f leadnews-service/leadnews-user/pom.xml -f [path]&#x2F;pom.xml：其中 path 为pom文件在仓库中的位置 3、在Build Steps中添加执行 shell，目标中填入如下命令： if [ -n &quot;$(docker ps -a -f name=$JOB_NAME --format &#x27;&#123;&#123;.ID&#125;&#125;&#x27;)&quot; ]; then # 删除之前的容器 docker rm -f $(docker ps -a -f name=$JOB_NAME --format &#x27;&#123;&#123;.ID&#125;&#125;&#x27;)fi# 清理镜像docker image prune -f# 启动docker服务docker run -d --net=host -e PARAMS=&quot;--spring.profiles.active=prod&quot; --name $JOB_NAME docker_storage/$JOB_NAME #JOB_NAME为Jenkins任务的名称，需要和构建的jar包文件名以及Docker镜像名保持一致 构建日志： [INFO] Building jar: /var/lib/jenkins/workspace/leadnews-user/leadnews-service/leadnews-user/target/leadnews-user-docker-info.jar[INFO] Successfully built docker_storage/leadnews-user:latest[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 18.869 s[INFO] Finished at: 2023-08-16T13:16:25+08:00[INFO] ------------------------------------------------------------------------[leadnews-user] $ /bin/sh -xe /tmp/jenkins7230786785147070619.sh++ docker ps -a -f name=leadnews-user --format &#x27;&#123;&#123;.ID&#125;&#125;&#x27;+ &#x27;[&#x27; -n de7f106527bc &#x27;]&#x27;++ docker ps -a -f name=leadnews-user --format &#x27;&#123;&#123;.ID&#125;&#125;&#x27;+ docker rm -f de7f106527bcde7f106527bc+ docker image prune -f+ docker run -d --net=host -e PARAMS=--spring.profiles.active=prod --name leadnews-user docker_storage/leadnews-useree78a237a4d8647b5e305f2d0a12b437ddc887d69d63e04dd6d238d67b6f705cFinished: SUCCESS 来到系统中，查看构建的镜像 [root@VM-28-13-centos maven]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker_storage/leadnews-user latest 61d0675c5e36 2 minutes ago 759 MB 查看运行的容器 [root@VM-28-13-centos maven]# docker psCONTAINER ID IMAGE CREATED STATUS PORTS NAMESee78a237a4d8 docker_storage/leadnews-user 3 minutes ago Up 3 minutes leadnews-user 部署到指定机器如果需要将构建的镜像在其他机器上启动，需要配置一个镜像仓库，将构建的镜像推送到镜像仓库，然后其他机器从镜像仓库中拉取镜像并启动容器 镜像仓库下载最新Registry镜像 docker pull registry 启动Registry镜像服务 docker run -d -p 5000:5000 --name registry -v /usr/local/docker/registry:/var/lib/registry registry 访问地址： http://ip:5000/v2/_catalog 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容 &#123; &quot;insecure-registries&quot;: [ &quot;ip:5000&quot; ]&#125; 重启Dokcer systemctl restart docker 创建任务构建参数 名称: docker_registry # 仓库名默认值: 124.221.23.47:5000 # 镜像仓库地址 shell脚本 image_tag=$docker_registry/docker_storage/$JOB_NAMEecho &#x27;================docker镜像清理================&#x27;if [ -n &quot;$(docker ps -a -f name=$JOB_NAME --format &#x27;&#123;&#123;.ID&#125;&#125;&#x27;)&quot; ]; then # 删除之前的容器 docker rm -f $(docker ps -a -f name=$JOB_NAME --format &#x27;&#123;&#123;.ID&#125;&#125;&#x27;)fi# 清理镜像docker image prune -f# 创建TAGdocker tag docker_storage/$JOB_NAME $image_tagecho &#x27;================docker镜像推送================&#x27;# 推送镜像docker push $image_tag# 删除Tagdocker rmi $image_tagecho &#x27;================docker镜像清理================&#x27; 新增构建步骤，选择远程执行命令 echo &#x27;================拉取最新镜像================&#x27;docker pull $docker_registry/docker_storage/$JOB_NAMEecho &#x27;================删除清理容器镜像================&#x27;if [ -n &quot;$(docker ps -a -f name=$JOB_NAME --format &#x27;&#123;&#123;.ID&#125;&#125;&#x27;)&quot; ]; then # 删除之前的容器 docker rm -f $(docker ps -a -f name=$JOB_NAME --format &#x27;&#123;&#123;.ID&#125;&#125;&#x27;)fi# 清理镜像docker image prune -fecho &#x27;================启动容器================&#x27;docker run -d --net=host -e PARAMS=&quot;--spring.profiles.active=prod&quot; --name $JOB_NAME $docker_registry/docker_storage/$JOB_NAME","tags":["Docker","Jenkins","微服务部署","Git"],"categories":["后端开发"]},{"title":"form-designer-naiveui","path":"/2023/04/27/form-designer-naiveui/","content":"这个是 Vue3 版本 form-create-designer-naiveui 是基于 @form-create&#x2F;naive-ui vue3版本实现的表单设计器组件。可以通过拖拽的方式快速创建表单，提高开发者对表单的开发效率，节省开发者的时间。 form-create-designer 是基于 @form-create&#x2F;element-ui 开发的表单设计器，本项目更换 form-create-designer 的 UI 框架为 Naive UI ，做出的更改如下： Element Plus v2.0.1 -&gt; Naive UI v2.34.3 codemirror v5.60.0 -&gt; v6.0.1 自定义ColorPicker组件，便于定制组件颜色 更新部分组件为Vue 3版本 文档 | 在线演示 | form-create 文档 如有任何建议或问题请在这里提出 引入NodeJs: npm i form-designer-naiveui 请自行导入NaiveUI并挂载 import formCreate from &#x27;@form-create/naive-ui&#x27;import FcDesigner from &#x27;form-designer-naiveui&#x27;app.use(formCreate)app.use(FcDesigner) 使用&lt;fc-designer ref=&quot;designer&quot;/&gt; 设置多语言通过 locale 配置项设置语言 &lt;template&gt; &lt;fc-designer :locale=&quot;locale&quot;&gt;&lt;/fc-designer&gt;&lt;/template&gt;&lt;script&gt;import En from &quot;form-designer-naiveui/locale/en&quot;;export default &#123; data()&#123; return &#123; locale: En, &#125; &#125;&#125;&lt;/script&gt; 组件props menuMenuList 重新配置拖拽的组件 heightint|string 设计器组件高度, 默认100% localeobject 设置多语言 configConfig 设置多语言 mask boolean 设置拖拽表单中的组件是否可以操作 组件方法 获取当前生成表单的生成规则 type getRule = () =&gt; Rule[] 示例: this.$refs.designer.getRule() 获取当前表单的全局配置 type getOption = () =&gt; Object 设置当前生成表单的规则 type setRule = (rules: Rule[]) =&gt; void; 设置当前表单的全局配置 type setOption = (option: Object) =&gt; void; 增加一组拖拽组件 type addMenu = (menu: Menu) =&gt; void; 删除一组拖拽组件 type removeMenu = (name: string) =&gt; void; 批量覆盖插入拖拽组件 type setMenuItem = (name: string, items: MenuItem[]) =&gt; void; 插入一个拖拽组件到分组 type appendMenuItem = (name:string, item: MenuItem) =&gt; void; 删除一个拖拽组件 type removeMenuItem = (item: string | MenuItem) =&gt; void; 新增一个拖拽组件的生成规则 type addComponent = (item: DragRule) =&gt; void; 运行项目下载源码 git clone https://github.com/SX-Code/form-designer-naiveui.git 安装依赖 npm i --legacy-peer-deps 运行项目 npm run dev Node版本太高，运行前使用下面命令 export NODE_OPTIONS=--openssl-legacy-provider email : &#50;&#x36;&#50;&#55;&#51;&#49;&#49;&#57;&#51;&#x35;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;","tags":["Vue","Naive UI","form-create"],"categories":["前端开发"]},{"title":"Spring Security实现登陆认证授权","path":"/2023/04/11/单体项目使用Spring-Security实现认证授权/","content":"前端可以根据权限信息控制菜单和页面展示，操作按钮的显示。但这并不够，如果有人拿到了接口，绕过了页面直接操作数据，这是很危险的。所以我们需要在后端也加入权限控制，只有拥有操作权限，该接口才能被授权访问。 在进入Controller方法前判断当前用户是否拥有访问权限，可以通过Filter加AOP的方式实现认证和授权。本次介绍的是成熟的框架：Spring Security。其他框架还有Shiro等。 Spring Security简介Spring Security的重要核心功能功能是“认证”和“授权”，即用户认证（Authentication）和用户授权（Authorization）两部分： （1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求提供用户名和密码，系统通过校验用户名和密码来完成认证过程。 （2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，用的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。 Spring Security的特点： 和Spring无缝整合 全面的权限控制 专门为Web开发而设计 重量级 Spring Boot出现后，其为Spring Security提供了自动配置方案，可以使用少量的配置来使用Spring Security。如果你的项目是基于Spring Boot的，使用Spring Security无疑是很棒的选择！ Spring Security实现权限要对Web资源进行保护，最好的办法莫过于Filter 要对方法调用进行保护，最好的方法莫过于AOP Spring Security进行认证和鉴权的时候就是利用一系列的Filter进行拦截的。 如图所示，一个请求要想访问到API就会从左到右经过蓝线框里的过滤器，其中绿色部分是负责认证的过滤器，蓝色部分就是负责异常处理，橙色部分则是负责授权。经过一系列拦截最终访问到我们的API。 FilterSecurityInterceptor：是一个方法级的过滤器，基本位于过滤链的最底部。 ExceptionTranslationFilter：是一个异常过滤器，用来处理在认证授权过程中抛出的异常。 UsernamePasswordAuthenticationFilter：对/login的POST请求做拦截，校验表单中用户名、密码。 这里我们只需要重点关注两个过滤器即可：UsernamePasswordAuthenticationFilter负责登陆认证，FilterSecurityInterceptor负责权限授权。 说明：Spring Security的核心逻辑全在这一套过滤器中，过滤器里会调用各种组件完成功能，掌握了这些过滤器和组件你就掌握了Spring Security！这个框架的使用方式就是对这些过滤器和组件进行扩展。 用户认证流程 自定义组件根据认证流程，我们需要自定义以下组件： UserDetails loadUserByUsername passwordEncoder 1、登陆Filter，判断用户名和密码是否正确，生成token 2、认证解析token组件，判断请求头是否有token，如果有认证完成 3、在配置类配置相关认证类 代码实现 完整项目地址：Server | GitHub 依赖创建一个spring-security模块（module），可以放在项目的common模块下 创建完成，导入相关的Maven依赖 pom.xml&lt;dependencies&gt; &lt;!-- Spring Security依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 工具类ResponseUtil用于写会数据给前端 Importimportimport com.fasterxml.jackson.databind.ObjectMapper;import com.swx.common.pojo.R;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import javax.servlet.http.HttpServletResponse;import java.io.IOException; utils.ResponseUtil.javapublic class ResponseUtil &#123; public static void out(HttpServletResponse response, R r) &#123; ObjectMapper mapper = new ObjectMapper(); response.setStatus(HttpStatus.OK.value()); response.setContentType(MediaType.APPLICATION_JSON_VALUE); response.setCharacterEncoding(&quot;UTF-8&quot;); try &#123; mapper.writeValue(response.getWriter(), r); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; JwtHelperImportimportpackage com.swx.common.jwt;import io.jsonwebtoken.*;import org.springframework.util.StringUtils;import java.util.Date; jwt.JwtHelper.javapublic class JwtHelper &#123; private static long tokenExpiration = 60 * 60 * 1000; private static String tokenSignKey = &quot;sw-code&quot;; public static String createToken(Long userId, String username) &#123; return Jwts.builder() .setSubject(&quot;AUTH-USER&quot;) .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration)) .claim(&quot;userId&quot;, userId) .claim(&quot;username&quot;, username) .signWith(SignatureAlgorithm.HS512, tokenSignKey) .compressWith(CompressionCodecs.GZIP) .compact(); &#125; public static Long getUserId(String token) &#123; if (StringUtils.isEmpty(token)) return null; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token); Claims body = claimsJws.getBody(); String userId = body.get(&quot;userId&quot;).toString(); return Long.parseLong(userId); &#125; public static String getUsername(String token) &#123; if (StringUtils.isEmpty(token)) return null; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token); Claims body = claimsJws.getBody(); return (String) body.get(&quot;username&quot;); &#125;&#125; 自定义UserDetail继承UserDetail的User，其中sysUser是项目数据库的实体类 Importimportimport com.swx.model.system.SysUser;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.User;import java.util.Collection; custom.CustomUser.javapublic class CustomUser extends User &#123; private SysUser sysUser; public CustomUser(SysUser sysUser, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(sysUser.getUsername(), sysUser.getPassword(), authorities); this.sysUser = sysUser; &#125; public SysUser getSysUser() &#123; return sysUser; &#125; public void setSysUser(SysUser sysUser) &#123; this.sysUser = sysUser; &#125;&#125; 自定义解码器用于匹配前端传过来的密码和数据库中的密码是否一致，其中MD5.encrypt是自定义的MD5加密工具 MD5：MD5 | GitHub Importimportimport com.swx.common.utils.MD5;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component; custom.CustomMd5PasswordEncoder.java@Componentpublic class CustomMd5PasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence rawPassword) &#123; return MD5.encrypt(rawPassword.toString()); &#125; @Override public boolean matches(CharSequence rawPassword, String encodedPassword) &#123; return encodedPassword.equals(MD5.encrypt(rawPassword.toString())); &#125;&#125; 自定义UserDetailsService该类的实现类会查询项目的数据库，根据用户名获取用户信息，包括密码等，用于匹配和授权。 注意要继承org.springframework.security.core.userdetails.UserDetailsService Importimportimport org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Component; custom.UserDetailsService.java@Componentpublic interface UserDetailsService extends org.springframework.security.core.userdetails.UserDetailsService &#123; /** * 根据用户名获取用户对象，获取不到直接抛异常 */ @Override UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;&#125; 实现该类 该实现可以放到项目的service.impl中，就像项目其他Service的实现类一样 SysUserService：SysUserServiceImpl | GitHub SysMenuService：SysMenuServiceImpl | GitHub Permission：Permission | GitHub Importimportimport com.swx.auth.service.SysMenuService;import com.swx.auth.service.SysUserService;import com.swx.model.system.SysUser;import com.swx.security.custom.CustomUser;import com.swx.security.custom.UserDetailsService;import com.swx.vo.system.Permission;import org.springframework.security.authentication.DisabledException;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Collections;import java.util.List; impl.UserDetailsServiceImpl.java@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; private final SysUserService sysUserService; private final SysMenuService sysMenuService; public UserDetailsServiceImpl(SysUserService sysUserService, SysMenuService sysMenuService) &#123; this.sysUserService = sysUserService; this.sysMenuService = sysMenuService; &#125; /** * 根据用户名获取用户对象，获取不到直接抛异常 */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; // 根据用户名查询 SysUser sysUser = sysUserService.getUserByUsername(username); if (null == sysUser) &#123; throw new UsernameNotFoundException(&quot;用户名不存在！&quot;); &#125; if (sysUser.getStatus() == 0) &#123; throw new DisabledException(&quot;disable&quot;); &#125; // 查询权限列表 List&lt;Permission&gt; permissions = sysMenuService.queryUserAuthListByUserId(sysUser.getId()); // 封装Spring Security的权限类型 List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); permissions.forEach(permission -&gt; &#123; authorities.add(new SimpleGrantedAuthority(permission.getAuth().trim())); &#125;); return new CustomUser(sysUser, authorities); &#125;&#125; 拦截器TokenLoginFilter获得输入的用户名和密码，封装成框架要求的对象，调用认证方法。认证成功则将权限信息存入Redis，并返回Token给前端。 该类继承UsernamePasswordAuthenticationFilter，实现登陆的拦截校验。 Importimportimport com.alibaba.fastjson2.JSON;import com.fasterxml.jackson.databind.ObjectMapper;import com.swx.common.jwt.JwtHelper;import com.swx.common.pojo.R;import com.swx.common.pojo.ResultCode;import com.swx.common.utils.ResponseUtil;import com.swx.security.custom.CustomUser;import com.swx.vo.system.LoginVo;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.BadCredentialsException;import org.springframework.security.authentication.DisabledException;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import org.springframework.security.web.util.matcher.AntPathRequestMatcher;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap; filter.TokenLoginFilter.java/** * 获得输入的用户名和密码，封装成框架要求的对象，调用认证方法 */public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter &#123; private final RedisTemplate&lt;String, String&gt; redisTemplate; // 构造方法 public TokenLoginFilter(AuthenticationManager authenticationManager, RedisTemplate&lt;String, String&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; this.setAuthenticationManager(authenticationManager); this.setPostOnly(false); // 指定登陆接口及提交方式，可以指定任意路径 this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;/admin/system/index/login&quot;, &quot;POST&quot;)); &#125; // 登陆认证 // 获取输入的用户名和密码，调用方法认证 @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; try &#123; // 获取用户信息 LoginVo loginVo = new ObjectMapper().readValue(request.getInputStream(), LoginVo.class); // 封装对象 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginVo.getUsername(), loginVo.getPassword()); // 调用方法 return this.getAuthenticationManager().authenticate(authenticationToken); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; // 认证成功调用的方法 @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; // 获取当前用户 CustomUser customUser = (CustomUser) authResult.getPrincipal(); // 生成Token String token = JwtHelper.createToken(customUser.getSysUser().getId(), customUser.getSysUser().getUsername()); // 获取当前用户的权限数据，放到Redis中，key: username value: permissions redisTemplate.opsForValue().set( customUser.getUsername(), JSON.toJSONString(customUser.getAuthorities())); // 返回 HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;, token); ResponseUtil.out(response, R.success(map)); &#125; // 认证失败调用的方法 @Override protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123; // 封装错误信息，用于返回 R r = R.fail(ResultCode.LOGIN_AUTH_FAIL); Throwable ex = failed.getCause(); if (ex instanceof DisabledException) &#123; r.setResultCode(ResultCode.USER_DISABLE); &#125; else if (failed instanceof UsernameNotFoundException || failed instanceof BadCredentialsException) &#123; r.setResultCode(ResultCode.USER_LOGIN_ERROR); &#125; ResponseUtil.out(response, r); &#125;&#125; TokenAuthenticationFilter判断是否完成认证，将认证信息保存到Security上下文中 Importimportimport com.alibaba.fastjson2.JSON;import com.swx.common.jwt.JwtHelper;import com.swx.common.pojo.R;import com.swx.common.pojo.ResultCode;import com.swx.common.utils.ResponseUtil;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.util.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Map; filter.TokenAuthenticationFilter.java/** * 判断是否完成认证 */public class TokenAuthenticationFilter extends OncePerRequestFilter &#123; private final RedisTemplate&lt;String, String&gt; redisTemplate; public TokenAuthenticationFilter(RedisTemplate&lt;String, String&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; // 如果是登陆接口，直接放行 if (&quot;/admin/system/index/login&quot;.equals(request.getRequestURI())) &#123; chain.doFilter(request, response); return; &#125; try &#123; UsernamePasswordAuthenticationToken authentication = getAuthentication(request); if (null != authentication) &#123; SecurityContextHolder.getContext().setAuthentication(authentication); chain.doFilter(request, response); &#125; else &#123; ResponseUtil.out(response, R.fail(ResultCode.LOGIN_AUTH_FAIL)); &#125; &#125; catch (JwtException e) &#123; SecurityContextHolder.getContext().setAuthentication(null); R r = R.fail(ResultCode.TOKEN_INVALID); if (e instanceof UnsupportedJwtException) &#123; r.setResultCode(ResultCode.TOKEN_UNSUPPORTED); &#125; ResponseUtil.out(response, r); &#125; &#125; private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) &#123; String token = request.getHeader(&quot;Authorization&quot;); if (!StringUtils.isEmpty(token)) &#123; String username = JwtHelper.getUsername(token); if (!StringUtils.isEmpty(username)) &#123; // 从redis中获取权限数据 String authString = redisTemplate.opsForValue().get(username); if (!StringUtils.isEmpty(authString)) &#123; List&lt;Map&gt; mapList = JSON.parseArray(authString, Map.class); System.out.println(mapList); List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); mapList.forEach(map -&gt; &#123; String authority = (String) map.get(&quot;authority&quot;); authorities.add(new SimpleGrantedAuthority(authority)); &#125;); return new UsernamePasswordAuthenticationToken(username, null, authorities); &#125; else &#123; return new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList()); &#125; &#125; &#125; return null; &#125;&#125; 配置文件创建一个Spring Security的配置文件，开启相关的注解 Importimportimport com.swx.security.custom.CustomMd5PasswordEncoder;import com.swx.security.filter.TokenAuthenticationFilter;import com.swx.security.filter.TokenLoginFilter;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; config.WebSecurityConfig.java@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; private final UserDetailsService userDetailsService; private final CustomMd5PasswordEncoder customMd5PasswordEncoder; private final RedisTemplate&lt;String, String&gt; redisTemplate; public WebSecurityConfig(UserDetailsService userDetailsService, CustomMd5PasswordEncoder customMd5PasswordEncoder, RedisTemplate&lt;String, String&gt; redisTemplate) &#123; this.userDetailsService = userDetailsService; this.customMd5PasswordEncoder = customMd5PasswordEncoder; this.redisTemplate = redisTemplate; &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable() .cors().and() .authorizeRequests() .antMatchers(&quot;/admin/system/index/login&quot;).permitAll() .anyRequest().authenticated() .and() .addFilterBefore(new TokenAuthenticationFilter(redisTemplate), UsernamePasswordAuthenticationFilter.class) .addFilter(new TokenLoginFilter(authenticationManager(), redisTemplate)); http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(customMd5PasswordEncoder); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/favicon.icon&quot;, &quot;/swagger-resources/**&quot;, &quot;webjars/**&quot;, &quot;/v2/**&quot;, &quot;swagger-ui.html/**&quot;, &quot;doc.html&quot;); &#125;&#125; 食用教程可以在业务模块中导入pom信息 &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;spring-security&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 在需要授权的接口上加入注解，就像这样 RoleController.java@Api(tags = &quot;角色管理接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/admin/system/sysRole&quot;)public class SysRoleController &#123; private final SysRoleService sysRoleService; public SysRoleController(SysRoleService sysRoleService) &#123; this.sysRoleService = sysRoleService; &#125; @ApiOperation(&quot;为用户分配角色&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_assign&#x27;)&quot;) @PostMapping(&quot;/doAssign&quot;) public void doAssign(@RequestBody AssignRoleVo assignRoleVo) &#123; sysRoleService.doAssign(assignRoleVo); &#125; @ApiOperation(&quot;查询所有角色&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_list&#x27;)&quot;) @GetMapping(&quot;/findAll&quot;) public List&lt;SysRole&gt; findAll() &#123; return sysRoleService.list(); &#125; /** * * @param page 当前页 * @param limit 记录数 * @param sysRoleQueryVo 查询参数 * @return 分页信息 */ @ApiOperation(&quot;条件分页查询&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_list&#x27;)&quot;) @GetMapping(&quot;&#123;page&#125;/&#123;limit&#125;&quot;) public IPage&lt;SysRole&gt; pageQueryRole(@PathVariable Long page, @PathVariable Long limit, SysRoleQueryVo sysRoleQueryVo) &#123; // 自定义Page，修改current为page，和前端保持一致 CustomPage&lt;SysRole&gt; pageParam = new CustomPage&lt;&gt;(page, limit); LambdaQueryWrapper&lt;SysRole&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); String roleName = sysRoleQueryVo.getRoleName(); if (!StringUtils.isEmpty(roleName)) &#123; wrapper.like(SysRole::getRoleName, roleName); &#125; IPage&lt;SysRole&gt; iPage = sysRoleService.page(pageParam, wrapper); return iPage; &#125; @ApiOperation(&quot;添加角色&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_add&#x27;)&quot;) @PostMapping(&quot;&quot;) public void save(@RequestBody SysRole role) &#123; boolean save = sysRoleService.save(role); if (!save) &#123; throw new BizException(&quot;添加失败&quot;); &#125; &#125; /** * 根据id查询角色 * @param id 角色id * @return 角色 */ @ApiOperation(&quot;根据ID查询&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_list&#x27;)&quot;) @GetMapping(&quot;&#123;id&#125;&quot;) public SysRole get(@PathVariable Long id) &#123; return sysRoleService.getById(id); &#125; /** * 更新角色 * @param role 角色信息 */ @ApiOperation(&quot;更新角色&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_update&#x27;)&quot;) @PutMapping(&quot;&quot;) public void update(@RequestBody SysRole role) &#123; boolean update = sysRoleService.updateById(role); if (!update) &#123; throw new BizException(&quot;更新失败&quot;); &#125; &#125; @ApiOperation(&quot;根据id删除&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_remove&#x27;)&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public void delete(@PathVariable Long id) &#123; boolean delete = sysRoleService.removeById(id); if (!delete) &#123; throw new BizException(&quot;删除失败&quot;); &#125; &#125; @ApiOperation(&quot;批量删除&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_remove&#x27;)&quot;) @DeleteMapping(&quot;batch&quot;) public void batchRemove(@RequestBody List&lt;Long&gt; ids) &#123; boolean delete = sysRoleService.removeByIds(ids); if (!delete) &#123; throw new BizException(&quot;删除失败&quot;); &#125; &#125;&#125;","tags":["Spring Boot","Spring Security"],"categories":["后端开发"]},{"title":"Mybatis-Plus自动生成代码","path":"/2023/02/18/Mybatis-Plus自动生成代码/","content":"什么是Mybatis-Plus Mybatis-Plus：为简化开发而生 1.MyBatis-Plus（简称 MP）是一个基于 MyBatis 的增强工具，它对 Mybatis 的基础功能进行了增强，但未做任何改变。 使得我们可以可以在 Mybatis 开发的项目上直接进行升级为 Mybatis-plus，正如它对自己的定位，它能够帮助我们进一步简化开发过程，提高开发效率。 2.Mybatis-Plus 其实可以看作是对 Mybatis 的再一次封装，升级之后，对于单表的 CRUD 操作，调用 Mybatis-Plus 所提供的 API 就能够轻松实现，此外还提供了各种查询方式、分页等行为。最最重要的，开发人员还不用去编写 XML，这就大大降低了开发难度 其官方主页：https://baomidou.com 使用代码生成数据库准备使用user表作为案例，其脚本如下： CREATE TABLE `tb2023`.`t_user` ( `id` int UNSIGNED NOT NULL AUTO_INCREMENT, `username` varchar(50) NULL COMMENT &#x27;用户名&#x27;, `password` varchar(50) NULL COMMENT &#x27;密码&#x27;, `gender` tinyint NULL COMMENT &#x27;性别 0=女 1=男&#x27;, `version` int DEFAULT NULL COMMENT &#x27;乐观锁&#x27;, `deleted` tinyint unsigned DEFAULT &#x27;1&#x27; COMMENT &#x27;删除标志，默认0不删除 1删除&#x27;, `create_time` timestamp NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` timestamp NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)); SpringBoot项目 使用IDEA新建一个SpringBoot项目 pom文件如下： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- JDBC --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis-Plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis-Plus自动生成代码 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 模版引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置生成策略在test中新建java文件CodeGenerator.java，写入一下代码： test/java/CodeGeneratorpublic class CodeGenerator &#123; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/src/main/java&quot;); gc.setAuthor(&quot;sw-code&quot;); gc.setOpen(false); // 是否打开文件资源管理器 gc.setFileOverride(false); // 是否覆盖 gc.setServiceName(&quot;%sService&quot;); // 去Service的I前缀 gc.setSwagger2(true); // 实体属性 Swagger2 注解 gc.setIdType(IdType.AUTO); // 主键策略 gc.setDateType(DateType.ONLY_DATE); // 定义生成的实体类中日期类型 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql:///tb2023?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;nullCatalogMeansCurrent=true&quot;); // dsc.setSchemaName(&quot;public&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;swx852345&quot;); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setParent(&quot;com.swx.docker&quot;); pc.setEntity(&quot;pojo&quot;); pc.setMapper(&quot;mapper&quot;); pc.setService(&quot;service&quot;); pc.setController(&quot;controller&quot;); mpg.setPackageInfo(pc); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;t_user&quot;); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); strategy.setLogicDeleteFieldName(&quot;deleted&quot;); // 自动填充 TableFill deleted = new TableFill(&quot;deleted&quot;, FieldFill.INSERT); TableFill createTime = new TableFill(&quot;create_time&quot;, FieldFill.INSERT); TableFill updateTime = new TableFill(&quot;update_time&quot;, FieldFill.INSERT_UPDATE); List&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(createTime); tableFills.add(updateTime); tableFills.add(deleted); strategy.setTableFillList(tableFills); // 乐观锁 strategy.setVersionFieldName(&quot;version&quot;); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(&quot;t_&quot;); mpg.setStrategy(strategy); mpg.execute(); &#125;&#125; 可根据自己的情况修改生成规则。 开始生成代码编辑完成，点击开始生成代码 生成的目录包括：pojo、mapper、service、controller，即代表成功。 注意：自动生成的mapper.xml在mapper下，如果需要可移动到resource目录下，并修改yml文件。 其他配置yml配置resource/application.ymlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///tb2023?useSSL=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: swx852345 swagger2: enabled: true mvc: pathmatch: matching-strategy: ANT_PATH_MATCHERmybatis-plus: type-aliases-package: com.swx.docker # 别名扫描包 global-config: db-config: # 逻辑删除 logic-not-delete-value: 1 logic-delete-value: -1 Swagger配置config/swaggerConfig.java/** * 访问网址：http://localhost:port/swagger-ui/index.html */@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Value(value = &quot;$&#123;spring.swagger2.enabled&#125;&quot;) private Boolean swaggerEnabled; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30) .apiInfo(apiInfo()) .enable(swaggerEnabled) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.swx.docker&quot;)) // 写上自己的包名 .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;接口文档&quot;) .description(&quot;用restful风格写接口&quot;) .termsOfServiceUrl(&quot;&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; SpringBoot版本如果是2.6.0以上，项目启动时会报错： Failed to start bean ‘documentationPluginsBootstrapper’; nested exception is java.lang.NullPointerException: 在配置文件里加入下面内容可解决： application.ymlspring: mvc: pathmatch: matching-strategy: ANT_PATH_MATCHER 自动填充配置字段update_time和create_time添加了@TableField注解，需要配置一下Handler handler/AutoFillMetaObjectHandler.java@Componentpublic class AutoFillMetaObjectHandler implements MetaObjectHandler &#123; @Value(value = &quot;$&#123;mybatis-plus.global-config.db-config.logic-not-delete-value&#125;&quot;) private Integer notDeleted; @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;deleted&quot;, notDeleted, metaObject); this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125;&#125; 启动项目为了方便测试，我们加入两个Controller controller/UserController.java@Api(&quot;用户User接口&quot;)@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; private final UserService userService; public UserController(UserService userService) &#123; this.userService = userService; &#125; @ApiOperation(&quot;添加用户&quot;) @PostMapping(&quot;/add&quot;) public void addUser(@RequestBody User user) &#123; userService.save(user); &#125; @ApiOperation(&quot;添加用户&quot;) @PostMapping(&quot;/get/&#123;id&#125;&quot;) public void getUser(@PathVariable Integer id) &#123; userService.getById(id); &#125;&#125; 测试项目使用Swagger测试接口，地址栏访问：http://localhost:8080/swagger-ui/index.html","tags":["Spring Boot","Mybatis Plus","Swagger"],"categories":["后端开发"]},{"title":"Redis安装系列教程","path":"/2022/11/16/Redis安装系列教程/","content":"安装说明安装选用的Linux版本为CentOS 7 Redis的官网地址：http://redis.io/ 单机安装Redis安装Redis下载源文件 wget https://download.redis.io/redis-stable.tar.gz 解压到/opt tar -xzvf redis-stable.tar.gz -C /opt 编译安装 cd /opt/redis-stablemakemake install 编译遇到Python 3错误编译时如果遇到Python3报错，需要先安装Python3，当然默认的Python2是不能卸载的。安装依赖包yum -y groupinstall &quot;Development tools&quot;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel下载Pythonwget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz新建空文件夹mkdir /usr/local/python3解压并安装tar -xvJf Python-3.6.2.tar.xzcd Python-3.6.2./configure --prefix=/usr/local/python3make &amp;&amp; make install最后创建软链接ln -s /usr/local/python3/bin/python3 /usr/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 编译错误zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory编译错误zmalloc.h:50:31: fatal error: jemalloc&#x2F;jemalloc.h: No such file or directory使用下面的命令：make MALLOC-libc然后再安装make install 默认会安装在/usr/local/bin中 cd /usr/local/binll 配置Redis配置文件位置在/etc/redis.conf，使用下面命令编辑 vi /etc/redis.conf 修改配置文件 # 监听的地址，默认是127.0.0.1，会导致只能在本地访问，修改为0.0.0.0可在任意地址访问bind 0.0.0.0# 设置守护进程，后台运行daemonize yes# 设置密码requirepass 123123 其他常见配置，可不修改 # 监听的端口prot 6397# 工作目录dir ./# 数据库数量databases 16# 设置redis能够使用的最大内存maxmemory 512mb# 日志文件，默认为空 logfile &quot;redis.log&quot; 重启redis sudo systemctl restart redis Redis主从集群 共包含三个节点，一个主节点，两个从节点。 这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下： IP PORT 角色 192.168.52.101 7001 master 192.168.52.101 7002 slave 192.168.52.101 7003 slave 准备实例和配置要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。 1）创建目录 我们创建三个文件夹，名字分别叫7001、7002、7003: # 进入/opt目录cd /opt# 创建目录mkdir 7001 7002 7003 2）修改配置文件 开启RDB（默认开启），关闭AOF（默认关闭） # 开启RDB# save &quot;&quot;save 3600 1save 300 100save 60 10000# 关闭AOFappendonly no 3）拷贝配置文件到每个实例目录 将/etc/redis.conf文件拷贝到三个目录中 cd /optecho 7001 7002 7003 | xargs -t -n 1 cp /opt/redis-stable/redis.conf 4）修改每个实例的端口、工作目录 修改每个文件夹中的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置修改到自己所在的目录 cd /optsed -i -e &#x27;s/6379/7001/g&#x27; -e &#x27;s/dir \\/var\\/lib\\/redis/dir \\/tmp\\/7001\\//g&#x27; 7001/redis.confsed -i -e &#x27;s/6379/7002/g&#x27; -e &#x27;s/dir \\/var\\/lib\\/redis/dir \\/tmp\\/7002\\//g&#x27; 7002/redis.confsed -i -e &#x27;s/6379/7003/g&#x27; -e &#x27;s/dir \\/var\\/lib\\/redis/dir \\/tmp\\/7003\\//g&#x27; 7003/redis.conf 5）修改每个实例的声明IP 虚拟机本身有多个IP，为了避免混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息 # 逐一执行sed -i &#x27;1a replica-announce-ip 192.168.52.101&#x27; 7001/redis.confsed -i &#x27;1a replica-announce-ip 192.168.52.101&#x27; 7002/redis.confsed -i &#x27;1a replica-announce-ip 192.168.52.101&#x27; 7003/redis.conf# 一键修改printf &#x27;%s &#x27; 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i &#x27;1a replica-announce-ip 192.168.52.101&#x27; &#123;&#125;/redis.conf 启动为了方便查看日志，可以启动3个ssh窗口，分别启动3个redis实例。启动命令： cd /optredis-server 7001/redis.confredis-server 7002/redis.confredis-server 7003/redis.conf 开启主从关系现在三个实例还没有任何关系，要配置主从可以使用replicaof或者slaceof（5.0以前）命令。 有临时和永久两种模式： 修改配置文件（永久生效） 在redis.conf中添加一行配置 slaveof &lt;masterip&gt; &lt;masterport&gt; 使用redis-cli客户端连接到redis服务，执行命令slaveof命令（重启后失效）： slaveof &lt;masterip&gt; &lt;masterport&gt; 注意：在5.0以后新增命令replicaof，与slaveof效果一致。 使用客户端方式： 再打开一个终端，用于客户端连接 # 7002redis-cli -p 7002SLAVEOF 192.168.52.101 7001# 7003redis-cli -p 7003SLAVEOF 192.168.52.101 7001 当看到7001出现下面提示，即成功。 104351:M 15 Nov 2022 21:57:38.427 * Ready to accept connections104351:M 15 Nov 2022 21:57:54.722 * Replica 192.168.52.101:7002 asks for synchronization104351:M 15 Nov 2022 21:57:54.722 * Partial resynchronization not accepted: Replication ID mismatch (Replica asked for &#x27;f05f17dfba099a756e9a2fced1a1444fbc9fb60e&#x27;, my replication IDs are &#x27;c33ebaeb03975554c7e534413fbd136b47ab377b&#x27; and &#x27;0000000000000000000000000000000000000000&#x27;)104351:M 15 Nov 2022 21:57:54.722 * Replication backlog created, my new replication IDs are &#x27;72984f6fa2a4549194b49eba1df261c33d73fdfa&#x27; and &#x27;0000000000000000000000000000000000000000&#x27;104351:M 15 Nov 2022 21:57:54.722 * Delay next BGSAVE for diskless SYNC104351:M 15 Nov 2022 21:57:59.299 * Starting BGSAVE for SYNC with target: replicas sockets104351:M 15 Nov 2022 21:57:59.299 * Background RDB transfer started by pid 104362104362:C 15 Nov 2022 21:57:59.302 * Fork CoW for RDB: current 0 MB, peak 0 MB, average 0 MB104351:M 15 Nov 2022 21:57:59.302 # Diskless rdb transfer, done reading from pipe, 1 replicas still up.104351:M 15 Nov 2022 21:57:59.304 * Background RDB transfer terminated with success 出现 Error condition on socket for SYNC: Connection refused出现 Error condition on socket for SYNC: Connection refused问题描述104319:S 15 Nov 2022 21:43:43.662 * Connecting to MASTER 192.168.52.101:7001104319:S 15 Nov 2022 21:43:43.662 * MASTER &lt;-&gt; REPLICA sync started104319:S 15 Nov 2022 21:43:43.662 # Error condition on socket for SYNC: Connection refused解决方案修改配置文件中的bind字段bind 0.0.0.0 出现 -DENIED Redis is running in protected mode because protected mode is enabled and no password is set for the default user.出现 -DENIED Redis is running in protected mode because protected mode is enabled and no password is set for the default user.问题描述Error reply to PING from master: &#x27;-DENIED Redis is running in protected mode because protected mode is enabled and no password is set for the default user.&#x27;解决方案1因为主服务器开启了保护模式或者设置了密码，关闭保护模式protected-mode no解决方案2设置密码CONFIG SET masterauth 123123 测试使用客户端连接7001，查看主从信息 redis-cli -p 7001127.0.0.1:7001&gt; INFO replication# Replicationrole:masterconnected_slaves:2slave0:ip=192.168.52.101,port=7002,state=online,offset=504,lag=0slave1:ip=192.168.52.101,port=7003,state=online,offset=504,lag=0master_failover_state:no-failovermaster_replid:72984f6fa2a4549194b49eba1df261c33d73fdfamaster_replid2:0000000000000000000000000000000000000000master_repl_offset:504second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:504 在7001中set一个数据，在其他Redisget # setredis-cli -p 7001set num 123#getredis-cli -p 7002get num 当我们在从节点set时会报错 set num 666(error) READONLY You can&#x27;t write against a read only replica. 搭建哨兵集群这里我们搭建一个三节点形成的Sentinel集群，来监督之前的Redis主从集群。如图： 三个Sentinel实例信息如下： 节点 IP PORT s1 192.168.52.101 27001 s2 192.168.52.101 27002 s3 192.168.52.101 27003 准备实例和配置要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录 创建三个文件夹，名字分别叫s1、s2、s3: # 进入/opt目录cd /opt# 创建目录mkdir s1 s2 s3 然后我们在s1目录创建一个sentinel.conf文件，添加以下内容 port 27001sentinel announce-ip 192.168.52.101sentinel monitor mymaster 192.168.52.101 7001 2sentinel down-after-milliseconds mymaster 5000sentinel failover-timeout mymaster 60000dir &quot;/opt/s1&quot; 参数解释： port 27001：是当前sentinel实例的端口 sentinel monitor mymaster 192.168.52.101 7001 2：指定主节点信息 mymaster：主节点名称，自定义，任意写 192.168.150.101 7001：主节点的ip和端口 2：选举master时的quorum值 然后将s1/sentinel文件拷贝到s2、s3两个目录（在/opt目录执行命令） # 方式一：逐个拷贝cp s1/sentinel.conf s2cp s1/sentinel.conf s3# 方式二：管道组合命令，一键拷贝echo s2 s3 | xargs -t -n 1 cp s1/sentinel.conf 修改s2、s3两个文件夹内的配置文件，将端口分别修改27002、27003: sed -i -e &#x27;s/27001/27002/g&#x27; -e &#x27;s/s1/s2/g&#x27; s2/sentinel.confsed -i -e &#x27;s/27001/27003/g&#x27; -e &#x27;s/s1/s3/g&#x27; s3/sentinel.conf 启动为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令： # 第1个redis-sentinel s1/sentinel.conf# 第2个redis-sentinel s2/sentinel.conf# 第3个redis-sentinel s3/sentinel.conf 启动后： 测试测试前请保证redis主从集群已开启，sentinel集群也开启 关闭7001，后来到sentinel窗口，可以看到窗口中有日志 +sdown master mymaster 192.168.52.101 7001+odown master mymaster 192.168.52.101 7001 #quorum 3/2+new-epoch 6+try-failover master mymaster 192.168.52.101 7001Sentinel new configuration saved on disk+vote-for-leader f8060fe283e55014ffedb8129a3109917856aa72 65352ec72f29b4649d332d945d38f45dac88b4784 voted for f8060fe283e55014ffedb8129a3109917856aa72 6e3fcf15bfe26030bd793a3ebb37394f50e34702c voted for f8060fe283e55014ffedb8129a3109917856aa72 6+elected-leader master mymaster 192.168.52.101 7001+failover-state-select-slave master mymaster 192.168.52.101 7001+selected-slave slave 192.168.52.101:7002 192.168.52.101 7002 @ mymaster 192.168.52.101 7001+failover-state-send-slaveof-noone slave 192.168.52.101:7002 192.168.52.101 7002 @ mymaster 192.168.52.101 7001+failover-state-wait-promotion slave 192.168.52.101:7002 192.168.52.101 7002 @ mymaster 192.168.52.101 7001Sentinel new configuration saved on disk+promoted-slave slave 192.168.52.101:7002 192.168.52.101 7002 @ mymaster 192.168.52.101 7001+failover-state-reconf-slaves master mymaster 192.168.52.101 7001+slave-reconf-sent slave 192.168.52.101:7003 192.168.52.101 7003 @ mymaster 192.168.52.101 7001-odown master mymaster 192.168.52.101 7001+slave-reconf-inprog slave 192.168.52.101:7003 192.168.52.101 7003 @ mymaster 192.168.52.101 7001+slave-reconf-done slave 192.168.52.101:7003 192.168.52.101 7003 @ mymaster 192.168.52.101 7001+failover-end master mymaster 192.168.52.101 7001+switch-master mymaster 192.168.52.101 7001 192.168.52.101 7002 从日志中可以看到是7002被选举成为新的master 再次启动7001，会自动成为slave 搭建分片集群 主从模式、哨兵集群感觉没啥用，就不搭建了，这里直接搭建真·Redis集群 集群结构分片集群需要的节点数量较多，这里我们搭建了一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下： 这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下： IP PORT 角色 192.168.52.101 7001 master 192.168.52.101 7002 master 192.168.52.101 7003 master 192.168.52.101 8001 slave 192.168.52.101 8002 slave 192.168.52.101 8003 slave 准备实例和配置删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录： # 进入opt目录cd /opt# 删除旧的，避免配置干扰rm -rf 7001 7002 7003# 创建目录mkdir 7001 7002 7003 8001 8002 8003 在&#x2F;tmp下准备一个新的redis.conf文件，内容如下： port 6379# 开启集群功能cluster-enabled yes# 集群的配置文件名称，不需要我们创建，由redis自己维护cluster-config-file /opt/6379/nodes.conf# 节点心跳失败的超时时间cluster-node-timeout 5000# 持久化文件存放目录dir /opt/6379# 绑定地址bind 0.0.0.0# 让redis后台运行daemonize yes# 注册的实例ipreplica-announce-ip 129.168.52.101# 保护模式protected-mode no# 数据库数量databases 1# 日志logfile /opt/6379/run.log 将这个文件拷贝到每个目录下： # 进入/opt目录cd /opt# 执行拷贝echo 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf 修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致： # 进入/opt目录cd /opt# 修改配置文件printf &#x27;%s &#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i &#x27;s/6379/&#123;&#125;/g&#x27; &#123;&#125;/redis.conf 启动因为已经配置了后台启动模式，所以可以直接启动服务： # 进入/opt目录cd /opt# 一键启动所有服务printf &#x27;%s &#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf 通过ps查看状态： ps -ef | grep redis 如果要关闭所有进程，可以执行命令 ps -ef | grep redis | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill 或者（推荐这种方式）： printf &#x27;%s &#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown 创建集群虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。 我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。 1）Redis5.0之前Redis5.0之前集群命令都是用redis安装包下的src&#x2F;redis-trib.rb来实现的。因为redis-trib.rb是有rubby语法编写所以需要安装ruby环境。 yum -y install zlib ruby rubygemsgem install redis 然后通过命令来管理集群： # 进入redis的src目录cd /opt/redis-stable/src# 创建集群./redis-trib.rb create --teplicas 1 192.168.52.101:7001 192.168.52.101:7002 192.168.52.101:7003 192.168.52.101:8001 192.168.52.101:8002 192.168.52.101:8003 2）Redis5.0之后我们使用的是Redis7.0.5版本，集群管理已经集成到了redis-cli中，格式如下： redis-cli --cluster create --cluster-replicas 1 192.168.52.101:7001 192.168.52.101:7002 192.168.52.101:7003 192.168.52.101:8001 192.168.52.101:8002 192.168.52.101:8003 命令说明： redid-cli --cluster或者./redis-trib.rb：代表集群操作命令 create：代表是创建集群 --replicas 1或者--cluster-replicas 1：指定集群中每个master的副本个数为1，此时节点总数 / (replicas + 1)得到的就是master的数量。因此节点列表中的前n个就是master，其他节点都是slave节点，随机分配到不同master 运行后的样子： 这里输入yes 通过命令可以查看集群状态： redis-cli -p 7001 cluster nodes 测试使用下面命令连接Redis集群 redis-cli -c -p 7001 set一个值 127.0.0.1:7001&gt; set num 123OK 再set一个值 set a 1-&gt; Redirected to slot [15495] located at 192.168.52.101:7003OK192.168.52.101:7003&gt; a计算得到的hash值为15495，该值所在的节点为7003 get一个值 192.168.52.101:7003&gt; get a&quot;1&quot; 再get一个值 192.168.52.101:7003&gt; get num-&gt; Redirected to slot [2765] located at 192.168.52.101:7001&quot;123&quot;192.168.52.101:7001&gt; 可以看到已经切换到7001了","tags":["Redis"],"categories":["后端开发"]},{"title":"Redis实现附近店铺功能","path":"/2022/11/14/Redis实现附近店铺功能/","content":"数据存储形式Redis按照商户类型做分组，类型相同的作为一组，以typeId为key存入同一个GEO集合中 Key Value Score shop:gep:美食 麻辣香锅海底捞火锅 40541350798820954054135064014509 shop:geo:KTV 星聚会KTV开乐迪 KTV 40541350634243764054134341336239 MySQLCREATE TABLE `tb_shop` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `name` varchar(128) NOT NULL COMMENT &#x27;商铺名称&#x27;, `type_id` bigint unsigned NOT NULL COMMENT &#x27;商铺类型的id&#x27;, `images` varchar(1024) NOT NULL COMMENT &#x27;商铺图片，多个图片以&#x27;&#x27;,&#x27;&#x27;隔开&#x27;, `area` varchar(128) DEFAULT NULL COMMENT &#x27;商圈，例如陆家嘴&#x27;, `address` varchar(255) NOT NULL COMMENT &#x27;地址&#x27;, `x` double unsigned NOT NULL COMMENT &#x27;经度&#x27;, `y` double unsigned NOT NULL COMMENT &#x27;维度&#x27;, `avg_price` bigint unsigned DEFAULT NULL COMMENT &#x27;均价，取整数&#x27;, `sold` int(10) unsigned zerofill NOT NULL COMMENT &#x27;销量&#x27;, `comments` int(10) unsigned zerofill NOT NULL COMMENT &#x27;评论数量&#x27;, `score` int(2) unsigned zerofill NOT NULL COMMENT &#x27;评分，1~5分，乘10保存，避免小数&#x27;, `open_hours` varchar(32) DEFAULT NULL COMMENT &#x27;营业时间，例如 10:00-22:00&#x27;, `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`) USING BTREE, KEY `foreign_key_type` (`type_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=15 ROW_FORMAT=COMPACT; 数据准备先将MySQL中的店铺信息存储到Redis中 @Testvoid loadShopData() &#123; List&lt;Shop&gt; list = shopService.list(); Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId)); for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123; Long typeId = entry.getKey(); String key = &quot;shop:geo:&quot; + typeId; List&lt;Shop&gt; value = entry.getValue(); List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(); for (Shop shop : value) &#123; locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;(String.valueOf(shop.getId()), new Point(shop.getX(), shop.getY()))); &#125; stringRedisTemplate.opsForGeo().add(key, locations); &#125;&#125; 实现附近商户功能接口说明 说明 请求方式 GET 请求路径 &#x2F;shop&#x2F;of&#x2F;type 请求参数 typeId：商户类型current：页码，滑动刷新x：经度y：纬度 返回值 List：符合要求的商户信息 版本说明SpringDataReids的2.3.9版本不支持Redis6.2提供的GEOSEARCH命令，因此需要修改版本。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;6.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 更多GEOSEARCH操作见：\tRedis学习笔记- GEO数据结构https://sx-code.github.io/wiki/redis/GEO数据结构/index.html 实体类点击查看实体类@Data@EqualsAndHashCode(callSuper = false)@Accessors(chain = true)@TableName(&quot;tb_shop&quot;)public class Shop implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 主键 */ @TableId(value = &quot;id&quot;, type = IdType.AUTO) private Long id; /** * 商铺名称 */ private String name; /** * 商铺类型的id */ private Long typeId; /** * 商铺图片，多个图片以&#x27;,&#x27;隔开 */ private String images; /** * 商圈，例如陆家嘴 */ private String area; /** * 地址 */ private String address; /** * 经度 */ private Double x; /** * 维度 */ private Double y; /** * 均价，取整数 */ private Long avgPrice; /** * 销量 */ private Integer sold; /** * 评论数量 */ private Integer comments; /** * 评分，1~5分，乘10保存，避免小数 */ private Integer score; /** * 营业时间，例如 10:00-22:00 */ private String openHours; /** * 创建时间 */ private LocalDateTime createTime; /** * 更新时间 */ private LocalDateTime updateTime; @TableField(exist = false) private Double distance;&#125; Controller其中x, y可以不传入 /** * 根据商铺类型分页查询商铺信息 * @param typeId 商铺类型 * @param current 页码 * @return 商铺列表 */@GetMapping(&quot;/of/type&quot;)public Result queryShopByType( @RequestParam(&quot;typeId&quot;) Integer typeId, @RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current, @RequestParam(value = &quot;x&quot;, required = false) Double x, @RequestParam(value = &quot;y&quot;, required = false) Double y) &#123; List&lt;Shop&gt; records = shopService.queryShopByType(typeId, current, x, y); // 返回数据 return Result.ok(records);&#125; ServiceImpl@Resourceprivate StringRedisTemplate stringRedisTemplate;public static final int DEFAULT_PAGE_SIZE = 5;public static final String SHOP_GEO_KEY = &quot;shop:geo:&quot;;@Overridepublic List&lt;Shop&gt; queryShopByType(Integer typeId, Integer current, Double x, Double y) &#123; // 判断是否需要根据坐标查询 if (x == null || y == null) &#123; // 不需要坐标查询, 根据类型分页查询 Page&lt;Shop&gt; page = query() .eq(&quot;type_id&quot;, typeId) .page(new Page&lt;&gt;(current, DEFAULT_PAGE_SIZE)); return page.getRecords(); &#125; // 计算分页参数 int from = (current - 1) * DEFAULT_PAGE_SIZE; int end = current * DEFAULT_PAGE_SIZE; // 查询redis String key = SHOP_GEO_KEY + typeId; GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate .opsForGeo() .search(key, GeoReference.fromCoordinate(x, y), new Distance(5000), RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)); if (results == null) &#123; return Collections.emptyList(); &#125; // 逻辑分页 List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent(); if (list.size() &lt;= from) &#123; // 数据不足，直接返回空集合 return Collections.emptyList(); &#125; Map&lt;String, Distance&gt; distanceMap = new HashMap&lt;&gt;(list.size()); ArrayList&lt;Long&gt; ids = new ArrayList&lt;&gt;(); list.stream().skip(from).forEach(result -&gt; &#123; String shopIdStr = result.getContent().getName(); ids.add(Long.valueOf(shopIdStr)); Distance distance = result.getDistance(); distanceMap.put(shopIdStr, distance); &#125;); // 使用in查询，并按顺序返回查询结果 String idStr = StrUtil.join(&quot;,&quot;, ids); List&lt;Shop&gt; shops = query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list(); // 填入Distance for (Shop shop : shops) &#123; shop.setDistance(distanceMap.get(shop.getId().toString()).getValue()); &#125; return shops;&#125; 由于limit()只能传入查询数量，所以需要做逻辑分页，使用stream().skip(from)可以跳过from以及之前的。","tags":["Redis"],"categories":["后端开发"]},{"title":"Redis实现一人一赞功能","path":"/2022/11/11/Redis应用-实现点赞功能/","content":"需求 同一个用户只能点赞一次，再次点击则取消点赞 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性） 获取最新点赞的前5个用户展示 实现步骤 给Blog类中添加一个isLike字段，标示是否被当前用户点赞 利用Redis的ZSet集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1 修改查询Blog的业务，判断当前登陆用户是否点赞过，赋值给isLike字段 使用ZSet的range函数取出最新点赞的前5个用户ID，查询信息。 代码实操 实体类点击查看实体类@Data@EqualsAndHashCode(callSuper = false)@Accessors(chain = true)@TableName(&quot;tb_blog&quot;)public class Blog implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 主键 */ @TableId(value = &quot;id&quot;, type = IdType.AUTO) private Long id; /** * 商户id */ private Long shopId; /** * 用户id */ private Long userId; /** * 用户图标 */ @TableField(exist = false) private String icon; /** * 用户姓名 */ @TableField(exist = false) private String name; /** * 是否点赞过了 */ @TableField(exist = false) private Boolean isLike; /** * 标题 */ private String title; /** * 探店的照片，最多9张，多张以&quot;,&quot;隔开 */ private String images; /** * 探店的文字描述 */ private String content; /** * 点赞数量 */ private Integer liked; /** * 评论数量 */ private Integer comments; /** * 创建时间 */ private LocalDateTime createTime; /** * 更新时间 */ private LocalDateTime updateTime;&#125; 点赞Blog首先从ThreadHolder中获取登陆用户的ID，根据key查询是否点赞，如果没有点赞，更新数据库后，以用户ID和点赞时间为value存入Redis的ZSet中；如果已点赞，先更新数据库，后删除Redis数据。 public static final String BLOG_LIKED_KEY = &quot;blog:liked:&quot;;@ResourceStringRedisTemplate stringRedisTempla @Overridepublic void likeBlog(Long id) &#123; // 获取登陆用户 Long userId = UserHolder.getUser().getId(); String key = BLOG_LIKED_KEY + id; Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); if (score == null) &#123; boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update(); if (isSuccess) &#123; stringRedisTemplate.opsForZSet().add(key, String.valueOf(userId), System.currentTimeMillis()); &#125; &#125; else &#123; boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update(); if (isSuccess) &#123; stringRedisTemplate.opsForZSet().remove(key, String.valueOf(userId)); &#125; &#125;&#125; 查询BlogController @GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryBlogById(@PathVariable(&quot;id&quot;) Long id) &#123; try &#123; Blog blog = blogService.queryBlogById(id); return Result.ok(blog); &#125; catch (Exception e) &#123; return Result.fail(e.getMessage()); &#125;&#125; Service实现类 查询Redis中是否有该用户点赞信息，如果有，则设置Blog类中的isLike = true。 public static final String BLOG_LIKED_KEY = &quot;blog:liked:&quot;;@ResourceStringRedisTemplate stringRedisTemplate;@Overridepublic Blog queryBlogById(Long id) throws Exception &#123; Blog blog = getById(id); if (blog == null) &#123; throw new Exception(&quot;笔记不存在！&quot;); &#125; queryBlogUser(blog); // 查询blog是否被点赞 isBlogLiked(blog); return blog;&#125;/** * 查询博客的作者 * @param blog 博客 */private void queryBlogUser(Blog blog) &#123; User user = userService.getById(blog.getUserId()); blog.setIcon(user.getIcon()); blog.setName(user.getNickName());&#125;/** * 查询博客是否被浏览者点赞 * @param blog 博客 */private void isBlogLiked(Blog blog) &#123; UserDTO user = UserHolder.getUser(); if (user == null) &#123; // 用户未登录，无需查询是否被点赞 return; &#125; Long userId = user.getId(); String key = BLOG_LIKED_KEY + blog.getId(); Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); blog.setIsLike(score != null);&#125; 点赞Top5根据点赞时间获取点赞的前5个用户 public static final String BLOG_LIKED_KEY = &quot;blog:liked:&quot;;@ResourceStringRedisTemplate stringRedisTempla@Overridepublic List&lt;UserDTO&gt; queryBlogLikes(Long id) &#123; String key = RedisConstants.BLOG_LIKED_KEY + id; Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4); if (top5 == null || top5.isEmpty()) &#123; return Collections.emptyList(); &#125; // 解析出其中的用户id List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList()); // 将User转为UserDTO，隐藏信息 String idStr = StrUtil.join(&quot;,&quot;, ids); return userService.query() .in(&quot;id&quot;, ids) .last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;) .list() .stream() .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)) .collect(Collectors.toList());&#125; ZSet中返回的结果是根据点赞顺序来的，但是使用IN查询的结果却不是。使用ORDER BY FIELD(id, id1, id2)返回按照原始字段顺序的结果 总结使用Redis中的可排序集合ZSet进行点赞数据的存储 更加完善的做法应该是从Redis读取数据持久化到MySQL中 文章点赞数量也应该使用Redis来存储，定时持久化。","tags":["Redis"],"categories":["后端开发"]},{"title":"Redis实现优惠券秒杀","path":"/2022/11/09/Redis实现优惠券秒杀/","content":"本次项目用到的两张表 tb_voucher：优惠券的基本信息，优惠券金额、使用规制等 CREATE TABLE `tb_voucher` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `shop_id` bigint unsigned DEFAULT NULL COMMENT &#x27;商铺id&#x27;, `title` varchar(255) NOT NULL COMMENT &#x27;代金券标题&#x27;, `sub_title` varchar(255) DEFAULT NULL COMMENT &#x27;副标题&#x27;, `rules` varchar(1024) DEFAULT NULL COMMENT &#x27;使用规则&#x27;, `pay_value` bigint unsigned NOT NULL COMMENT &#x27;支付金额，单位是分。例如200代表2元&#x27;, `actual_value` bigint NOT NULL COMMENT &#x27;抵扣金额，单位是分。例如200代表2元&#x27;, `type` tinyint unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;0,普通券；1,秒杀券&#x27;, `status` tinyint unsigned NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;1,上架; 2,下架; 3,过期&#x27;, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4; tb_seckill_voucher：优惠券的库存、开始抢购时间。特价优惠券才需要填写这些信息 CREATE TABLE `tb_seckill_voucher` ( `voucher_id` bigint unsigned NOT NULL COMMENT &#x27;关联的优惠券的id&#x27;, `stock` int NOT NULL COMMENT &#x27;库存&#x27;, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `begin_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;生效时间&#x27;, `end_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;失效时间&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`voucher_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=COMPACT COMMENT=&#x27;秒杀优惠券表，与优惠券是一对一关系&#x27;; 问题分析我们先来分析一下优惠券秒杀项目中会出现的问题： 全局唯一ID问题 超卖问题 一人一单问题 全局唯一ID使用Reids自定义全局ID生成器，要在分布式系统中使用需要满足：唯一性、高可用、高性能、递增型、安全性。 为了增加ID安全性，不可直接使用Redis自增的数值，而是拼接一些其他信息 ID的组成部分： 符号位：1bit，永远为0 时间戳：31bit，以秒为单位，可以使用69年 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID 点击查看实现代码@Componentpublic class RedisIdWorker &#123; /** * 开始时间戳 */ private static final long BEGIN_TIMESTAMP = 1640995200L; /** * 序列号位数 */ private static final int COUNT_BITS = 32; private final StringRedisTemplate stringRedisTemplate; public RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; public long nextId(String keyPrefix) &#123; // 生成时间戳 LocalDateTime now = LocalDateTime.now(); long nowSecond = now.toEpochSecond(ZoneOffset.UTC); long timestamp = nowSecond - BEGIN_TIMESTAMP; // 生成序列号 // 获取当天日期，精确到天 String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;)); long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date); // 拼接并返回 return timestamp &lt;&lt; COUNT_BITS | count; &#125;&#125; 超卖问题问题分析假设当券剩下最后一张时，有三个线程（用户）同时抢购，线程1先查询结果有1个，这时线程2和3在1扣减之前先查询了结果也是1，此时线程1先去执行扣减操作，这是数据库中券为0。由于线程2和3查询也是1，所以也去扣减，超卖问题出现了。 解决方案超买问题就是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁： 悲观锁 认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行 例如Synchronized、Lock都属于悲观锁 乐观锁 认为线程安全问题不一定会发生，因此不加锁，只是在更新时有没有其它线程对数据做修改 如果没有修改则认为是安全的，自己才更新数据 如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常 乐观锁乐观锁的关键是判断之前查询得到的数据是否有被修改过，常见的两种方式： 版本号法 Id stock version 10 1 1 在操作数据之前先查询version，修改时判断version是否和之前查询的一致 set stock = stock - 1, version = version + 1where id = 10 and version = 1 CAS法 Id stock 10 1 在操作数据之前先查询stock，修改时判断stock是否和之前查询的一致 set stock = stock - 1where id = 10 and stock = 1 代码实操在减少库存代码中，加入对stock的判断 @Transactional@Overridepublic boolean cutVoucher(Long voucherId, Integer stock) &#123; return update() .setSql(&quot;stock = stock-1&quot;) .eq(&quot;voucher_id&quot;, voucherId) .eq(&quot;stock&quot;, stock) .update();&#125; 这样改存在失败率太高的问题，其实只要减少时的stock大于0就可以执行扣减操作 @Transactional@Overridepublic boolean cutVoucher(Long voucherId) &#123; return update() .setSql(&quot;stock = stock-1&quot;) .eq(&quot;voucher_id&quot;, voucherId) .gt(&quot;stock&quot;, 0) .update();&#125; 总结超卖这样的线程安全问题，解决方案有哪些？ 悲观锁：添加同步锁，让线程串行执行 优点：简单粗暴 缺点：性能一般 乐观锁：不加锁，在更新时判断是否有其他线程在修改 优点：性能好 缺点：存在成功率低的问题 一人一单每个用户只能抢购一个优惠券 解决思路 我们可以看到是先查询订单，之后再进行判断和扣减库操作，也存在线程安全问题。 这里我们直接使用Redisson，进行加锁处理。 Redssion时一个在Redis的基础上实现的Java常驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。 代码实操我们在pom文件中引入Redisson的依赖 &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.13.6&lt;/version&gt;&lt;/dependency&gt; 再通过@Bean的方式交给Spring管理 @Configurationpublic class RedisConfig &#123; @Bean public RedissonClient redissonClient() &#123; // 配置类 Config config = new Config(); // 添加redis地址，这里添加了单点地址，也可使用config.useClusterServers()，添加集群地址 config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setPassword(&quot;123123&quot;); // 创建客户端 return Redisson.create(config); &#125;&#125; 先看一下简单的使用 点击查看使用代码@Resourceprivate IVoucherOrderService voucherOrderService;@Resourceprivate RedissonClient redissonClient;@Transactionalpublic Result createVoucherOrder(Long voucherId) &#123; // 获取用户ID Long userId = UserHolder.getUser().getId(); // 创建锁对象，仅对用户锁 RLock redisLock = redissonClient.getLock(&quot;lock:order:&quot; + userId); // 获取锁 boolean isLock = redisLock.tryLock(); // 判断是否获取锁成功 if (!isLock) &#123; // 获取锁失败，返回错误或重试 return Result.fail(&quot;不允许重复下单&quot;); &#125; try &#123; int count = voucherOrderService.query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count(); if (count &gt; 0) &#123; // 用户已经购买过了 return Result.fail(&quot;您已经领过该券！&quot;); &#125; // 扣减库存 boolean success = seckillVoucherService.cutVoucher(voucherId); if (!success) &#123; return Result.fail(&quot;库存不足&quot;); &#125; Long orderId = voucherOrderService.seckillVoucher(voucherId); return Result.ok(orderId); &#125; finally &#123; // 释放锁 redisLock.unlock(); &#125;&#125;","tags":["Redis"],"categories":["后端开发"]},{"title":"安卓开发-使用Retrofit上传图片","path":"/2022/11/08/安卓开发使用Retrofit上传图片/","content":"Retrofit使用协程发送请求参考文章 使用Kotlin协程配合Retrofit发送请求https://sx-code.github.io/2022/11/08/使用Kotlin协程配合Retrofit发送请求/ 导入依赖app的build文件中加入： implementation &#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;implementation &#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27; 注意依赖版本 Retrofit实例/** * 创建Retrofit提供API Service */object RetrofitClient &#123; const val BASE_URL = &quot;http://192.168.2.194:8080/&quot; // http://localhost:8080/ val okHttpClient = OkHttpClient.Builder() .callTimeout(30, TimeUnit.SECONDS) .build() val retrofit = Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(okHttpClient) .build() val articleService = retrofit.create(ArticleService::class.java)&#125; Serviceinterface ArticleService &#123; @Multipart @POST(&quot;article/upload/picture&quot;) suspend fun uploadSingle(@Part file: MultipartBody.Part): ResultData&lt;Picture&gt; @Multipart @POST(&quot;article/upload/pictures&quot;) suspend fun uploadMulti(@Part files: List&lt;MultipartBody.Part&gt;): ResultData&lt;Picture&gt;&#125; 注意，请求路径前不加/，因为BASE_URL中已经加了 在ViewModel中使用class ArticleViewModel : ViewModel() &#123; val picture by lazy &#123; MutableLiveData&lt;Picture&gt;() &#125; /** * 上传单张图片 */ fun uploadSinglePicture(file: File) &#123; val builder = MultipartBody.Builder().setType(MultipartBody.FORM) //表单类型 val requestFile: RequestBody = RequestBody.create(MediaType.parse(&quot;image/*&quot;), file) builder.addFormDataPart(&quot;file&quot;, file.name, requestFile) val part = builder.build().part(0) viewModelScope.launch &#123; val resultData = RetrofitClient.articleService.uploadSingle(part) picture.value = resultData.data &#125; &#125; /** * 上传多张图片 */ fun uploadSinglePicture(files: List&lt;File&gt;) &#123; val builder = MultipartBody.Builder().setType(MultipartBody.FORM) //表单类型 for (file in files) &#123; val requestFile: RequestBody = RequestBody.create(MediaType.parse(&quot;image/*&quot;), file) builder.addFormDataPart(&quot;file&quot;, file.name, requestFile) &#125; val parts = builder.build().parts() viewModelScope.launch &#123; val resultData = RetrofitClient.articleService.uploadMulti(parts) picture.value = resultData.data &#125; &#125;&#125; SpringBoot项目接收/** * 接收单张图片 */@PostMapping(&quot;upload/picture&quot;)public Map&lt;String, Object&gt; uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile file) &#123; System.out.println(file.getOriginalFilename()); Map&lt;String, Object&gt; dataMap = new HashMap&lt;&gt;(); dataMap.put(&quot;url&quot;, &quot;http://localhost:8080/picture/&quot; + file.getOriginalFilename()); return dataMap;&#125; 额外参数这个直接添加就行了……………..","tags":["Android","Retrofit"],"categories":["Android开发"]},{"title":"安卓开发-解决WebView+Recyclerview实现文章详情页的高度问题","path":"/2022/11/08/解决WebView-Recyclerview实现文章详情页的高度问题/","content":"最近在写一个APP时，需要显示文章详情页，准备使用WebView和RecyclerView实现上面文章，下面评论。出现了WebView高度问题，WebView加载HTML格式数据，而非URL。 这里的WebView为自定义组件NestedScrollingWebView，已解决嵌套滑动问题。 问题1如果WebView设置为wrap_content，可能由于网络和性能会出现文章加载没有评论快，导致评论会在WebView渲染数据时提前显示在上面的情况，很不美观。 点击查看问题 问题2如果WebView设置为match_parent，当文章高度不足一屏时，下面空白太大，不美观。 点击查看问题 left 文章内容超过一屏幕时 right 文章内容不足一屏幕时 解决方案效果可以先看一下效果 点击查看效果 思路利用JS获取高度，然后通知（loadUrl(js)）WebView改变高度。关于JS获取高度，这里采用了一种我觉得很准确的方法 private fun getHtmlData(title:String, bodyHTML: String): String &#123; val head = (&quot;&lt;head&gt;&quot; + &quot;&lt;meta name=\\&quot;viewport\\&quot; &quot; + &quot;content=\\&quot;width=device-width, &quot; + &quot;initial-scale=1.0, user-scalable=no\\&quot;&gt; &quot; + &quot;&lt;style&gt;&lt;/style&gt;&lt;/head&gt;&quot;) return &quot;&lt;html&gt;$head&lt;body&gt;&quot; + &quot;&lt;h2 class=&#x27;title&#x27;&gt;$title&lt;/h2&gt;$bodyHTML&lt;div class=&#x27;bottom&#x27;&gt;&lt;/div&gt;&quot; + &quot;&lt;/body&gt;&lt;/html&gt;&quot;&#125; 在文章内容的最下面加一个div，通过document.querySelector(&#39;.bottom&#39;).offsetTop来用于确定高度 具体方法1、先创建一个Mobile类 private inner class Mobile &#123; @JavascriptInterface fun onGetWebContentHeight(height: Int) &#123; contentWV.post &#123; val layoutParams = contentWV.layoutParams layoutParams.height = Utils.getPixelByDp(this@JsSetHeightActivity, height) contentWV.layoutParams = layoutParams Log.i(TAG, &quot;onGetWebContentHeight: height=$height&quot;) &#125; &#125;&#125; 2、在初始化WebView时，设置必要参数 private fun initView() &#123; contentWV = findViewById&lt;NestedScrollingWebView&gt;(R.id.content_wv) // 开启js val setting = contentWV.settings setting.javaScriptEnabled = true // 添加JS接口 val mobile = Mobile() contentWV.addJavascriptInterface(mobile, &quot;mobile&quot;) // 在 onPageFinished时重新设置高度 val webClient = object : WebViewClient() &#123; override fun onPageFinished(view: WebView?, url: String?) &#123; val js = &quot;javascript:mobile.onGetWebContentHeight(document.querySelector(&#x27;.bottom&#x27;).offsetTop)&quot; view?.loadUrl(js) &#125; &#125; contentWV.webViewClient = webClient&#125; 在页面加载完成之后，会重新设置高度 Demo下载文章详情 Demo下载 参考文中的WebView以及NestedScroll的用法参考：10分钟带你入门NestedScrolling机制 - SegmentFault 思否 其他实现方案：上面webview 下边评论 (applemei.com)","tags":["Android"],"categories":["Android开发"]},{"title":"安卓开发-封装处理Retrofit协程请求中的异常","path":"/2022/11/08/封装处理Retrofit协程请求中的异常/","content":"上篇文章讲解了怎么使用Kotlin的协程配合Retrofit发起网络请求，使用也是非常方便，但是在处理请求异常还不是很人性化。这篇文章，我们将处理异常的代码进行封装，以便对异常情况返回给页面，提供更加友好的提示。 编写拓展方法我们写一个扩展（全局）方法，就叫ViewModelExt.kt，在下面创建方法。 /** * ViewModel扩展方法：启动协程 * @param block 协程逻辑 * @param onError 错误回调方法 * @param onComplete 完成回调方法 */fun ViewModel.launch( block: suspend CoroutineScope.() -&gt; Unit, onError: (e: Throwable) -&gt; Unit = &#123; _: Throwable -&gt; &#125;, onComplete: () -&gt; Unit = &#123;&#125;) &#123; viewModelScope.launch( CoroutineExceptionHandler &#123; _, throwable -&gt; run &#123; // 这里统一处理错误 ExceptionUtil.catchException(throwable) onError(throwable) &#125; &#125; ) &#123; try &#123; block.invoke(this) &#125; finally &#123; onComplete() &#125; &#125;&#125; 统一异常处理拓展方法里面对写成过程做了统一拦截，在onComplete方法可以做统一的异常处理 /** * 异常工具类 * @author ssq */object ExceptionUtil &#123; /** * 处理异常，toast提示错误信息 */ fun catchException(e: Throwable) &#123; e.printStackTrace() when (e) &#123; is HttpException -&gt; &#123; catchHttpException(e.code()) &#125; is SocketTimeoutException -&gt; &#123; showToast(R.string.common_error_net_time_out) &#125; is UnknownHostException, is NetworkErrorException -&gt; &#123; showToast(R.string.common_error_net) &#125; is MalformedJsonException, is JsonSyntaxException -&gt; &#123; showToast(R.string.common_error_server_json) &#125; is InterruptedIOException -&gt; &#123; showToast(&quot;服务器连接失败，请稍后重试&quot;) &#125; // 自定义接口异常 is ApiException -&gt; &#123; showToast(e.message?:&quot;&quot;, e.code) &#125; is ConnectException -&gt; &#123; showToast( &quot;连接服务器失败&quot; ) &#125; else -&gt; &#123; showToast(&quot;$&#123;MyApplication.instance.getString( R.string.common_error_do_something_fail )&#125;：$&#123;e::class.java.name&#125;&quot;) &#125; &#125; &#125; /** * 处理网络异常 */ fun catchHttpException(errorCode: Int) &#123; if (errorCode in 200 until 300) return// 成功code则不处理 showToast( catchHttpExceptionCode( errorCode ), errorCode ) &#125; /** * toast提示 */ private fun showToast(@StringRes errorMsg: Int, errorCode: Int = -1) &#123; showToast( MyApplication.instance.getString( errorMsg ), errorCode ) &#125; /** * toast提示 */ private fun showToast(errorMsg: String, errorCode: Int = -1) &#123; if (errorCode == -1) &#123; ToastUtils.showShort(errorMsg) &#125; else &#123; ToastUtils.showShort(&quot;$errorCode：$errorMsg&quot;) &#125; &#125; /** * 处理网络异常 */ private fun catchHttpExceptionCode(errorCode: Int): Int = when (errorCode) &#123; in 500..600 -&gt; R.string.common_error_server in 400 until 500 -&gt; R.string.common_error_request else -&gt; R.string.common_error_request &#125;&#125; ApiException是自定义的异常类 如何使用我们在一个ViewModel中可以这样使用 fun login(user: User) = launch(&#123; val resultData = RetrofitClient.userService.login(user) if (resultData.code == 20000) &#123; userInfo.value = RetrofitClient.userService.getUserInfo().data &#125;&#125;,onError = &#123; e: Throwable -&gt;&#125;) 注意：我们在ViewModel的拓展方法中已经进行了协程调用操作，所以这里直接调用拓展方法即可。 如果是返回的结果不对，可以这样做 fun login(user: User) = launch(&#123; val resultData = RetrofitClient.userService.login(user) if (resultData.code == 20000) &#123; userInfo.value = RetrofitClient.userService.getUserInfo().data &#125; else &#123; throw ApiException(-1, &quot;返回结果出错&quot;) &#125;&#125;,onError = &#123; e: Throwable -&gt; // 在这里进行处理&#125;) ApiException是自定义的异常处理，该异常同样会被拦截，进入onError中，可以在这里进行处理。","tags":["Android","Kotlin","Retrofit"],"categories":["Android开发"]},{"title":"安卓开发-使用Kotlin协程配合Retrofit发送请求","path":"/2022/11/08/使用Kotlin协程配合Retrofit发送请求/","content":"Retrofit2.6开始增加了对Kotlin协程的支持，可以通过suspend函数进行异步调用。本文简单介绍一下使用Kotlin协程配合Retrofit使用，发起网络请求。 导入依赖app的build文件中加入： implementation &#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;implementation &#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27;implementation &#x27;androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1&#x27; 注意依赖版本 data class定义一个结果类，可以与后端的数据保持一致 data class ResultData&lt;T&gt;( val code: Int, val message: String, val data: T) ServiceArticleService是一个专门用来写请求方法的接口，不用我们实现。 interface ArticleService &#123; @GET(&quot;article/get/&#123;id&#125;&quot;) suspend fun getArticleById(@Path(&quot;id&quot;) id: Long): ResultData&lt;Article&gt;&#125; 注意，请求路径前不加/，因为BASE_URL中已经加了 Retrofit实例/** * 创建Retrofit提供API Service */object RetrofitClient &#123; const val BASE_URL = &quot;http://192.168.2.194:8080/&quot; // http://localhost:8080/ val okHttpClient = OkHttpClient.Builder() .callTimeout(30, TimeUnit.SECONDS) .build() val retrofit = Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(okHttpClient) .build() val articleService = retrofit.create(ArticleService::class.java)&#125; 在ViewModel中使用class ArticleViewModel : ViewModel() &#123; val article by lazy &#123; MutableLiveData&lt;Article&gt;() &#125; fun getArticle(id: Long) &#123; viewModelScope.launch &#123; val article = RetrofitClient.articleService.getArticleById(id) contentList.value = articleList.data Log.d(&quot;ViewPagerViewModel&quot;, &quot;getArticle: $article&quot;) &#125; &#125;&#125; ViewModelScope为了调用suspend方法，需要提供一个CoroutineScope，如果是在ViewModel中进行api请求，可以像实例中那样使用ktx提供的viewModelScope，viewModelScope可以帮助我们在viewModel的onCleared时自动进行job的cancel，否则需要在手动cancel。 不在ViewModel中使用，例如在Activity中使用时，可以如下调用 CoroutineScope(Dispatchers.Main).launch &#123; // ...&#125; 不使用协程Serviceinterface ArticleService &#123; @GET(&quot;article/get/&#123;id&#125;&quot;) fun getArticleById(@Path(&quot;id&quot;) id: Long): Call&lt;Article&gt;&#125; 返回Call类型结果，通过enqueue插入队列等待回调处理 fun getArticle(id: Long) &#123; private val api = RetrofitClient.articleService api.getArticleById().enqueue(object : Callback&lt;Article&gt; &#123; override fun onResponse(call: Call&lt;Article&gt;, response: Response&lt;Article&gt;) &#123; // 成功逻辑 &#125; override fun onFailure(call: Call&lt;Article&gt;, t: Throwable) &#123; // 失败逻辑 &#125; &#125;)&#125;","tags":["Android","Kotlin","Retrofit"],"categories":["Android开发"]},{"title":"自定义Naive UI的数据表格Data Table中按钮Button图标","path":"/2022/11/08/自定义Naive-UI的数据表格Data-Table中按钮Button图标/","content":"在Naive UI官网中详细介绍了[数据表格 Data Table](数据表格 Data Table - Naive UI)的使用方式，支持我们在表格中放入按钮Button，进行更多的操作。 &#123;\ttitle: &quot;Action&quot;,\tkey: &quot;actions&quot;,\trender(row) &#123; return h( NButton, &#123; strong: true, tertiary: true, size: &quot;small&quot;, onClick: () =&gt; play(row), &#125;, &#123; default: () =&gt; &quot;Play&quot; &#125; );\t&#125;,&#125;, 根据案例可知default是设置文字的，在[Button](按钮 Button - Naive UI)的Slot中还有一个icon，这个就是自定义按钮图标的 名称 参数 说明 default () 按钮的内容 icon () 按钮的图标 使用方法如下：原文：sw-code &lt;template&gt; &lt;n-data-table :columns=&quot;columns&quot; :data=&quot;data&quot; :pagination=&quot;pagination&quot; :bordered=&quot;false&quot; /&gt;&lt;/template&gt;&lt;script&gt;import &#123; h, defineComponent &#125; from &#x27;vue&#x27;import &#123; NButton &#125; from &#x27;naive-ui&#x27;import &#123; DeleteFilled &#125; from &#x27;@vicons/antd&#x27;const createColumns = (&#123; checkRow, deleteItem &#125;) =&gt; &#123; return [ &#123; title: &quot;操作&quot;, key: &quot;actions&quot;, align: &quot;center&quot;, width: &quot;200&quot;, render(row) &#123; return [ h( NButton, &#123; strong: true, tertiary: true, size: &quot;small&quot;, onClick: () =&gt; checkRow(row), &#125;, &#123; default: () =&gt; &quot;Check&quot; &#125; ), h( NButton, &#123; quaternary: true, circle: true, size: &quot;small&quot;, style: &#123; marginLeft: &quot;20px&quot;, &#125;, onClick: () =&gt; deleteItem(row), &#125;, &#123; icon: () =&gt; h(NIcon, null, &#123; default: () =&gt; h(DeleteFilled) &#125;) &#125; ), ]; &#125;, &#125;, ];&#125;;export default defineComponent(&#123; setup() &#123; return &#123; data: null, columns: createColumns(&#123; checkRow(row) &#123; console.log(row) &#125;, deleteItem(row) &#123; console.log(row) &#125; &#125;), pagination: false &#125; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;","tags":["Naive UI"],"categories":["前端开发"]},{"title":"SpringBoot统一封装返回结果和异常情况","path":"/2022/11/07/SpringBoot统一封装返回结果和异常情况/","content":"项目地址Gitee地址https://gitee.com/SX-Code/springboot-response_result 项目简介在springboot项目里我们希望接口返回的数据包含至少三个属性： code：请求接口的返回码，成功或者异常等返回编码，例如定义请求成功。 message：请求接口的描述，也就是对返回编码的描述。 data：请求接口成功，返回的结果。 &#123; &quot;code&quot;:20000, &quot;message&quot;:&quot;成功&quot;, &quot;data&quot;:&#123; &quot;info&quot;:&quot;测试成功&quot; &#125;&#125; 开发环境 工具：IDEA SpringBoot版本：2.2.2.RELEASE 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- swagger3 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 创建 SpringBoot 工程新建 SpringBoot 项目common_utils，包名com.spring.utils 返回结果统一创建code枚举在com.spring.utils中创建 pojo 包，并添加枚举ResultCode public enum ResultCode &#123; /* 成功状态码 */ SUCCESS(20000, &quot;成功&quot;), /* 参数错误 */ PARAM_IS_INVALID(1001, &quot;参数无效&quot;), PARAM_IS_BLANK(1002, &quot;参数为空&quot;), PARAM_TYPE_BIND_ERROR(1003, &quot;参数类型错误&quot;), PARAM_NOT_COMPLETE(1004, &quot;参数缺失&quot;), /* 用户错误 2001-2999*/ USER_NOTLOGGED_IN(2001, &quot;用户未登录&quot;), USER_LOGIN_ERROR(2002, &quot;账号不存在或密码错误&quot;), SYSTEM_ERROR(10000, &quot;系统异常，请稍后重试&quot;); private Integer code; private String message; private ResultCode(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer code() &#123; return this.code; &#125; public String message() &#123; return this.message; &#125;&#125; 可根据项目自定义，结果返回码 创建返回结果实体在 pojo 包中添加返回结果类R @Data@ApiModel(value = &quot;返回结果实体类&quot;, description = &quot;结果实体类&quot;)public class R implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = &quot;返回码&quot;) private Integer code; @ApiModelProperty(value = &quot;返回消息&quot;) private String message; @ApiModelProperty(value = &quot;返回数据&quot;) private Object data; private R() &#123; &#125; public R(ResultCode resultCode, Object data) &#123; this.code = resultCode.code(); this.message = resultCode.message(); this.data = data; &#125; private void setResultCode(ResultCode resultCode) &#123; this.code = resultCode.code(); this.message = resultCode.message(); &#125; // 返回成功 public static R success() &#123; R result = new R(); result.setResultCode(ResultCode.SUCCESS); return result; &#125; // 返回成功 public static R success(Object data) &#123; R result = new R(); result.setResultCode(ResultCode.SUCCESS); result.setData(data); return result; &#125; // 返回失败 public static R fail(Integer code, String message) &#123; R result = new R(); result.setCode(code); result.setMessage(message); return result; &#125; // 返回失败 public static R fail(ResultCode resultCode) &#123; R result = new R(); result.setResultCode(resultCode); return result; &#125;&#125; 自定义一个注解新建包annotation，并添加ResponseResult注解类 @Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.TYPE, ElementType.METHOD&#125;)@Documentedpublic @interface ResponseResult &#123;&#125; 定义拦截器新建包interceptor，并添加ResponseResultInterceptorJava类 @Componentpublic class ResponseResultInterceptor implements HandlerInterceptor &#123; //标记名称 public static final String RESPONSE_RESULT_ANN = &quot;RESPONSE-RESULT-ANN&quot;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO Auto-generated method stub if (handler instanceof HandlerMethod) &#123; final HandlerMethod handlerMethod = (HandlerMethod) handler; final Class&lt;?&gt; clazz = handlerMethod.getBeanType(); final Method method = handlerMethod.getMethod(); // 判断是否在类对象上添加了注解 if (clazz.isAnnotationPresent(ResponseResult.class)) &#123; // 设置此请求返回体，需要包装，往下传递，在ResponseBodyAdvice接口进行判断 request.setAttribute(RESPONSE_RESULT_ANN, clazz.getAnnotation(ResponseResult.class)); &#125; else if (method.isAnnotationPresent(ResponseResult.class)) &#123; request.setAttribute(RESPONSE_RESULT_ANN, method.getAnnotation(ResponseResult.class)); &#125; &#125; return true; &#125;&#125; 用于拦截请求，判断 Controller 是否添加了@ResponseResult注解 注册拦截器新建包config，并添加WebAppConfig配置类 @Configurationpublic class WebAppConfig implements WebMvcConfigurer &#123; // SpringMVC 需要手动添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; ResponseResultInterceptor interceptor = new ResponseResultInterceptor(); registry.addInterceptor(interceptor); WebMvcConfigurer.super.addInterceptors(registry); &#125;&#125; 方法返回值拦截处理器新建包handler，并添加ResponseResultHandler配置类，实现ResponseBodyAdvice重写两个方法 import org.springframework.web.method.HandlerMethod;/** * 使用 @ControllerAdvice &amp; ResponseBodyAdvice * 拦截Controller方法默认返回参数，统一处理返回值/响应体 */@ControllerAdvicepublic class ResponseResultHandler implements ResponseBodyAdvice&lt;Object&gt; &#123; // 标记名称 public static final String RESPONSE_RESULT_ANN = &quot;RESPONSE-RESULT-ANN&quot;; // 判断是否要执行 beforeBodyWrite 方法，true为执行，false不执行，有注解标记的时候处理返回值 @Override public boolean supports(MethodParameter arg0, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; arg1) &#123; ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = sra.getRequest(); // 判断请求是否有包装标记 ResponseResult responseResultAnn = (ResponseResult) request.getAttribute(RESPONSE_RESULT_ANN); return responseResultAnn == null ? false : true; &#125; // 对返回值做包装处理 @Override public Object beforeBodyWrite(Object body, MethodParameter arg1, MediaType arg2, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; arg3, ServerHttpRequest arg4, ServerHttpResponse arg5) &#123; if (body instanceof R) &#123; return (R) body; &#125; else if (body instanceof String) &#123; return body; &#125; return R.success(body); &#125;&#125; 实现ResponseBodyAdvice重写两个方法 添加@ControllerAdvice注解 测试新建包controller，并添加TestController测试类 @RestController@ResponseResultpublic class TestController &#123; @GetMapping(&quot;/test&quot;) public Map&lt;String, Object&gt; test() &#123; HashMap&lt;String, Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;info&quot;, &quot;测试成功&quot;); return data; &#125;&#125; 添加@ResponseResult注解 启动项目，在默认端口: 8080 浏览器访问地址：localhost:8080/test &#123;&quot;code&quot;:20000,&quot;message&quot;:&quot;成功&quot;,&quot;data&quot;:&#123;&quot;info&quot;:&quot;测试成功&quot;&#125;&#125; 总结1、创建code枚举和返回结果实体类 2、自定义一个注解@ResponseResult 3、定义拦截器，拦截请求，判断Controller上是否添加了@ResponseResult注解。如果添加了注解在request中添加注解标记，往下传递 4、添加@ControllerAdvice注解 ，实现ResponseBodyAdvice接口，并重写两个方法，通过判断request中是否有注解标记，如果有就往下执行，进一步包装。没有就直接返回，不需包装。 问题1、如果要返回错误结果，这种方法显然不方便 @GetMapping(&quot;/fail&quot;)public R error() &#123; int res = 0; // 查询结果数 if(res == 0) &#123; return R.fail(10001, &quot;没有数据&quot;); &#125; return R.success(res);&#125; 2、我们需要对错误和异常进行进一步的封装 封装错误和异常结果创建错误结果实体在包pojo中添加ErrorResult实体类 /** * 异常结果包装类 * @author sw-code * */public class ErrorResult &#123; private Integer code; private String message; private String exception; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public String getException() &#123; return exception; &#125; public void setException(String exception) &#123; this.exception = exception; &#125; public static ErrorResult fail(ResultCode resultCode, Throwable e, String message) &#123; ErrorResult errorResult = ErrorResult.fail(resultCode, e); errorResult.setMessage(message); return errorResult; &#125; public static ErrorResult fail(ResultCode resultCode, Throwable e) &#123; ErrorResult errorResult = new ErrorResult(); errorResult.setCode(resultCode.code()); errorResult.setMessage(resultCode.message()); errorResult.setException(e.getClass().getName()); return errorResult; &#125; public static ErrorResult fail(Integer code, String message) &#123; ErrorResult errorResult = new ErrorResult(); errorResult.setCode(code); errorResult.setMessage(message); return errorResult; &#125;\t&#125; 自定义异常类在包pojo中添加BizException实体类，继承RuntimeException @Datapublic class BizException extends RuntimeException &#123; /** * 错误码 */ private Integer code; /** * 错误信息 */ private String message; public BizException() &#123; super(); &#125; public BizException(ResultCode resultCode) &#123; super(resultCode.message()); this.code = resultCode.code(); this.message = resultCode.message(); &#125; public BizException(ResultCode resultCode, Throwable cause) &#123; super(resultCode.message(), cause); this.code = resultCode.code(); this.message = resultCode.message(); &#125; public BizException(String message) &#123; super(message); this.code = -1; this.message = message; &#125; public BizException(Integer code, String message) &#123; super(message); this.code = code; this.message = message; &#125; public BizException(Integer code, String message, Throwable cause) &#123; super(message, cause); this.code = code; this.message = message; &#125; @Override public synchronized Throwable fillInStackTrace() &#123; return this; &#125;&#125; 全局异常处理类在包handler中添加GlobalExceptionHandler，添加@RestControllerAdvice注解 /** * 全局异常处理类 * @RestControllerAdvice(@ControllerAdvice)，拦截异常并统一处理 * @author sw-code * */@Slf4j@RestControllerAdvicepublic class GlobalExceptionHandler &#123; /** * 处理自定义的业务异常 * @param e\t异常对象 * @param request\trequest * @return\t错误结果 */ @ExceptionHandler(BizException.class) public ErrorResult bizExceptionHandler(BizException e, HttpServletRequest request) &#123; log.error(&quot;发生业务异常！原因是: &#123;&#125;&quot;, e.getMessage()); return ErrorResult.fail(e.getCode(), e.getMessage()); &#125; // 拦截抛出的异常，@ResponseStatus：用来改变响应状态码 @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Throwable.class) public ErrorResult handlerThrowable(Throwable e, HttpServletRequest request) &#123; log.error(&quot;发生未知异常！原因是: &quot;, e); ErrorResult error = ErrorResult.fail(ResultCode.SYSTEM_ERROR, e); return error; &#125; // 参数校验异常 @ExceptionHandler(BindException.class) public ErrorResult handleBindExcpetion(BindException e, HttpServletRequest request) &#123; log.error(&quot;发生参数校验异常！原因是：&quot;,e); ErrorResult error = ErrorResult.fail(ResultCode.PARAM_IS_INVALID, e, e.getAllErrors().get(0).getDefaultMessage()); return error; &#125; @ExceptionHandler(MethodArgumentNotValidException.class) public ErrorResult handleMethodArgumentNotValidException(MethodArgumentNotValidException e, HttpServletRequest request) &#123; log.error(&quot;发生参数校验异常！原因是：&quot;,e); ErrorResult error = ErrorResult.fail(ResultCode.PARAM_IS_INVALID,e,e.getBindingResult().getAllErrors().get(0).getDefaultMessage()); return error; &#125;\t&#125; 添加注解@RestControllerAdvice(@ControllerAdvice)，拦截异常并统一处理 修改方法返回值拦截处理器将错误和异常结果也进行统一封装 /** * 使用 @ControllerAdvice &amp; ResponseBodyAdvice * 拦截Controller方法默认返回参数，统一处理返回值/响应体 */@ControllerAdvicepublic class ResponseResultHandler implements ResponseBodyAdvice&lt;Object&gt; &#123; // 标记名称 public static final String RESPONSE_RESULT_ANN = &quot;RESPONSE-RESULT-ANN&quot;; // 判断是否要执行 beforeBodyWrite 方法，true为执行，false不执行，有注解标记的时候处理返回值 @Override public boolean supports(MethodParameter arg0, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; arg1) &#123; ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = sra.getRequest(); // 判断请求是否有包装标记 ResponseResult responseResultAnn = (ResponseResult) request.getAttribute(RESPONSE_RESULT_ANN); return responseResultAnn == null ? false : true; &#125; // 对返回值做包装处理，如果属于异常结果，则需要再包装 @Override public Object beforeBodyWrite(Object body, MethodParameter arg1, MediaType arg2, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; arg3, ServerHttpRequest arg4, ServerHttpResponse arg5) &#123; if (body instanceof ErrorResult) &#123; ErrorResult error = (ErrorResult) body; return R.fail(error.getCode(), error.getMessage()); &#125; else if (body instanceof R) &#123; return (R) body; &#125; else if (body instanceof String) &#123; return body; &#125; return R.success(body); &#125;&#125; 测试@GetMapping(&quot;/fail&quot;)public Integer error() &#123; int res = 0; // 查询结果数 if( res == 0 ) &#123; throw new BizException(&quot;没有数据&quot;); &#125; return res;&#125; 返回结果 &#123;&quot;code&quot;:-1,&quot;message&quot;:&quot;没有数据&quot;,&quot;data&quot;:null&#125; 我们无需担心返回类型，如果需要返回错误提示信息，可以直接抛出自定义异常(BizException)，并添加自定义错误信息。","tags":["Spring Boot"],"categories":["后端开发"]},{"title":"Redis实现短信登录","path":"/2022/11/07/Redis实现短信登录/","content":"验证码发送和验证登陆注册思路流程整体的思路以及流程如题： 代码实现 实体类 User实体类 @Data@EqualsAndHashCode(callSuper = false)@Accessors(chain = true)@TableName(&quot;tb_user&quot;)public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @TableId(value = &quot;id&quot;, type = IdType.AUTO) private Long id; private String phone; private String password; private String nickName; private String icon = &quot;&quot;; private LocalDateTime createTime; private LocalDateTime updateTime;&#125; UserDTO import lombok.Data;@Datapublic class UserDTO &#123; private Long id; private String nickName; private String icon;&#125; 发送手机验证码 import cn.hutool.core.util.RandomUtil;@Resourceprivate StringRedisTemplate stringRedisTemplate;public static final String LOGIN_CODE_KEY = &quot;login:code:&quot;;public static final Long LOGIN_CODE_TTL = 2L;/** * 发送手机验证码 */@PostMapping(&quot;code&quot;)public Result sendCode(@RequestParam(&quot;phone&quot;) String phone) &#123; // 校验手机号 if (RegexUtils.isPhoneInvalid(phone)) &#123; // 不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; // 符合，生成验证码 String code = RandomUtil.randomNumbers(6); String key = LOGIN_CODE_KEY + phone; // 保存验证码, redis stringRedisTemplate.opsForValue().set(key, code, LOGIN_CODE_TTL, TimeUnit.MINUTES); // 发送验证码，模拟 log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code); return Result.ok();&#125; 短信验证登陆注册 import cn.hutool.core.lang.UUID;@Resourceprivate IUserService userService;@Resourceprivate StringRedisTemplate stringRedisTemplate;public static final String LOGIN_CODE_KEY = &quot;login:code:&quot;;public static final String LOGIN_USER_KEY = &quot;login:token:&quot;;public static final Long LOGIN_USER_TTL = 30L;/** * 登录功能 * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码 */@PostMapping(&quot;/login&quot;)public Result login(@RequestBody LoginFormDTO loginForm)&#123; String phone = loginForm.getPhone(); // 校验手机号 if (RegexUtils.isPhoneInvalid(phone)) &#123; // 不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; // 校验验证码 String key = LOGIN_CODE_KEY + phone; String cacheCode = stringRedisTemplate.opsForValue().get(key); String code = loginForm.getCode(); if (cacheCode == null || !cacheCode.equals(code)) &#123; // 不一致，返回错误信息 return Result.fail(&quot;验证码错误&quot;); &#125; // 一致，根据手机号查询用户 User user = userService.queryUser(phone); if (user == null) &#123; // 不存在，创建新用户并保存 user = createUserWithPhone(phone); userService.save(user); &#125; // 保存用户信息到 redis String token = UUID.randomUUID().toString(true); UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString() )); String tokenKey = LOGIN_USER_KEY + token; stringRedisTemplate.opsForHash().putAll(tokenKey, userMap); stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES); // 返回token return Result.ok(token);&#125;/** * 创建用户 * @param phone\t手机号 */private User createUserWithPhone(String phone) &#123; User user = new User(); user.setPhone(phone); user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10)); return user;&#125; 登陆校验拦截思路流程 第一个拦截器是为了刷新token的有效期，防止用户在访问不需要登陆操作页面时间过长而导致token失效。 第二个拦截器是拦截未登陆用户，或者长时间未操作页面导致登陆失效。 代码实现 第一个拦截器 public class RefreshTokenInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 获取请求头中的token String token = request.getHeader(&quot;authorization&quot;); if (StringUtils.isBlank(token)) &#123; return true; &#125; // 获取redis中的用户 String key = RedisConstants.LOGIN_USER_KEY + token; Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(key); if (entries.isEmpty()) &#123; return true; &#125; UserDTO userDTO = BeanUtil.fillBeanWithMap(entries, new UserDTO(), false); // 存在，保存到ThreadLocal UserHolder.saveUser(userDTO); // 刷新token有效期 stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES); return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; UserHolder.removeUser(); &#125; 第二个拦截器 public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (UserHolder.getUser() == null) &#123; // 不存在，拦截,返回401状态码 response.setStatus(401); return false; &#125; return true; &#125;&#125; 注册拦截器 注意拦截顺序，默认按照添加顺序，也可手动指定。 @Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).order(0); registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( &quot;/voucher/**&quot;, &quot;/shop-type/**&quot;, &quot;/shop/**&quot;, &quot;/user/code&quot;, &quot;/user/login&quot;, &quot;/blog/hot&quot; ).order(1); &#125;&#125;","tags":["Redis"],"categories":["后端开发"]},{"path":"/about/index.html","content":"swcode这是我的简介 关于作者关于本站友情链接 个人信息 - 博客园: https://www.cnblogs.com/sw-code - GitHub: https://github.com/SX-Code - Email: songwuxingxox@outlook.com - QQ: 2627311935 工作经历 本站建站初衷是存放学习笔记、个人博客以及一些小技巧。 李阳 sw-code"},{"path":"/custom/css/CodeStyle.css","content":":root { --code-autor: '© swcode'; } .tag-plugin.banner{ margin-top: 0px !important; } pre > .hljs { border-radius: 0px !important; padding: .7rem 1rem !important } /*语法高亮*/ .hljs { position: relative; display: block; overflow-x: hidden; /*背景跟随Stellar*/ background: var(--block); color: #9c67a1; padding: 30px 5px 2px 5px; box-shadow: 0 10px 30px 0px rgb(0 0 0 / 40%) } .hljs::before { content: var(--code-tip); position: absolute; left: 15px; top: 10px; overflow: visible; width: 12px; height: 12px; border-radius: 16px; box-shadow: 20px 0 #a9a6a1, 40px 0 #999; -webkit-box-shadow: 20px 0 #999, 40px 0 #999; background-color: #999; white-space: nowrap; text-indent: 75px; font-size: 16px; line-height: 12px; font-weight: 700; color: #999 } .highlight:hover .hljs::before { color: #35cd4b; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; -webkit-box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; background-color: #fc625d; } .hljs-ln { display: inline-block; overflow-x: auto; padding-bottom: 5px } .hljs-ln td { padding: 0; background-color: var(--block) } .hljs-ln::-webkit-scrollbar { height: 10px; border-radius: 5px; background: #333; } .hljs-ln::-webkit-scrollbar-thumb { background-color: #bbb; border-radius: 5px; } .hljs-ln::-webkit-scrollbar-thumb:hover { background: #ddd; } .hljs table tbody tr { border: none } .hljs .hljs-ln-line { padding: 1px 10px; border: none } td.hljs-ln-line.hljs-ln-numbers { border-right: 1px solid #666; } .hljs-keyword, .hljs-literal, .hljs-symbol, .hljs-name { color: #c78300 } .hljs-link { color: #569cd6; text-decoration: underline } .hljs-built_in, .hljs-type { color: #4ec9b0 } .hljs-number, .hljs-class { color: #2094f3 } .hljs-string, .hljs-meta-string { color: #4caf50 } .hljs-regexp, .hljs-template-tag { color: #9a5334 } .hljs-subst, .hljs-function, .hljs-title, .hljs-params, .hljs-formula { color: #c78300 } .hljs-property { color: #9c67a1; } .hljs-comment, .hljs-quote { color: #57a64a; font-style: italic } .hljs-doctag { color: #608b4e } .hljs-meta, .hljs-meta-keyword, .hljs-tag { color: #9b9b9b } .hljs-variable, .hljs-template-variable { color: #bd63c5 } .hljs-attr, .hljs-attribute, .hljs-builtin-name { color: #d34141 } .hljs-section { color: gold } .hljs-emphasis { font-style: italic } .hljs-strong { font-weight: bold } .hljs-bullet, .hljs-selector-tag, .hljs-selector-id, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo { color: #c78300 } .hljs-addition { background-color: #144212; display: inline-block; width: 100% } .hljs-deletion { background-color: #600; display: inline-block; width: 100% } .hljs.language-html::before { content: \"HTML\" } .hljs.language-xml::before { content: \"XML\" } .hljs.language-javascript::before { content: \"JavaScript\" } .hljs.language-c::before { content: \"C\" } .hljs.language-cpp::before { content: \"C++\" } .hljs.language-java::before { content: \"Java\" } .hljs.language-asp::before { content: \"ASP\" } .hljs.language-actionscript::before { content: \"ActionScript/Flash/Flex\" } .hljs.language-bash::before { content: \"Bash\" } .hljs.language-css::before { content: \"CSS\" } .hljs.language-asp::before { content: \"ASP\" } .hljs.language-cs::before, .hljs.language-csharp::before { content: \"C#\" } .hljs.language-d::before { content: \"D\" } .hljs.language-golang::before, .hljs.language-go::before { content: \"Go\" } .hljs.language-json::before { content: \"JSON\" } .hljs.language-lua::before { content: \"Lua\" } .hljs.language-less::before { content: \"LESS\" } .hljs.language-md::before, .hljs.language-markdown::before, .hljs.language-mkdown::before, .hljs.language-mkd::before { content: \"Markdown\" } .hljs.language-mm::before, .hljs.language-objc::before, .hljs.language-obj-c::before, .hljs.language-objective-c::before { content: \"Objective-C\" } .hljs.language-php::before { content: \"PHP\" } .hljs.language-perl::before, .hljs.language-pl::before, .hljs.language-pm::before { content: \"Perl\" } .hljs.language-python::before, .hljs.language-py::before, .hljs.language-gyp::before, .hljs.language-ipython::before { content: \"Python\" } .hljs.language-r::before { content: \"R\" } .hljs.language-ruby::before, .hljs.language-rb::before, .hljs.language-gemspec::before, .hljs.language-podspec::before, .hljs.language-thor::before, .hljs.language-irb::before { content: \"Ruby\" } .hljs.language-sql::before, .hljs.language-mysql::before { content: \"SQL\" } .hljs.language-sh::before, .hljs.language-shell::before, .hljs.language-Session::before, .hljs.language-shellsession::before, .hljs.language-console::before { content: \"Shell\" } .hljs.language-swift::before { content: \"Swift\" } .hljs.language-vb::before { content: \"VB/VBScript\" } .hljs.language-yaml::before { content: \"YAML\" } /*stellar主题补偿*/ /* .md-text pre>.hljs { padding-top: 2rem !important; } */ .md-text pre { padding: 0 !important; } code { /* background-image: linear-gradient(90deg, rgba(60, 10, 30, .04) 3%, transparent 0), linear-gradient(1turn, rgba(60, 10, 30, .04) 3%, transparent 0) !important; */ background-size: 20px 20px !important; background-position: 50% !important; } /* 作者信息 */ figure.author::after { content: var(--code-autor); text-align: right; font-size: 10px; float: right; margin-top: 3px; padding-right: 15px; padding-bottom: 8px; color: #999 } figcaption span { border-radius: 0px 0px 12px 12px !important; } /* 复制代码按钮 */ .highlight { position: relative; } .highlight .code .copy-btn { position: absolute; top: 0; right: 0; padding: 4px 0.5rem; opacity: 0.25; font-weight: 700; color: var(--theme); cursor: pointer; transination: opacity 0.3s; } .highlight .code .copy-btn:hover { color: var(--text-code); opacity: 0.75; } .highlight .code .copy-btn.success { color: var(--swiper-theme-color); opacity: 0.75; } /* 描述 */ .md-text .highlight figcaption span { font-size: small; } /* 折叠 */ code.hljs { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 6; } td.code:before { right: 25px !important; z-index: 99 } .hljsOpen { -webkit-line-clamp: 99999 !important; } .CodeCloseDiv { color: #999; background: var(--block); display: flex; justify-content: center; /* margin-top: inherit; */ margin-bottom: -18px; } .CodeClose { color: #999; margin-top: 3px; background: var(--block); } .highlight button:hover, .highlight table:hover+button { color: var(--swiper-theme-color); opacity: 0.75; }"},{"title":"解决方案之2PC","path":"/wiki/dtx/2pc.html","content":"2PC是强一致性的CP的方案 什么是2PC2CP即两阶段提交协议，是将整个事务流程分为两阶段，准备阶段（Prepare phase）、提交阶段（commit phase） 在计算机中部分关系型数据库如Oracle、MySQL支持两阶段提交协议，如下图： 准备阶段（Prepare phase）：事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo&#x2F;Redo日志，此时事务没有提交。 Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件 提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：必须在最后阶段释放锁资源。 下图展示了2PC的两阶段，分成功和失败两个情况说明： 成功情况： 失败情况： 解决方案XA解决方案2PC的传统方案是在数据库层面实现的，如Oracle、MySQL都支持2PC协议，为了统一标准减少行业内不必要的对接成本，需要定制标准化的处理模型及接口标准，国际开发标准组织Open Group定义了分布式事务处理模型DTP（Distributed Transaction Processing Reference Model）。 DTP模型定义如下角色： AP（Application Program）：即应用程序，可以理解为使用DTP分布事务的程序。 RM（Resource Manager）：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对数据库进行控制，资源管理器控制着分支事务， TM（Transaction Manager）：事务管理器，复制协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是全局事务。 DTP模型定义TM和RM之间通讯的接口规范叫XA，简单理解为数据库提供的2PC接口协议，基于数据库的XA协议来实现2PC又称为XA方案。 以上三个角色之间的交互方式如下： 1）TM向AP提供应用程序编程接口，AP通过TM提交及回滚事务。 2）TM交易中间件通过XA接口来通知RM数据库事务的开始、结束以及提交、回滚等。 总结： 整个2PC的事务流程涉及到三个角色AP、RM、TM。AP指的是使用2PC分布式事务的一个应用程序；RM值得时资源管理器，它控制着分支事务；TM指的是事务管理器，它控制着整个全局事务。 1）在准备阶段RM执行实际业务操作，但不提交事务，资源锁定； 2）在提交阶段TM会接受RM在准备阶段的执行回复，只要有任一RM执行失败，TM会通知所有RM执行回滚操作，否则，TM将会通知所有RM提交该事务。提交阶段结束资源锁释放 XA方案的问题： 1、需要本地数据库支持XA协议 2、资源锁需要等到两个阶段结束才释放，性能较差。 Seata方案Seata是由阿里中间件团队发起的开源项目Fescar，后更名为Seata，他是一个开源的分布式事务框架。 传统2PC的问题在Seata中得到了解决，它通过对本地关系数据库的分支书屋的协调来驱动完成全局事务，是工作在应用层的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务0侵入的方式解决微服务场景下面临的分布式事务问题，他目前提供AT模式（即2PC）即TCC模式的分布式事务解决方案。 Seata的设计思想如下： Seata的设计目的其一是对业务无侵入，因此业务无侵入的2PC方案着手，在传统2PC的基础上演进，并解决2PC方案面临的问题。 Seata把分布式事务理解成一个包含若干分支事务的全局事务。全局事务的职责是协调其管辖的分支事物达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务，下图是全局事务与分支事务的关系图： 与传统2PC模型类似，Seata定义了3个组件来协调分布式事务的处理过程 **Transaction Coordinator (TC)**：事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各个分支事务的提交或回滚。 **Transaction Manager (TM)**：事务管理器，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向TC发起全局提交或全局回滚的指令。 **Resource Manager (RM)**：控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分支（本地）事务的提交和回滚。 以新用户注册送积分举例Seata的分布式事务过程： 具体的执行流程如下： 用户服务的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID。 用户服务的 RM 向 TC 注册分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 XID 对应全局事务的管辖。 用户服务执行分支事务，向用户表插入一条记录。 逻辑执行到远程调用积分服务时(XID 在微服务调用链路的上下文中传播)。积分服务的 RM 向 TC 注册分支事务，该分支事务执行增加积分的逻辑，并将其纳入XID 对应全局事务的管辖。 积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后，返回用户服务。 用户服务分支事务执行完毕。 TM 向 TC 发起针对 XID 的全局提交或回滚决议。 TC 调度 XID 下管辖的全部分 支事务完成提交或回滚请求。 回滚即反向操作 Seata实现2PC与传统2PC的差别： 架构层次方面，传统2PC方案的 RM 实际上是在数据库层 RM本质上就是数据库自身，通过 XA 协实现，而 Seata 的 RM 是以jar包的形式作为中间件层部署在应用程序这一侧的。 两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1 就将本地事务提交，这样就可以省去Phase2持锁的时间 ，整体提高效率。"},{"title":"BASE理论","path":"/wiki/dtx/base.html","content":"1、理解强一致性和最终一致性 CAP理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availablity）和分区容忍性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP既舍弃一致性，保证可用性和分区容忍性，但是在实际生产中很多场景都要实现一致性，比如主从同步，即使不要一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和CAP中的一致性不同，CAP中的一致性要求在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。 2、Base理论介绍 BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障时允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致性，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔性事务”。 基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出现问题了，商品依然可以正常浏览 软状态：由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的“支付中”、“数据同步中“等状态，待数据最终一致后状态改为”成功“状态。"},{"title":"CAP理论","path":"/wiki/dtx/cap.html","content":"分布式是提供服务的各个节点分布在不同机器上，相互之间通过网络交互。不能因为有一点网络问题就导致整个系统无法提供服务，网络因素成为了分布式事务的考量标准之一。因此，分布式事务需要进一步的理论支持 ，接下来，我们先来学习一下分布式系统的CAP理论。 理解CAPCAP是Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性和分区容忍性。 C - Consistency 分布式系统一致性的特点： 1、由于存在数据同步的过程，写操作的响应会有一定的延迟。2、未来保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。3、如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。 A - Availability 可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。 追求可用性将导致不满足一致性 P - Partition tolerance 通常分布式系统的各个结点部署在不同的子网，这就是网络分区，不可避免的出现由于网络问题而导致结点之间通信失败，此时仍可以对外提供服务，这叫分区容忍性。 如何实现分区容忍性？1、尽量使用异步操作取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间实现松耦合。2、添加从数据库结点，其中一个从结点挂掉其他从结点提供服务 分区容忍性是分布式系统具备的基本能力。 CAP组合方式在所有分布式事务场景中不会同时具备CAP三个特性，C和A是不能共存的。 1）AP： 放弃一致性，追求分区容忍性和可用性，这是很多分布式系统设计时的选择。BASE理论就是根据AP理论拓展而来。 2）CP： 放弃可用性，追求分区容忍性和一致性，zookeeper就是追求强一致。 3）CA： 放弃分区容忍性，即不进行分区，不考虑网络不通或结点宕机的问题，那么系统将不再是一个分布式系统。关系型数据库就能满足CA。"},{"path":"/custom/js/CodeStyle.js","content":"const maxLine = 20; /** * 所有class为code的td标签 */ const reg = new RegExp(\"fa-angles-down\");//这里利用正则表达式 var codeElementArr = document.querySelectorAll('td.code'); codeElementArr.forEach((code, index) => { const preCode = code.children[0].children[0] //add id, example: ZYCode1、ZYCode2... 可能以后用到index吧 // preCode.setAttribute('id','ZYCode'+(index+1)) preCode.setAttribute('style', '-webkit-line-clamp: ' + maxLine + ';') //add over if (preCode.outerHTML.split('').length > maxLine) { let clickScroll; const codeCopyDiv = document.createElement('div'); codeCopyDiv.setAttribute('class', 'CodeCloseDiv'); // 显示折叠 code.parentNode.parentNode.parentNode.parentNode.appendChild(codeCopyDiv); // 显示作者 code.parentNode.parentNode.parentNode.parentNode.classList.add('author') // 其他样式 preCode.parentNode.setAttribute('style', 'margin-bottom: 0px'); const codeCopyOver = document.createElement('button'); // codeCopyOver.setAttribute('id','ZYCodeOver'+(index+1)); codeCopyOver.setAttribute('class', 'CodeClose'); const openI= document.createElement('i'); openI.setAttribute('class', \"fa-solid fa-angles-down fa-beat-fade\"); codeCopyOver.appendChild(openI); const haveDes = code.parentNode.parentNode.parentNode.parentNode.childNodes.length===3 code.parentNode.parentNode.parentNode.parentNode.children[haveDes?2:1].appendChild(codeCopyOver); codeCopyOver.addEventListener('click', async () => { let isOpen = reg.test(codeCopyOver.childNodes[0].className); if (!isOpen) { codeCopyOver.childNodes[0].setAttribute('class', 'fa-solid fa-angles-down fa-beat-fade'); document.documentElement.scrollTop = clickScroll; preCode.setAttribute('style', '-webkit-line-clamp: ' + maxLine + ';padding-bottom:0px!important'); } else { codeCopyOver.childNodes[0].setAttribute('class', 'fa-solid fa-angles-up fa-beat-fade'); clickScroll = document.documentElement.scrollTop; preCode.setAttribute('style', '-webkit-line-clamp: 99999;padding-bottom:0px!important') } }) } // add btn const codeCopyBtn = document.createElement('div'); codeCopyBtn.classList.add('copy-btn'); // copy icon const copyI = document.createElement('i'); copyI.setAttribute('class', 'fa-regular fa-copy'); copyI.style.color = '#aa69ec'; codeCopyBtn.appendChild(copyI); code.appendChild(codeCopyBtn); //add fun codeCopyBtn.addEventListener('click', async () => { const currentCodeElement = code.children[0]?.innerText; await copyCode(currentCodeElement); setCopySuccessIcon(codeCopyBtn.childNodes[0]) codeCopyBtn.classList.add('success'); setTimeout(() => { setCopyIcon(codeCopyBtn.childNodes[0]) codeCopyBtn.classList.remove('success'); }, 3000) }) }) // 设置拷贝图标 function setCopyIcon(node) { node.setAttribute('class', 'fa-regular fa-copy'); node.style.color = '#aa69ec'; } // 设置拷贝成功图标 function setCopySuccessIcon(node) { node.setAttribute('class', 'fa-regular fa-circle-check'); node.style.color = 'limegreen'; } async function copyCode(currentCode) { if (navigator.clipboard) { try { await navigator.clipboard.writeText(currentCode) } catch (error) { // 未获得用户许可 console.error(error) } } else { console.error('当前浏览器不支持此api') } }"},{"title":"注册账号案例分析","path":"/wiki/dtx/example1.html","content":"业务流程采用用户、账号分离设计(这样设计的好处是，当用户的业务信息发生变化时，不会影响的认证、授权等系统机制)，因此需要保证用户信息与账号信息的一致性。 用户向用户中心发起注册请求，用户中心保存用户业务信息，然后通知统一账号服务新建该用户所对应登录账号。 解决方案分析针对注册业务，如果用户与账号信息不一致，则会号致严重问题，因此该业务对一致性要求较为严格，即当用户服务和账号服务任意一方出现问题都需要回滚事务。 根据上述需求进行解决方案分析： 1、采用可靠消息一致性方案可靠消息一致性要求只要消息发出，事务参与者接到消息就要将事务执行成功，不存在回滚的要求，所以不适用。 2、采用最大努力通知方案最大努力通知表示发起通知方执行完本地事务后将结果通知给事务参与者，即使事务参与者执行业务处理失败发起通知方也不会回滚事务，所以不适用。 3、采用Seata实现2PC在用户中心发起全局事务 ，统一账户服务为事务参与者，用户中心和统一账户服务只要有一方出现问题则全局事务回滚，符合要求。 实现方法如下： 用户中心添加用户信息，开启全局事务 统一账号服务添加账号信息，作为事务参与者 其中一方执行失败Seata对SQL进行逆操作删除用户信息和账号信息 ，实现回滚。 4、采用Hmily实现TCC ICC也可以实现用户中心和统一账户服务只要有一方出现问题则全局事务回滚，符合要求。 实现方法如下： 用户中心 try：添加用户，状态为不可展confirm：更新用户状态为可用cancel：删除用户 统一账号服务 try：添加账号，状态为不可用confirm ：更新账号状态为可用cancel ：删除账号"},{"title":"存管开户案例分析","path":"/wiki/dtx/example2.html","content":"业务流程根据政策要求 ，P2P业务必须让银行存管资金，用户的资金在银行存管系统的账户中，而不在P2P平台中，因此用户要在银行存管系统开户。 用户向用户中心提交开户资料，用户中心生成开户请求号并重定向至银行存管系统开户页面。用户设置存管密码并确认开户后，银行存管立即返回“请求已受理’。在某一时刻，银行存管系统处理完该开户请求后，将调用回调地址通知处理结果，若通知失败，则按一定策略重试通知。同时，银行存管系统应提供开户结果查询的接口，供用户中心校对结果。 解决方案分析P2P平台的用户中心与银行存管系统之间属于跨系统交互，银行存管系统属于外部系统，用户中心无法干预银行存管系统，所以用户中心只能在收到银行存管系统的业务处理结果通知后积极处理，开户后的使用情况完全由用户中心来控制。 根据上述需求进行解决方案分析： 1、采用Seata实现2PC需要侵入银行存管系统的数据库，由于它的外部系统，所以不适用。 2、采用Hmily实现TCCTCC侵入性更强，所以不适用。 3、基于MQ的可靠消息一致性如果让银行存管系统监听MQ则不合适，因为它的外部系统。如果银行存管系统将消息发给MQ，用户中心监听MQ是可以的，但是由于相对银行存管系统来说用户中心属于外部系统，银行存管理系统是不会让外部系统直接监听自己的MQ的，基于MQ的通信协议也不方便外部系统间的交互，所以本方案不合适。 4、最大努力通知方案银行存管系统内部使用MQ ，银行存管系统处理完业务后将处理结果发给MQ，由银行存管的通知程序专门发送通知，并且采用互联网协议通知给第三方系统（用户中心）。 下图中发起通知即银行存管系统："},{"title":"满标审核案例分析","path":"/wiki/dtx/example3.html","content":"业务流程在借款人标的募集够所有的资金后，P2P运营管理员审批该标的，触发放款，并开启还款流程。 管理员对某标的满标审批通过，交易中心修改标的状态为”还款中”，同时要通知还款服务生成还款计划。 解决方案分析生成还款计划是一个执行时长较长的业务，不建议阻塞主业务流程，此业务对一致性要求较低。 根据上述需求进行解决方案分析：1、采用Seata实现2PCseata在事务执行过程会进行数库资源缺定，，由于事务执行时长较长会将资源锁定较长时间，所以不适用。 2、采用Hmily实现TCC本需求对业务一致性要求较低，因为生成还款计划的时长较长，所以不要求交易中心修改标的状态为”还款中’就立即生成还款计划 ，所以本方案不适用。 3、基于MQ的可靠消息一致性满标审批通过后由交易中心修改标的状态为“还款中”并且向还款服务发送消息，还款服务接收到消息开始生成还款计划，基本于MQ的可靠消息一致性方案适用此场景。 4、最大努力通知方案满标审批通过后由交易中心向还款服务发送通知要求生成还款计划，还款服务并且对外提供还款计划生成结果校对接口供其它服务查询，最大努力通知方案也适用本场景。"},{"title":"可靠消息最终一致性","path":"/wiki/dtx/final_c.html","content":"可靠消息最终一致性是AP的解决方案 是什么？可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者）一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致 此方案是利用消息中间件完成： 如下图： 事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消 息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信，由于网络通信的不确定性会导致分布式事务问题。 因此可靠消息最终一致性方亲要解决以下几个问题： 本地事务与消息发送的原子性问题 本地事务与消息发送的原子性问题即：事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的关键问题。 先来尝试下这种操作，先发送消息，再操作数据库： BEGIN TRANSACTION;\t-- 发送MQ\t-- 数据库操作COMMIT TRANSACTION; 这种情况下无法保证数据库操作与发送消息的一致性，因为可能发送消息成功，数据库操作失败。 第二种方案，先进行数据库操作，再发送消息： BEGIN TRANSACTION;\t-- 数据库操作\t-- 发送MQCOMMIT TRANSACTION; 这种情况下貌似没有问题，如果发送MQ消息失败，就会拋出异常，导致数据库事务回滚。但如果是超时异常，数据库回滚，但MQ其实已经正常发送了，同样会导致不一致。 事务参与方接收消息的可靠性 事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。 消息重复消费的问题 由于网路存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消理，就导致了消息的重复消费。 要解决消息重复消费的问题就要实现事务参与方的方法幂等性。 解决方案本地消息方案 RocketMQ事务消息方案RocketMQ事务消息设计则主要是为了解决Producer端的消息发送与本地事务执行的原子性问题，RocketMQ的设计中broker与producer端的双向通信能力，使得broker天生可以作为一个事务协调者存在；而RocketMQ本身提供的存储机制为事务消息提供了持久化能力；RocketMQ的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证事务的最终一致性。 执行流程如下： 为了方便理解，以注册送积分的例子来描述整个流程。 Producer即MQ发送方，本例中是用户服务，负责新增用户。MQ订阅方即消息消费方，本例中是积分服务，负责新增积分。 1、Producer发送事务消息Producer（MQ发送方）发送事务消息至MQ Server，MQ Server将消息状态标记为Prepared（预备状态），注意此时这条消息消费者（MQ订阅方）是无法消费消息的。本例中，Producer发送“增加积分消息”到MQ Server。 2、MQ Server回应消息发送成功MQ Server接收到Producer发送的消息则回应发送成功表示MQ已接收到消息。 3、Producer执行本地事务Producer端执行业务代码逻辑，通过本地数据库事务控制。本例中，Producer执行添加用户操作。 4、消息投递若Producer本地事务执行成功则自动向MQ Server发送commit消息，MQ Server接收到commit消息后将“增加积分消息”状态标记为可消费，此时MQ订阅方（积分服务）可正常消息消息。 若Producer本地事务执行失败则自动向MQ Server发送rollback消息，MQ Server接收到rollback消息后将删除“增加积分消息”。 以上主干流程已由RocketMQ实现，对于开发者来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需要关注本地事务的执行状态即可。 Rocket MQ提供RocketMQLocalTransactionListener接口： public interface RocketMQLocalTransactionListener &#123; /** * 发送prepare消息成功此被回调，该方法用于执行本地事务 * @param msg 回传的消息，利用transactionId即可获取该消息的唯一Id * @param arg 调用send方法时传递的参数，当send时若有额外的参数可以传递到send中，这里能获取到 * @return 返回事务状态，COMMIT：提交 ROLLBACK：回滚 UNKNOWN：回调，主动查询 */ RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg); /** * 主动查询事务状态 * @param msg 利用transactionId来判断这条消息的本地事务执行状态 * @return 返回事务状态，COMMIT：提交 ROLLBACK：回滚 UNKNOWN：回调，主动查询 */ RocketMQLocalTransactionState checkLocalTransaction(Message msg);&#125; RocketMQ实现实例业务说明本实例通过RocketMQ中间件实现可靠消息最终一致性分布式事务，模拟两个账户的转账交易过程。 两个账户在不同的银行（张三在bank1、李四在bank2），bank1、bank2是两个微服务。交易过程是，张三给李四转账指定金额。 上述交易步骤，张三扣减金额给bank2发转账消息，两个操作必须是一个整体性事务。 数据库de_duplication表，交易记录表，用于交易幂等控制。 DROP TABLE IF EXISTS `de_duplication`;CREATE TABLE `de_duplication` &#123;\t`tx_no` varchar(64) NOT NULL,\t`create_time` datetime(0) NULL DEFAULT NULL,\tPRIMARY KEY (`tx_no`) USING BTREE&#125; ENGINE=InnoDB; ​ 伪代码消息传输的实体类对象 AccountChangeEvent@Datapublic class AccountChangeEvent implements Serializanble &#123; /** * 账号 */ private String accountNo; /** * 变动金额 */ private double amount; /** * 事务号 */ private String txNo;&#125; 发送方发送方Producer业务逻辑代码 AccountInfoServicepublic interface AccountInfoService &#123; /** * 向MQ发送转账消息 */ public void sendUpdateAccountBalance (AccountChangeEvent accountChangeEvent); /** * 扣减金额，由MQ回调执行 */ public void doUpdateAccountBalance(AccountChangeEvent accountChangeEvent);&#125; 实现接口类 AccountInfoServiceImpl@Servicepublic AccountInfoServiceImpl implements AccountInfoService &#123; @Autowire AccountInfoDao accountInfoDao; @Autowire RocketMQTemplate rocketMQTemplate; /** * 向 MQ 发送转账消息 */ @Override public void sendUpdateAccountBalance (AccountChangeEvent accountChangeEvent) &#123; // 将accountChangeEvent转为JSON JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;accountChange&quot;, accountChangeEvent); // 生成message类型 Message&lt;String&gt; message = MessageBuilder.withPayload(jsonObject.toJSONStrong()).build(); // 发送事务消息 /** * String txProducerGroup 生产组 * String destnation topic * Message&lt;?&gt; message, 消息内容 * Object arg 参数 */ rocketMQTemplate.sendMessageInTransaction(&quot;producer_group_txmsg_bank1&quot;, &quot;topic_txmsg&quot;, message, null); &#125; @Override @Transactional(rollbackFor = Exception.class) public void doUpdateAccountBalance(AccountChangeEvent accountChangeEvent) &#123; // 幂等判断 if (accountInfoDao.isExistTx(accountChangeEvent.getTxNo() &gt; 0)) &#123; return; &#125; // 扣减金额 accountInfoDao.updateAccountBalance(accountChangeEvent.getAccountNo(), accountChangeEvent.getAmount() * -1); // 添加事务日志 accountInfoDao.addTx(accountChangeEvent.getTxNo()); if (accountChangeEvent.getAmount() == 3) &#123; throw new RuntimeException(&quot;人为制造异常&quot;); &#125; &#125;&#125; 发送方Producer发送消息后，由MQ Server回调的方法实现 @Component@RocketMQTransactionListenerpublic class ProducerTxmsgListener implements RocketMQLocalTransactionListener &#123; @Autowire AccountInfoService accountInfoService; @Autowire AccountInfoDao accountInfoDao; /** * 事务消息发送后的回调，当消息发送给 MQ 成功，此方法会被回调 */ @Override @Transactional(rollbackFor = Exception.class) public RocketMQLocalTransactionState executedTransaction(Message message, Object arg) &#123; try &#123; // 解析 Message， 转成 AccountChangeEvent String messageString = new String(byte[] message.getPayload()); String accountChange = JSONObject.parseObject(messageString).getString(&quot;accountChange&quot;); AccountChangeEvent accountChangeEvent = JSONObject.parseObject(accountChange, AccountChangeEvent.class); // 执行本地事务 accountInfoService.doUpdateAccountBalance(accountChangeEvent); // 向 MQ 发送 commit 消息，MQ 将消息改为可消费状态 return RocketMQLocalTransactionState.COMMIT; &#125; catch (Exception e) &#123; e.printStackTrance(); return RocketMQLocalTransactionState.ROLLBACK; &#125; // 返回成功类型 &#125; /** * 事务状态回查，查询张三是否扣减金额 */ @Override public RocketMQLocalTransactionState checkLocalTransaction(Message message) &#123; // 解析 Message， 转成 AccountChangeEvent String messageString = new String(byte[] message.getPayload()); String accountChange = JSONObject.parseObject(messageString).getString(&quot;accountChange&quot;); AccountChangeEvent accountChangeEvent = JSONObject.parseObject(accountChange, AccountChangeEvent.class); // 判断事物是否执行 if (accountInfoDao.isExistTx(accountChangeEvent.getTxNo()) &gt; 0) &#123; return RocketMQLocalTransactionSta te.COMMIT; &#125; return RocketMQLocalTransactionState.UNKNOWN; &#125;&#125; 发送方提供一个转账的接口，用于向MQ发送一条转账消息（Prepared状态） @RestControllerpublic class AccountInfoController &#123; @Autowire private AccountInfoService accountInfoService; @GetMapping(&quot;/transfer&quot;) public String transfer(@RequestParam(&quot;accountNo&quot;) String accountNo, @RequestParam(&quot;amount&quot;) Double amount) &#123; // 创建一个事务ID，作为消息发送到 MQ String tx_no = UUID.randomUUID().toString(); AccountChangeEvent accountChangeEvent = new AccountChangeEvent(accountNo, amount, tx_no); // 发送消息 accountInfoService.sendUpdateAccountBalance(accountChangeEvent); return &quot;转账成功&quot;; &#125;&#125; 消费方定义消费方更新账户的方法 AccountInfoServicepublic interface AccountInfoService &#123; /** * 更新账户，增加金额 */ public void addAccountInfoBalance (AccountChangeEvent accountChangeEvent);&#125; 实现上述接口，该方法可能会重复执行，需要做好幂等判断 AccountInfoServiceImpl@Slf4j@Servicepublic AccountInfoServiceImpl implements AccountInfoService &#123; @Autowire AccountInfoDao accountInfoDao; @Override @Transactional(rollbackFor = Exception.class) public void addAccountInfoBalance (AccountChangeEvent accountChangeEvent) &#123; log.info(&quot;bank2更新本地账号, 账号: &#123;&#125;, 金额: &#123;&#125;&quot;, accountChangeEvent.getAccountNo(), accountChangeEvent.getAmount()) // 幂等判断 if (accountInfoDao.isExistTx(accountChangeEvent.getTxNo()) &gt; 0) &#123; return; &#125; // 增加金额 accountInfoDao.updateAccountBalance(accountChangeEvent.getAccountNo(), accountChangeEvent.getAmount()); // 添加事务记录 accountInfoDao.addTx(accountChangeEvent.getTxNo()); if (accountChangeEvent.getAmount() == 4) &#123; throw new RuntimeException(&quot;人为制造异常&quot;); &#125; &#125;&#125; 消费方监听MQ消息 TxmsgConsumer@Slf4j@Component@RocketMQMessageListener(comsumerGroup = &quot;consumer_group_txmsg_bank2&quot;, topic = &quot;topic_txmsg&quot;)public class TxmsgConsumer implements RocketMQListener&lt;String&gt; &#123; @Autowire private AccountInfoService accountInfoService; @Override public void onMessage(String message) &#123; log.info(&quot;开始消费消息: &#123;&#125;&quot;, message); // 解析 Message， 转成 AccountChangeEvent String messageString = new String(byte[] message.getPayload()); String accountChange = JSONObject.parseObject(messageString).getString(&quot;accountChange&quot;); AccountChangeEvent accountChangeEvent = JSONObject.parseObject(accountChange, AccountChangeEvent.class); // 增加金额 accountChangeEvent.setAccountNo(&quot;2&quot;); // 账户设置为李四的 accountInfoService.addAccountInfoBalance(accountChangeEvent); &#125;&#125; 小结可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性，本案例使用了RacketMQ 作为消息中间件，RocketMQ主要解决了两个功能： 本地事务与消息发送的原子性问题。 事务参与方接收消息的可靠性。 可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响，并实现两个服务的解耦。"},{"title":"什么是分布式事务","path":"/wiki/dtx/index.html","content":"本地事务在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一服务器，所以基于关系型数据库的事务又被称为本地事务。 数据库的四大事务ACID： A（Atomic）：原子性，构成事务的所有操作，要么都执行完，要么全部不执行，不可能出现部分成功部分失败的情况。 C（Consistecy）：一致性，在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转100元，转账前和转账后的数据是正确状态这叫一执性，如果出现张三转出100元，李四账户没有增加100元这就出现数据错误，就没有达到一致性。 I（Isolation）：隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事务不能看到其他事务运行过程的中间状态。通过配置事务隔离级别可以避免脏读、重复读等问题。 D（Durability）：持久性，事务完成之后，该事务对数据的更改会被持久化到数据库，且不能被回滚。 数据库事务在实现时会将一次事务涉及的所有操作全部归纳到一个不可分割的执行单元，该执行单元的所有操作要么成功，要么失败，只要其中任一操作执行失败，都将导致整个事务回滚。 分布式事务随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用，下图描述了单位应用向微服务的演变： 分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务于服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分事务、创建订单减库存事务，银行转账事务都是分布式事务。 我们知道本地事务依赖数据库本身提供的事务特性来完成，因此以下逻辑可以控制本地事务： begin transaction:\t-- 1.本地数据库操作:张三减少金额\t-- 2.本地数据库操作:李四增加金额commit transaction; 但是分布式环境下，会变成下边这样： begin transaction:\t-- 1.本地数据库操作:张三减少金额\t-- 2.远程调用:李四增加金额commit transaction; 可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。 因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在同一数据库中甚至不在用一应用系统里，实现转账事务需要通过远程调用，由于网络问题机会导致分布式事务问题 分布式事务产生的场景1、典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作比如：订单微服务和库存微服务，下单同时订单微服务请求库存微服务减库存简言之：跨JVM进程产生分布式事务 2、单体访问多个数据库实例 当单体系统需要访问多个数据库（实例）时就会产生分布式事务。比如：用户信息和订单信息分别在两MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同数据实例，需要通过不同的数据库链接去操作数据库，此时产生分布式事务。简言之：跨数据库实例产生分布式事务 3、多服务访问同一个数据库实例 比如：订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接尽心数据库操作，此时产生了分布式事务。"},{"title":"最大努力通知","path":"/wiki/dtx/notify.html","content":"什么是最大努力通知下面是一个充值的例子： 最大努力通知与可靠消息一致性有什么不同？ 可靠消息一致性有什么不同？ 1、解决方案思想不同可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方 ，消息的可靠性关键由发起通知方来保证。 最大努力通知，发起通知方尽最大的努力将业务处理结果通知到接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果 ，通知的可靠性关键在接收通知方。 2、﻿两者的业务应用场暑不同 可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。最大努力通知关注的是交易后的通知事务 ，即将交易结果可靠的通知出去。 3、 技术解决方向不同 可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。最大努力通知无法保证消息从发出到接收的一致性 ，只提供消息接收的可靠性机制。可靠机制是，最大努力的。 解决方案采用MQ的ack机制就可以实现最大努力通知 方案一 本方案是利用MQ的ack机制由MQ向接收通知方发送通知，流程如下： 发起通知方将通知发送给MQ，使用普通消息机制发送。 注意：如果消息没有发送出去可由接收方主动请求发起通知方查询业务执行结果 接收方监听MQ。 接收方接收消息，业务处理完成回应ack。 接收通知方若没有回应ack则MQ会重复通知。 MQ会按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔（如果MQ采用rocketMQ，在broker中可进行设置），直到达到通知要求的时间窗口上限。 接收通知方可通过消息校对接口来校对消息一致性。 方案二 方案一和方案二的不同点： 方案一种接收通知方与MQ接口，即接收通知方监听MQ，此方案主要应用于内部应用之间的通知 方案二由通知程序与MQ接口，通知程序监听MQ，收到MQ的消息后由通知程序通过互联网接口协议调用接收通知方。此方案主要应用于外部应用之间的通知，例如支付宝、微信的支付结果通知。 RocketMQ实现方案一本案例有账户系统和充值系统两个微服务，其中账户系统的数据库是bank数据库，其中有张三账户。充值系统的数据库使用bank_pay数据库，记录了账户的充值记录。 数据库bank_pay数据库，记录充值信息 CREATE DATABASE `bank_pay` CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_general_ci&#x27;;CREATE TABLE `account_pay` (\t`id` varchar(64) NOT NULL, `account_no` varchar(100) NULL DEFAULT NULL COMMENT &#x27;账户&#x27;, `pay_amount` double NULL DEFAULT NULL COMMENT &#x27;充值金额&#x27;, `result` varchar(20) DEFAULT NULL COMMENT &#x27;充值结果:success, fail&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_general_ci&#x27;; 伪代码充值服务（发送方）充值微服务实现如下功能： 充值接口 充值结果查询接口 Dao @Mapper@Componentpublic interface AccountPayDao &#123; @Insert(&quot;insert into account_pay(id, account_no, pay_amount, result) values(#&#123;id&#125;, #&#123;accountNo&#125;, #&#123;payAmount&#125;, #&#123;result&#125;)&quot;) int insertAccountPay(@Param(&quot;id&quot;) String id, @Param(&quot;accountNo&quot;) String accountNo, @Param(&quot;payAmount&quot;) Double payAmount, @Param(&quot;result&quot;) String result); @Select(&quot;select id, account_no accountNo, pay_amount payAmount,result from account_pay where id=#&#123;txNo&#125;&quot;) AccountPay findByIdTxNo(@Param(&quot;txNo&quot;) String txNo);&#125; Service AccountPayServicepublic interface AccountPayService &#123; // 充值 public AccountPay insertAccountPay(AccountPay accountPay); // 查询充值结果 public AccountPay getAccountPay(String txNo);&#125; 实现类 AccountPayServiceImpl@Service@Slf4jpublic class AccountPayServiceImpl implements AccountPayService &#123; @Autowire RocketMQTemplate rocketMQTemplate; @Autowire AccountPayDao accountPayDao; @Transactional @Override public AccountPay insertAccountPay(AccountPay accountPay) &#123; int result = accountPayDao.insertAccountPay(accountPay.getId(), accountPay.getAccountNo(), accountPay.getPayAmount(), &quot;success&quot;); if (result &gt; 0) &#123; // 发送通知 accountPay.setResult(&quot;success&quot;); rocketMQTemplate.convertAndSend(&quot;topic_notifymsg&quot;, accountPay); return accountPay; &#125; return null; &#125; @Override public AccountPay getAccountPay(String txNo) &#123; return accountPayDao.findByIdTxNo(txNo); &#125;&#125; Controller AccountPayController@RestControllerpublic class AccountPayController &#123; @Autowired AccountPayService accountPayService; @GetMapping(&quot;/paydo&quot;) public AccountPay pay(AccountPay accountPay) &#123; String txNo = UUID.randomUUID.toString(); accountPay.setId(txNo); return accountPayService.insertAccountPay(accountPay); &#125; @GetMapping(&quot;/payresult/&#123;txNo&#125;&quot;) public AccountPay payresult(@Pathvariable(&quot;txNo&quot;) String txNo) &#123; return accountPayService.getAccountPay(txNo); &#125;&#125; 账户服务（接收方）账户微服务实现如下功能： 监听MQ，接收充值结果，根据充值结果完成账户金额修改。 主动查询充值系统，根据充值结果完成账户修改。 Dao AccountInfoDao@Mapper@Componentpublic interface AccountInfoDao &#123; // 修改账户金额 @Update(&quot;update account_info set account_balance= account_balance+#&#123;amount&#125; where account_no = #&#123;accountNo&#125;&quot;) int updateAccountBalance(@Param(&quot;id&quot;) String id, @Param(&quot;accountNo&quot;) String accountNo, @Param(&quot;amount&quot;) Double amount); // 查询幂等记录，用于幂等控制 @Select(&quot;select count(1) from de_duplication where tx_no=#&#123;txNo&#125;&quot;) int isExistTx(@Param(&quot;txNo&quot;) String txNo); // 添加事务记录，用于幂等控制 @Insert(&quot;insert into de_duplication values(#&#123;txNo&#125;, now())&quot;) int addTx(@Param(&quot;txNo&quot;) String txNo);&#125; Client 通过Feign远程调用充值系统的结果查询接口 PayClient/** * 远程调用充值系统查询接口 */@FeignClient(value = &quot;bank-pay&quot;, fallback = PayFallback.class)public interface PayClient &#123; @GetMapping(&quot;/pay/payresult/&#123;txNo&#125;&quot;) public AccountPay payresult(@Pathvariable(&quot;txNo&quot;) String txNo);&#125; 服务降级方法 PayFallback@Componentpublic class PayFallback implements PayClient &#123; @Override public AccountPay payresult(String txNo) &#123; AccountPay accountPay = new AccountPay(); accountPay.setResult(&quot;fail&quot;); return accountPay; &#125;&#125; Service AccountInfoServicepublic interface AccountInfoService &#123; public void updateAccountBalance(AccountChangeEvent accountChange); public AccountPay queryPayResult(String txNo);&#125; 实现该接口 AccountInfoServiceImpl@Service@Slf4jpublic class AccountInfoServiceImpl implements AccountInfoService &#123; @Autowire PayClient payClient; @Autowire AccountPayDao accountInfoDao; /** * 更新账户余额 */ @Transactional @Override public void updateAccountBalance(AccountChangeEvent accountChange) &#123; // 幂等校验 int existTx = accountInfoDao.isExistTx(accountChange.getTxNo()); if (existTx &gt; 0) &#123; log.info(&quot;该消息已处理: &#123;&#125;&quot;, JSONObject.toJSONStrong(accountChange)); return; &#125; // 添加事务记录 accountInfoDao.addTx(accountChange.getTxNo()); // 更新账户金额 accountInfoDao.updateAccountBalance(accountChange.getAccountNo(), accountChange.getAmount()); &#125; /** * 主动查询充值结果 * * @param txNo 事务ID */ @Override public AccountPay queryPayResult(String txNo) &#123; // 主动请求充值系统查询充值结果 AccountPay accountPay = payClient.queryPayResult(txNo); // 充值结果 String result = accountPay.getResult(); if (&quot;success&quot;.equals(result)) &#123; AccountChangeEvent accountChangeEvent = new AccountChangeEvent(); accountChangeEvent.setAccountNo(accountPay.getAccountNo()); accountChangeEvent.setAmount(accountPay.getPayAmount()); accountChangeEvent.setTxNo(accountPay.getId()); // TODO: 注意这里事务会失效，同类中非事务调用事务 updateAccountBalance(accountChangeEvent); &#125; return accountPay; &#125;&#125; Listener 监听MQ，接收充值服务发送的消息，成功后更新数据库。 NotifyMsgListerner// 监听MQ@RocketMQMessageListener(topic = &quot;topic_notifymsg&quot;, consumerGroup = &quot;consumer_gruop_notifymsg_bank&quot;)public class NotifyMsgListerner implements RocketMQListener&lt;AccountPay&gt; &#123; @Autowire AccountInfoService accountInfoService; @Override public void onMessage(AccountPay accountPay) &#123; if (&quot;success&quot;.equals(result)) &#123; AccountChangeEvent accountChangeEvent = new AccountChangeEvent(); accountChangeEvent.setAccountNo(accountPay.getAccountNo()); accountChangeEvent.setAmount(accountPay.getPayAmount()); accountChangeEvent.setTxNo(accountPay.getId()); // TODO: 注意这里事务会失效，同类中非事务调用事务 accountInfoService.updateAccountBalance(accountChangeEvent); &#125; &#125;&#125; Controller 接收方可以主动查询通知方事务结果 AccountInfoController@RestControllerpublic class AccountInfoController &#123; @Autowired AccountInfoService accountInfoService; // 主动查询充值结果 @GetMapping(&quot;/payresult/&#123;txNo&#125;&quot;) public AccountPay result(@Pathvariable(&quot;txNo&quot;) String txNo) &#123; return accountInfoService.queryPayResult(txNo); &#125;&#125;"},{"title":"Seata实现2PC事务","path":"/wiki/dtx/seata-2pc.html","content":"实例程序技术架构如下： 交互流程如下： 1、请求bank1进行转账，传入转账金额。 2、bank1减少金额，调用bank2，传入转账金额。 搭建Demo工程demo工程的Git地址：https://gitee.com/SX-Code/dtx-seata-demo demo工程搭建教程：\tSeata实现分布式事务 Seata执行流程 要点说明：1、每个RM使用DtaSourceProxy连接数据库，其目的是使用ConnetionProxy，使用数据源和数据连接代理的目的就是在第一阶段将undo_log和业务数据放在一个本地事务提交，这样就保存了只要有业务操作就一定有undo_log。 2、在第一阶段undo_log中存放了数据修改前和修改后的值，为事务回滚作好准备，所以第一阶段完成就已经将分支事务提交，也就释放了锁资源。 3、TM开启全局事务开始，将XID全局事务id放在事务上下文中，通过feign调用也将XID传入下游分支事务，每个分支事务将自己的BranchID分支事务ID与XID关联。 4、第二阶段全局事务提交，TC会通知各个分支参与者提交分支事务，在第一阶段就已经提交了分支事务，这里各参与者只需要删除undo_log即可，并且可以异步执行 ，第二阶段很快可以完成。 5、第二阶段全局事务回滚，TC会通知各个分支参与者回滚分支事务，通过 XID 和BranchID 找到相应的回滚日志，通过回滚日志生成反向的SQL并执行，以完成分支事务回滚到之前的状态，如果回滚失败则会重试回滚操作。 细节说明： TM 请求 TC 开启一个全局事务。TC 会生成一个 XID 作为该全局事务的编号。 XID，会在微服务的调用链路中传播，保证将多个微服务的子事务关联在一起。 RM 请求 TC 将本地事务注册为全局事务的分支事务，通过全局事务的 XID 进行关联。 TM 请求 TC 告诉 XID 对应的全局事务是进行提交还是回滚。 TC 驱动 RM 们将 XID 对应的自己的本地事务进行提交还是回滚。"},{"title":"解决方案之TCC","path":"/wiki/dtx/tcc.html","content":"什么是TCC事务ICC是Try、Confirm、Cancel三个词语的缩写，TCC要求每个分支事务实现三个操作：预处理Try、确认Confirm、撤销Cancel。 Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作即口滚操作。TM首先发起所有的分支事务的Try操作，任何一个分支事务的Try操作执行失败，TM将会发起所有分支事务的Cancel操作，若Try操作全部成功，TM将会发起所有分支事务的Confirm操作，其Confirm&#x2F;Cancel操作若执行失败，TM会进行重试。 成功情况： 失败情况： TCC分为三个阶段： Try 阶段是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confirm一起才能真正构成一个完整的业务逻辑。 confirm 阶段是做确认提交，Try阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用TCC则认为 Confirm 阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引入重试机制或人工处理。 Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用TCC则认为 Cancel 阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。 TM事务管理器TM事务管理器可以实现为独立的服务，也可以让全局事务发起方充当TM的角色，TM独立出来是为了成为公用组件，是为了考虑系统结构和软件复用。 TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条，用来记录事务上下文，追踪和记录状态，由于 Confirm 和 Cancel 失败需进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同。 TCC解决方案目前市面上的TCC框架众多比如下面这几种： tcc-transaction hmily ByteTCC EasyTransaction Seata TCC模式原理举例一个扣减用户余额的业务。假设账户A原来金额是100，需要扣减30元。 阶段一（Try）：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30 阶段二：加入要提交（Confirm），则冻结金额扣减30 阶段二：如果要回滚（Cancel），则冻结金额扣减30，可用余额增加30 阶段二只操作冻结金额（预留资源），一阶段每个事务只操作自己的冻结金额（预留资源），事务相互之间没有关联（隔离） 空回滚、幂等、悬挂空回滚在没有调用TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。 出现原因是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行 Try 阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的Cancel方法，从而形成空回滚。 解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚：如果没执行，那就是空回滚。前面已经说过TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。再额外增加一张分支事务记录表 ，其中有全局事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。 幂等通过前面介绍已经了解到 ，为了保证TCC二阶段提交重试机制不会引发数据不一致，要求 TCC 的二阶段Try、Confirm 和 Cancel接口保证幕等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。 解决思路在上述”分支事务记录’中增加执行状态，每次执行前都直询该状态。 悬挂 Cancel 比 Try 先执行，需要阻止 Try 执行 悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行。 出现原因是在 RPC 调用分支事务try时，先注册分支事务，再执行RPC调用，如果此时RPC 调用的网络发生拥堵，通常 RPC调用是有超时时间的，RPC 超时以后，TM就会通知RM回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行，而一个Try 方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就称为悬挂，即业务资源预留后没法继续处理。 解决思路是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，“分支事务记录”表中是否已经有二阶段事务记录，如果有则不执行Try。"},{"title":"实现TCC","path":"/wiki/dtx/tcc_pt.html","content":"Hmily实现TCC流程介绍try:\ttry幂等校验\ttry悬挂处理\t检查余额是否够扣减金额\t扣减金额confirm:\t空cacel:\tcancel幂等校验\tcancel空回滚处理\t增加可用余额 数据库每个数据库都要创建try、confirm、cacel三张日志表 CREATE TABLE `local_try_log` (\t`tx_no` varchar(64) NOT NULL COMMENT &#x27;事务ID&#x27;, `create_time` datetime DEFAULT NULL, PRIMARY KEY (`tx_no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8CREATE TABLE `local_confirm_log` (\t`tx_no` varchar(64) NOT NULL COMMENT &#x27;事务ID&#x27;, `create_time` datetime DEFAULT NULL, PRIMARY KEY (`tx_no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8CREATE TABLE `local_cancel_log` (\t`tx_no` varchar(64) NOT NULL COMMENT &#x27;事务ID&#x27;, `create_time` datetime DEFAULT NULL, PRIMARY KEY (`tx_no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 伪代码使用伪代码方式实现TCC流程 远程调用接口 @FeignClient(value=&quot;tcc-demo-bank2&quot;)public interface Bank2Client &#123; @GetMapping(&quot;/bank2/transfer&quot;) @Hmily // 将全局事务信息带到bank2 Boolean transfer(@RequestParam(&quot;amount&quot;), Double amount);&#125; 发起方，扣减金额 /** * Bank1微服务 */@Slf4j@Servicepublic AccountInfoServiceImpl implements AccountInfoService &#123; @Autowire AccountInfoDao accountInfoDao; @Autowire Bank2Client bank2Client; // Feign接口 /** * 账户扣款，就是TCC的try方法 */ @Override @Transactional @Hmily(confirmMethod=&quot;commit&quot;, cancelMethod=&quot;rollback&quot;) public void updateAccountBalance(String accountNo, Double amount) &#123; // 获取全局事务ID String transId = HmilyTransactionContextLocal.getInstance().get().getTransactionId(); log.info(&quot;bank1 try begin 开始执行... xid: &#123;&#125;&quot;, transId); // try幂等校验，判断local_try_log表中是否有try日志记录，如果有则不执行 if (accountInfoDao.isExistTry(transId) &gt; 0) &#123; log.info(&quot;bank1 try 已经执行，无需重复执行, xid: &#123;&#125;&quot;, transId); return; &#125; // try悬挂处理，如果cacel、confirm有一个已经执行了，try不再执行 if (accountInfoDao.isExistConfirm(transId) &gt; 0 || accountInfoDao.isExistCancel(transId) &gt; 0) &#123; log.info(&quot;bank1 try悬挂处理 cancel或confirm已经执行, 不允许执行try, xid: &#123;&#125;&quot;, transId); return; &#125; // 扣减金额，检查余额是足够 SET banlance = banlance- #&#123;amount&#125; WHERE banlance &gt;= #&#123;amount&#125; if (accountInfoDao.substractAccountBalance(accountNo, amount) &lt;= 0) &#123; log.error(&quot;bank1 扣减失败&quot;); throw new RuntimeException(&quot;bank1 try 扣减金额失败, xid: &quot; + transId); &#125; // 新增 try 执行记录，用于幂等判断 accountInfoDao.addTry(transId); // 远程调用李四，转账 if (bank2Client.transfer(amount)) &#123; throw new RuntimeException(&quot;bank1 远程调用 bank2 微服务失败, xid: &quot; + transId); &#125; &#125; /** * confirm方法 */ public void commit(String accountNo, Double amount) &#123; // 获取全局事务ID String transId = HmilyTransactionContextLocal.getInstance().get().getTransactionId(); log.info(&quot;bank1 comfirm begin 开始执行... xid: &#123;&#125;&quot;, transId); &#125; /** * cancel方法 */ @Transactional public void rollback(String accountNo, Double amount) &#123; // 获取全局事务ID String transId = HmilyTransactionContextLocal.getInstance().get().getTransactionId(); log.info(&quot;bank1 try cancel 开始执行... xid: &#123;&#125;&quot;, transId); // cancel幂等校验 if (accountInfoDao.isExistCancel(transId) &gt; 0) &#123; log.info(&quot;bank2 cancel 已经执行，无需重复执行, xid: &#123;&#125;&quot;, transId); return; &#125; // cancel空回滚处理，如果try没有执行，cancel不允许执行 if (accountInfoDao.isExistTry(transId) &lt;= 0) &#123; log.info(&quot;bank2 空回滚处理, try 没有执行，不允许cancel执行, xid: &#123;&#125;&quot;, transId); return; &#125; // 增加可用余额 accountInfoDao.addAcountBalance(accountNo, amount); // 增加一条 cancel 的执行记录 accountInfoDao.addCancel(transId); &#125;&#125; 被调用方，增加金额 /** * Bank2微服务 */@Slf4j@Servicepublic AccountInfoServiceImpl implements AccountInfoService &#123; @Autowire AccountInfoDao accountInfoDao; /** * 账户扣款，就是TCC的try方法 */ @Override @Hmily(confirmMethod=&quot;commit&quot;, cancelMethod=&quot;rollback&quot;) public void updateAccountBalance(String accountNo, Double amount) &#123; // 获取全局事务ID String transId = HmilyTransactionContextLocal.getInstance().get().getTransactionId(); log.info(&quot;bank2 try begin 开始执行... xid: &#123;&#125;&quot;, transId); &#125; /** * confirm方法 */ @Transactional public void commit(String accountNo, Double amount) &#123; // 获取全局事务ID String transId = HmilyTransactionContextLocal.getInstance().get().getTransactionId(); log.info(&quot;bank1 comfirm begin 开始执行... xid: &#123;&#125;&quot;, transId); if (accountInfoDao.isExistConfirm() &gt; 0) &#123; log.info(&quot;bank2 comfirm 已经执行, 无需重复执行 xid: &#123;&#125;&quot;, transId); return; &#125; // 增加金额 accountInfoDao.addAcountBalance(accountNo, amount); // 新增 confirm 执行记录，用于幂等判断 accountInfoDao.addConfirm(transId); &#125; /** * cancel方法 */ public void rollback(String accountNo, Double amount) &#123; // 获取全局事务ID String transId = HmilyTransactionContextLocal.getInstance().get().getTransactionId(); log.info(&quot;bank1 cancel begin 开始执行... xid: &#123;&#125;&quot;, transId); &#125;&#125; Seata实现TCC为了实现空回滚、防止业务悬挂，以及幂等性要求。我们必须在数据库记录冻结金额的同时，记录当前事务id和执行状态，为此我们设计了一张表： CREATE TABLE `account_freeze_tbl` (`xid` varchar (128) NOT NULL,`user_id` varchar (255) DEFAULT NULL COMMENT &#x27;用户id&#x27;,`freeze_money` int(11) unsigned DEFAULT &#x27;0&#x27; COMMENT，冻结金额’，`state` int (1) DEFAULT NULL COMMENT #事务状态, 0:try, 1: confirm, 2:cancel&#x27;,PRIMARY KEY (`xid`) USING BTREE) ENGINE=InnODB DEFAULT CHARSET-utf8 ROW_FORMAT=COMPACT; 流程介绍Try业务 记录冻结金额和事务状态到account_freeze表 扣减account表可用 Confirm业务 根据xid删除account_freeze表的冻结记录 Cancel业务 修改account_freeze表，冻冻结金额为0，state为2 修改account表，恢复可用金额 如何判断是否空回滚 cancel业务中，根据xid查询account_freeze，如果为null则说明try还没做，需要空回滚 如何避免业务悬挂 try业务中，根据xid查询account_freeze，如果 已经存在则证明Cancel已经执行，拒绝执行try业务 伪代码TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，语法如下： @LocalTCCpublic interface AccountTCCService &#123; /** * Try逻辑，@TwoPhaseBusinessAction中的name属性要与当前方法名一致，用于指定Try逻辑对应的方法 */ @TwoPhaseBusinessAction(name=&quot;deduct&quot;, commitMethod=&quot;confirm&quot;, rollbackMethod=&quot;cancel&quot;) void deduct(@BusinessActionContextParameter(paramName=&quot;param&quot;) String userId, @BusinessActionContextParameter(paramName=&quot;money&quot;) double money); /** * 二阶段confirm确认方法，可以另命名，但要保证与commitMethod一致 * * @param context 上下文，可以传递 try 方法的参数 * @return boolean 执行是否成功 */ boolean confirm(BusinessActionContext context); /** * 二阶段回滚方法，但要保证与rollbackMethod一致 * * @param context 上下文，可以传递 try 方法的参数 * @return boolean 执行是否成功 */ boolean cancel(BusinessActionContext context);&#125; 实现类： @Slf4j@Servicepublic class AccountTCCServiceImpl implements AccountTCCService &#123; @Autowired private AccountMapper accountMapper; @Autowired private AccountFreezeMapper accountFreezeMapper; @Override @Transactional(rollbackFor = Exception.class) void deduct(String userId, double money) &#123; // 获取事务ID String xid = RootContext.getXID(); // 判断freeze是否有冻结记录，如果有一定是CANCEL执行过了 AccountFreeze oldFreeze = accountFreezeMapper.selectById(xid); if (oldFreeze != null) &#123; // CANCEL执行过，拒绝业务 return; &#125; // 扣减可用余额，余额的数据库字段为 unsigned，如果扣减为负报异常，直接回滚 accountMapper.deduct(userId, money); // 记录冻结金额，事务状态 AccountFreeze freeze = new AccountFreeze(); freeze.setUserId(userId); freeze.setFreeMoney(money); freeze.setState(AccountFreeze.State.TRY); freeze.setXid(xid); accountFreezeMapper.insert(freeze); &#125; @Override boolean confirm(BusinessActionContext ctx) &#123; // 获取事务ID String xid = RootContext.getXID(); // 删除冻结金额 int count = accountFreezeMapper.deleteById(xid); return count == 1; &#125; /** * 二阶段回滚方法，但要保证与rollbackMethod一致 * * @param context 上下文，可以传递 try 方法的参数 * @return boolean 执行是否成功 */ @Override boolean cancel(BusinessActionContext ctx) &#123; // 获取事务ID String xid = RootContext.getXID(); AccountFreeze freeze = accountFreezeMapper.selectById(xid); // 判断空回滚，判断freeze是否为null，为null证明try没执行，需要空回滚 if (freeze == null) &#123; String userId = ctx.getActionContext(&quot;userId&quot;).toString() AccountFreeze freeze = new AccountFreeze(); freeze.setUserId(userId); freeze.setFreeMoney(0); freeze.setState(AccountFreeze.State.CANCEL); freeze.setXid(xid); accountFreezeMapper.insert(freeze); return true; &#125; // 幂等判断 if (freeze.getState() == AccountFreeze.State.CANCEL) &#123; // 已经处理过，无需处理 return true; &#125; // 恢复可用金额 accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney()); // 清空冻结金额，状态置为CANCEL，避免业务悬挂 freeze.setFreeMoney(0); freeze.setState(AccountFreeze.State.CANCEL); int count = accountFreezeMapper.updateById(freeze); return count == 1; &#125;&#125; 小结如果拿TCC事务的处理流程与2PC两阶段提交做比较，2PC通常都是在跨库的DB层面，而TCC则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能。 而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。 由于从业务服务是同步调用，其结果会影响到主业务服务的决策，因此通用型 TCC 分布式事务解决方案适用于执行时间确定且较短的业务，比如互联网金融企业最核心的三个服务：交易、支付、账务："},{"title":"欢迎","path":"/wiki/recommend/index.html","content":"Wallpapers Friends"},{"title":"笔记简介","path":"/wiki/adminpro/01_introduce/index.html","content":"Naive Ui Admin 是一个基于 Vue3.0、Vite、 Naive UI、TypeScript 的中后台解决方案，它使用了最新的前端技术栈，并提炼了典型的业务模型，页面，包括二次封装组件、动态菜单、权限校验、粒子化权限控制等功能，它可以帮助你快速搭建企业级中后台项目， 相信不管是从新技术使用还是其他方面，都能帮助到你。 源项目地址：https://github.com/jekip/naive-ui-admin 本项目地址：https://gitee.com/SX-Code/naive-admin-js 本次使用JS+Vue实现Naive Ui Admin，带你阅读项目的流程。 让我先了解一下后台系统的登陆授权流程： 首先在我们需要登陆获取Token， 在路由守卫中如果有Token就会去请求用户信息，获取该用户的权限列表， 然后和路由中配置的权限进行匹配，剔除该用户没有权限访问的路由， 之后动态添加过滤之后的路由到总的路由中，此时用户就能重定向到可以访问的路由。 进入系统前，会根据路由信息动态生成菜单 页面展示"},{"title":"项目搭建","path":"/wiki/adminpro/02_project_prepare/01_项目搭建.html","content":"Webpack本次项目搭建使用Vue3提供的脚手架工具，使用UI方式搭建项目基础框架。 安装vue&#x2F;cli-init sudo npm install -g @vue/cli 运行图形界面 vue ui 在此创建项目，给项目起个名字 预设选择手动，当然如果你之前配置过，也可以直接使用之前保存的模板 勾选的项目，根据自己喜好来： Babel Router Vue Linter&#x2F;Formatter 使用配置文件 这一步，同样可以安装喜好来： 注意Linter+Prettier可能对格式要求较高，开发过程中可能会报错。请根据自己喜好选择是否使用。 当然开发过程中可以使用命令一键调整格式。 Vitevite方式使用下面命令初始化项目 npm init vite@latest"},{"title":"依赖安装","path":"/wiki/adminpro/02_project_prepare/02_依赖安装.html","content":"可以使用命令和UI方式安装都可，这里提供命令方式。 Naive UI安装npm i -D naive-ui 配置创建src/plugins/naive.js，写入以下内容： plugins/naive.jsimport * as NaiveUI from &#x27;naive-ui&#x27;;const naive = NaiveUI.create(&#123; components: [ NaiveUI.NMessageProvider, NaiveUI.NDialogProvider, NaiveUI.NConfigProvider, NaiveUI.NButton, NaiveUI.NIcon, NaiveUI.NDrawer, NaiveUI.NDrawerContent, NaiveUI.NLayout, NaiveUI.NLayoutHeader, NaiveUI.NLayoutContent, NaiveUI.NLayoutFooter, NaiveUI.NLayoutSider, NaiveUI.NMenu, NaiveUI.NBreadcrumb, NaiveUI.NBreadcrumbItem, NaiveUI.NDropdown, NaiveUI.NSpace, NaiveUI.NTooltip, NaiveUI.NAvatar, NaiveUI.NTabs, NaiveUI.NTabPane, NaiveUI.NBackTop, NaiveUI.NNotificationProvider, NaiveUI.NProgress, NaiveUI.NLoadingBarProvider, NaiveUI.NForm, NaiveUI.NFormItem, NaiveUI.NCheckbox, NaiveUI.NInput, ],&#125;);export function setupNaive(app) &#123; app.use(naive);&#125; 按需引入即可。 创建src/plugins/index.js，写入以下内容： plugins/index.jsexport &#123; setupNaive &#125; from &#x27;@/plugins/naive&#x27;; 注册在src/main.js中注册Naive UI组件 main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import &#123; setupNaive &#125; from &#x27;./plugins&#x27;;async function bootstrap() &#123; const app = createApp(App); // 注册全局常用的 naive-ui 组件 setupNaive(app); app.mount(&#x27;#app&#x27;, true);&#125;bootstrap(); pinaPinia 是 Vue 新一代的轻量级状态管理库，相当于 Vuex，也是Vue核心团队推荐的状态管理库。 安装npm install pinia 配置创建src/store/index.js，内容如下 import &#123; createPinia &#125; from &quot;pinia&quot;;const store = createPinia();export function setupStore(app) &#123; app.use(store);&#125;export &#123; store &#125;; 挂载挂载Store，修改src/main.js src/main.jsimport &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &#123; setupStore &#125; from &quot;./store&quot;;import &#123; setupNaive &#125; from &quot;./plugins&quot;;async function bootstrap() &#123; const app = createApp(App); // 挂载状态管理 setupStore(app); // 注册全局常用的 naive-ui 组件 setupNaive(app); app.mount(&quot;#app&quot;, true);&#125;bootstrap(); Store的配置远不止此，会在后续慢慢完善 tailwindcss(可选)Tailwind 是一个功能类优先的 CSS 框架，它集成了诸如 flex, pt-4, text-center和 rotate-90这样的的类，它们能直接在脚本标记语言中组合起来，构建出任何设计。无需离开您的HTML，即可快速建立现代网站。 安装npm install -S tailwindcss@next 配置 Vite需要更多额外配置，请自行百度查询解决 创建src/styles/tailwind.css，写入以下内容： styles/tailwind.css/*! @import */@tailwind base;@tailwind components;@tailwind utilities; 引入CSS在src/main.js中引入css文件： main.jsimport &#x27;./styles/tailwind.css&#x27;; xiconsxicons 是一款整合自 fluentui-system-icons、ionicons、ant-design-icons、material-design-icons、Font-Awesome、tabler-icons 和 carbon的 SVG Vue/React 组件。提供精致图标库。 安装命令： npm i -D @vicons/ionicons5npm i -D @vicons/antd 其他依赖# less 装载npm install less-loader# 拖拽, 安装vue-draggable-nextnpm install -S vue-draggable-nextnpm install -S vuedraggable@next# 触发resize问题npm install element-resize-detector --save# 图标 vue3 draggable拖拽组件报错Cannot read property ‘header‘和‘updated‘问题_draggable header_"},{"title":"资源文件","path":"/wiki/adminpro/02_project_prepare/03_资源文件.html","content":"图片资源准备一些静态资源文件，如下 assets images exception 403.svg 404.svg 500.svg developing.svg load-error.svg nodata.svg 下载地址：图片资源https://wwab.lanzoue.com/iO2a20pgmn5c 样式资源transition动画样式，下载地址：样式资源https://wwab.lanzoue.com/id6ev0pgn4fe 创建src/styles/transition/index.less，填入以下内容： styles/index.less@import &#x27;./base.less&#x27;;@import &#x27;./fade.less&#x27;;@import &#x27;./scale.less&#x27;;@import &#x27;./slide.less&#x27;;@import &#x27;./scroll.less&#x27;;@import &#x27;./zoom.less&#x27;;.collapse-transition &#123; transition: 0.2s height ease-in-out, 0.2s padding-top ease-in-out, 0.2s padding-bottom ease-in-out;&#125; common创建src/styles/common.less，填入以下内容： #app,body,html &#123; height: 100%;&#125;body &#123; font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB, Microsoft YaHei, &#x27;\\5FAE\\8F6F\\96C5\\9ED1&#x27;, Arial, sans-serif; line-height: 1.5; color: #515a6e; font-size: 14px; background-color: #f7f7f7; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;//重置样式.anticon &#123; svg &#123; vertical-align: initial; &#125;&#125;a &#123; color: #2d8cf0; background: transparent; text-decoration: none; outline: none; cursor: pointer; transition: color 0.2s ease;&#125;a:active,a:hover &#123; outline-width: 0;&#125;a:hover &#123; color: #57a3f3;&#125;a:active &#123; color: #2b85e4;&#125;a:active,a:hover &#123; outline: 0; text-decoration: none;&#125;/* 滚动条凹槽的颜色，还可以设置边框属性 */*::-webkit-scrollbar-track-piece &#123; background-color: #f8f8f8; -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em;&#125;/* 滚动条的宽度 */*::-webkit-scrollbar &#123; width: 9px; height: 9px;&#125;/* 滚动条的设置 */*::-webkit-scrollbar-thumb &#123; background-color: #ddd; background-clip: padding-box; -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em;&#125;/* 滚动条鼠标移上去 */*::-webkit-scrollbar-thumb:hover &#123; background-color: #bbb;&#125;/* router view transition */.zoom-fade-enter-active,.zoom-fade-leave-active &#123; transition: transform 0.35s, opacity 0.28s ease-in-out;&#125;.zoom-fade-enter-from &#123; opacity: 0; transform: scale(0.97);&#125;.zoom-fade-leave-to &#123; opacity: 0; transform: scale(1.03);&#125;//antd 卡片样式定制body .n-card &#123; transition: all 0.2s ease-in-out;&#125;body .n-icon &#123; vertical-align: middle;&#125;body .proCard &#123; border-radius: 4px; .n-card__content &#123; padding: 16px; &amp;:first-child &#123; padding-top: 16px; &#125; &#125;&#125;body .n-modal &#123; border-radius: 6px;&#125;//body .proCardTabs&#123;// .n-card__content&#123; padding-top: 3px&#125;// .n-card__content:first-child&#123; padding-top: 3px&#125;//&#125;.n-layout-page-header &#123; margin: 0 -10px;&#125;img, video&#123; display: block; max-width: 100%; height: auto;&#125;.flex &#123; display: flex !important;&#125;.mx-2 &#123; margin-left: 0.5rem; margin-right: 0.5rem;&#125; var创建src/styles/var.less，填入以下内容： styles/var.less@primaryColor: #2d8cf0;@primaryColorHover: #57a3f3;@header-height: 64px;@footer-height: 70px; index创建src/styles/index.less，填入以下内容： styles/index.less@import &#x27;transition/index.less&#x27;;@import &#x27;./var.less&#x27;;@import &#x27;./common.less&#x27;; 引入样式修改stc/App.vue，引入样式： &lt;style lang=&quot;less&quot;&gt;@import &#x27;styles/index.less&#x27;;&lt;/style&gt;"},{"title":"项目设置","path":"/wiki/adminpro/02_project_prepare/04_项目设置.html","content":"网站配置这部份的配置信息，不需要也不能动态的变更，直接使用即可。 项目的Logo信息，可在这里进行修改，Vite方式忽略 创建src/config/website.config.js文件，写入以下内容： config/website.config.jsimport logoImage from &#x27;@/assets/images/logo.png&#x27;;import loginImage from &#x27;@/assets/images/account-logo.png&#x27;;export const websiteConfig = Object.freeze(&#123; title: &#x27;CloudUpOA&#x27;, logo: logoImage, loginImage: loginImage, loginDesc: &#x27;云尚办公后台管理系统&#x27;,&#125;); projectSetting默认设置创建src/settings/projectSetting.js文件，写入以下内容： settings/projectSetting.jsconst setting = &#123; //导航模式 vertical 左侧菜单模式 horizontal 顶部菜单模式 navMode: &#x27;vertical&#x27;, //导航风格 dark 暗色侧边栏 light 白色侧边栏 header-dark 暗色顶栏 navTheme: &#x27;dark&#x27;, // 是否处于移动端模式 isMobile: false, //顶部 headerSetting: &#123; //背景色 bgColor: &#x27;#fff&#x27;, //固定顶部 fixed: true, //显示重载按钮 isReload: true, &#125;, //页脚 showFooter: true, //多标签 multiTabsSetting: &#123; //背景色 bgColor: &#x27;#fff&#x27;, //是否显示 show: true, //固定多标签 fixed: true, &#125;, //菜单 menuSetting: &#123; //最小宽度 minMenuWidth: 64, //菜单宽度 menuWidth: 200, //固定菜单 fixed: true, //分割菜单 mixMenu: false, //触发移动端侧边栏的宽度 mobileWidth: 800, // 折叠菜单 collapsed: false, &#125;, //面包屑 crumbsSetting: &#123; //是否显示 show: true, //显示图标 showIcon: false, &#125;, //菜单权限模式 FIXED 前端固定路由 BACK 动态获取 permissionMode: &#x27;FIXED&#x27;, //是否开启路由动画 isPageAnimate: true, //路由动画类型 pageAnimateType: &#x27;zoom-fade&#x27;,&#125;;export default setting; 状态保存 使用Store，保存当前菜单设置的状态，方便提供动态修改页面效果的功能 创建src/store/modules/projectSetting.js，写入以下内容： store/modules/projectSetting.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; store &#125; from &#x27;@/store&#x27;;import projectSetting from &#x27;@/settings/projectSetting&#x27;;const &#123; navMode, navTheme, isMobile, headerSetting, showFooter, menuSetting, multiTabsSetting, crumbsSetting, permissionMode, isPageAnimate, pageAnimateType,&#125; = projectSettingexport const useProjectSettingStore = defineStore(&#123; id: &#x27;app-project-setting&#x27;, state: () =&gt; (&#123; navMode: navMode, //导航模式 navTheme, //导航风格 isMobile, // 是否处于移动端模式 headerSetting, //顶部设置 showFooter, //页脚 menuSetting, //多标签 multiTabsSetting, //多标签 crumbsSetting, //面包屑 permissionMode, //权限模式 isPageAnimate, //是否开启路由动画 pageAnimateType, //路由动画类型 &#125;), getters: &#123; getNavMode() &#123; return this.navMode; &#125;, getNavTheme() &#123; return this.navTheme; &#125;, getIsMobile() &#123; return this.isMobile; &#125;, getHeaderSetting() &#123; return this.headerSetting; &#125;, getShowFooter() &#123; return this.showFooter; &#125;, getMenuSetting() &#123; return this.menuSetting; &#125;, getMultiTabsSetting() &#123; return this.multiTabsSetting; &#125;, getCrumbsSetting() &#123; return this.multiTabsSetting; &#125;, getPermissionMode() &#123; return this.permissionMode; &#125;, getIsPageAnimate() &#123; return this.isPageAnimate; &#125;, getPageAnimateType() &#123; return this.pageAnimateType; &#125;, &#125;, actions: &#123; setNavTheme(value) &#123; this.navTheme = value; &#125;, setIsMobile(value) &#123; this.isMobile = value &#125;, &#125;,&#125;);// Need to be used outside the setupexport function useProjectSettingStoreWithOut() &#123; return useProjectSettingStore(store);&#125; 监听读取当Store中的数据变化时，我们需要及时通知页面做出更改，因此需要监听其变化。 使用computed监听数据变化 创建src/hooks/setting/useProjectSetting.js hooks/setting/useProjectSetting.jsimport &#123; computed &#125; from &#x27;vue&#x27;;import &#123; useProjectSettingStore &#125; from &#x27;@/store/modules/projectSetting&#x27;;export function useProjectSetting() &#123; const projectStore = useProjectSettingStore(); const getNavMode = computed(() =&gt; projectStore.navMode); const getNavTheme = computed(() =&gt; projectStore.navTheme); const getIsMobile = computed(() =&gt; projectStore.isMobile); const getHeaderSetting = computed(() =&gt; projectStore.headerSetting); const getMultiTabsSetting = computed(() =&gt; projectStore.multiTabsSetting); const getMenuSetting = computed(() =&gt; projectStore.menuSetting); const getCrumbsSetting = computed(() =&gt; projectStore.crumbsSetting); const getPermissionMode = computed(() =&gt; projectStore.permissionMode); const getShowFooter = computed(() =&gt; projectStore.showFooter); const getIsPageAnimate = computed(() =&gt; projectStore.isPageAnimate); const getPageAnimateType = computed(() =&gt; projectStore.pageAnimateType); return &#123; getNavMode, getNavTheme, getIsMobile, getHeaderSetting, getMultiTabsSetting, getMenuSetting, getCrumbsSetting, getPermissionMode, getShowFooter, getIsPageAnimate, getPageAnimateType, &#125;;&#125; designSetting默认设置创建src/settings/designSetting.js文件，写入以下内容： settings/designSetting.js// app theme preset colorexport const appThemeList = [ &quot;#2d8cf0&quot;, &quot;#0960bd&quot;, &quot;#0084f4&quot;, &quot;#009688&quot;, &quot;#536dfe&quot;, &quot;#ff5c93&quot;, &quot;#ee4f12&quot;, &quot;#0096c7&quot;, &quot;#9c27b0&quot;, &quot;#ff9800&quot;, &quot;#FF3D68&quot;, &quot;#00C1D4&quot;, &quot;#71EFA3&quot;, &quot;#171010&quot;, &quot;#78DEC7&quot;, &quot;#1768AC&quot;, &quot;#FB9300&quot;, &quot;#FC5404&quot;,];const setting = &#123; //深色主题 darkTheme: false, //系统主题色 appTheme: &quot;#2d8cf0&quot;, //系统内置主题色列表 appThemeList,&#125;;export default setting; 状态保存创建src/store/modules/designSetting.js，写入以下内容： store/modules/designSetting.jsimport &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; store &#125; from &quot;@/store&quot;;import designSetting from &quot;@/settings/designSetting&quot;;const &#123; darkTheme, appTheme, appThemeList &#125; = designSetting;export const useDesignSettingStore = defineStore(&#123; id: &quot;app-design-setting&quot;, state: () =&gt; (&#123; darkTheme, //深色主题 appTheme, //系统风格 appThemeList, //系统内置风格 &#125;), getters: &#123; getDarkTheme() &#123; return this.darkTheme; &#125;, getAppTheme() &#123; return this.appTheme; &#125;, getAppThemeList() &#123; return this.appThemeList; &#125;, &#125;, actions: &#123;&#125;,&#125;);// Need to be used outside the setupexport function useDesignSettingWithOut() &#123; return useDesignSettingStore(store);&#125; 监听读取当Store中的数据变化时，我们需要及时通知页面做出更改，因此需要监听其变化。 使用computed监听数据变化 创建src/hooks/setting/useDesignSetting.js hooks/setting/useDesignSetting.jsimport &#123; computed &#125; from &#x27;vue&#x27;;import &#123; useDesignSettingStore &#125; from &#x27;@/store/modules/designSetting&#x27;;export function useDesignSetting() &#123; const designStore = useDesignSettingStore(); const getDarkTheme = computed(() =&gt; designStore.darkTheme); const getAppTheme = computed(() =&gt; designStore.appTheme); const getAppThemeList = computed(() =&gt; designStore.appThemeList); return &#123; getDarkTheme, getAppTheme, getAppThemeList, &#125;;&#125; 环境ENV关于文件名：必须以如下方式命名，不要乱起名，也无需专门手动控制加载哪个文件 .env ：全局默认配置文件，不论什么环境都会加载合并 .env.development ：开发环境下的配置文件 .env.production ：生产环境下的配置文件 Webpack注意：属性名必须以VUE_APP_开头，比如VUE_APP_XXX 创建src/.env # portPORT = 8001# spa-titleVUE_APP_TITLE = CloudUpOA# spa shortnameVUE_APP_SHORT_NAME = CloudUpOA 创建src/.env.development NODE_ENV = &#x27;development&#x27;# 网站根目录VUE_APP_PUBLIC_PATH = /# 是否开启mockVUE_APP_USE_MOCK = true# 网站前缀VUE_APP_BASE_URL = /# 是否删除consoleVUE_APP_DROP_CONSOLE = true# API 接口地址VUE_APP_API_URL =# 图片上传地址VUE_APP_UPLOAD_URL=# 图片前缀地址VUE_APP_IMG_URL=# 接口前缀VUE_APP_API_URL_PREFIX = /dev-api 输出控制台创建src/utils/logs.js utils/logs.jsconst projectName = process.env.VUE_APP_TITLE;export function warn(message) &#123; console.warn(`[$&#123;projectName&#125; warn]:$&#123;message&#125;`);&#125;export function error(message) &#123; throw new Error(`[$&#123;projectName&#125; error]:$&#123;message&#125;`);&#125; 获取方法创建src/utils/env.js，写入以下内容： utils/env.jsimport &#123; warn &#125; from &#x27;@/utils/log&#x27;;export function getAppEnvConfig() &#123; const ENV = process.env; const &#123; VUE_APP_TITLE, VUE_APP_API_URL, VUE_APP_SHORT_NAME, VUE_APP_API_URL_PREFIX, VUE_APP_UPLOAD_URL, VUE_APP_PROD_MOCK, VUE_APP_IMG_URL, &#125; = ENV; if (!/^[a-zA-Z_]*$/.test(VUE_APP_SHORT_NAME)) &#123; warn( `VUE_APP_SHORT_NAME Variables can only be characters/underscores, please modify in the environment variables and re-running.` ); &#125; return &#123; VUE_APP_TITLE, VUE_APP_API_URL, VUE_APP_SHORT_NAME, VUE_APP_API_URL_PREFIX, VUE_APP_UPLOAD_URL, VUE_APP_PROD_MOCK, VUE_APP_IMG_URL, &#125;;&#125;/** * @description: Development model */export const devMode = &#x27;development&#x27;;/** * @description: Production mode */export const prodMode = &#x27;production&#x27;;/** * @description: Get environment variables * @returns: * @example: */export function getEnv() &#123; return process.env.NODE_ENV;&#125;/** * @description: Is it a development mode * @returns: * @example: */export function isDevMode() &#123; return process.env.NODE_ENV === devMode;&#125;/** * @description: Is it a production mode * @returns: * @example: */export function isProdMode() &#123; return import.meta.env.NODE_ENV === devMode;&#125; 换名读取以VUE_APP_XXX的方式在项目中使用，终归是不方便。这里我们提供一种读取方式，更换其名称。 创建src/hooks/setting/index.js hooks/setting/index.jsimport &#123; warn &#125; from &#x27;@/utils/log&#x27;;import &#123; getAppEnvConfig &#125; from &#x27;@/utils/env&#x27;;export const useGlobSetting = () =&gt; &#123; const &#123; VUE_APP_TITLE, VUE_APP_API_URL, VUE_APP_SHORT_NAME, VUE_APP_API_URL_PREFIX, VUE_APP_UPLOAD_URL, VUE_APP_PROD_MOCK, VUE_APP_IMG_URL, &#125; = getAppEnvConfig(); if (!/[a-zA-Z_]*/.test(VUE_APP_SHORT_NAME)) &#123; warn( `VUE_APP_APP_SHORT_NAME Variables can only be characters/underscores, please modify in the environment variables and re-running.` ); &#125; // Take global configuration const glob = &#123; title: VUE_APP_TITLE, apiUrl: VUE_APP_API_URL, shortName: VUE_APP_SHORT_NAME, urlPrefix: VUE_APP_API_URL_PREFIX, uploadUrl: VUE_APP_UPLOAD_URL, prodMock: VUE_APP_PROD_MOCK, imgUrl: VUE_APP_IMG_URL, &#125;; return glob;&#125;; Vite注意：属性名必须以VITE_开头，比如VUE_XXX 创建src/.env # portVITE_PORT = 8001# spa-titleVITE_GLOB_APP_TITLE = 医院管理系统# spa shortnameVITE_GLOB_APP_SHORT_NAME = 医院管理系统 创建src/.env.development # 只在开发模式中被载入VITE_PORT = 8001# 网站根目录VITE_PUBLIC_PATH = /# 网站前缀VITE_BASE_URL = /# 跨域代理，可以配置多个，请注意不要换行#VITE_PROXY = [[&quot;/appApi&quot;,&quot;http://localhost:8001&quot;],[&quot;/upload&quot;,&quot;http://localhost:8001/upload&quot;]]VITE_PROXY=[[&quot;/api&quot;,&quot;http://localhost:9000&quot;]]# API 接口地址VITE_GLOB_API_URL =# 图片上传地址VITE_GLOB_UPLOAD_URL=# 图片前缀地址VITE_GLOB_IMG_URL=# 接口前缀VITE_GLOB_API_URL_PREFIX = /api 输出控制台创建src/utils/log.js utils/logs.jsconst projectName = import.meta.env.VITE_GLOB_APP_TITLE;export function warn(message) &#123; console.warn(`[$&#123;projectName&#125; warn]:$&#123;message&#125;`);&#125;export function error(message) &#123; throw new Error(`[$&#123;projectName&#125; error]:$&#123;message&#125;`);&#125; 获取方法创建src/utils/env.js，写入以下内容： @/build/getConfigFileName getConfigFileName.js/** * Get the configuration file variable name * @param env */export const getConfigFileName = (env) =&gt; &#123; return `__PRODUCTION__$&#123;env.VITE_GLOB_APP_SHORT_NAME || &#x27;__APP&#x27;&#125;__CONF__` .toUpperCase() .replace(/\\s/g, &#x27;&#x27;);&#125;; utils/env.jsimport &#123; warn &#125; from &#x27;@/utils/log&#x27;;import pkg from &#x27;../../package.json&#x27;;import &#123; getConfigFileName &#125; from &#x27;../../build/getConfigFileName&#x27;;export function getCommonStoragePrefix() &#123; const &#123; VITE_GLOB_APP_SHORT_NAME &#125; = getAppEnvConfig(); return `$&#123;VITE_GLOB_APP_SHORT_NAME&#125;__$&#123;getEnv()&#125;`.toUpperCase();&#125;// Generate cache key according to versionexport function getStorageShortName() &#123; return `$&#123;getCommonStoragePrefix()&#125;$&#123;`__$&#123;pkg.version&#125;`&#125;__`.toUpperCase();&#125;export function getAppEnvConfig() &#123; const ENV_NAME = getConfigFileName(import.meta.env); const ENV = (import.meta.env.DEV ? // Get the global configuration (the configuration will be extracted independently when packaging) (import.meta.env) : window[ENV_NAME]); const &#123; VITE_GLOB_APP_TITLE, VITE_GLOB_API_URL, VITE_GLOB_APP_SHORT_NAME, VITE_GLOB_API_URL_PREFIX, VITE_GLOB_UPLOAD_URL, VITE_GLOB_PROD_MOCK, VITE_GLOB_IMG_URL, &#125; = ENV; if (!/^[a-zA-Z\\_]*$/.test(VITE_GLOB_APP_SHORT_NAME)) &#123; warn( `VITE_GLOB_APP_SHORT_NAME Variables can only be characters/underscores, please modify in the environment variables and re-running.` ); &#125; return &#123; VITE_GLOB_APP_TITLE, VITE_GLOB_API_URL, VITE_GLOB_APP_SHORT_NAME, VITE_GLOB_API_URL_PREFIX, VITE_GLOB_UPLOAD_URL, VITE_GLOB_PROD_MOCK, VITE_GLOB_IMG_URL, &#125;;&#125;/** * @description: Development model */export const devMode = &#x27;development&#x27;;/** * @description: Production mode */export const prodMode = &#x27;production&#x27;;/** * @description: Get environment variables * @returns: * @example: */export function getEnv() &#123; return import.meta.env.MODE;&#125;/** * @description: Is it a development mode * @returns: * @example: */export function isDevMode() &#123; return import.meta.env.DEV;&#125;/** * @description: Is it a production mode * @returns: * @example: */export function isProdMode() &#123; return import.meta.env.PROD;&#125; 换名读取以VITE_XXX的方式在项目中使用，终归是不方便。这里我们提供一种读取方式，更换其名称。 创建src/hooks/setting/index.js hooks/setting/index.jsimport &#123; warn &#125; from &#x27;@/utils/log&#x27;;import &#123; getAppEnvConfig &#125; from &#x27;@/utils/env&#x27;;export const useGlobSetting = () =&gt; &#123; const &#123; VITE_GLOB_APP_TITLE, VITE_GLOB_API_URL, VITE_GLOB_APP_SHORT_NAME, VITE_GLOB_API_URL_PREFIX, VITE_GLOB_UPLOAD_URL, VITE_GLOB_PROD_MOCK, VITE_GLOB_IMG_URL, &#125; = getAppEnvConfig(); if (!/[a-zA-Z\\_]*/.test(VITE_GLOB_APP_SHORT_NAME)) &#123; warn( `VITE_GLOB_APP_SHORT_NAME Variables can only be characters/underscores, please modify in the environment variables and re-running.` ); &#125; // Take global configuration const glob = &#123; title: VITE_GLOB_APP_TITLE, apiUrl: VITE_GLOB_API_URL, shortName: VITE_GLOB_APP_SHORT_NAME, urlPrefix: VITE_GLOB_API_URL_PREFIX, uploadUrl: VITE_GLOB_UPLOAD_URL, prodMock: VITE_GLOB_PROD_MOCK, imgUrl: VITE_GLOB_IMG_URL, &#125;; return glob;&#125;; Env解析工具根目录创建build/utils.js文件，用来获取所有.env.*的配置信息，内容如下 安装工具 npm install dotenv --save-dev utils.jsimport fs from &#x27;fs&#x27;;import path from &#x27;path&#x27;;import dotenv from &#x27;dotenv&#x27;;export function isDevFn(mode) &#123; return mode === &#x27;development&#x27;;&#125;export function isProdFn(mode) &#123; return mode === &#x27;production&#x27;;&#125;/** * Whether to generate package preview */export function isReportMode() &#123; return process.env.REPORT === &#x27;true&#x27;;&#125;// Read all environment variable configuration files to process.envexport function wrapperEnv(envConf) &#123; const ret = &#123;&#125;; for (const envName of Object.keys(envConf)) &#123; let realName = envConf[envName].replace(/\\ /g, &#x27; &#x27;); realName = realName === &#x27;true&#x27; ? true : realName === &#x27;false&#x27; ? false : realName; if (envName === &#x27;VITE_PORT&#x27;) &#123; realName = Number(realName); &#125; if (envName === &#x27;VITE_PROXY&#x27;) &#123; try &#123; realName = JSON.parse(realName); &#125; catch (error) &#123;&#125; &#125; ret[envName] = realName; process.env[envName] = realName; &#125; return ret;&#125;/** * Get the environment variables starting with the specified prefix * @param match prefix * @param confFiles ext */export function getEnvConfig(match = &#x27;VITE_GLOB_&#x27;, confFiles = [&#x27;.env&#x27;, &#x27;.env.production&#x27;]) &#123; let envConfig = &#123;&#125;; confFiles.forEach((item) =&gt; &#123; try &#123; const env = dotenv.parse(fs.readFileSync(path.resolve(process.cwd(), item))); envConfig = &#123; ...envConfig, ...env &#125;; &#125; catch (error) &#123;&#125; &#125;); Object.keys(envConfig).forEach((key) =&gt; &#123; const reg = new RegExp(`^($&#123;match&#125;)`); if (!reg.test(key)) &#123; Reflect.deleteProperty(envConfig, key); &#125; &#125;); return envConfig;&#125;/** * Get user root directory * @param dir file path */export function getRootPath(...dir) &#123; return path.resolve(process.cwd(), ...dir);&#125; 挂载Naive UI上下文挂载 Naive-ui 脱离上下文的 API，在 setup 外使用 useDialog、useMessage、useNotification、useLoadingBar，可以通过 createDiscreteApi 来构建对应的 API。 在plugins/目录创建 naiveDiscreateApi.js naiveDiscreateApi.jsimport * as NaiveUI from &#x27;naive-ui&#x27;;import &#123; computed &#125; from &#x27;vue&#x27;;import &#123; useDesignSettingWithOut &#125; from &#x27;@/store/modules/designSetting&#x27;;import &#123; lighten &#125; from &#x27;@/utils/index&#x27;;/** * 挂载 Naive-ui 脱离上下文的 API * 如果你想在 setup 外使用 useDialog、useMessage、useNotification、useLoadingBar，可以通过 createDiscreteApi 来构建对应的 API。 * https://www.naiveui.com/zh-CN/dark/components/discrete */export function setupNaiveDiscreteApi() &#123; const designStore = useDesignSettingWithOut(); const configProviderPropsRef = computed(() =&gt; (&#123; theme: designStore.darkTheme ? NaiveUI.darkTheme : undefined, themeOverrides: &#123; common: &#123; primaryColor: designStore.appTheme, primaryColorHover: lighten(designStore.appTheme, 6), primaryColorPressed: lighten(designStore.appTheme, 6), &#125;, LoadingBar: &#123; colorLoading: designStore.appTheme, &#125;, &#125;, &#125;)); const &#123; message, dialog, notification, loadingBar &#125; = NaiveUI.createDiscreteApi( [&#x27;message&#x27;, &#x27;dialog&#x27;, &#x27;notification&#x27;, &#x27;loadingBar&#x27;], &#123; configProviderProps: configProviderPropsRef, &#125; ); window[&#x27;$message&#x27;] = message; window[&#x27;$dialog&#x27;] = dialog; window[&#x27;$notification&#x27;] = notification; window[&#x27;$loading&#x27;] = loadingBar;&#125; 修改plugins/index.js，添加如下代码 index.jsexport &#123; setupNaive &#125; from &#x27;@/plugins/naive&#x27;;export &#123; setupNaiveDiscreteApi &#125; from &#x27;@/plugins/naiveDiscreteApi&#x27;; 修改main.js，添加如下代码 main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123; setupStore &#125; from &#x27;./store&#x27;import &#123; setupNaive, setupNaiveDiscreteApi &#125; from &#x27;./plugins&#x27;import router, &#123; setupRouter &#125; from &#x27;./router&#x27;;async function bootstrap() &#123; const app = createApp(App); // 挂载状态管理 setupStore(app); // 注册全局常用的 naive-ui 组件 setupNaive(app); // 挂载 naive-ui 脱离上下文的 Api setupNaiveDiscreteApi(); // 挂载路由 setupRouter(app); // 路由准备就绪后挂载 APP 实例 // https://router.vuejs.org/api/interfaces/router.html#isready await router.isReady(); app.mount(&#x27;#app&#x27;, true);&#125;bootstrap();"},{"title":"常量字符","path":"/wiki/adminpro/02_project_prepare/05_常量字符.html","content":"定义一些常量字符，类似其他语言的枚举。如果你是用的是Typescript，还可以用来做类型判断等。 httpEnum注意ResultEnum需要和后端的code保持一致 创建src/enums/httpEnum.js，写入以下内容： enums/httpEnum.js/** * @description: 请求结果集 */export const ResultEnum = &#123; SUCCESS: 2000, ERROR: -1, TIMEOUT: 10042, TOKEN_TIMEOUT: 10041, TYPE: &#x27;success&#x27;,&#125;;/** * @description: 请求方法 */export const RequestEnum = &#123; GET: &#x27;GET&#x27;, POST: &#x27;POST&#x27;, PATCH: &#x27;PATCH&#x27;, PUT: &#x27;PUT&#x27;, DELETE: &#x27;DELETE&#x27;,&#125;;/** * @description: 常用的contentTyp类型 */export const ContentTypeEnum = &#123; // json JSON: &#x27;application/json;charset=UTF-8&#x27;, // json TEXT: &#x27;text/plain;charset=UTF-8&#x27;, // form-data 一般配合qs FORM_URLENCODED: &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;, // form-data 上传 FORM_DATA: &#x27;multipart/form-data;charset=UTF-8&#x27;,&#125;; pageEnum创建src/enums/pageEnum.js，写入以下内容： enums/pageEnum.jsexport const PageEnum = &#123; // 登录 BASE_LOGIN: &#x27;/login&#x27;, BASE_LOGIN_NAME: &#x27;Login&#x27;, //重定向 REDIRECT: &#x27;/redirect&#x27;, REDIRECT_NAME: &#x27;Redirect&#x27;, // 首页 BASE_HOME: &#x27;/dashboard&#x27;, //首页跳转默认路由 BASE_HOME_REDIRECT: &#x27;/dashboard/console&#x27;, // 错误 ERROR_PAGE_NAME: &#x27;ErrorPage&#x27;,&#125;;"},{"title":"工具方法","path":"/wiki/adminpro/02_project_prepare/06_工具方法.html","content":"提供一些基础的工具方法，可以根据自己的需要增删。 is创建src/utils/is/index.js，写入以下内容： utils/is/index.jsconst toString = Object.prototype.toString;/** * @description: 判断值是否未某个类型 */export function is(val, type) &#123; return toString.call(val) === `[object $&#123;type&#125;]`;&#125;/** * @description: 是否为函数 */export function isFunction(val) &#123; return is(val, &#x27;Function&#x27;) || is(val, &#x27;AsyncFunction&#x27;);&#125;/** * @description: 是否已定义 */export const isDef = (val) =&gt; &#123; return typeof val !== &#x27;undefined&#x27;;&#125;;export const isUnDef = (val) =&gt; &#123; return !isDef(val);&#125;;/** * @description: 是否为对象 */export const isObject = (val) =&gt; &#123; return val !== null &amp;&amp; is(val, &#x27;Object&#x27;);&#125;;/** * @description: 是否为时间 */export function isDate(val) &#123; return is(val, &#x27;Date&#x27;);&#125;/** * @description: 是否为数值 */export function isNumber(val) &#123; return is(val, &#x27;Number&#x27;);&#125;/** * @description: 是否为AsyncFunction */export function isAsyncFunction(val) &#123; return is(val, &#x27;AsyncFunction&#x27;);&#125;/** * @description: 是否为promise */export function isPromise(val) &#123; return ( is(val, &#x27;Promise&#x27;) &amp;&amp; isObject(val) &amp;&amp; isFunction(val.then) &amp;&amp; isFunction(val.catch) );&#125;/** * @description: 是否为字符串 */export function isString(val) &#123; return is(val, &#x27;String&#x27;);&#125;/** * @description: 是否为boolean类型 */export function isBoolean(val) &#123; return is(val, &#x27;Boolean&#x27;);&#125;/** * @description: 是否为数组 */export function isArray(val) &#123; return val &amp;&amp; Array.isArray(val);&#125;/** * @description: 是否客户端 */export const isClient = () =&gt; &#123; return typeof window !== &#x27;undefined&#x27;;&#125;;/** * @description: 是否为浏览器 */export const isWindow = (val) =&gt; &#123; return typeof window !== &#x27;undefined&#x27; &amp;&amp; is(val, &#x27;Window&#x27;);&#125;;export const isElement = (val) =&gt; &#123; return isObject(val) &amp;&amp; !!val.tagName;&#125;;export const isServer = typeof window === &#x27;undefined&#x27;;// 是否为图片节点export function isImageDom(o) &#123; return o &amp;&amp; [&#x27;IMAGE&#x27;, &#x27;IMG&#x27;].includes(o.tagName);&#125;export function isNull(val) &#123; return val === null;&#125;export function isNullAndUnDef(val) &#123; return isUnDef(val) &amp;&amp; isNull(val);&#125;export function isNullOrUnDef(val) &#123; return isUnDef(val) || isNull(val);&#125;/** * 判断是否 url * */export function isUrl(url) &#123; return /^(http|https):\\/\\//g.test(url);&#125; index创建src/utils/index.js，写入以下内容： utils/index.jsimport &#123; PageEnum &#125; from &#x27;@/enums/pageEnum&#x27;;import &#123; NIcon &#125; from &#x27;naive-ui&#x27;;import &#123; h &#125; from &#x27;vue&#x27;;import &#123; isObject &#125; from &#x27;./is&#x27;;/** * render 图标 * */export function renderIcon(icon) &#123; return () =&gt; h(NIcon, null, &#123; default: () =&gt; h(icon) &#125;);&#125;/** * Sums the passed percentage to the R, G or B of a HEX color * @param &#123;string&#125; color The color to change * @param &#123;number&#125; amount The amount to change the color by * @returns &#123;string&#125; The processed part of the color */function addLight(color, amount) &#123; const cc = parseInt(color, 16) + amount; const c = cc &gt; 255 ? 255 : cc; return c.toString(16).length &gt; 1 ? c.toString(16) : `0$&#123;c.toString(16)&#125;`;&#125;/** * Lightens a 6 char HEX color according to the passed percentage * @param &#123;string&#125; color The color to change * @param &#123;number&#125; amount The amount to change the color by * @returns &#123;string&#125; The processed color represented as HEX */export function lighten(color, amount) &#123; color = color.indexOf(&#x27;#&#x27;) &gt;= 0 ? color.substring(1, color.length) : color; amount = Math.trunc((255 * amount) / 100); return `#$&#123;addLight(color.substring(0, 2), amount)&#125;$&#123;addLight( color.substring(2, 4), amount )&#125;$&#123;addLight(color.substring(4, 6), amount)&#125;`;&#125;export function deepMerge(src = &#123;&#125;, target = &#123;&#125;) &#123; let key; for (key in target) &#123; src[key] = isObject(src[key]) ? deepMerge(src[key], target[key]) : (src[key] = target[key]); &#125; return src;&#125; StorageStorage提供CRUD本地缓存和Cookies的功能 创建src/utils/Storage.js，填入以下内容： utils/Storage.js// 默认缓存期限为7天const DEFAULT_CACHE_TIME = 60 * 60 * 24 * 7;export const createStorage = (&#123; prefixKey = &#x27;&#x27;, storage = localStorage,&#125; = &#123;&#125;) =&gt; &#123; // 本地缓存对象 function Storage() &#123; this.storage = storage; this.prefixKey = prefixKey; this.getKey = function (key) &#123; return `$&#123;this.prefixKey&#125;$&#123;key&#125;`.toUpperCase(); &#125;; /** * @description 设置缓存 * @param &#123;string&#125; key 缓存键 * @param &#123;*&#125; value 缓存值 * @param expire */ this.set = function (key, value, expire = DEFAULT_CACHE_TIME) &#123; const stringData = JSON.stringify(&#123; value, expire: expire != null ? new Date().getTime() + expire * 1000 : null, &#125;); this.storage.setItem(this.getKey(key), stringData); &#125;; /** * 读取缓存 * @param &#123;string&#125; key 缓存键 * @param &#123;*=&#125; def 默认值 */ this.get = function (key, def = null) &#123; const item = this.storage.getItem(this.getKey(key)); if (item) &#123; try &#123; const data = JSON.parse(item); const &#123; value, expire &#125; = data; // 在有效期内直接返回 if (expire === null || expire &gt;= Date.now()) &#123; return value; &#125; this.remove(key); &#125; catch (e) &#123; return def; &#125; &#125; return def; &#125;; /** * 从缓存删除某项 * @param &#123;string&#125; key */ this.remove = function (key) &#123; this.storage.removeItem(this.getKey(key)); &#125;; /** * 清空所有缓存 * @memberOf Cache */ this.clear = function () &#123; this.storage.clear(); &#125;; /** * 设置cookie * @param &#123;string&#125; name cookie 名称 * @param &#123;*&#125; value cookie 值 * @param &#123;number=&#125; expire 过期时间 * 如果过期时间未设置，默认关闭浏览器自动删除 * @example */ this.setCookie = function (name, value, expire = DEFAULT_CACHE_TIME) &#123; document.cookie = `$&#123;this.getKey(name)&#125;=$&#123;value&#125;; Max-Age=$&#123;expire&#125;`; &#125;; this.getCookie = function (name) &#123; const cookieArr = document.cookie.split(&#x27;; &#x27;); for (let i = 0, length = cookieArr.length; i &lt; length; i++) &#123; const kv = cookieArr[i].split(&#x27;=&#x27;); if (kv[0] === this.getKey(name)) &#123; return kv[1]; &#125; &#125; return &#x27;&#x27;; &#125;; /** * 根据名字删除指定的cookie * @param &#123;string&#125; key */ this.removeCookie = function (key) &#123; this.setCookie(key, 1, -1); &#125;; /** * 清空cookie，使所有cookie失效 */ this.clearCookie = function () &#123; const keys = document.cookie.match(/[^ =;]+(?==)/g); if (keys) &#123; for (let i = keys.length; i--; ) &#123; document.cookie = keys[i] + &#x27;=0;expire=&#x27; + new Date(0).toUTCString(); &#125; &#125; &#125;; &#125; return new Storage();&#125;;export const storage = createStorage();export default Storage; urlUtils当我们在使用POST请求是，可能需要将对象添加当作参数拼接到URL上面 创建src/utils/urlUtils.js，填入以下内容： utils/urlUtils.js/** * 将对象添加当作参数拼接到URL上面 * @param baseUrl 需要拼接的url * @param obj 参数对象 * @returns &#123;string&#125; 拼接后的对象 * 例子: * let obj = &#123;a: &#x27;3&#x27;, b: &#x27;4&#x27;&#125; * setObjToUrlParams(&#x27;www.baidu.com&#x27;, obj) * ==&gt;www.baidu.com?a=3&amp;b=4 */export function setObjToUrlParams(baseUrl, obj) &#123; let parameters = &#x27;&#x27;; let url = &#x27;&#x27;; for (const key in obj) &#123; parameters += key + &#x27;=&#x27; + encodeURIComponent(obj[key]) + &#x27;&amp;&#x27;; &#125; parameters = parameters.replace(/&amp;$/, &#x27;&#x27;); if (/\\?$/.test(baseUrl)) &#123; url = baseUrl + parameters; &#125; else &#123; url = baseUrl.replace(/\\/?$/, &#x27;?&#x27;) + parameters; &#125; return url;&#125; 工具方法远不止这些，后面会逐渐完善"},{"title":"状态管理","path":"/wiki/adminpro/03_advanced_operation/01_状态管理.html","content":"在依赖安装部分，我们使用更好用的 Pinia 替代 Vuex，并进行了基础的配置。 该部分我们添加一点些需要进行状态管理的对象。 常量创建src/store/mutation-types.js，写入以下内容： store/mutation-types.jsexport const ACCESS_TOKEN = &#x27;ACCESS-TOKEN&#x27;; // 用户tokenexport const CURRENT_USER = &#x27;CURRENT-USER&#x27;; // 当前用户信息export const TABS_ROUTES = &#x27;TABS-ROUTES&#x27;; // 标签页 用户状态管理值得注意的是，登陆和获取用户信息的请求是在此处发起的。网络请求方法：getUserInfo, login将在网络配置部分予以实现，这里为了不报错可实现两个空方法。 创建src/store/modules/user.js，写入以下内容： store/modules/user.jsimport &#123; storage &#125; from &#x27;@/utils/Storage&#x27;;import &#123; defineStore &#125; from &#x27;pinia&#x27;;import &#123; store &#125; from &#x27;@/store&#x27;;import &#123; ACCESS_TOKEN, CURRENT_USER &#125; from &#x27;../mutation-types&#x27;;import &#123; getUserInfo, login &#125; from &#x27;@/api/system/user&#x27;;import &#123; ResultEnum &#125; from &#x27;@/enums/httpEnum&#x27;;export const useUserStore = defineStore(&#123; id: &#x27;app-user&#x27;, state: () =&gt; (&#123; token: storage.get(ACCESS_TOKEN, &#x27;&#x27;), username: &#x27;&#x27;, welcome: &#x27;&#x27;, avatar: &#x27;&#x27;, permissions: [], info: storage.get(CURRENT_USER, &#123;&#125;), &#125;), getters: &#123; getToken() &#123; return this.token; &#125;, getAvatar() &#123; return this.avatar; &#125;, getNickname() &#123; return this.username; &#125;, getPermissions() &#123; return this.permissions; &#125;, getUserInfo() &#123; return this.info; &#125;, &#125;, actions: &#123; setToken(token) &#123; this.token = token; &#125;, setAvatar(avatar) &#123; this.avatar = avatar; &#125;, setPermissions(permissions) &#123; this.permissions = permissions; &#125;, setUserInfo(info) &#123; this.info = info; &#125;, // 登录 async login(userInfo) &#123; try &#123; const response = await login(userInfo); const &#123; data: result, code &#125; = response; if (code === ResultEnum.SUCCESS) &#123; const ex = 7 * 24 * 60 * 60; storage.set(ACCESS_TOKEN, result.token, ex); storage.set(CURRENT_USER, result, ex); this.setToken(result.token); this.setUserInfo(result); &#125; return Promise.resolve(response); &#125; catch (e) &#123; return Promise.reject(e); &#125; &#125;, // 获取用户信息 GetInfo() &#123; const that = this; return new Promise((resolve, reject) =&gt; &#123; getUserInfo() .then((res) =&gt; &#123; const result = res; if (result.permissions &amp;&amp; result.permissions.length) &#123; const permissionsList = result.permissions; that.setPermissions(permissionsList); that.setUserInfo(result); &#125; else &#123; reject( new Error(&#x27;getInfo: permissionsList must be a non-null array !&#x27;) ); &#125; that.setAvatar(result.avatar); resolve(res); &#125;) .catch((error) =&gt; &#123; reject(error); &#125;); &#125;); &#125;, // 登出 async logout() &#123; this.setPermissions([]); this.setUserInfo(&#x27;&#x27;); storage.remove(ACCESS_TOKEN); storage.remove(CURRENT_USER); return Promise.resolve(&#x27;&#x27;); &#125;, &#125;,&#125;);// Need to be used outside the setupexport function useUserStoreWidthOut() &#123; return useUserStore(store);&#125; 标签页状态管理 不使用标签页功能时，可不添加其状态管理 本项目实现了页面标签页以及组件缓存功能。 创建src/store/modules/tabsView.js，写入以下内容： store/modules/tabsView.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;;// 不需要出现在标签页中的路由const whiteList = [&#x27;Redirect&#x27;, &#x27;login&#x27;];//保留固定路由function retainAffixRoute(list) &#123; return list.filter((item) =&gt; item?.meta?.affix ?? false);&#125;export const useTabsViewStore = defineStore(&#123; id: &#x27;app-tabs-view&#x27;, state: () =&gt; (&#123; tabsList: [], &#125;), getters: &#123;&#125;, actions: &#123; initTabs(routes) &#123; // 初始化标签页 this.tabsList = routes; &#125;, addTabs(route) &#123; // 添加标签页 if (whiteList.includes(route.name)) return false; const isExists = this.tabsList.some( (item) =&gt; item.fullPath == route.fullPath ); if (!isExists) &#123; this.tabsList.push(route); &#125; return true; &#125;, closeLeftTabs(route) &#123; // 关闭左侧 const index = this.tabsList.findIndex( (item) =&gt; item.fullPath == route.fullPath ); this.tabsList = this.tabsList.filter( (item, i) =&gt; i &gt;= index || (item?.meta?.affix ?? false) ); &#125;, closeRightTabs(route) &#123; // 关闭右侧 const index = this.tabsList.findIndex( (item) =&gt; item.fullPath == route.fullPath ); this.tabsList = this.tabsList.filter( (item, i) =&gt; i &lt;= index || (item?.meta?.affix ?? false) ); &#125;, closeOtherTabs(route) &#123; // 关闭其他 this.tabsList = this.tabsList.filter( (item) =&gt; item.fullPath == route.fullPath || (item?.meta?.affix ?? false) ); &#125;, closeCurrentTab(route) &#123; // 关闭当前页 const index = this.tabsList.findIndex( (item) =&gt; item.fullPath == route.fullPath ); this.tabsList.splice(index, 1); &#125;, closeAllTabs() &#123; // 关闭全部 console.log(retainAffixRoute(this.tabsList)); this.tabsList = retainAffixRoute(this.tabsList); &#125;, &#125;,&#125;);"},{"title":"VUE页面","path":"/wiki/adminpro/03_advanced_operation/02_VUE页面.html","content":"创建几个简单的Vue页面，方便代码编写。 APP VUEApp.vue是最根本的vue文件，我们可以在此处挂载 NaiveUI 的全局主题配置、Message配置、Dialog配置、Notification配置等。 创建src/components/Application/index.js，写入以下内容： components/Application/index.jsimport AppProvider from &#x27;./Application.vue&#x27;;export &#123; AppProvider &#125;; 创建src/components/Application/Application.vue，写入以下内容： components/Application/Application.vue&lt;template&gt; &lt;n-dialog-provider&gt; &lt;n-notification-provider&gt; &lt;n-message-provider&gt; &lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt; &lt;/n-message-provider&gt; &lt;/n-notification-provider&gt; &lt;/n-dialog-provider&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;import &#123; NDialogProvider, NNotificationProvider, NMessageProvider,&#125; from &#x27;naive-ui&#x27;;export default defineComponent(&#123; name: &#x27;Application&#x27;, components: &#123; NDialogProvider, NNotificationProvider, NMessageProvider, &#125;, setup() &#123; return &#123;&#125;; &#125;,&#125;);&lt;/script&gt; 修改src/App.vue，内容如下： App.vue&lt;template&gt; &lt;NConfigProvider :locale=&quot;zhCN&quot; :date-locale=&quot;dateZhCN&quot; :theme=&quot;getDarkTheme&quot; :theme-overrides=&quot;getThemeOverrides&quot; &gt; &lt;AppProvider&gt; &lt;RouterView /&gt; &lt;/AppProvider&gt; &lt;/NConfigProvider&gt;&lt;/template&gt;&lt;script&gt;import &#123; computed, defineComponent &#125; from &#x27;vue&#x27;;// locale &amp; dateLocaleimport &#123; zhCN, dateZhCN, darkTheme &#125; from &#x27;naive-ui&#x27;;import &#123; AppProvider &#125; from &#x27;@/components/Application&#x27;;import &#123; useDesignSettingStore &#125; from &#x27;@/store/modules/designSetting&#x27;;import &#123; lighten &#125; from &#x27;@/utils/index&#x27;;export default defineComponent(&#123; components: &#123; AppProvider &#125;, setup() &#123; const designStore = useDesignSettingStore(); /** * @type import(&#x27;naive-ui&#x27;).GlobalThemeOverrides */ const getThemeOverrides = computed(() =&gt; &#123; const appTheme = designStore.appTheme; const lightenStr = lighten(designStore.appTheme, 6); return &#123; common: &#123; primaryColor: appTheme, primaryColorHover: lightenStr, primaryColorPressed: lightenStr, primaryColorSuppl: appTheme, &#125;, LoadingBar: &#123; colorLoading: appTheme, &#125;, &#125;; &#125;); const getDarkTheme = computed(() =&gt; designStore.darkTheme ? darkTheme : undefined ); return &#123; zhCN, dateZhCN, getDarkTheme, getThemeOverrides, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;@import &#x27;styles/index.less&#x27;;&lt;/style&gt; 错误页面403页面创建src/views/exception/403.vue，写入以下内容： views/exception/403.vue&lt;template&gt; &lt;div class=&quot;flex flex-col justify-center page-container&quot;&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;img src=&quot;~@/assets/images/exception/403.svg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;h1 class=&quot;text-base text-gray-500&quot;&gt;抱歉，你无权访问该页面&lt;/h1&gt; &lt;n-button type=&quot;info&quot; @click=&quot;goHome&quot;&gt;回到首页&lt;/n-button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;import &#123; useRouter &#125; from &#x27;vue-router&#x27;;export default defineComponent(&#123; setup() &#123; const router = useRouter(); function goHome() &#123; router.push(&#x27;/&#x27;); &#125; return &#123; goHome, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.page-container &#123; width: 100%; border-radius: 4px; padding: 50px 0; height: 100vh; .text-center &#123; h1 &#123; color: #666; padding: 20px 0; &#125; &#125; img &#123; width: 350px; margin: 0 auto; &#125;&#125;&lt;/style&gt; 404页面创建src/views/exception/404.vue，写入以下内容： views/exception/404.vue&lt;template&gt; &lt;div class=&quot;flex flex-col justify-center page-container&quot;&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;img src=&quot;~@/assets/images/exception/404.svg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;h1 class=&quot;text-base text-gray-500&quot;&gt;抱歉，你访问的页面不存在&lt;/h1&gt; &lt;n-button type=&quot;info&quot; @click=&quot;goHome&quot;&gt;回到首页&lt;/n-button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;import &#123; useRouter &#125; from &#x27;vue-router&#x27;;export default defineComponent(&#123; setup() &#123; const router = useRouter(); function goHome() &#123; router.push(&#x27;/&#x27;); &#125; return &#123; goHome, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.page-container &#123; width: 100%; border-radius: 4px; padding: 50px 0; height: 100vh; .text-center &#123; h1 &#123; color: #666; padding: 20px 0; &#125; &#125; img &#123; width: 350px; margin: 0 auto; &#125;&#125;&lt;/style&gt; 500页面创建src/views/exception/500.vue，写入以下内容： views/exception/500.vue&lt;template&gt; &lt;div class=&quot;flex flex-col justify-center page-container&quot;&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;img src=&quot;~@/assets/images/exception/500.svg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;h1 class=&quot;text-base text-gray-500&quot;&gt;抱歉，服务器出错了&lt;/h1&gt; &lt;n-button type=&quot;info&quot; @click=&quot;goHome&quot;&gt;回到首页&lt;/n-button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;import &#123; useRouter &#125; from &#x27;vue-router&#x27;;export default defineComponent(&#123; setup() &#123; const router = useRouter(); function goHome() &#123; router.push(&#x27;/&#x27;); &#125; return &#123; goHome, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.page-container &#123; width: 100%; border-radius: 4px; padding: 50px 0; height: 100vh; .text-center &#123; h1 &#123; color: #666; padding: 20px 0; &#125; &#125; img &#123; width: 350px; margin: 0 auto; &#125;&#125;&lt;/style&gt; 重定向页面该页面是用来做重定向使用的 创建src/views/redirect/index.vue，写入以下内容： view/redirect/index.vue&lt;template&gt; &lt;div&gt; &lt;NEmpty /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent, onBeforeMount &#125; from &#x27;vue&#x27;;import &#123; useRoute, useRouter &#125; from &#x27;vue-router&#x27;;import &#123; NEmpty &#125; from &#x27;naive-ui&#x27;;export default defineComponent(&#123; name: &#x27;Redirect&#x27;, components: &#123; NEmpty &#125;, setup() &#123; const route = useRoute(); const router = useRouter(); onBeforeMount(() =&gt; &#123; const &#123; params, query &#125; = route; const &#123; path &#125; = params; router.replace(&#123; path: &#x27;/&#x27; + (Array.isArray(path) ? path.join(&#x27;/&#x27;) : path), query, &#125;); &#125;); &#125;,&#125;);&lt;/script&gt; Dashboard页面创建两个空的Dashboard页面 主控台创建src/views/dashboard/console/console.vue，写入以下内容： dashboard/console/console.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;主控台&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; setup() &#123;&#125;,&#125;);&lt;/script&gt; 工作台创建src/views/dashboard/workplace/workplace.vue，写入以下内容： dashboard/workplace/workplace.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;工作台&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; setup() &#123;&#125;,&#125;);&lt;/script&gt;"},{"title":"路由配置","path":"/wiki/adminpro/03_advanced_operation/03_路由配置.html","content":"路由是项目中最重要的部分。本节将实现路由权限控制，动态生成菜单 目录结构 src router modules dashboard.js base.js constant.js index.js router-guards.js store modules asyncRoute.js 组件常量创建src/router/constant.js，填入以下内容： router/constant.jsexport const RedirectName = &#x27;Redirect&#x27;;export const ErrorPage = () =&gt; import(&#x27;@/views/exception/404.vue&#x27;);export const Layout = () =&gt; import(&#x27;@/layout/index.vue&#x27;); Layout将在项目布局篇中予以实现，这里为了不报错可以先写一个空的index.vue 单个路由定义单独的页面路由组件，后续会统一读取添加到路由以及生成菜单。 错误和重定向页面路由创建src/router/base.js，填入以下内容： router/base.jsimport &#123; ErrorPage, RedirectName, Layout &#125; from &#x27;@/router/constant&#x27;;// 404 on a pageexport const ErrorPageRoute = &#123; path: &#x27;/:path(.*)*&#x27;, component: Layout, meta: &#123; title: &#x27;ErrorPage&#x27;, hideBreadcrumb: true, &#125;, children: [ &#123; path: &#x27;/:path(.*)*&#x27;, component: ErrorPage, meta: &#123; title: &#x27;ErrorPage&#x27;, hideBreadcrumb: true, &#125;, &#125;, ],&#125;;export const RedirectRoute = &#123; path: &#x27;/redirect&#x27;, name: RedirectName, component: Layout, meta: &#123; title: RedirectName, hideBreadcrumb: true, &#125;, children: [ &#123; path: &#x27;/redirect/:path(.*)&#x27;, name: RedirectName, component: () =&gt; import(&#x27;@/views/redirect/index.vue&#x27;), meta: &#123; title: RedirectName, hideBreadcrumb: true, &#125;, &#125;, ],&#125;; Dashboard页面路由创建src/router/modules/dashboard.js，填入以下内容： router/modules/dashboard.jsconst routeName = &#x27;dashboard&#x27;;import &#123; Layout &#125; from &#x27;@/router/constant&#x27;;import &#123; DashboardOutlined &#125; from &#x27;@vicons/antd&#x27;;import &#123; renderIcon &#125; from &#x27;@/utils/index&#x27;;const routes = [ &#123; path: &#x27;/dashboard&#x27;, name: routeName, redirect: &#x27;/dashboard/console&#x27;, component: Layout, meta: &#123; title: &#x27;Dashboard&#x27;, icon: renderIcon(DashboardOutlined), permissions: [&#x27;dashboard_console&#x27;, &#x27;dashboard_workplace&#x27;], sort: 0, &#125;, children: [ &#123; path: &#x27;console&#x27;, name: `$&#123;routeName&#125;_console`, meta: &#123; title: &#x27;主控台&#x27;, permissions: [&#x27;dashboard_console&#x27;], affix: true, &#125;, component: () =&gt; import(&#x27;@/views/dashboard/console/console.vue&#x27;), &#125;, &#123; path: &#x27;workplace&#x27;, name: `$&#123;routeName&#125;_workplace`, meta: &#123; title: &#x27;工作台&#x27;, keepAlive: true, permissions: [&#x27;dashboard_workplace&#x27;], &#125;, component: () =&gt; import(&#x27;@/views/dashboard/workplace/workplace.vue&#x27;), &#125;, ], &#125;,];export default routes; 路由整合暂时未添加路由守卫功能，后续会增加。 新建src/router/index.js，内容如下： Vite 方式请如用如下代码组装路由 const modules = import.meta.glob(&#x27;./modules/**/*.js&#x27;, &#123; eager: true &#125;);// 整合modules下的路由，形成列表const routeModuleList = Object.keys(modules).reduce((list, key) =&gt; &#123; const mod = modules[key].default ?? &#123;&#125;; const modList = Array.isArray(mod) ? [...mod] : [mod]; return [...list, ...modList];&#125;, []); router/index.jsimport &#123; PageEnum &#125; from &#x27;@/enums/pageEnum&#x27;;import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;;import &#123; RedirectRoute &#125; from &#x27;@/router/base&#x27;;import &#123; ErrorPageRoute &#125; from &#x27;./base&#x27;;const modules = require.context(&#x27;@/router/modules/&#x27;, false, /\\.js$/);// 整合modules下的路由，形成列表const routeModuleList = [];modules.keys().forEach((key) =&gt; &#123; const mod = modules(key).default || &#123;&#125;; const modeList = Array.isArray(mod) ? [...mod] : [mod]; routeModuleList.push(...modeList);&#125;);function sortRoute(a, b) &#123; return (a.meta?.sort || 0) - (b.meta?.sort || 0);&#125;routeModuleList.sort(sortRoute);// 根路由export const RootRoute = &#123; path: &#x27;/&#x27;, name: &#x27;Root&#x27;, redirect: PageEnum.BASE_HOME, meta: &#123; title: &#x27;Root&#x27;, &#125;,&#125;;// 登录路由export const LoginRoute = &#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: () =&gt; import(&#x27;@/views/login/index.vue&#x27;), meta: &#123; title: &#x27;登录&#x27;, &#125;,&#125;;//需要验证权限export const asyncRoutes = [...routeModuleList];// 普通路由，无需验证权限export const constantRouter = [ LoginRoute, RootRoute, RedirectRoute, ErrorPageRoute];const router = createRouter(&#123; history: createWebHashHistory(&#x27;&#x27;), routes: constantRouter, strict: true, scrollBehavior: () =&gt; (&#123; left: 0, top: 0 &#125;),&#125;);export function setupRouter(app) &#123; app.use(router);&#125;export default router; 挂载路由在src/main.js中挂载路由 main.jsimport &#x27;./styles/tailwind.css&#x27;;import &#123; createApp &#125; from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import router, &#123; setupRouter &#125; from &#x27;./router&#x27;;import &#123; setupStore &#125; from &#x27;./store&#x27;;import &#123; setupNaive &#125; from &#x27;./plugins&#x27;;async function bootstrap() &#123; const app = createApp(App); // 挂载状态管理 setupStore(app); // 注册全局常用的 naive-ui 组件 setupNaive(app); // 挂载路由 setupRouter(app); // 路由准备就绪后挂载 APP 实例 // https://router.vuejs.org/api/interfaces/router.html#isready await router.isReady(); app.mount(&#x27;#app&#x27;, true);&#125;bootstrap(); 动态路由动态路由一般有两种实现方式： 后端获取路由列表数据，在前端做数据处理后动态生成路由和菜单信息 使用权限过滤，过滤账户是否拥有某一个权限，并将菜单从加载列表移除 本次项目使用的是权限过滤方式。 创建src/store/modules/asyncRoute.js store/modules/asyncRoute.jsimport &#123; asyncRoutes, constantRouter &#125; from &#x27;@/router&#x27;;import &#123; defineStore &#125; from &#x27;pinia&#x27;;import &#123; toRaw, unref &#125; from &#x27;vue&#x27;;import &#123; store &#125; from &#x27;@/store&#x27;;import &#123; useProjectSetting &#125; from &#x27;@/hooks/setting/useProjectSetting&#x27;;const DEFAULT_CONFIG = &#123; id: &#x27;id&#x27;, children: &#x27;children&#x27;, pid: &#x27;pid&#x27;,&#125;;const getConfig = (config) =&gt; Object.assign(&#123;&#125;, DEFAULT_CONFIG, config);function filter(tree, func, config = &#123;&#125;) &#123; config = getConfig(config); const children = config.children; function listFilter(list) &#123; return list .map((node) =&gt; (&#123; ...node &#125;)) .filter((node) =&gt; &#123; node[children] = node[children] &amp;&amp; listFilter(node[children]); return func(node) || (node[children] &amp;&amp; node[children].length); &#125;); &#125; return listFilter(tree);&#125;export const useAsyncRouteStore = defineStore(&#123; id: &#x27;app-async-route&#x27;, state: () =&gt; (&#123; menus: [], routers: constantRouter, addRouters: [], keepAliveComponents: [], // Whether the route has been dynamically added isDynamicAddedRoute: false, &#125;), getters: &#123; getMenus() &#123; return this.menus; &#125;, getIsDynamicAddedRoute() &#123; return this.isDynamicAddedRoute; &#125;, &#125;, actions: &#123; getRouters() &#123; return toRaw(this.addRouters); &#125;, setDynamicAddedRoute(added) &#123; this.isDynamicAddedRoute = added; &#125;, // 设置动态路由 setRouters(routers) &#123; this.addRouters = routers; this.routers = constantRouter.concat(routers); &#125;, setMenus(menus) &#123; // 设置动态路由 this.menus = menus; &#125;, setKeepAliveComponents(compNames) &#123; // 设置需要缓存的组件 this.keepAliveComponents = compNames; &#125;, generateRoutes(data) &#123; let accessedRouters; const permissionsList = data.permissions || []; const routeFilter = (route) =&gt; &#123; const &#123; meta &#125; = route; const &#123; permissions &#125; = meta || &#123;&#125;; if (!permissions) return true; return permissionsList.some((item) =&gt; permissions.includes(item.value)); &#125;; const &#123; getPermissionMode &#125; = useProjectSetting(); const permissionMode = unref(getPermissionMode); if (permissionMode === &#x27;BACK&#x27;) &#123; // 从后端获取数据，动态生成菜单 &#125; else &#123; try &#123; // 过滤账户是否拥有某一个权限，并将菜单从加载列表移除 accessedRouters = filter(asyncRoutes, routeFilter); &#125; catch (error) &#123; console.log(error); &#125; &#125; accessedRouters = accessedRouters.filter(routeFilter); this.setRouters(accessedRouters); this.setMenus(accessedRouters); return toRaw(accessedRouters); &#125;, &#125;,&#125;);// Need to be used outside the setupexport function useAsyncRouteStoreWidthOut() &#123; return useAsyncRouteStore(store);&#125; generateRoutes(data) ​\t该方法将在获取到用户信息后执行，用于动态生成路由和侧边栏菜单信息，在路由守卫中执行 路由守卫路由守卫负责拦截每次的路由跳转，我们可以在每次路由跳转前，判断Token是否过期、获取用户信息、动态添加路由等操作；在路由跳转之后，可以缓存组件等。 创建src/router/router-guards.js，内容如下： router/router-guards.jsimport &#123; PageEnum &#125; from &#x27;@/enums/pageEnum&#x27;;import &#123; useAsyncRouteStoreWidthOut &#125; from &#x27;@/store/modules/asyncRoute&#x27;;import &#123; useUserStoreWidthOut &#125; from &#x27;@/store/modules/user&#x27;;import &#123; ACCESS_TOKEN &#125; from &#x27;@/store/mutation-types&#x27;;import &#123; storage &#125; from &#x27;@/utils/Storage&#x27;;import &#123; isNavigationFailure &#125; from &#x27;vue-router&#x27;;import &#123; ErrorPageRoute &#125; from &#x27;./base&#x27;;const LOGIN_PATH = PageEnum.BASE_LOGIN;// 路由守卫白名单，即不进行重定向const whitePathList = [LOGIN_PATH];// 创建路由守卫export function createRouterGuards(router) &#123; const userStore = useUserStoreWidthOut(); const asyncRouteStore = useAsyncRouteStoreWidthOut(); router.beforeEach(async (to, from, next) =&gt; &#123; const Loading = window[&#x27;$loading&#x27;] || null; Loading &amp;&amp; Loading.start(); if (from.path === LOGIN_PATH &amp;&amp; to.name === &#x27;errorPage&#x27;) &#123; next(PageEnum.BASE_HOME); return; &#125; // 白名单直接进入 if (whitePathList.includes(to.path)) &#123; next(); return; &#125; // 获取登录的TOKEN const token = storage.get(ACCESS_TOKEN); if (!token) &#123; // You can access without permissions. You need to set the routing meta.ignoreAuth to true if (to.meta.ignoreAuth) &#123; next(); return; &#125; // 重定向到登录页，带跳转前的路径 const redirectData = &#123; path: LOGIN_PATH, replace: true, &#125;; if (to.path) &#123; redirectData.query = &#123; ...redirectData.query, redirect: to.path, &#125;; &#125; next(redirectData); return; &#125; // 动态路由添加完成后，由此放行 if (asyncRouteStore.getIsDynamicAddedRoute) &#123; next(); return; &#125; const userInfo = await userStore.GetInfo(); const routes = asyncRouteStore.generateRoutes(userInfo); // 动态添加可访问路由表, 将过滤之后的动态路由添加到路由表形成完整的路由 routes.forEach((item) =&gt; &#123; router.addRoute(item); &#125;); // 不需要动态添加404 const isErrorPage = router .getRoutes() .findIndex((item) =&gt; item.name === ErrorPageRoute.name); if (isErrorPage === -1) &#123; router.addRoute(ErrorPageRoute); &#125; const redirectPath = from.query.redirect || to.path; const redirect = decodeURIComponent(redirectPath); // 解决动态路由白屏问题，https://blog.csdn.net/qq_41912398/article/details/109231418 const nextData = to.path === redirect ? &#123; ...to, replace: true &#125; : &#123; path: redirect &#125;; // 动态路由添加完成，放行的出口 asyncRouteStore.setDynamicAddedRoute(true); next(nextData); Loading &amp;&amp; Loading.finish(); &#125;); router.afterEach((to, _, failure) =&gt; &#123; document.title = to?.meta?.title || document.title; if (isNavigationFailure(failure)) &#123; //console.log(&#x27;failed navigation&#x27;, failure) &#125; const asyncRouteStore = useAsyncRouteStoreWidthOut(); // 在这里设置需要缓存的组件名称 const keepAliveComponents = asyncRouteStore.keepAliveComponents; const currentComName = to.matched.find( (item) =&gt; item.name == to.name )?.name; if ( currentComName &amp;&amp; !keepAliveComponents.includes(currentComName) &amp;&amp; to.meta?.keepAlive ) &#123; // 需要缓存的组件 keepAliveComponents.push(currentComName); &#125; else if (!to.meta?.keepAlive || to.name == &#x27;Redirect&#x27;) &#123; // 不需要缓存的组件 const index = asyncRouteStore.keepAliveComponents.findIndex( (name) =&gt; name == currentComName ); if (index != -1) &#123; keepAliveComponents.splice(index, 1); &#125; &#125; asyncRouteStore.setKeepAliveComponents(keepAliveComponents); const Loading = window[&#x27;$loading&#x27;] || null; Loading &amp;&amp; Loading.finish(); &#125;); router.onError((error) =&gt; &#123; console.log(error, &#x27;路由错误&#x27;); &#125;);&#125; 在src/router/index.js，加载路由守卫： router/index.jsimport &#123; createRouterGuards &#125; from &#x27;./router-guards&#x27;;export function setupRouter(app) &#123; app.use(router); createRouterGuards(router);&#125;"},{"title":"项目布局","path":"/wiki/adminpro/03_advanced_operation/04_项目布局.html","content":"虽然写了很多，但是我们依然跑不起来项目，看不到页面。这部分将实现页面的整体布局，并通过跳过网络请求部分，查看项目。 后台管理的基本布局如下图： 侧边栏侧边栏的菜单是由路由动态动态生成的 generatorMenu修改src/utils/index.js，添加如下的方法： utils/index.js/** * 递归组装菜单格式 */export function generatorMenu(routerMap) &#123; return filterRouter(routerMap).map((item) =&gt; &#123; const isRoot = isRootRouter(item); const info = isRoot ? item.children[0] : item; const currentMenu = &#123; ...info, ...info.meta, label: info.meta?.title, key: info.name, icon: isRoot ? item.meta?.icon : info.meta?.icon, &#125;; // 是否有子菜单，并递归处理 if (info.children &amp;&amp; info.children.length &gt; 0) &#123; // 递归 currentMenu.children = generatorMenu(info.children); &#125; return currentMenu; &#125;);&#125;/** * 判断根路由 Router * */export function isRootRouter(item) &#123; return ( item.meta?.alwaysShow != true &amp;&amp; item?.children?.filter((item) =&gt; !item?.meta?.hidden)?.length === 1 );&#125;/** * 排除Router */export function filterRouter(routerMap) &#123; return routerMap.filter((item) =&gt; &#123; return ( (item.meta?.hidden || false) != true &amp;&amp; ![&#x27;/:path(.*)*&#x27;, &#x27;/&#x27;, PageEnum.REDIRECT, PageEnum.BASE_LOGIN].includes( item.path ) ); &#125;);&#125; index.js创建layout/components/Menu/index.js文件夹，写入以下内容： components/Menu/index.jsimport AsideMenu from &#x27;./index.vue&#x27;export &#123; AsideMenu &#125; index.vue创建layout/components/Menu/index.vue文件夹，写入以下内容： components/Menu/index.vue&lt;template&gt; &lt;NMenu :options=&quot;menus&quot; :inverted=&quot;inverted&quot; :mode=&quot;mode&quot; :collapsed=&quot;collapsed&quot; :collapsed-width=&quot;64&quot; :collapsed-icon-size=&quot;20&quot; :indent=&quot;24&quot; :expanded-keys=&quot;openKeys&quot; :value=&quot;getSelectedKeys&quot; @update:value=&quot;clickMenuItem&quot; @update:expanded-keys=&quot;menuExpanded&quot; /&gt;&lt;/template&gt;&lt;script&gt;import &#123; computed, defineComponent, onMounted, reactive, ref, toRefs, unref, watch,&#125; from &#x27;vue&#x27;;import &#123; useRoute, useRouter &#125; from &#x27;vue-router&#x27;;import &#123; useAsyncRouteStore &#125; from &#x27;@/store/modules/asyncRoute&#x27;;import &#123; generatorMenu &#125; from &#x27;@/utils&#x27;;import &#123; useProjectSettingStore &#125; from &#x27;@/store/modules/projectSetting&#x27;;export default defineComponent(&#123; props: &#123; mode: &#123; // 菜单模式 type: String, default: &#x27;vertical&#x27;, &#125;, collapsed: &#123; // 侧边栏菜单是否收起 type: Boolean, &#125;, //位置 location: &#123; type: String, default: &#x27;left&#x27;, &#125;, &#125;, emits: [&#x27;update:collapsed&#x27;, &#x27;clickMenuItem&#x27;], setup(props, &#123; emit &#125;) &#123; // 当前路由 const currentRoute = useRoute(); const router = useRouter(); const asyncRouteStore = useAsyncRouteStore(); const settingStore = useProjectSettingStore(); const menus = ref([]); const selectedKeys = ref(currentRoute.name); const headerMenuSelectKey = ref(&#x27;&#x27;); // 获取当前打开的子菜单 const matched = currentRoute.matched; const getOpenKeys = matched &amp;&amp; matched.length ? matched.map((item) =&gt; item.name) : []; const state = reactive(&#123; openKeys: getOpenKeys, &#125;); const inverted = computed(() =&gt; &#123; return [&#x27;dark&#x27;, &#x27;header-dark&#x27;].includes(settingStore.navTheme); &#125;); const getSelectedKeys = computed(() =&gt; &#123; let location = props.location; return location === &#x27;left&#x27; || (location === &#x27;header&#x27; &amp;&amp; settingStore.getNavMode === &#x27;horizontal&#x27;) ? unref(selectedKeys) : unref(headerMenuSelectKey); &#125;); // 监听分割菜单 watch( () =&gt; currentRoute.fullPath, () =&gt; &#123; updateMenu(); &#125; ); function updateSelectedKeys() &#123; const matched = currentRoute.matched; state.openKeys = matched.map((item) =&gt; item.name); const activeMenu = currentRoute.meta?.activeMenu || &#x27;&#x27;; selectedKeys.value = activeMenu ? activeMenu : currentRoute.name; &#125; function updateMenu() &#123; if (!settingStore.menuSetting.mixMenu) &#123; menus.value = generatorMenu(asyncRouteStore.getMenus); &#125; else &#123; // 混合菜单，不予实现 &#125; updateSelectedKeys(); &#125; // 点击菜单 function clickMenuItem(key) &#123; if (/http(s)?:/.test(key)) &#123; window.open(key); &#125; else &#123; router.push(&#123; name: key &#125;); &#125; emit(&#x27;clickMenuItem&#x27;, key); &#125; // 展开菜单 function menuExpanded(openKeys) &#123; if (!openKeys) return; const latestOpenKey = openKeys.find( (key) =&gt; state.openKeys.indexOf(key) === -1 ); const isExistChildren = findChildrenLen(latestOpenKey); state.openKeys = isExistChildren ? latestOpenKey ? [latestOpenKey] : [] : openKeys; &#125; //查找是否存在子路由 function findChildrenLen(key) &#123; if (!key) return false; const subRouteChildren = []; for (const &#123; children, key &#125; of unref(menus)) &#123; if (children &amp;&amp; children.length) &#123; subRouteChildren.push(key); &#125; &#125; return subRouteChildren.includes(key); &#125; onMounted(() =&gt; &#123; updateMenu(); &#125;); return &#123; ...toRefs(state), menus, inverted, clickMenuItem, menuExpanded, getSelectedKeys, headerMenuSelectKey, &#125;; &#125;,&#125;);&lt;/script&gt; LOGO为侧边栏上方的LOGO组件 index.js创建layout/components/Logo/index.js文件夹，写入以下内容： components/Logo/index.jsimport Logo from &#x27;./index.vue&#x27;;export &#123; Logo &#125;; index.vue创建layout/components/Logo/index.vue文件夹，写入以下内容： components/Logo/index.vue&lt;template&gt; &lt;div class=&quot;logo&quot;&gt; &lt;img :src=&quot;websiteConfig.logo&quot; alt=&quot;&quot; :class=&quot;&#123; &#x27;mr-2&#x27;: !collapsed &#125;&quot; /&gt; &lt;h2 v-show=&quot;!collapsed&quot; class=&quot;title&quot;&gt;&#123;&#123; websiteConfig.title &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;import &#123; websiteConfig &#125; from &#x27;@/config/website.config&#x27;;export default defineComponent(&#123; props: &#123; collapsed: &#123; type: Boolean, &#125;, &#125;, setup() &#123; return &#123; websiteConfig, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.logo &#123; display: flex; align-items: center; justify-content: center; height: 64px; line-height: 64px; overflow: hidden; white-space: nowrap; img &#123; width: auto; height: 32px; &#125; .title &#123; margin: 0; &#125;&#125;&lt;/style&gt; 头部份这部分是后台的上方头部份，这里也是有很多小的功能： 左侧菜单收起 面包屑 切换全屏 个人中心 项目配置 components.js导入需要用到的图标 创建src/layout/components/Header/components.js layout/components/Header/components.jsimport &#123; SettingOutlined, SearchOutlined, MenuFoldOutlined, MenuUnfoldOutlined, FullscreenOutlined, FullscreenExitOutlined, PoweroffOutlined, GithubOutlined, LockOutlined, ReloadOutlined, LogoutOutlined, UserOutlined, CheckOutlined,&#125; from &#x27;@vicons/antd&#x27;;export default &#123; SettingOutlined, LockOutlined, GithubOutlined, SearchOutlined, MenuFoldOutlined, MenuUnfoldOutlined, FullscreenOutlined, FullscreenExitOutlined, PoweroffOutlined, ReloadOutlined, LogoutOutlined, UserOutlined, CheckOutlined,&#125;; index.js创建layout/components/Header/index.js文件夹，写入以下内容： components/Header/index.jsimport PageHeader from &#x27;./index.vue&#x27;;export &#123; PageHeader &#125;; index.vue创建layout/components/Header/index.vue文件夹，写入以下内容： components/Header/index.vue&lt;template&gt; &lt;div class=&quot;layout-header&quot;&gt; &lt;!--顶部菜单--&gt; &lt;div class=&quot;layout-header-left&quot; v-if=&quot;navMode === &#x27;horizontal&#x27; || navMode === &#x27;horizontal-mix&#x27;&quot; &gt; &lt;div class=&quot;logo&quot; v-if=&quot;navMode === &#x27;horizontal&#x27;&quot;&gt; &lt;img :src=&quot;websiteConfig.logo&quot; alt=&quot;&quot; /&gt; &lt;h2 v-show=&quot;!collapsed&quot; class=&quot;title&quot;&gt;&#123;&#123; websiteConfig.title &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;AsideMenu v-model:collapsed=&quot;collapsed&quot; v-model:location=&quot;getMenuLocation&quot; :inverted=&quot;getInverted&quot; mode=&quot;horizontal&quot; /&gt; &lt;/div&gt; &lt;!--左侧菜单--&gt; &lt;div class=&quot;layout-header-left&quot; v-else&gt; &lt;!-- 菜单收起 --&gt; &lt;div class=&quot;ml-1 layout-header-trigger layout-header-trigger-min&quot; @click=&quot;() =&gt; $emit(&#x27;update:collapsed&#x27;, !collapsed)&quot; &gt; &lt;n-icon size=&quot;18&quot; v-if=&quot;collapsed&quot;&gt; &lt;MenuUnfoldOutlined /&gt; &lt;/n-icon&gt; &lt;n-icon size=&quot;18&quot; v-else&gt; &lt;MenuFoldOutlined /&gt; &lt;/n-icon&gt; &lt;/div&gt; &lt;!-- 刷新 --&gt; &lt;div class=&quot;mr-1 layout-header-trigger layout-header-trigger-min&quot; v-if=&quot;headerSetting.isReload&quot; @click=&quot;reloadPage&quot; &gt; &lt;n-icon size=&quot;18&quot;&gt; &lt;ReloadOutlined /&gt; &lt;/n-icon&gt; &lt;/div&gt; &lt;!-- 面包屑 --&gt; &lt;n-breadcrumb v-if=&quot;crumbsSetting.show&quot;&gt; &lt;template v-for=&quot;routeItem in breadcrumbList&quot; :key=&quot;routeItem.name&quot;&gt; &lt;n-breadcrumb-item v-if=&quot;routeItem.meta.title&quot;&gt; &lt;n-dropdown v-if=&quot;routeItem.children.length&quot; :options=&quot;routeItem.children&quot; @select=&quot;dropdownSelect&quot; &gt; &lt;span class=&quot;link-text&quot;&gt; &lt;component v-if=&quot;crumbsSetting.showIcon &amp;&amp; routeItem.meta.icon&quot; :is=&quot;routeItem.meta.icon&quot; /&gt; &#123;&#123; routeItem.meta.title &#125;&#125; &lt;/span&gt; &lt;/n-dropdown&gt; &lt;span class=&quot;link-text&quot; v-else&gt; &lt;component v-if=&quot;crumbsSetting.showIcon &amp;&amp; routeItem.meta.icon&quot; :is=&quot;routeItem.meta.icon&quot; /&gt; &#123;&#123; routeItem.meta.title &#125;&#125; &lt;/span&gt; &lt;/n-breadcrumb-item&gt; &lt;/template&gt; &lt;/n-breadcrumb&gt; &lt;/div&gt; &lt;div class=&quot;layout-header-right&quot;&gt; &lt;div class=&quot;layout-header-trigger layout-header-trigger-min&quot; v-for=&quot;item in iconList&quot; :key=&quot;item.icon.name&quot; &gt; &lt;n-tooltip placement=&quot;bottom&quot;&gt; &lt;template #trigger&gt; &lt;n-icon size=&quot;18&quot;&gt; &lt;component :is=&quot;item.icon&quot; v-on=&quot;item.eventObject || &#123;&#125;&quot; /&gt; &lt;/n-icon&gt; &lt;/template&gt; &lt;span&gt;&#123;&#123; item.tips &#125;&#125;&lt;/span&gt; &lt;/n-tooltip&gt; &lt;/div&gt; &lt;!--切换全屏--&gt; &lt;div class=&quot;layout-header-trigger layout-header-trigger-min&quot;&gt; &lt;n-tooltip placement=&quot;bottom&quot;&gt; &lt;template #trigger&gt; &lt;n-icon size=&quot;18&quot;&gt; &lt;component :is=&quot;fullscreenIcon&quot; @click=&quot;toggleFullScreen&quot; /&gt; &lt;/n-icon&gt; &lt;/template&gt; &lt;span&gt;全屏&lt;/span&gt; &lt;/n-tooltip&gt; &lt;/div&gt; &lt;!-- 个人中心 --&gt; &lt;div class=&quot;layout-header-trigger layout-header-trigger-min&quot;&gt; &lt;n-dropdown trigger=&quot;hover&quot; @select=&quot;avatarSelect&quot; :options=&quot;avatarOptions&quot; &gt; &lt;div class=&quot;avatar&quot;&gt; &lt;n-avatar round&gt; &#123;&#123; username &#125;&#125; &lt;template #icon&gt; &lt;UserOutlined /&gt; &lt;/template&gt; &lt;/n-avatar&gt; &lt;/div&gt; &lt;/n-dropdown&gt; &lt;/div&gt; &lt;!--设置--&gt; &lt;div class=&quot;layout-header-trigger layout-header-trigger-min&quot; @click=&quot;openSetting&quot; &gt; &lt;n-tooltip placement=&quot;bottom-end&quot;&gt; &lt;template #trigger&gt; &lt;n-icon size=&quot;18&quot; style=&quot;font-weight: bold&quot;&gt; &lt;SettingOutlined /&gt; &lt;/n-icon&gt; &lt;/template&gt; &lt;span&gt;项目配置&lt;/span&gt; &lt;/n-tooltip&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent, reactive, toRefs, computed, unref &#125; from &#x27;vue&#x27;;import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;;import components from &#x27;./components&#x27;;import &#123; NDialogProvider, useDialog, useMessage &#125; from &#x27;naive-ui&#x27;;import &#123; TABS_ROUTES &#125; from &#x27;@/store/mutation-types&#x27;;import &#123; useUserStore &#125; from &#x27;@/store/modules/user&#x27;;// import ProjectSetting from &#x27;./ProjectSetting.vue&#x27;; // 界面设置功能，暂时不予实现import &#123; AsideMenu &#125; from &#x27;@/layout/components/Menu&#x27;;import &#123; useProjectSetting &#125; from &#x27;@/hooks/setting/useProjectSetting&#x27;;import &#123; websiteConfig &#125; from &#x27;@/config/website.config&#x27;;export default defineComponent(&#123; name: &#x27;PageHeader&#x27;, components: &#123; ...components, NDialogProvider, AsideMenu &#125;, props: &#123; collapsed: &#123; type: Boolean, &#125;, inverted: &#123; type: Boolean, &#125;, &#125;, setup(props) &#123; const userStore = useUserStore(); const message = useMessage(); const dialog = useDialog(); const &#123; getNavMode, getNavTheme, getHeaderSetting, getMenuSetting, getCrumbsSetting, &#125; = useProjectSetting(); const &#123; username &#125; = userStore?.info || &#123;&#125;; const state = reactive(&#123; username: username || &#x27;&#x27;, fullscreenIcon: &#x27;FullscreenOutlined&#x27;, navMode: getNavMode, navTheme: getNavTheme, headerSetting: getHeaderSetting, crumbsSetting: getCrumbsSetting, &#125;); const getInverted = computed(() =&gt; &#123; const navTheme = unref(getNavTheme); return [&#x27;light&#x27;, &#x27;header-dark&#x27;].includes(navTheme) ? props.inverted : !props.inverted; &#125;); const getChangeStyle = computed(() =&gt; &#123; const &#123; collapsed &#125; = props; const &#123; minMenuWidth, menuWidth &#125; = unref(getMenuSetting); return &#123; left: collapsed ? `$&#123;minMenuWidth&#125;px` : `$&#123;menuWidth&#125;px`, width: `calc(100% - $&#123; collapsed ? `$&#123;minMenuWidth&#125;px` : `$&#123;menuWidth&#125;px` &#125;)`, &#125;; &#125;); const getMenuLocation = computed(() =&gt; &#123; return &#x27;header&#x27;; &#125;); const router = useRouter(); const route = useRoute(); const generator = (routerMap) =&gt; &#123; return routerMap.map((item) =&gt; &#123; const currentMenu = &#123; ...item, label: item.meta.title, key: item.name, disabled: item.path === &#x27;/&#x27;, &#125;; // 是否有子菜单，并递归处理 if (item.children &amp;&amp; item.children.length &gt; 0) &#123; // Recursion currentMenu.children = generator(item.children, currentMenu); &#125; return currentMenu; &#125;); &#125;; const breadcrumbList = computed(() =&gt; &#123; return generator(route.matched); &#125;); const dropdownSelect = (key) =&gt; &#123; router.push(&#123; name: key &#125;); &#125;; // 刷新页面 const reloadPage = () =&gt; &#123; router.push(&#123; path: &#x27;/redirect&#x27; + unref(route).fullPath, &#125;); &#125;; // 退出登录 const doLogout = () =&gt; &#123; dialog.info(&#123; title: &#x27;提示&#x27;, content: &#x27;您确定要退出登录吗&#x27;, positiveText: &#x27;确定&#x27;, negativeText: &#x27;取消&#x27;, onPositiveClick: () =&gt; &#123; userStore.logout().then(() =&gt; &#123; message.success(&#x27;成功退出登录&#x27;); // 移除标签页 localStorage.removeItem(TABS_ROUTES); router .replace(&#123; name: &#x27;Login&#x27;, query: &#123; redirect: route.fullPath, &#125;, &#125;) .finally(() =&gt; location.reload()); &#125;); &#125;, onNegativeClick: () =&gt; &#123;&#125;, &#125;); &#125;; // 切换全屏图标 const toggleFullscreenIcon = () =&gt; (state.fullscreenIcon = document.fullscreenElement !== null ? &#x27;FullscreenExitOutlined&#x27; : &#x27;FullscreenOutlined&#x27;); // 监听全屏切换事件 document.addEventListener(&#x27;fullscreenchange&#x27;, toggleFullscreenIcon); // 全屏切换 const toggleFullScreen = () =&gt; &#123; if (!document.fullscreenElement) &#123; document.documentElement.requestFullscreen(); &#125; else &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; &#125; &#125;; // 图标列表 const iconList = [ &#123; icon: &#x27;SearchOutlined&#x27;, tips: &#x27;搜索&#x27;, &#125;, &#123; icon: &#x27;GithubOutlined&#x27;, tips: &#x27;github&#x27;, eventObject: &#123; click: () =&gt; window.open(&#x27;https://github.com/jekip/naive-ui-admin&#x27;), &#125;, &#125;, ]; const avatarOptions = [ &#123; label: &#x27;个人设置&#x27;, key: 1, &#125;, &#123; label: &#x27;退出登录&#x27;, key: 2, &#125;, ]; //头像下拉菜单 const avatarSelect = (key) =&gt; &#123; switch (key) &#123; case 1: router.push(&#123; name: &#x27;Setting&#x27; &#125;); break; case 2: doLogout(); break; &#125; &#125;; return &#123; ...toRefs(state), iconList, toggleFullScreen, doLogout, route, dropdownSelect, avatarOptions, getChangeStyle, avatarSelect, breadcrumbList, reloadPage, getInverted, getMenuLocation, websiteConfig, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;@import &#x27;@/styles/var.less&#x27;;.layout-header &#123; display: flex; justify-content: space-between; align-items: center; padding: 0; height: @header-height; box-shadow: 0 1px 4px rgb(0 21 41 / 8%); transition: all 0.2s ease-in-out; width: 100%; z-index: 11; &amp;-left &#123; display: flex; align-items: center; .logo &#123; display: flex; align-items: center; justify-content: center; height: 64px; line-height: 64px; overflow: hidden; white-space: nowrap; padding-left: 10px; img &#123; width: auto; height: 32px; margin-right: 10px; &#125; .title &#123; margin-bottom: 0; &#125; &#125; ::v-deep(.ant-breadcrumb span:last-child .link-text) &#123; color: #515a6e; &#125; .n-breadcrumb &#123; display: inline-block; &#125; &amp;-menu &#123; color: var(--text-color); &#125; &#125; &amp;-right &#123; display: flex; align-items: center; margin-right: 20px; .avatar &#123; display: flex; align-items: center; height: 64px; &#125; &gt; * &#123; cursor: pointer; &#125; &#125; &amp;-trigger &#123; display: inline-block; width: 64px; height: 64px; text-align: center; cursor: pointer; transition: all 0.2s ease-in-out; .n-icon &#123; display: flex; align-items: center; height: 64px; line-height: 64px; &#125; &amp;:hover &#123; background: hsla(0, 0%, 100%, 0.08); &#125; .anticon &#123; font-size: 16px; color: #515a6e; &#125; &#125; &amp;-trigger-min &#123; width: auto; padding: 0 12px; &#125;&#125;.layout-header-light &#123; background: #fff; color: #515a6e; .n-icon &#123; color: #515a6e; &#125; .layout-header-left &#123; ::v-deep( .n-breadcrumb .n-breadcrumb-item:last-child .n-breadcrumb-item__link ) &#123; color: #515a6e; &#125; &#125; .layout-header-trigger &#123; &amp;:hover &#123; background: #f8f8f9; &#125; &#125;&#125;.layout-header-fix &#123; position: fixed; top: 0; right: 0; left: 200px; z-index: 11;&#125;&lt;/style&gt; 中间部分这部分是用来处理项目中变化部分的，即加载不同的路由组件渲染不同的子页面。 自定义了RouterView，方便路由渲染页面。 index.js创建layout/components/Main/index.js文件夹，写入以下内容： components/Main/index.jsimport MainView from &#x27;./index.vue&#x27;;export &#123; MainView &#125;; index.vue创建layout/components/Main/index.vue文件夹，写入以下内容： components/Main/index.vue&lt;template&gt; &lt;RouterView&gt; &lt;template #default=&quot;&#123; Component, route &#125;&quot;&gt; &lt;transition :name=&quot;getTransitionName&quot; mode=&quot;out-in&quot; appear&gt; &lt;keep-alive v-if=&quot;keepAliveComponents&quot; :include=&quot;keepAliveComponents&quot;&gt; &lt;component :is=&quot;Component&quot; :key=&quot;route.fullPath&quot; /&gt; &lt;/keep-alive&gt; &lt;component v-else :is=&quot;Component&quot; :key=&quot;route.fullPath&quot; /&gt; &lt;/transition&gt; &lt;/template&gt; &lt;/RouterView&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent, computed, unref &#125; from &#x27;vue&#x27;;import &#123; useAsyncRouteStore &#125; from &#x27;@/store/modules/asyncRoute&#x27;;import &#123; useProjectSetting &#125; from &#x27;@/hooks/setting/useProjectSetting&#x27;;export default defineComponent(&#123; name: &#x27;MainView&#x27;, components: &#123;&#125;, props: &#123; notNeedKey: &#123; type: Boolean, default: false, &#125;, animate: &#123; type: Boolean, default: true, &#125;, &#125;, setup() &#123; const &#123; getIsPageAnimate, getPageAnimateType &#125; = useProjectSetting(); const asyncRouteStore = useAsyncRouteStore(); // 需要缓存的路由组件 const keepAliveComponents = computed( () =&gt; asyncRouteStore.keepAliveComponents ); const getTransitionName = computed(() =&gt; &#123; return unref(getIsPageAnimate) ? unref(getPageAnimateType) : &#x27;&#x27;; &#125;); return &#123; keepAliveComponents, getTransitionName, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt; 标签页index.js创建layout/components/TabsView/index.js文件夹，写入以下内容： components/TabsView/index.jsimport TabsView from &#x27;./index.vue&#x27;;export &#123; TabsView &#125;; index.vue创建layout/components/TabsView/index.vue文件夹，写入以下内容： components/TabsView/index.vue&lt;template&gt; &lt;div class=&quot;tabs-view box-border&quot; :class=&quot;&#123; &#x27;tabs-view-fix&#x27;: multiTabsSetting.fixed, &#x27;tabs-view-fixed-header&#x27;: isMultiHeaderFixed, &#x27;tabs-view-default-background&#x27;: getDarkTheme === false, &#x27;tabs-view-dark-background&#x27;: getDarkTheme === true, &#125;&quot; :style=&quot;getChangeStyle&quot; &gt; &lt;div class=&quot;tabs-view-main&quot;&gt; &lt;div ref=&quot;navWrap&quot; class=&quot;tabs-card&quot; :class=&quot;&#123; &#x27;tabs-card-scrollable&#x27;: scrollable &#125;&quot; &gt; &lt;span class=&quot;tabs-card-prev&quot; :class=&quot;&#123; &#x27;tabs-card-prev-hide&#x27;: !scrollable &#125;&quot; @click=&quot;scrollPrev&quot; &gt; &lt;n-icon size=&quot;16&quot; color=&quot;#515a6e&quot;&gt; &lt;LeftOutlined /&gt; &lt;/n-icon&gt; &lt;/span&gt; &lt;span class=&quot;tabs-card-next&quot; :class=&quot;&#123; &#x27;tabs-card-next-hide&#x27;: !scrollable &#125;&quot; @click=&quot;scrollNext&quot; &gt; &lt;n-icon size=&quot;16&quot; color=&quot;#515a6e&quot;&gt; &lt;RightOutlined /&gt; &lt;/n-icon&gt; &lt;/span&gt; &lt;div ref=&quot;navScroll&quot; class=&quot;tabs-card-scroll&quot;&gt; &lt;Draggable :list=&quot;tabsList&quot; animation=&quot;300&quot; item-key=&quot;fullPath&quot; class=&quot;flex&quot; &gt; &lt;template #item=&quot;&#123; element &#125;&quot;&gt; &lt;div :id=&quot;`tag$&#123;element.fullPath.split(&#x27;/&#x27;).join(&#x27;\\/&#x27;)&#125;`&quot; class=&quot;tabs-card-scroll-item&quot; :class=&quot;&#123; &#x27;active-item&#x27;: activeKey === element.path &#125;&quot; @click.stop=&quot;goPage(element)&quot; @contextmenu=&quot;handleContextMenu($event, element)&quot; &gt; &lt;span&gt;&#123;&#123; element.meta.title &#125;&#125;&lt;/span&gt; &lt;n-icon size=&quot;14&quot; @click.stop=&quot;closeTabItem(element)&quot; v-if=&quot;!element.meta.affix&quot; &gt; &lt;CloseOutlined /&gt; &lt;/n-icon&gt; &lt;/div&gt; &lt;/template&gt; &lt;/Draggable&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tabs-close&quot;&gt; &lt;n-dropdown trigger=&quot;hover&quot; @select=&quot;closeHandleSelect&quot; placement=&quot;bottom-end&quot; :options=&quot;TabsMenuOptions&quot; &gt; &lt;div class=&quot;tabs-close-btn&quot;&gt; &lt;n-icon size=&quot;16&quot; color=&quot;#515a6e&quot;&gt; &lt;DownOutlined /&gt; &lt;/n-icon&gt; &lt;/div&gt; &lt;/n-dropdown&gt; &lt;/div&gt; &lt;n-dropdown :show=&quot;showDropdown&quot; :x=&quot;dropdownX&quot; :y=&quot;dropdownY&quot; @clickoutside=&quot;onClickOutside&quot; placement=&quot;bottom-start&quot; @select=&quot;closeHandleSelect&quot; :options=&quot;TabsMenuOptions&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent, reactive, computed, ref, toRefs, unref, provide, watch, onMounted, nextTick,&#125; from &#x27;vue&#x27;;import &#123; useRoute, useRouter &#125; from &#x27;vue-router&#x27;;import &#123; storage &#125; from &#x27;@/utils/Storage&#x27;;import &#123; TABS_ROUTES &#125; from &#x27;@/store/mutation-types&#x27;;import &#123; useTabsViewStore &#125; from &#x27;@/store/modules/tabsView&#x27;;import &#123; useAsyncRouteStore &#125; from &#x27;@/store/modules/asyncRoute&#x27;;import &#123; useProjectSetting &#125; from &#x27;@/hooks/setting/useProjectSetting&#x27;;import &#123; useMessage &#125; from &#x27;naive-ui&#x27;;import Draggable from &#x27;vuedraggable&#x27;;import &#123; PageEnum &#125; from &#x27;@/enums/pageEnum&#x27;;import &#123; DownOutlined, ReloadOutlined, CloseOutlined, ColumnWidthOutlined, MinusOutlined, LeftOutlined, RightOutlined,&#125; from &#x27;@vicons/antd&#x27;;import &#123; renderIcon &#125; from &#x27;@/utils&#x27;;import elementResizeDetectorMaker from &#x27;element-resize-detector&#x27;;import &#123; useDesignSetting &#125; from &#x27;@/hooks/setting/useDesignSetting&#x27;;import &#123; useProjectSettingStore &#125; from &#x27;@/store/modules/projectSetting&#x27;;import &#123; useThemeVars &#125; from &#x27;naive-ui&#x27;;import &#123; useGo &#125; from &#x27;@/hooks/web/usePage&#x27;;export default defineComponent(&#123; name: &#x27;TabsView&#x27;, components: &#123; DownOutlined, CloseOutlined, LeftOutlined, RightOutlined, Draggable, &#125;, props: &#123; collapsed: &#123; type: Boolean, &#125;, &#125;, setup(props) &#123; const &#123; getDarkTheme, getAppTheme &#125; = useDesignSetting(); const &#123; getNavMode, getHeaderSetting, getMenuSetting, getMultiTabsSetting, getIsMobile, &#125; = useProjectSetting(); const settingStore = useProjectSettingStore(); const message = useMessage(); const route = useRoute(); const router = useRouter(); const tabsViewStore = useTabsViewStore(); const asyncRouteStore = useAsyncRouteStore(); const navScroll = ref(null); const navWrap = ref(null); const isCurrent = ref(false); const go = useGo(); const themeVars = useThemeVars(); const getCardColor = computed(() =&gt; &#123; return themeVars.value.cardColor; &#125;); const getBaseColor = computed(() =&gt; &#123; return themeVars.value.textColor1; &#125;); const state = reactive(&#123; activeKey: route.fullPath, scrollable: false, dropdownX: 0, dropdownY: 0, showDropdown: false, isMultiHeaderFixed: false, multiTabsSetting: getMultiTabsSetting, &#125;); // 获取简易的路由对象 const getSimpleRoute = (route) =&gt; &#123; const &#123; fullPath, hash, meta, name, params, path, query &#125; = route; return &#123; fullPath, hash, meta, name, params, path, query &#125;; &#125;; const isMixMenuNoneSub = computed(() =&gt; &#123; const mixMenu = settingStore.menuSetting.mixMenu; const currentRoute = useRoute(); const navMode = unref(getNavMode); if (unref(navMode) != &#x27;horizontal-mix&#x27;) return true; return !( unref(navMode) === &#x27;horizontal-mix&#x27; &amp;&amp; mixMenu &amp;&amp; currentRoute.meta.isRoot ); &#125;); //动态组装样式 菜单缩进 const getChangeStyle = computed(() =&gt; &#123; const &#123; collapsed &#125; = props; const navMode = unref(getNavMode); const &#123; minMenuWidth, menuWidth &#125; = unref(getMenuSetting); const &#123; fixed &#125; = unref(getMultiTabsSetting); let lenNum = navMode === &#x27;horizontal&#x27; || !isMixMenuNoneSub.value ? &#x27;0px&#x27; : collapsed ? `$&#123;minMenuWidth&#125;px` : `$&#123;menuWidth&#125;px`; if (getIsMobile.value) &#123; return &#123; left: &#x27;0px&#x27;, width: &#x27;100%&#x27;, &#125;; &#125; return &#123; left: lenNum, width: `calc(100% - $&#123;!fixed ? &#x27;0px&#x27; : lenNum&#125;)`, &#125;; &#125;); //tags 右侧下拉菜单 const TabsMenuOptions = computed(() =&gt; &#123; const isDisabled = unref(tabsList).length &lt;= 1; return [ &#123; label: &#x27;刷新当前&#x27;, key: &#x27;1&#x27;, icon: renderIcon(ReloadOutlined), &#125;, &#123; label: `关闭当前`, key: &#x27;2&#x27;, disabled: unref(isCurrent) || isDisabled, icon: renderIcon(CloseOutlined), &#125;, &#123; label: &#x27;关闭其他&#x27;, key: &#x27;3&#x27;, disabled: isDisabled, icon: renderIcon(ColumnWidthOutlined), &#125;, &#123; label: &#x27;关闭全部&#x27;, key: &#x27;4&#x27;, disabled: isDisabled, icon: renderIcon(MinusOutlined), &#125;, ]; &#125;); let cacheRoutes = []; const simpleRoute = getSimpleRoute(route); try &#123; const routesStr = storage.get(TABS_ROUTES); cacheRoutes = routesStr ? JSON.parse(routesStr) : [simpleRoute]; &#125; catch (e) &#123; cacheRoutes = [simpleRoute]; &#125; // 将最新的路由信息同步到 localStorage 中 const routes = router.getRoutes(); cacheRoutes.forEach((cacheRoute) =&gt; &#123; const route = routes.find((route) =&gt; route.path === cacheRoute.path); if (route) &#123; cacheRoute.meta = route.meta || cacheRoute.meta; cacheRoute.name = route.name || cacheRoute.name; &#125; &#125;); // 初始化标签页 tabsViewStore.initTabs(cacheRoutes); //监听滚动条 function onScroll(e) &#123; let scrollTop = e.target.scrollTop || document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; // 滚动条偏移量 state.isMultiHeaderFixed = !!( !getHeaderSetting.value.fixed &amp;&amp; getMultiTabsSetting.value.fixed &amp;&amp; scrollTop &gt;= 64 ); &#125; window.addEventListener(&#x27;scroll&#x27;, onScroll, true); // 移除缓存组件名称 const delKeepAliveCompName = () =&gt; &#123; if (route.meta.keepAlive) &#123; const name = router.currentRoute.value.matched.find( (item) =&gt; item.name == route.name )?.components?.default.name; if (name) &#123; asyncRouteStore.keepAliveComponents = asyncRouteStore.keepAliveComponents.filter((item) =&gt; item != name); &#125; &#125; &#125;; // 标签页列表 const tabsList = computed(() =&gt; tabsViewStore.tabsList); const whiteList = [ PageEnum.BASE_LOGIN_NAME, PageEnum.REDIRECT_NAME, PageEnum.ERROR_PAGE_NAME, ]; watch( () =&gt; route.fullPath, (to) =&gt; &#123; if (whiteList.includes(route.name)) return; state.activeKey = to; tabsViewStore.addTabs(getSimpleRoute(route)); updateNavScroll(true); &#125;, &#123; immediate: true &#125; ); // 在页面关闭或刷新之前，保存数据 window.addEventListener(&#x27;beforeunload&#x27;, () =&gt; &#123; storage.set(TABS_ROUTES, JSON.stringify(tabsList.value)); &#125;); // 关闭当前页面 const removeTab = (route) =&gt; &#123; if (tabsList.value.length === 1) &#123; return message.warning(&#x27;这已经是最后一页，不能再关闭了！&#x27;); &#125; delKeepAliveCompName(); tabsViewStore.closeCurrentTab(route); // 如果关闭的是当前页 if (state.activeKey === route.fullPath) &#123; const currentRoute = tabsList.value[Math.max(0, tabsList.value.length - 1)]; state.activeKey = currentRoute.fullPath; router.push(currentRoute); &#125; updateNavScroll(); &#125;; // 刷新页面 const reloadPage = () =&gt; &#123; delKeepAliveCompName(); router.push(&#123; path: &#x27;/redirect&#x27; + unref(route).fullPath, &#125;); &#125;; // 注入刷新页面方法 provide(&#x27;reloadPage&#x27;, reloadPage); // 关闭左侧 const closeLeft = (route) =&gt; &#123; tabsViewStore.closeLeftTabs(route); state.activeKey = route.fullPath; router.replace(route.fullPath); updateNavScroll(); &#125;; // 关闭右侧 const closeRight = (route) =&gt; &#123; tabsViewStore.closeRightTabs(route); state.activeKey = route.fullPath; router.replace(route.fullPath); updateNavScroll(); &#125;; // 关闭其他 const closeOther = (route) =&gt; &#123; tabsViewStore.closeOtherTabs(route); state.activeKey = route.fullPath; router.replace(route.fullPath); updateNavScroll(); &#125;; // 关闭全部 const closeAll = () =&gt; &#123; tabsViewStore.closeAllTabs(); router.replace(PageEnum.BASE_HOME); updateNavScroll(); &#125;; //tab 操作 const closeHandleSelect = (key) =&gt; &#123; switch (key) &#123; //刷新 case &#x27;1&#x27;: reloadPage(); break; //关闭 case &#x27;2&#x27;: removeTab(route); break; //关闭其他 case &#x27;3&#x27;: closeOther(route); break; //关闭所有 case &#x27;4&#x27;: closeAll(); break; &#125; updateNavScroll(); state.showDropdown = false; &#125;; /** * @param value 要滚动到的位置 * @param amplitude 每次滚动的长度 */ function scrollTo(value, amplitude) &#123; const currentScroll = navScroll.value.scrollLeft; const scrollWidth = (amplitude &gt; 0 &amp;&amp; currentScroll + amplitude &gt;= value) || (amplitude &lt; 0 &amp;&amp; currentScroll + amplitude &lt;= value) ? value : currentScroll + amplitude; navScroll.value &amp;&amp; navScroll.value.scrollTo(scrollWidth, 0); if (scrollWidth === value) return; return window.requestAnimationFrame(() =&gt; scrollTo(value, amplitude)); &#125; function scrollPrev() &#123; const containerWidth = navScroll.value.offsetWidth; const currentScroll = navScroll.value.scrollLeft; if (!currentScroll) return; const scrollLeft = currentScroll &gt; containerWidth ? currentScroll - containerWidth : 0; scrollTo(scrollLeft, (scrollLeft - currentScroll) / 20); &#125; function scrollNext() &#123; const containerWidth = navScroll.value.offsetWidth; const navWidth = navScroll.value.scrollWidth; const currentScroll = navScroll.value.scrollLeft; if (navWidth - currentScroll &lt;= containerWidth) return; const scrollLeft = navWidth - currentScroll &gt; containerWidth * 2 ? currentScroll + containerWidth : navWidth - containerWidth; scrollTo(scrollLeft, (scrollLeft - currentScroll) / 20); &#125; /** * @param autoScroll 是否开启自动滚动功能 */ async function updateNavScroll(autoScroll) &#123; await nextTick(); if (!navScroll.value) return; const containerWidth = navScroll.value.offsetWidth; const navWidth = navScroll.value.scrollWidth; if (containerWidth &lt; navWidth) &#123; state.scrollable = true; if (autoScroll) &#123; let tagList = navScroll.value.querySelectorAll(&#x27;.tabs-card-scroll-item&#x27;) || []; [...tagList].forEach((tag) =&gt; &#123; // fix SyntaxError if (tag.id === `tag$&#123;state.activeKey.split(&#x27;/&#x27;).join(&#x27;/&#x27;)&#125;`) &#123; // eslint-disable-line tag.scrollIntoView &amp;&amp; tag.scrollIntoView(); &#125; &#125;); &#125; &#125; else &#123; state.scrollable = false; &#125; &#125; function handleResize() &#123; updateNavScroll(true); &#125; function handleContextMenu(e, item) &#123; e.preventDefault(); isCurrent.value = PageEnum.BASE_HOME_REDIRECT === item.path; state.showDropdown = false; nextTick().then(() =&gt; &#123; state.showDropdown = true; state.dropdownX = e.clientX; state.dropdownY = e.clientY; &#125;); &#125; function onClickOutside() &#123; state.showDropdown = false; &#125; //tags 跳转页面 function goPage(e) &#123; const &#123; fullPath &#125; = e; if (fullPath === route.fullPath) return; state.activeKey = fullPath; go(e, true); &#125; //删除tab function closeTabItem(e) &#123; const &#123; fullPath &#125; = e; const routeInfo = tabsList.value.find( (item) =&gt; item.fullPath == fullPath ); removeTab(routeInfo); &#125; onMounted(() =&gt; &#123; onElementResize(); &#125;); function onElementResize() &#123; let observer; observer = elementResizeDetectorMaker(); observer.listenTo(navWrap.value, handleResize); &#125; return &#123; ...toRefs(state), navWrap, navScroll, route, tabsList, goPage, closeTabItem, closeLeft, closeRight, closeOther, closeAll, reloadPage, getChangeStyle, TabsMenuOptions, closeHandleSelect, scrollNext, scrollPrev, handleContextMenu, onClickOutside, getDarkTheme, getAppTheme, getCardColor, getBaseColor, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.tabs-view &#123; width: 100%; padding: 6px 0; display: flex; transition: all 0.2s ease-in-out; &amp;-main &#123; height: 32px; display: flex; max-width: 100%; min-width: 100%; .tabs-card &#123; -webkit-box-flex: 1; flex-grow: 1; flex-shrink: 1; overflow: hidden; position: relative; .tabs-card-prev, .tabs-card-next &#123; width: 32px; text-align: center; position: absolute; line-height: 32px; cursor: pointer; .n-icon &#123; display: flex; align-items: center; justify-content: center; height: 32px; width: 32px; &#125; &#125; .tabs-card-prev &#123; left: 0; &#125; .tabs-card-next &#123; right: 0; &#125; .tabs-card-next-hide, .tabs-card-prev-hide &#123; display: none; &#125; &amp;-scroll &#123; white-space: nowrap; overflow: hidden; &amp;-item &#123; background: v-bind(getCardColor); color: v-bind(getBaseColor); height: 32px; padding: 6px 16px 4px; border-radius: 3px; margin-right: 6px; cursor: pointer; display: inline-block; position: relative; flex: 0 0 auto; span &#123; float: left; vertical-align: middle; &#125; &amp;:hover &#123; color: #515a6e; &#125; .n-icon &#123; height: 22px; width: 21px; margin-right: -6px; position: relative; vertical-align: middle; text-align: center; color: #808695; &amp;:hover &#123; color: #515a6e !important; &#125; svg &#123; height: 21px; display: inline-block; &#125; &#125; &#125; .active-item &#123; color: v-bind(getAppTheme); &#125; &#125; &#125; .tabs-card-scrollable &#123; padding: 0 32px; overflow: hidden; &#125; &#125; .tabs-close &#123; min-width: 32px; width: 32px; height: 32px; line-height: 32px; text-align: center; background: var(--color); border-radius: 2px; cursor: pointer; &amp;-btn &#123; color: var(--color); height: 100%; display: flex; align-items: center; justify-content: center; &#125; &#125;&#125;.tabs-view-default-background &#123; background: #f5f7f9;&#125;.tabs-view-dark-background &#123; background: #101014;&#125;.tabs-view-fix &#123; position: fixed; z-index: 5; padding: 6px 10px 6px 10px; left: 200px;&#125;.tabs-view-fixed-header &#123; top: 0;&#125;&lt;/style&gt; 组装组件创建src/layout/index.vue，写入以下内容： layout/index.vue&lt;template&gt; &lt;n-layout class=&quot;layout&quot; :position=&quot;fixedMenu&quot; has-sider&gt; &lt;n-layout-sider v-if=&quot;!isMobile &amp;&amp; navMode === &#x27;vertical&#x27;&quot; show-trigger=&quot;bar&quot; @collapse=&quot;collapsed = true&quot; :position=&quot;fixedMenu&quot; @expand=&quot;collapsed = false&quot; :collapsed=&quot;collapsed&quot; collapsed-mode=&quot;width&quot; :collapsed-width=&quot;64&quot; :width=&quot;leftMenuWidth&quot; :native-scrollbar=&quot;false&quot; :inverted=&quot;inverted&quot; class=&quot;layout-sider&quot; &gt; &lt;Logo :collapsed=&quot;collapsed&quot; /&gt; &lt;AsideMenu v-model:collapsed=&quot;collapsed&quot; v-model:location=&quot;getMenuLocation&quot; /&gt; &lt;/n-layout-sider&gt; &lt;!-- 移动端侧边栏 --&gt; &lt;n-drawer v-model:show=&quot;showSideDrawder&quot; :width=&quot;menuWidth&quot; :placement=&quot;&#x27;left&#x27;&quot; class=&quot;layout-side-drawer&quot; &gt; &lt;Logo :collapsed=&quot;collapsed&quot; /&gt; &lt;AsideMenu @clickMenuItem=&quot;collapsed = false&quot; /&gt; &lt;/n-drawer&gt; &lt;!-- 头部 --&gt; &lt;n-layout :inverted=&quot;inverted&quot;&gt; &lt;n-layout-header :inverted=&quot;getHeaderInverted&quot; :position=&quot;fixedHeader&quot;&gt; &lt;PageHeader v-model:collapsed=&quot;collapsed&quot; :inverted=&quot;inverted&quot; /&gt; &lt;/n-layout-header&gt; &lt;!-- 中间部分 --&gt; &lt;n-layout-content class=&quot;layout-content&quot; :class=&quot;&#123; &#x27;layout-default-background&#x27;: getDarkTheme === false &#125;&quot; &gt; &lt;div class=&quot;layout-content-main&quot; :class=&quot;&#123; &#x27;layout-content-main-fix&#x27;: fixedMulti, &#x27;fluid-header&#x27;: fixedHeader === &#x27;static&#x27;, &#125;&quot; &gt; &lt;TabsView v-if=&quot;isMultiTabs&quot; v-model:collapsed=&quot;collapsed&quot; /&gt; &lt;div class=&quot;main-view&quot; :class=&quot;&#123; &#x27;main-view-fix&#x27;: fixedMulti, noMultiTabs: !isMultiTabs, &#x27;mt-3&#x27;: !isMultiTabs, &#125;&quot; &gt; &lt;MainView /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/n-layout-content&gt; &lt;n-back-top :right=&quot;100&quot; /&gt; &lt;/n-layout&gt; &lt;/n-layout&gt;&lt;/template&gt;&lt;script&gt;import &#123; computed, defineComponent, onMounted, ref, unref &#125; from &#x27;vue&#x27;;import &#123; Logo &#125; from &#x27;./components/Logo&#x27;;import &#123; PageHeader &#125; from &#x27;./components/Header&#x27;;import &#123; MainView &#125; from &#x27;./components/Main&#x27;;import &#123; TabsView &#125; from &#x27;./components/TabsView&#x27;;import &#123; AsideMenu &#125; from &#x27;./components/Menu&#x27;;import &#123; useProjectSetting &#125; from &#x27;@/hooks/setting/useProjectSetting&#x27;;import &#123; useProjectSettingStore &#125; from &#x27;@/store/modules/projectSetting&#x27;;import &#123; useDesignSetting &#125; from &#x27;@/hooks/setting/useDesignSetting&#x27;;export default defineComponent(&#123; components: &#123; Logo, PageHeader, MainView, TabsView, AsideMenu &#125;, setup() &#123; const &#123; getNavMode, getNavTheme, getHeaderSetting, getMenuSetting, getMultiTabsSetting, &#125; = useProjectSetting(); const settingStore = useProjectSettingStore(); const &#123; getDarkTheme &#125; = useDesignSetting(); const navMode = getNavMode; const collapsed = ref(false); const &#123; mobileWidth, menuWidth &#125; = unref(getMenuSetting); const isMobile = computed(&#123; get: () =&gt; settingStore.getIsMobile, set: (val) =&gt; settingStore.setIsMobile(val), &#125;); // 固定头部 const fixedHeader = computed(() =&gt; &#123; const &#123; fixed &#125; = unref(getHeaderSetting); return fixed ? &#x27;absolute&#x27; : &#x27;static&#x27;; &#125;); // 固定菜单 const fixedMenu = computed(() =&gt; &#123; const &#123; fixed &#125; = unref(getHeaderSetting); return fixed ? &#x27;absolute&#x27; : &#x27;static&#x27;; &#125;); // 多标签页 const isMultiTabs = computed(() =&gt; &#123; return unref(getMultiTabsSetting).show; &#125;); const fixedMulti = computed(() =&gt; &#123; return unref(getMultiTabsSetting).fixed; &#125;); const leftMenuWidth = computed(() =&gt; &#123; const &#123; minMenuWidth, menuWidth &#125; = unref(getMenuSetting); return collapsed.value ? minMenuWidth : menuWidth; &#125;); const inverted = computed(() =&gt; &#123; return [&#x27;dark&#x27;, &#x27;header-dark&#x27;].includes(unref(getNavTheme)); &#125;); const getHeaderInverted = computed(() =&gt; &#123; const navTheme = unref(getNavTheme); return [&#x27;light&#x27;, &#x27;header-dark&#x27;].includes(navTheme) ? unref(inverted) : !unref(inverted); &#125;); const getMenuLocation = computed(() =&gt; &#123; return &#x27;left&#x27;; &#125;); // 控制显示或隐藏移动端侧边栏 const showSideDrawder = computed(&#123; get: () =&gt; isMobile.value &amp;&amp; collapsed.value, set: (val) =&gt; (collapsed.value = val), &#125;); //判断是否触发移动端模式 const checkMobileMode = () =&gt; &#123; if (document.body.clientWidth &lt;= mobileWidth) &#123; isMobile.value = true; &#125; else &#123; isMobile.value = false; &#125; collapsed.value = false; &#125;; // 监听宽度变化 const watchWidth = () =&gt; &#123; const Width = document.body.clientWidth; if (Width &lt;= 950) &#123; collapsed.value = true; &#125; else collapsed.value = false; checkMobileMode(); &#125;; onMounted(() =&gt; &#123; checkMobileMode(); window.addEventListener(&#x27;resize&#x27;, watchWidth); &#125;); return &#123; navMode, isMultiTabs, menuWidth, isMobile, fixedMulti, fixedMenu, fixedHeader, collapsed, inverted, checkMobileMode, getDarkTheme, getHeaderInverted, leftMenuWidth, getMenuLocation, showSideDrawder, &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.layout-side-drawer &#123; background-color: rgb(0, 20, 40); .layout-sider &#123; min-height: 100vh; box-shadow: 2px 0 8px 0 rgb(29 35 41 / 5%); position: relative; z-index: 13; transition: all 0.2s ease-in-out; &#125;&#125;&lt;/style&gt;&lt;style lang=&quot;less&quot; scoped&gt;.layout &#123; display: flex; flex-direction: row; flex: auto; &amp;-default-background &#123; background: #f5f7f9; &#125; .layout-sider &#123; min-height: 100vh; box-shadow: 2px 0 8px 0 rgb(29 35 41 / 5%); position: relative; z-index: 13; transition: all 0.2s ease-in-out; &#125; .layout-sider-fix &#123; position: fixed; top: 0; left: 0; &#125; .ant-layout &#123; overflow: hidden; &#125; .layout-right-fix &#123; overflow-x: hidden; padding-left: 200px; min-height: 100vh; transition: all 0.2s ease-in-out; &#125; .layout-content &#123; flex: auto; min-height: 100vh; &#125; .n-layout-header.n-layout-header--absolute-positioned &#123; z-index: 11; &#125; .n-layout-footer &#123; background: none; &#125;&#125;.layout-content-main &#123; margin: 0 10px 10px; position: relative; padding-top: 64px;&#125;.layout-content-main-fix &#123; padding-top: 64px;&#125;.fluid-header &#123; padding-top: 0;&#125;.main-view-fix &#123; padding-top: 44px;&#125;.noMultiTabs &#123; padding-top: 0;&#125;&lt;/style&gt; 至此，我们完成了Layout的编写，当页面需要被加载到中间部分时，只需要在定义其路由时指定 ​\tcomponent: Layout"},{"title":"启动项目","path":"/wiki/adminpro/03_advanced_operation/05_启动项目.html","content":"我们已将完成了骨架大部分功能的实现，现在只需要一点小操作就可以让项目跑起来。 首先在我们需要登陆获取Token， 在路由守卫中如果有Token就会去请求用户信息，获取该用户的权限列表， 然后和路由中配置的权限进行匹配，剔除该用户没有权限访问的路由， 之后动态添加过滤之后的路由到总的路由中，此时用户就能重定向到可以访问的路由。 进入系统前，回根据路由信息动态生成菜单 通过上面步骤我们可知，必须要有Token，需要有用户信息且包含权限列表。 更改代码使用token2绕过Token检查，注释掉获取用户信息步骤，自定义用户信息。 修改src/router/router-guards.js，内容如下： router/router-guards.jsimport &#123; PageEnum &#125; from &#x27;@/enums/pageEnum&#x27;;import &#123; useAsyncRouteStoreWidthOut &#125; from &#x27;@/store/modules/asyncRoute&#x27;;// import &#123; useUserStoreWidthOut &#125; from &#x27;@/store/modules/user&#x27;;import &#123; ACCESS_TOKEN &#125; from &#x27;@/store/mutation-types&#x27;;import &#123; storage &#125; from &#x27;@/utils/Storage&#x27;;import &#123; isNavigationFailure &#125; from &#x27;vue-router&#x27;;// import &#123; ErrorPageRoute &#125; from &#x27;./base&#x27;;const LOGIN_PATH = PageEnum.BASE_LOGIN;// 路由守卫白名单，即不进行重定向const whitePathList = [LOGIN_PATH];// 创建路由守卫export function createRouterGuards(router) &#123; // const userStore = useUserStoreWidthOut(); const asyncRouteStore = useAsyncRouteStoreWidthOut(); router.beforeEach(async (to, from, next) =&gt; &#123; const Loading = window[&#x27;$loading&#x27;] || null; Loading &amp;&amp; Loading.start(); if (from.path === LOGIN_PATH &amp;&amp; to.name === &#x27;errorPage&#x27;) &#123; next(PageEnum.BASE_HOME); return; &#125; // 白名单直接进入 if (whitePathList.includes(to.path)) &#123; next(); return; &#125; // 获取登录的TOKEN const token = storage.get(ACCESS_TOKEN); const token2 = &#x27;token&#x27; + token; if (!token2) &#123; // You can access without permissions. You need to set the routing meta.ignoreAuth to true if (to.meta.ignoreAuth) &#123; next(); return; &#125; // 重定向到登录页，带跳转前的路径 const redirectData = &#123; path: LOGIN_PATH, replace: true, &#125;; if (to.path) &#123; redirectData.query = &#123; ...redirectData.query, redirect: to.path, &#125;; &#125; next(redirectData); return; &#125; // 动态路由添加完成后，由此放行 if (asyncRouteStore.getIsDynamicAddedRoute) &#123; next(); return; &#125; const userInfo = &#123; userId: &#x27;1&#x27;, username: &#x27;admin&#x27;, realName: &#x27;Admin&#x27;, desc: &#x27;manager&#x27;, token, permissions: [ &#123; label: &#x27;主控台&#x27;, value: &#x27;dashboard_console&#x27;, &#125;, &#123; label: &#x27;工作台&#x27;, value: &#x27;dashboard_workplace&#x27;, &#125;, ], &#125;; // const userInfo = await userStore.GetInfo(); const routes = asyncRouteStore.generateRoutes(userInfo); // 动态添加可访问路由表, 将过滤之后的动态路由添加到路由表形成完整的路由 routes.forEach((item) =&gt; &#123; router.addRoute(item); &#125;); const redirectPath = from.query.redirect || to.path; const redirect = decodeURIComponent(redirectPath); // 解决动态路由白屏问题，https://blog.csdn.net/qq_41912398/article/details/109231418 const nextData = to.path === redirect ? &#123; ...to, replace: true &#125; : &#123; path: redirect &#125;; // 动态路由添加完成，放行的出口 asyncRouteStore.setDynamicAddedRoute(true); next(nextData); Loading &amp;&amp; Loading.finish(); &#125;); router.afterEach((to, _, failure) =&gt; &#123; document.title = to?.meta?.title || document.title; if (isNavigationFailure(failure)) &#123; //console.log(&#x27;failed navigation&#x27;, failure) &#125; const asyncRouteStore = useAsyncRouteStoreWidthOut(); // 在这里设置需要缓存的组件名称 const keepAliveComponents = asyncRouteStore.keepAliveComponents; const currentComName = to.matched.find( (item) =&gt; item.name == to.name )?.name; if ( currentComName &amp;&amp; !keepAliveComponents.includes(currentComName) &amp;&amp; to.meta?.keepAlive ) &#123; // 需要缓存的组件 keepAliveComponents.push(currentComName); &#125; else if (!to.meta?.keepAlive || to.name == &#x27;Redirect&#x27;) &#123; // 不需要缓存的组件 const index = asyncRouteStore.keepAliveComponents.findIndex( (name) =&gt; name == currentComName ); if (index != -1) &#123; keepAliveComponents.splice(index, 1); &#125; &#125; asyncRouteStore.setKeepAliveComponents(keepAliveComponents); const Loading = window[&#x27;$loading&#x27;] || null; Loading &amp;&amp; Loading.finish(); &#125;); router.onError((error) =&gt; &#123; console.log(error, &#x27;路由错误&#x27;); &#125;);&#125; 格式问题修改.eslintrc.js，代码检查工具eslint的配置信息， .eslintrc.jsmodule.exports = &#123; root: true, env: &#123; node: true, &#125;, extends: [ &quot;plugin:vue/vue3-essential&quot;, &quot;eslint:recommended&quot;, &quot;plugin:prettier/recommended&quot;, ], parserOptions: &#123; parser: &quot;@babel/eslint-parser&quot;, &#125;, rules: &#123; &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;, &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;, // 关闭名称校验 &quot;vue/multi-word-component-names&quot;: &quot;off&quot;, &#x27;vue/no-mutating-props&#x27;: 0, &#x27;linebreak-style&#x27;: [ 0,&#x27;error&#x27;,&#x27;windows&#x27;,], &#x27;quotes&#x27;: [0, &quot;single&quot;], &#x27;prettier/prettier&#x27;: [ &#x27;warn&#x27;,&#123; singleQuote: true &#125; ] &#125;,&#125;; 添加修复命令 修改package.json文件，添加lint-fix，如下： &#123; &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;lint-fix&quot;: &quot;eslint --fix --ext .js --ext .jsx --ext .vue src/&quot; &#125;,&#125; 在终端使用下面命令修复代码报错 npm run lint-fix 启动项目终端运行下面命令启动 npm run serve"},{"title":"网络配置","path":"/wiki/adminpro/03_advanced_operation/06_网络配置.html","content":"这部分是项目中重要的部分，主要负责网络请求事务。通过封装Axios提供更加灵活便利的http请求方法。 目录结构 utils http axios Axios.js axiosCancel.js checkStatus.js helper.js index.jsapi system user.js 环境信息Webpack查看根目录下.env.development文件，重要内容如下： .env.developmentNODE_ENV = &#x27;develpoment&#x27;# 接口前缀VUE_APP_API_URL_PREFIX = /dev-api 修改vue.config.js文件，内容如下： 使用代理可解决跨域问题 vue.config.jsconst &#123; defineConfig &#125; = require(&quot;@vue/cli-service&quot;);module.exports = defineConfig(&#123; transpileDependencies: true, // 基本路径 publicPath: &#x27;/&#x27;, outputDir: &#x27;dist&#x27;, // 开发环境配置 devServer: &#123; proxy: &#123; [process.env.VUE_APP_API_URL_PREFIX]: &#123; target: &#x27;http://localhost:8800/&#x27;, changeOrigin: true, pathRewrite: &#123; [&#x27;^&#x27; + process.env.VUE_APP_API_URL_PREFIX]: &#x27;&#x27; &#125; &#125; &#125; &#125;&#125;); 说明 使用路径重写之后，原本http://localhost:8800/dev-api/xxx中的/dev-api会被替换成&#39;&#39;，从而变成真正的后端地址：http://localhost:8800/xxx Vite查看根目录下.env.development文件，重要内容如下： .env.developmentVITE_PROXY=[[&quot;/api&quot;,&quot;http://localhost:9000&quot;]] 定义解析方法，创建代理对象 根目录创建build/vite/proxy.js文件，内容如下： proxy.js/** * Used to parse the .env.development proxy configuration */const httpsRE = /^https:\\/\\//;/** * Generate proxy * @param list */export function createProxy(list = []) &#123; const ret = &#123;&#125;; for (const [prefix, target] of list) &#123; const isHttps = httpsRE.test(target); // https://github.com/http-party/node-http-proxy#options ret[prefix] = &#123; target: target, changeOrigin: true, ws: true, rewrite: (path) =&gt; path.replace(new RegExp(`^$&#123;prefix&#125;`), &#x27;&#x27;), // https is require secure=false ...(isHttps ? &#123; secure: false &#125; : &#123;&#125;), &#125;; &#125; return ret;&#125; 修改vite.config.js文件，内容如下： vite.config.jsimport &#123; loadEnv &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import &#123; resolve &#125; from &#x27;path&#x27;import &#123; wrapperEnv &#125; from &#x27;./build/utils&#x27;;import &#123; createProxy &#125; from &#x27;./build/vite/proxy&#x27;;function pathResolve(dir) &#123; return resolve(process.cwd(), &#x27;.&#x27;, dir)&#125;export default (&#123; command, mode &#125;) =&gt; &#123; const root = process.cwd(); const env = loadEnv(mode, root); const viteEnv = wrapperEnv(env); const &#123; VITE_PUBLIC_PATH, VITE_PORT, VITE_PROXY &#125; = viteEnv; return &#123; base: VITE_PUBLIC_PATH, resolve: &#123; alias: [ &#123; find: /\\/#\\//, replacement: pathResolve(&#x27;types&#x27;) + &#x27;/&#x27;, &#125;, &#123; find: &#x27;@&#x27;, replacement: pathResolve(&#x27;src&#x27;) + &#x27;/&#x27;, &#125;, ], dedupe: [&#x27;vue&#x27;], &#125;, plugins: [vue()], server: &#123; host: true, port: VITE_PORT, proxy: createProxy(VITE_PROXY) &#125; &#125;&#125; 工具方法创建src/utils/http/axios/helper.js，内容如下： utils/http/axios/helper.jsimport &#123; isObject, isString &#125; from &#x27;@/utils/is&#x27;;const DATE_TIME_FORMAT = &#x27;YYYY-MM-DD HH:mm&#x27;;export function joinTimestamp(join, restful = false) &#123; if (!join) &#123; return restful ? &#x27;&#x27; : &#123;&#125;; &#125; const now = new Date().getTime(); if (restful) &#123; return `?_t=$&#123;now&#125;`; &#125; return &#123; _t: now &#125;;&#125;/** * @description: Format request parameter time */export function formatRequestDate(params) &#123; if (Object.prototype.toString.call(params) !== &#x27;[object Object]&#x27;) &#123; return; &#125; for (const key in params) &#123; if (params[key] &amp;&amp; params[key]._isAMomentObject) &#123; params[key] = params[key].format(DATE_TIME_FORMAT); &#125; if (isString(key)) &#123; const value = params[key]; if (value) &#123; try &#123; params[key] = isString(value) ? value.trim() : value; &#125; catch (error) &#123; throw new Error(error); &#125; &#125; &#125; if (isObject(params[key])) &#123; formatRequestDate(params[key]); &#125; &#125;&#125; 创建src/utils/http/axios/checkStatus.js，内容如下： utils/http/axios/checkStatus.jsexport function checkStatus(status, msg) &#123; const $message = window[&#x27;$message&#x27;]; switch (status) &#123; case 400: $message.error(msg); break; // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: $message.error(&#x27;用户没有权限（令牌、用户名、密码错误）!&#x27;); break; case 403: $message.error(&#x27;用户得到授权，但是访问是被禁止的。!&#x27;); break; // 404请求不存在 case 404: $message.error(&#x27;网络请求错误，未找到该资源!&#x27;); break; case 405: $message.error(&#x27;网络请求错误，请求方法未允许!&#x27;); break; case 408: $message.error(&#x27;网络请求超时&#x27;); break; case 500: $message.error(&#x27;服务器错误,请联系管理员!&#x27;); break; case 501: $message.error(&#x27;网络未实现&#x27;); break; case 502: $message.error(&#x27;网络错误&#x27;); break; case 503: $message.error(&#x27;服务不可用，服务器暂时过载或维护!&#x27;); break; case 504: $message.error(&#x27;网络超时&#x27;); break; case 505: $message.error(&#x27;http版本不支持该请求!&#x27;); break; default: $message.error(msg); &#125;&#125; 封装请求使用axios做网络请求。在使用之前，需要对axios做进一步的封装，方便请求数据。 安装axios，以安装请忽略 npm install axios 重复请求对于重复的 get 请求，会导致页面更新多次，发生页面抖动的现象，影响用户体验；对于重复的 post 请求，会导致在服务端生成两次记录。 一般的处理方法是在用户即将发送请求，但还未发送请求时给页面添加一个 loading 效果，提示数据正在加载，loading 会阻止用户继续操作。如果在 loading 显示之前，用户就已经触发了两次请求的情况，则失效。 保险起见，我们使用Axios提供的取消请求的方式。 详细讲解见： Axios如何取消重复请求——掘金https://juejin.cn/post/6981821001688416293 工具qs安装，如果安装了请忽略 npm install qs 创建src/utils/http/axios/axiosCancel.js，内容如下： axios/axiosCancel.jsimport &#123; isFunction &#125; from &quot;@/utils/is&quot;;import axios from &quot;axios&quot;;import qs from &quot;qs&quot;;// 声明一个 Map 用于存储每个请求的标识 和 取消函数let pendingMap = new Map();export const getPendingUrl = (config) =&gt; [ config.method, config.url, qs.stringify(config.data), qs.stringify(config.params), ].join(&quot;&amp;&quot;);export class AxiosCanceler &#123; /** * 添加请求 * @param &#123;Object&#125; config */ addPending(config) &#123; // 检查是否存在重复请求，若存在则取消已发的请求 this.removePending(config); const url = getPendingUrl(config); config.cancelToken = config.cancelToken || new axios.CancelToken((cancel) =&gt; &#123; // 通过构造生成取消函数 if (!pendingMap.has(url)) &#123; // 如果 pending 中不存在当前请求，则添加进去 pendingMap.set(url, cancel); &#125; &#125;); &#125; /** * @description: 清空所有pending */ removeAllPending() &#123; pendingMap.forEach((cancel) =&gt; &#123; cancel &amp;&amp; isFunction(cancel) &amp;&amp; cancel(); &#125;); pendingMap.clear(); &#125; /** * 移除请求 * @param &#123;Object&#125; config */ removePending(config) &#123; const url = getPendingUrl(config); if (pendingMap.has(url)) &#123; // 如果在 pending 中存在当前请求标识，需要取消当前请求，并且移除 const cancel = pendingMap.get(url); cancel &amp;&amp; cancel(url); pendingMap.delete(url); &#125; &#125; /** * @description: 重置 */ reset() &#123; pendingMap = new Map(); &#125;&#125; isFunction是工具文件中提供的方法，详见工具方法篇。 配置Axios安装lodash-es工具，以安装请忽略 npm install lodash-es 新建src/utils/http/axios/Axios.js，写入以下内容： axios/Axios.jsimport axios from &#x27;axios&#x27;;import &#123; cloneDeep &#125; from &#x27;lodash-es&#x27;;import &#123; isFunction &#125; from &#x27;@/utils/is&#x27;;import &#123; ContentTypeEnum &#125; from &#x27;@/enums/httpEnum&#x27;;import &#123; AxiosCanceler &#125; from &#x27;./axiosCancel&#x27;;/** * @description: axios模块 */export class VAxios &#123; #axiosInstance; #options; constructor(options) &#123; this.#axiosInstance = axios.create(options); this.#options = options; this.#setupInterceptors(); &#125; getAxios() &#123; return this.#axiosInstance; &#125; /** * @description: 重新配置axios */ configAxios(config) &#123; if (!this.#axiosInstance) &#123; return; &#125; this.#createAxios(config); &#125; /** * @description: 设置通用header */ setHeader(headers) &#123; if (!this.#axiosInstance) &#123; return; &#125; Object.assign(this.#axiosInstance.defaults.headers, headers); &#125; /** * @description: 创建axios实例 */ #createAxios(config) &#123; this.#axiosInstance = axios.create(config); &#125; #getTransform() &#123; const &#123; transform &#125; = this.#options; return transform; &#125; /** * @description: 请求方法 */ request(config, options) &#123; let conf = cloneDeep(config); const transform = this.#getTransform(); const &#123; requestOptions &#125; = this.#options; // 合并请求配置项 const opt = Object.assign(&#123;&#125;, requestOptions, options); const &#123; beforeRequestHook, requestCatch, transformRequestData &#125; = transform || &#123;&#125;; if (beforeRequestHook &amp;&amp; isFunction(beforeRequestHook)) &#123; // 请求之前处理config conf = beforeRequestHook(conf, opt); &#125; // 重新赋值 赋值成最新的配置 conf.requestOptions = opt; return new Promise((resolve, reject) =&gt; &#123; this.#axiosInstance .request(conf) .then((res) =&gt; &#123; // 请求是否被取消 const isCancel = axios.isCancel(res); if ( transformRequestData &amp;&amp; isFunction(transformRequestData) &amp;&amp; !isCancel ) &#123; try &#123; const ret = transformRequestData(res, opt); resolve(ret); &#125; catch (err) &#123; reject(err || new Error(&#x27;request error!&#x27;)); &#125; return; &#125; resolve(res); &#125;) .catch((e) =&gt; &#123; if (requestCatch &amp;&amp; isFunction(requestCatch)) &#123; reject(requestCatch(e)); return; &#125; reject(e); &#125;); &#125;); &#125; /** * @description: 文件上传 */ uploadFile(config, params) &#123; const formData = new window.FormData(); const customFilename = params.name || &#x27;file&#x27;; if (params.filename) &#123; formData.append(customFilename, params.file, params.filename); &#125; else &#123; formData.append(customFilename, params.file); &#125; if (params.data) &#123; Object.keys(params.data).forEach((key) =&gt; &#123; const value = params.data[key]; if (Array.isArray(value)) &#123; value.forEach((item) =&gt; &#123; formData.append(`$&#123;key&#125;[]`, item); &#125;); return; &#125; formData.append(key, params.data[key]); &#125;); &#125; return this.#axiosInstance.request(&#123; method: &#x27;POST&#x27;, data: formData, headers: &#123; &#x27;Content-Type&#x27;: ContentTypeEnum.FORM_DATA, ignoreCancelToken: true, &#125;, ...config, &#125;); &#125; /** * @description: 拦截器配置 */ #setupInterceptors() &#123; // transform会在创建Axios时，被封装进options被传进来 const transform = this.#getTransform(); if (!transform) &#123; return; &#125; const &#123; requestInterceptors, requestInterceptorsCatch, responseInterceptors, responseInterceptorsCatch, &#125; = transform; const axiosCanceler = new AxiosCanceler(); // 请求拦截器配置处理 this.#axiosInstance.interceptors.request.use((config) =&gt; &#123; const &#123; headers: &#123; ignoreCancelToken &#125;, &#125; = config; const ignoreCancel = ignoreCancelToken !== undefined ? ignoreCancelToken : this.#options.requestOptions?.ignoreCancelToken; // 仅当配置中ignoreCancelToken为false时执行，即不忽略重复请求 !ignoreCancel &amp;&amp; axiosCanceler.addPending(config); if (requestInterceptors &amp;&amp; isFunction(requestInterceptors)) &#123; config = requestInterceptors(config, this.#options); &#125; return config; &#125;, undefined); // 请求拦截器错误捕获 requestInterceptorsCatch &amp;&amp; isFunction(requestInterceptorsCatch) &amp;&amp; this.#axiosInstance.interceptors.request.use( undefined, requestInterceptorsCatch ); // 相应结果拦截处理 this.#axiosInstance.interceptors.response.use((res) =&gt; &#123; res &amp;&amp; axiosCanceler.removePending(res.config); if (responseInterceptors &amp;&amp; isFunction(responseInterceptors)) &#123; res = responseInterceptors(res); &#125; return res; &#125;, undefined); // 相应结果拦截器错误捕获 responseInterceptorsCatch &amp;&amp; isFunction(responseInterceptorsCatch) &amp;&amp; this.#axiosInstance.interceptors.response.use( undefined, responseInterceptorsCatch ); &#125;&#125; 说明，以下这些数据处理方法将在创建Axios时创建，并以参数形式封装到options中。 beforeRequestHook：请求之前处理config transformRequestData：处理请求数据 requestCatch：请求失败处理 requestInterceptors：请求之前的拦截器 responseInterceptors：请求之后的拦截器 requestInterceptorsCatch：请求之前的拦截器错误处理 responseInterceptorsCatch：请求之后的拦截器错误处理 ContentTypeEnum是一些字符常量，见常量篇。isFunction是工具提供的方法，见工具篇。 类私成员的写法需要有工具支持，使用命令安装： npm install --save-dev @babel/plugin-proposal-class-properties 根目录修改配置文件babel.config.js babel.config.jsmodule.exports = &#123; presets: [&quot;@vue/cli-plugin-babel/preset&quot;], plugins: [ &quot;@babel/plugin-proposal-class-properties&quot;, &quot;@babel/plugin-proposal-private-methods&quot; ]&#125;; 创建Axios配置完成Axios之后，我们要将Axios创建出来，并传入一些参数配置信息。 创建src/utils/http/axios/index.js，内容如下： axios/index.js// axios配置 可自行根据项目进行更改，只需更改该文件即可，其他文件可以不动import &#123; ContentTypeEnum, RequestEnum, ResultEnum &#125; from &#x27;@/enums/httpEnum&#x27;;import &#123; PageEnum &#125; from &#x27;@/enums/pageEnum&#x27;;import router from &#x27;@/router&#x27;;import &#123; storage &#125; from &#x27;@/utils/Storage&#x27;;import &#123; isString, isUrl &#125; from &#x27;@/utils/is&#x27;;import &#123; formatRequestDate, joinTimestamp &#125; from &#x27;./helper&#x27;;import &#123; setObjToUrlParams &#125; from &#x27;@/utils/urlUtils&#x27;;import &#123; useUserStoreWidthOut &#125; from &#x27;@/store/modules/user&#x27;;import axios from &#x27;axios&#x27;;import &#123; VAxios &#125; from &#x27;./Axios&#x27;;import &#123; deepMerge &#125; from &#x27;@/utils&#x27;;import &#123; useGlobSetting &#125; from &#x27;@/hooks/setting&#x27;;import &#123; checkStatus &#125; from &#x27;./checkStatus&#x27;;const globSetting = useGlobSetting();const urlPrefix = globSetting.urlPrefix || &#x27;&#x27;;/** * @description: 数据处理，方便区分多种处理方式 */const transform = &#123; /** * @description: 处理请求数据 */ transformRequestData: (res, options) =&gt; &#123; const &#123; isShowMessage = true, isShowErrorMessage, isShowSuccessMessage, successMessageText, errorMessageText, isTransformResponse, isReturnNativeResponse, &#125; = options; // 是否返回原生响应头 比如：需要获取响应头时使用该属性 if (isReturnNativeResponse) &#123; return res; &#125; // 不进行任何处理，直接返回 // 用于页面代码可能需要直接获取code，data，message这些信息时开启 if (!isTransformResponse) &#123; return res.data; &#125; const &#123; data &#125; = res; const $dialog = window[&#x27;$dialog&#x27;]; const $message = window[&#x27;$message&#x27;]; if (!data) &#123; // return &#x27;[HTTP] Request has no return value&#x27;; throw new Error(&#x27;请求出错，请稍候重试&#x27;); &#125; // 这里 code，data，message为 后台统一的字段，需要修改为项目自己的接口返回格式 const &#123; code, data: result, message &#125; = data; // 请求成功 const hasSuccess = data &amp;&amp; Reflect.has(data, &#x27;code&#x27;) &amp;&amp; code === ResultEnum.SUCCESS; // 是否显示提示信息 if (isShowMessage) &#123; if (hasSuccess &amp;&amp; (successMessageText || isShowSuccessMessage)) &#123; // 是否显示自定义信息提示 $dialog.success(&#123; type: &#x27;success&#x27;, content: successMessageText || message || &#x27;操作成功！&#x27;, &#125;); &#125; else if (!hasSuccess &amp;&amp; (errorMessageText || isShowErrorMessage)) &#123; // 是否显示自定义信息提示 $message.error(message || errorMessageText || &#x27;操作失败！&#x27;); &#125; else if (!hasSuccess &amp;&amp; options.errorMessageMode === &#x27;modal&#x27;) &#123; // errorMessageMode=‘custom-modal’的时候会显示modal错误弹窗，而不是消息提示，用于一些比较重要的错误 $dialog.info(&#123; title: &#x27;提示&#x27;, content: &#x27;message&#x27;, positiveText: &#x27;确定&#x27;, onPositiveClick: () =&gt; &#123;&#125;, &#125;); &#125; &#125; // 接口请求成功，直接返回结果 if (code === ResultEnum.SUCCESS) &#123; return result; &#125; // 接口请求错误，统一提示错误信息 这里逻辑可以根据项目进行修改 let errMsg = message; switch (code) &#123; // 请求失败 case ResultEnum.ERROR: $message.error(errMsg); break; case ResultEnum.TOKEN_TIMEOUT: &#123; const LoginName = PageEnum.BASE_LOGIN_NAME; const LoginPath = PageEnum.BASE_LOGIN; if (router.currentRoute.value?.name === LoginName) return; // 到登陆页 errMsg = &#x27;登录超时，请重新登录!&#x27;; $dialog.warning(&#123; title: &#x27;提示&#x27;, content: &#x27;登录身份已失效，请重新登录!&#x27;, positiveText: &#x27;确定&#x27;, closeable: false, onPositiveClick: () =&gt; &#123; storage.clear(); window.location.href = LoginPath; &#125;, onNegativeClick: () =&gt; &#123;&#125;, &#125;); break; &#125; &#125; throw new Error(errMsg); &#125;, // 请求之前处理config beforeRequestHook: (config, options) =&gt; &#123; const &#123; apiUrl, joinPrefix, joinParamsToUrl, formatDate, joinTime = true, urlPrefix, &#125; = options; const isUrlStr = isUrl(config.url); if (!isUrlStr &amp;&amp; joinPrefix) &#123; config.url = `$&#123;urlPrefix&#125;$&#123;config.url&#125;`; &#125; if (!isUrlStr &amp;&amp; apiUrl &amp;&amp; isString(apiUrl)) &#123; config.url = `$&#123;apiUrl&#125;$&#123;config.url&#125;`; &#125; const params = config.params || &#123;&#125;; const data = config.data || false; if (config.method?.toUpperCase() === RequestEnum.GET) &#123; if (!isString(params)) &#123; // 给 get 请求加上时间戳参数，避免从缓存中拿数据。 config.params = Object.assign( params || &#123;&#125;, joinTimestamp(joinTime, false) ); &#125; else &#123; // 兼容restful风格 config.url = config.url + params + `$&#123;joinTimestamp(joinTime, true)&#125;`; config.params = undefined; &#125; &#125; else &#123; if (!isString(params)) &#123; formatDate &amp;&amp; formatRequestDate(params); if ( Reflect.has(config, &#x27;data&#x27;) &amp;&amp; config.data &amp;&amp; Object.keys(config.data).length &gt; 0 ) &#123; config.data = data; config.params = params; &#125; else &#123; config.data = params; config.params = undefined; &#125; if (joinParamsToUrl) &#123; config.url = setObjToUrlParams( config.url, Object.assign(&#123;&#125;, config.params, config.data) ); &#125; &#125; else &#123; // 兼容restful风格 config.url = config.url + params; config.params = undefined; &#125; &#125; return config; &#125;, /** * @description: 请求拦截器处理 */ requestInterceptors: (config, options) =&gt; &#123; // 请求之前处理config const userStore = useUserStoreWidthOut(); const token = userStore.getToken; if (token &amp;&amp; config?.requestOptions?.withToken !== false) &#123; // jwt token config.headers.Authorization = options.authenticationScheme ? `$&#123;options.authenticationScheme&#125; $&#123;token&#125;` : token; &#125; return config; &#125;, /** * @description: 响应错误处理 */ responseInterceptorsCatch: (error) =&gt; &#123; const $dialog = window[&#x27;$dialog&#x27;]; const $message = window[&#x27;$message&#x27;]; const &#123; response, code, message &#125; = error || &#123;&#125;; // TODO 此处要根据后端接口返回格式修改 const msg = response &amp;&amp; response.data &amp;&amp; response.data.message ? response.data.message : &#x27;&#x27;; const err = error.toString(); try &#123; if (code === &#x27;ECONNABORTED&#x27; &amp;&amp; message.indexOf(&#x27;timeout&#x27;) !== -1) &#123; $message.error(&#x27;接口请求超时，请刷新页面重试!&#x27;); return; &#125; if (err &amp;&amp; err.includes(&#x27;Network Error&#x27;)) &#123; $dialog.info(&#123; title: &#x27;网络异常&#x27;, content: &#x27;请检查您的网络连接是否正常&#x27;, positiveText: &#x27;确定&#x27;, //negativeText: &#x27;取消&#x27;, closable: false, maskClosable: false, onPositiveClick: () =&gt; &#123;&#125;, onNegativeClick: () =&gt; &#123;&#125;, &#125;); return Promise.reject(error); &#125; &#125; catch (error) &#123; throw new Error(error); &#125; // 请求是否被取消 const isCancel = axios.isCancel(error); if (!isCancel) &#123; checkStatus(error.response &amp;&amp; error.response.status, msg); &#125; else &#123; console.log(error, &#x27;请求被取消！&#x27;); &#125; //return Promise.reject(error); return Promise.reject(response?.data); &#125;,&#125;;function createAxios(opt) &#123; return new VAxios( deepMerge( &#123; timeout: 10 * 1000, authenticationScheme: &#x27;&#x27;, // 接口前缀 prefixUrl: urlPrefix, headers: &#123; &#x27;Content-Type&#x27;: ContentTypeEnum.JSON &#125;, // 数据处理方式 transform, // 配置项，下面的选项都可以在独立的接口请求中覆盖 requestOptions: &#123; // 默认将prefix 添加到url joinPrefix: true, // 是否返回原生响应头 比如：需要获取响应头时使用该属性 isReturnNativeResponse: false, // 需要对返回数据进行处理 isTransformResponse: true, // post请求的时候添加参数到url joinParamsToUrl: false, // 格式化提交参数时间 formatDate: true, // 消息提示类型 errorMessageMode: &#x27;none&#x27;, // 接口地址 apiUrl: globSetting.apiUrl, // 接口拼接地址 urlPrefix: urlPrefix, // 是否加入时间戳 joinTime: true, // 忽略重复请求 ignoreCancelToken: true, // 是否携带token withToken: true, &#125;, withCredentials: false, &#125;, opt || &#123;&#125; ) );&#125;export const http = createAxios(); 值得注意的是 ​\t我们在创建Axios时初始化了很多参数，这些参数都可以在发起请求时使用，方便自定义。"},{"title":"请求API","path":"/wiki/adminpro/03_advanced_operation/07_请求API.html","content":"网络配置完成，我们就可以编写发起请求的API接口。 我们以最基本的登陆请求为例，登陆是在userStore中发起的，流程为： 发起login请求，用于获取Token 发起info请求，用户获取用户的基本信息 创建src/api/system/user.js，写入以下内容： api/system/user.jsimport &#123; http &#125; from &#x27;@/utils/http/axios&#x27;;/** * @description: 获取用户信息 */export function getUserInfo() &#123; return http.request(&#123; url: &#x27;/admin/system/index/info&#x27;, method: &#x27;get&#x27;, &#125;);&#125;/** * @description: 用户登录 */export function login(params) &#123; return http.request( &#123; url: &#x27;/admin/system/index/login&#x27;, method: &#x27;POST&#x27;, params, &#125;, &#123; isTransformResponse: false, &#125; );&#125;/** * @description: 用户登出 */export function logout(params) &#123; return http.request(&#123; url: &#x27;/admin/system/index/logout&#x27;, method: &#x27;POST&#x27;, params, &#125;);&#125; 值得注意的是： ​\t在login请求中我们自定义了isTransformResponse: false，即不处理请求到的数据，一般用于需要获取code进行判断的操作。"},{"title":"笔记概述","path":"/wiki/cloudoa/01_introduce/index.html","content":"介绍 云尚办公系统是一套自动办公系统，系统主要包含：管理端和员工端。 管理端包含：系统管理、权限管理、审批管理、公众号菜单管理。 员工端采用微信公众号操作，包含：办公审批、微信授权登录、消息推送等功能。 后端技术：Spring Boot + Mybatis Plus + MySQL 前端技术：vue cli + axios + pinia + router + js 开发工具：IntelliJ IDEA、Visual Studio Code 核心技术 权限控制Spring Security 工作流引擎Activiti 微信公众号菜单推送、授权登陆、消息推送 动态表单Form Create Naiveui 项目预览 云尚办公系统项目预览网址http://8.130.38.57:82/cloud-oa-admin/ 页面展示"},{"title":"Docker部署","path":"/wiki/cloudoa/02_install/docker_install.html","content":"服务器端提供了docker-compose文件，方便快速搭建后台服务。 部署服务器端参考上一步，通过下载源码启动后端服务项目。 修改配置文件打开servuce-oa/src/main/resources/application.yaml，修改配置信息 spring: application: name: service-oa profiles: active: prod 打开application-prod.yaml，修改password和prefix： application-prod.yamlspring: datasource: url: jdbc:mysql://mysql:3306/guigu-oa?serverTimezone=GMT%2B8&amp;useSSL=false&amp;characterEncoding=utf-8 username: root password: xxxxxxxx redis: host: redis password: xxxxxxxxwx: mp: app-id: xxxxxxxxxxxxxxxxxx secret: xxxxxxxxxxxxxxxxxxxxxxxwechat: prefix: http://xxxxxx.yyy.cn 注意！因为使用Docker所有涉及服务之间的网络通讯，这里mysql和redis的host不能是localhost或者127.0.0.1。可以使用真实的IP，或者为所有服务创建一个自定义网络，它们之间使用服务名通讯。 app-id：微信公众号的appId secret：微信公众号的secret prefix：微信公众号的授权回调页面域名 👈获取方式：微信公众号测试申请 打包项目使用maven.package打包项目，完成后可在service-oa/target中找到。 将service-oa.jar和Dockerfile上传到Linux服务器的同一目录，方便构建镜像。 构建Docker镜像Docker需要安装Docker，安装方式可以在本站的Docker笔记中找到。 DockerfileFROM openjdk:8ADD service-oa.jar service-oa.jarRUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezoneEXPOSE 8800ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/service-oa.jar&quot;]MAINTAINER sw-code 确保service-oa.jar和Dockerfile在同一目录下，使用下面命令构建 docker build -t service-oa . 使用ps命令查看镜像： docker ps 使用docker-compose编排服务创建docker-compose.yaml文件，写入 docker-compose.yamlversion: &quot;1&quot;services: microService: image: service-oa container_name: oa ports: - &quot;8800:8800&quot; volumes: - /compose/microService:/data networks: - oa_net depends_on: - redis - mysql redis: image: redis:7.0.8 ports: - &quot;6379:6379&quot; volumes: - /compose/redis/redis.conf:/etc/redis/redis.conf - /compose/redis/data:/data networks: - oa_net command: /bin/sh -c &quot;redis-server /etc/redis/redis.conf&quot; privileged: true mysql: image: mysql:8 environment: MYSQL_ROOT_PASSWORD: &#x27;xxxxxx&#x27; MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27; MYSQL_DATABASE: &#x27;guigu-oa&#x27; ports: - &quot;3306:3306&quot; volumes: - /compose/mysql/data:/var/lib/mysql # 挂载数据 - /compose/mysql/conf:/etc/mysql/conf.d # 挂载配置文件 - /compose/mysql/db:/docker-entrypoint-initdb.d # 挂载配置文件 - /compose/mysql/logs:/logs # 挂载日志 networks: - oa_net command: --default-authentication-plugin=mysql_native_password # 解决外部无法访问networks: oa_net: 配置Redis打开docker-compose.yaml文件，需要提前准备好redis.conf配置文件： redis: image: redis:7.0.8 ports: - &quot;6379:6379&quot; volumes: - /compose/redis/redis.conf:/etc/redis/redis.conf - /compose/redis/data:/data networks: - oa_net command: redis-server /etc/redis/redis.conf 使用下面命令创建： mkdir -p /compose/redis/vim /compose/redis/redis.conf Redis配置文件，下载地址：https://redis.io/docs/management/config/ 修改以下几项，密码和项目保持一致： appendonly yesbind 0.0.0.0requirepass xxxxxxxx 启动服务DockerCompose使用docker-compose同样需要配置，配置方式可以在本站的Docker笔记中找到。 进入docker-compose.yaml所在目录，使用下面命令启动： docker compose up -d 查看服务情况 [root@swcode home]# docker psCONTAINER ID IMAGE PORTS NAMES098ce7d9d8d1 service-oa 0.0.0.0:8800-&gt;8800/tcp oa489f7552b8cc redis:7.0.8 0.0.0.0:6379-&gt;6379/tcp home-redis-16c6e9bd618cb mysql:8 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp home-mysql-1 配置数据库 使用远程连接方式导入数据 使用下面方式进入容器： docker exec -it home-mysql-1 /bin/sh 登陆mysql mysql -u root -p 修改权限 ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;xxxxxx&#x27;; 刷新权限 flush privileges; 使用Navicat等软件，创建数据库guigu-oa，使用SQL文件导入表结构和数据 guigu-oa.sql 部署前端编译项目修改.env.production，注意网站前缀要和部署时保持一致 .env.production# 网站前缀VUE_APP_BASE_URL = /cloud-oa-admin 打包项目 npm run build 压缩，方便上传 tar -zcvf dist.tar.gz dist/ Dockerfile# Docker image for vue application# VERSION 1.0.0# Author: swcode### 基础镜像，使用nginx镜像FROM nginx#作者LABEL maintainer=&quot;swcode &lt;2627311935@qq.com&gt;&quot;#应用构建成功后的文件被复制到镜像内COPY dist /usr/share/nginx/html/cloud-oa-admin/#拷贝.conf文件到镜像下，替换掉原有的nginx.confCOPY nginx.conf /etc/nginx/nginx.conf#启动容器时的进程ENTRYPOINT nginx -g &quot;daemon off;&quot; Nginx配置创建nginx.conf配置文件，基于location实现二级访问目录，代理后端接口，修改配置信息如下： nginx.confworker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/json; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; # 指定前端项目所在的位置 location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; location ^~/cloud-oa-admin &#123; alias /usr/share/nginx/html/cloud-oa-admin; index index.html index.htm; try_files $uri $uri/ /cloud-oa-admin/index.html; &#125; location /api &#123; default_type application/json; #internal; keepalive_timeout 30s; keepalive_requests 1000; #支持keep-alive proxy_http_version 1.1; rewrite /api(/.*) $1 break; proxy_pass_request_headers on; proxy_next_upstream error timeout; # 同一网络内部使用服务名访问 proxy_pass http://microService:8800; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; include servers/*;&#125; 注意！配置了root之后，其他的二级目录需要使用alias 做代理时，使用同一个自定义网络下的服务名 上传文件将dist.tar.gz上传到服务器，使用下面命令解压 tar -zxvf dist.tar.gz 确保下面三个文件在同一目录 Dockerfilenginx.confdist/ build镜像使用下面命令，build镜像 docker build -t web-oa . form-designer：表示镜像名，注意和docker-compose.yaml保持一致 ‘.’：表示当前目录 ngnix没有指定版本会自动拉取最新版，等待镜像build。。。 更新Docker Compose修改docker-compose.yaml，添加前端镜像 docker-compose.yamlversion: &quot;1&quot;services: microService: image: service-oa container_name: oa ports: - &quot;8800:8800&quot; volumes: - /compose/microService:/data networks: - oa_net depends_on: - redis - mysql web: image: web-oa container_name: web ports: - &quot;82:80&quot; networks: - oa_net redis: image: redis:7.0.8 ports: - &quot;6379:6379&quot; volumes: - /compose/redis/redis.conf:/etc/redis/redis.conf - /compose/redis/data:/data networks: - oa_net command: /bin/sh -c &quot;redis-server /etc/redis/redis.conf&quot; privileged: true mysql: image: mysql:8 environment: MYSQL_ROOT_PASSWORD: &#x27;xxxxxx&#x27; MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27; MYSQL_DATABASE: &#x27;guigu-oa&#x27; ports: - &quot;3306:3306&quot; volumes: - /compose/mysql/data:/var/lib/mysql # 挂载数据 - /compose/mysql/conf:/etc/mysql/conf.d # 挂载配置文件 - /compose/mysql/db:/docker-entrypoint-initdb.d # 挂载配置文件 - /compose/mysql/logs:/logs # 挂载日志 networks: - oa_net command: --default-authentication-plugin=mysql_native_password # 解决外部无法访问networks: oa_net: 启动项目进入docker-compose.yaml所在文件，执行下面命令 docker compose up -d 使用docker ps命令查看容器 [root@swcode cloudOA]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES87586a93bda2 service-oa &quot;java -jar /service-…&quot; 4 seconds ago Up 3 seconds 0.0.0.0:8800-&gt;8800/tcp oa393edce99db4 web-oa &quot;/bin/sh -c &#x27;nginx -…&quot; 4 seconds ago Up 3 seconds 0.0.0.0:82-&gt;80/tcp webe31581190458 mysql:8 &quot;docker-entrypoint.s…&quot; 4 seconds ago Up 3 seconds 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp cloudoa-mysql-1aa34fbcd0ecc redis:6.2.6 &quot;docker-entrypoint.s…&quot; 4 seconds ago Up 3 seconds 0.0.0.0:6379-&gt;6379/tcp cloudoa-redis-1 使用浏览器访问：http://ip:82/cloud-oa-admin"},{"title":"源码部署","path":"/wiki/cloudoa/02_install/source_install.html","content":"从 GitHub 获取代码git clone https://github.com/SX-Code/naive-ui-admin-js.git 目录说明.├── guigu-oa-admin # 管理端├── guigu-oa-web # 员工端├── server # 后端服务├── Dockerfile # 后端docerfile└── docker-compose.yaml # 后端docker部署 项目部署安装 Node.js如果您电脑未安装Node.js，请安装它。 验证 # 出现相应npm版本即可npm -v# 出现相应node版本即可node -v 如果你需要同时存在多个 node 版本，可以使用 Nvm 或者其他工具进行 Node.js 进行版本管理。 数据库部署创建数据库guigu-oa CREATE DATABASE IF NOT EXISTS gugui-oa; 使用sql文件导入表结构和数据 guigu-oa.sql 服务器部署服务器源码为server文件，使用IDEA工具编写，还请使用IDEA打开项目，包管理工具为Maven。 配置文件打开servuce-oa/src/main/resources/application-dev.yaml，修改配置信息 application-dev.yamlspring: datasource: username: root password: xxxxxxxx redis: password: xxxxxxxxwx: mp: app-id: xxxxxxxxxxxxxxxxxx secret: xxxxxxxxxxxxxxxxxxxxxxxwechat: prefix: http://xxxxxx.yyy.cn app-id：微信公众号的appId secret：微信公众号的secret prefix：微信公众号的授权回调页面域名 👈获取方式：微信公众号测试申请 启动项目找到ServiceAuthApplication.java或者使用IDEA工具启动项目 测试启动访问项目使用的Swagger文档地址：http://localhost:8800/doc.html 目录说明.├── server # 打包脚本相关│ ├── common # 项目common模块│ ├── model # 项目model模块│ ├── service-oa # 项目主服务模块│ └── pom.xml # 依赖管理文件 管理端部署管理端的源码为guigu-oa-admin文件，为Vue CLI项目，可以使用Visual Studio Code打开。 该项目基于Naive Ui Admin修改开发，更多可以参考其官方文档 安装依赖使用npm安装 npm i npm script&quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;lint-fix&quot;: &quot;eslint --fix --ext .js --ext .jsx --ext .vue src/&quot;&#125;, 配置文件修改vue.config.js，更改服务器的代理地址 const &#123; defineConfig &#125; = require(&quot;@vue/cli-service&quot;);module.exports = defineConfig(&#123; transpileDependencies: true, // 基本路径 publicPath: &#x27;/&#x27;, outputDir: &#x27;dist&#x27;, // 开发环境配置 devServer: &#123; proxy: &#123; [process.env.VUE_APP_API_URL_PREFIX]: &#123; target: &#x27;http://localhost:8800/&#x27;, changeOrigin: true, pathRewrite: &#123; [&#x27;^&#x27; + process.env.VUE_APP_API_URL_PREFIX]: &#x27;&#x27; &#125; &#125; &#125; &#125;&#125;); 启动项目使用npm启动项目 guigu-oa-adminnpm run serve 目录说明详细目录说明可参考：Naive Ui Admin | 目录说明 .├── views # 页面文件│ ├── login # 登陆页面│ ├── process # 审批流程│ │ ├── list # 流程列表│ │ ├── set # 审批模版设计│ │ ├── template # 审批模版│ │ └── type # 审批类型│ ├── system # 系统管理│ │ ├── menu # 菜单管理│ │ ├── role # 角色管理│ │ └── user # 用户管理│ └── wechat # 微信公众号│ │ └── menu # 微信公众号菜单 员工端部署部署方式和管理端一样 目录说明详细目录说明可参考：Naive Ui Admin | 目录说明 .├── views # 页面文件│ ├── apply # 发起审批页面│ ├── debug # 测试页面│ ├── list # 流程页面│ ├── process # 首页面│ └── show # 流程详情页面└── login.vue # 登陆授权页面"},{"title":"BasicForm 表单组件","path":"/wiki/adminpro/04_components_using/basicform.html","content":"对 form 组件进行封装 1、通过代码的方式配置多个表单组件 2、配置表格作为过滤查询条件 下载基础代码基础代码下载地址： https://wwab.lanzoue.com/i3p7I1fjkavcBasicForm代码下载 或者从Git仓库中直接拷贝代码，推荐！ 添加 BasicForm 组件打开项目，找到src目录，需要导入的文件及位置如下： Form ==&gt; src/components/ BasicTable组件中使用到了基础Naive UI组件，这里需要增量引入： 哪个组件打印警告信息，添加哪个组件即可。 import * as NaiveUI from &#x27;naive-ui&#x27;;const naive = NaiveUI.create(&#123; components: [ NaiveUI.NRadio, NaiveUI.NSelect, NaiveUI.NRadioGroup, NaiveUI.NGi, NaiveUI.NGrid,],&#125;);export function setupNaive(app) &#123; app.use(naive);&#125; 找到src/utils/index.js，添加如下工具方法 import &#123; unref &#125; from &#x27;vue&#x27;;// dynamic use hook propsexport function getDynamicProps(props) &#123; const ret = &#123;&#125;; Object.keys(props).map((key) =&gt; &#123; ret[key] = unref(props[key]); &#125;); return ret;&#125; 基础使用表单组件设置通过设置表单组件的属性可以渲染对应表单，以及表单的样式信息等 items.jsexport const schemas = [ &#123; field: &#x27;name&#x27;, component: &#x27;NInput&#x27;, label: &#x27;姓名&#x27;, defaultValue: &#x27;&#x27;, labelMessage: &#x27;这是一个提示&#x27;, rules: [&#123;required: true, trigger: [&#x27;blur&#x27;]&#125;], componentProps: &#123; placeholder: &#x27;请输入姓名&#x27;, onInput: (e) =&gt; &#123; console.log(`NInput: $&#123;e&#125;`); &#125;, &#125; &#125;, &#123; field: &#x27;phone&#x27;, component: &#x27;NInput&#x27;, label: &#x27;手机&#x27;, defaultValue: &#x27;&#x27;, componentProps: &#123; placeholder: &#x27;请输入手机号码&#x27;, &#125; &#125;, &#123; field: &#x27;type&#x27;, component: &#x27;NSelect&#x27;, label: &#x27;类型&#x27;, componentProps: &#123; placeholder: &#x27;请选择类型&#x27;, options: [ &#123; label: &#x27;舒适型&#x27;, value: &#x27;comfort&#x27; &#125;, &#123; label: &#x27;经济型&#x27;, value: &#x27;economical&#x27; &#125; ], onUpdateValue: (e) =&gt; &#123; console.log(`NSelect: $&#123;e&#125;`); &#125;, &#125; &#125;, &#123; field: &#x27;reserveTime&#x27;, component: &#x27;NDatePicker&#x27;, label: &#x27;预约时间&#x27;, defaultValue: 1183135260000, componentProps: &#123; type: &#x27;date&#x27;, clearable: true, onUpdateValue: (e) =&gt; &#123; console.log(`NDatePicker: $&#123;e&#125;`); &#125;, &#125; &#125;, &#123; field: &#x27;stayTime&#x27;, component: &#x27;NTimePicker&#x27;, label: &#x27;停留时间&#x27;, componentProps: &#123; clearable: true, onUpdateValue: (e) =&gt; &#123; console.log(`NTimePicker: $&#123;e&#125;`); &#125;, &#125; &#125;, &#123; field: &#x27;status&#x27;, label: &#x27;状态&#x27;, //插槽 slot: &#x27;statusSlot&#x27;, &#125;, &#123; field: &#x27;project&#x27;, component: &#x27;NCheckbox&#x27;, label: &#x27;预约项目&#x27;, componentProps: &#123; placeholder: &#x27;请选择预约项目&#x27;, options: [ &#123; label: &#x27;种牙&#x27;, value: &#x27;1&#x27; &#125;, &#123; label: &#x27;补牙&#x27;, value: &#x27;2&#x27; &#125;, &#123; label: &#x27;根管&#x27;, value: &#x27;3&#x27; &#125; ], onUpdateValue: (e) =&gt; &#123; console.log(`NCheckbox: $&#123;JSON.stringify(e)&#125;`); &#125;, &#125; &#125;, &#123; field: &#x27;source&#x27;, component: &#x27;NRadioGroup&#x27;, label: &#x27;来源&#x27;, componentProps: &#123; options: [ &#123; label: &#x27;网上&#x27;, value: &#x27;1&#x27; &#125;, &#123; label: &#x27;门店&#x27;, value: &#x27;2&#x27; &#125;, ], onUpdateValue: (e) =&gt; &#123; console.log(`NRadioGroup: $&#123;JSON.stringify(e)&#125;`); &#125;, &#125;, &#125;,]; 页面使用BasicForm添加组件item的使用方法 &lt;template&gt; &lt;n-card :bordered=&quot;false&quot; class=&quot;proCard table&quot;&gt; &lt;BasicForm @register=&quot;register&quot; @submit=&quot;handleSubmit&quot; @reset=&quot;handleReset&quot;&gt; &lt;template #statusSlot=&quot;&#123; model, field &#125;&quot;&gt; &lt;n-input v-model:value=&quot;model[field]&quot; /&gt; &lt;/template&gt; &lt;/BasicForm&gt; &lt;/n-card&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; reactive, ref, unref &#125; from &#x27;vue&#x27;import &#123; BasicForm, useForm &#125; from &#x27;@/components/Form&#x27;import &#123; schemas &#125; from &#x27;./items&#x27;;// 分页参数let params = reactive(&#123;&#125;)// 注册表单const [register, &#123; setProps &#125;] = useForm(&#123; gridProps: &#123; cols: 3 &#125;, showAdvancedButton: true, labelWidth: 100, schemas,&#125;);// 刷新表格function reloadData() &#123; console.log(unref(params));&#125;// 查询提交方法function handleSubmit(values) &#123; Object.assign(params, values); reloadData();&#125;// 查询重置方法function handleReset(values) &#123; params = values reloadData();&#125;&lt;/script&gt; 组合使用 表单组件设置通过设置表单组件的属性可以渲染对应表单，以及表单的样式信息等 columns.jsexport const schemas = [ &#123; field: &#x27;hosname&#x27;, component: &#x27;NInput&#x27;, label: &#x27;医院名称&#x27;, defaultValue: &#x27;&#x27;, labelMessage: &#x27;筛选医院名称&#x27;, componentProps: &#123; placeholder: &#x27;请输入医院名称&#x27;, &#125; &#125;, &#123; field: &#x27;hoscode&#x27;, component: &#x27;NInput&#x27;, label: &#x27;医院编号&#x27;, defaultValue: &#x27;&#x27;, labelMessage: &#x27;筛选医院编号&#x27;, componentProps: &#123; placeholder: &#x27;请输入医院编号&#x27;, &#125; &#125;,];export const columns = [ &#123; type: &#x27;selection&#x27;, key: &#x27;selection&#x27; &#125;, &#123; title: &#x27;医院名称&#x27;, key: &#x27;hosname&#x27;, &#125;, &#123; title: &#x27;医院编号&#x27;, key: &#x27;hoscode&#x27;, &#125;] 页面使用BasicForm常常配合BasicTable使用，下面一个简单实例 &lt;template&gt; &lt;n-card :bordered=&quot;false&quot; class=&quot;proCard table&quot;&gt; &lt;BasicForm @register=&quot;register&quot; @submit=&quot;handleSubmit&quot; @reset=&quot;handleReset&quot; /&gt; &lt;BasicTable :columns=&quot;columns&quot; :request=&quot;loadDataTable&quot; ref=&quot;actionRef&quot; :row-key=&quot;(row) =&gt; row.id&quot; :scroll-x=&quot;1000&quot; /&gt; &lt;/n-card&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;import &#123; getHospSetPageList &#125; from &#x27;@/api/hospset&#x27;import &#123; BasicForm, useForm &#125; from &#x27;@/components/Form&#x27;import &#123; BasicTable &#125; from &#x27;@/components/Table&#x27;import &#123; schemas, columns &#125; from &#x27;./columns&#x27;;// 分页参数const defalutParams = () =&gt; &#123; return &#123; hosname: null, hoscode: null, &#125;;&#125;;const params = reactive(defalutParams())const actionRef = ref(null)// 注册表单const [register, &#123; setProps &#125;] = useForm(&#123; gridProps: &#123; cols: 3 &#125;, showAdvancedButton: false, labelWidth: 100, schemas,&#125;);// 数据请求const loadDataTable = async (res) =&gt; &#123; return await getHospSetPageList(&#123; ...res, ...params &#125;);&#125;// 刷新表格function reloadTable() &#123; actionRef.value.reload();&#125;// 查询提交方法function handleSubmit(values) &#123; Object.assign(params, values); reloadTable();&#125;// 查询重置方法function handleReset() &#123; Object.assign(params, defalutParams()); reloadTable();&#125;&lt;/script&gt; 详细使用详细的使用教程见： https://docs.naiveadmin.com/components/form.htmlNaive Ui Admin | BasicForm 表单组件"},{"title":"BasicTable 表格组件","path":"/wiki/adminpro/04_components_using/basictable.html","content":"对 Data Table 组件进行封装，效果如下： 1、可实现基础的表格数据和分页信息的展示 2、可调整表格的样式，选择展示的列 3、可实现对列的操作功能 4、实现单选和多选操作 5、实现可编辑单元格，整行编辑操作 下载基础代码基础代码下载地址： https://wwab.lanzoue.com/iRUSW1fj5fcdBasicTable代码下载 或者从Git仓库中直接拷贝代码，推荐！ 添加 BasicTable 组件打开项目，找到src目录，需要导入的文件及位置如下： Table ==&gt; src/components/hooks/event ==&gt; src/hookssettings/componentSetting.js ==&gt; src/settings/utils/domUtils.js ==&gt; src/utils/directives =&gt; src/ BasicTable组件中使用到了基础Naive UI组件，这里需要增量引入： 哪个组件打印警告信息，添加哪个组件即可。 import * as NaiveUI from &#x27;naive-ui&#x27;;const naive = NaiveUI.create(&#123; components: [ NaiveUI.NSwitch, NaiveUI.NDataTable, NaiveUI.NCheckboxGroup, NaiveUI.NPopover],&#125;);export function setupNaive(app) &#123; app.use(naive);&#125; 安装vueuse依赖 npm i @vueuse/core 基础使用分页设置找到src/settings/componentSetting，修改其中的字段名，和后端返回的分页信息对应 export default &#123; table: &#123; apiSetting: &#123; // 当前页的字段名 pageField: &#x27;current&#x27;, // 每页数量字段名 sizeField: &#x27;size&#x27;, // 接口返回的数据字段名 listField: &#x27;records&#x27;, // 接口返回总页数字段名 totalField: &#x27;pages&#x27;, // 接口返回总数据个数 itemCountField: &#x27;total&#x27;, &#125;, //默认分页数量 defaultPageSize: 10, //可切换每页数量集合 pageSizes: [5, 10, 20, 30, 40], &#125;,&#125;; 表格列设置通过设置列的属性可以显示对应字段，以及列的样式信息等 columns.jsimport &#123; NSwitch &#125; from &quot;naive-ui&quot;;import &#123; h &#125; from &quot;vue&quot;;import &#123; DeleteOutlined, EditOutlined &#125; from &#x27;@vicons/antd&#x27;export const createListColumns = (&#123; currentIndex, switchStatus &#125;) =&gt; &#123; return [ &#123; type: &#x27;selection&#x27;, key: &#x27;selection&#x27; &#125;, &#123; title: &#x27;序号&#x27;, key: &#x27;index&#x27;, width: 60, render: (...[, record]) =&gt; &#123; return currentIndex() + record + 1; &#125;, &#125;, &#123; title: &#x27;医院名称&#x27;, key: &#x27;hosname&#x27;, &#125;, &#123; title: &#x27;医院编号&#x27;, key: &#x27;hoscode&#x27;, &#125;, &#123; title: &#x27;api基础路径&#x27;, key: &#x27;apiUrl&#x27;, width: 200, &#125;, &#123; title: &#x27;联系人姓名&#x27;, key: &#x27;contactsName&#x27;, &#125;, &#123; title: &#x27;联系人手机&#x27;, key: &#x27;contactsPhone&#x27;, &#125;, &#123; title: &#x27;状态&#x27;, key: &#x27;status&#x27;, render(row) &#123; return h(NSwitch, &#123; value: row.status === 1 ? true : false, onClick: () =&gt; switchStatus(row), &#125;); &#125;, &#125;, ]&#125;export function createActions(record, &#123;handleEdit, handleDelete&#125;) &#123; return [ &#123; label: &#x27;删除&#x27;, type: &#x27;error&#x27;, // 配置color会覆盖type color: &#x27;red&#x27;, icon: DeleteOutlined, onClick: handleDelete.bind(null, record) &#125;, &#123; label: &#x27;编辑&#x27;, type: &#x27;primary&#x27;, icon: EditOutlined, onClick: handleEdit.bind(null, record) &#125; ];&#125; 页面使用&lt;template&gt; &lt;n-card :bordered=&quot;false&quot; class=&quot;proCard table&quot;&gt; &lt;BasicTable :columns=&quot;columns&quot; :request=&quot;loadDataTable&quot; @fetch-success=&quot;fetchSuccess&quot; @update:checked-row-keys=&quot;onCheckedRow&quot; ref=&quot;actionRef&quot; :actionColumn=&quot;actionColumn&quot; :row-key=&quot;(row) =&gt; row.id&quot; :scroll-x=&quot;1000&quot;&gt; &lt;!-- 表格上方左侧的位置 --&gt; &lt;template #tableTitle&gt; &lt;n-space&gt; &lt;!-- 批量删除 --&gt; &lt;n-button strong secondary type=&quot;error&quot; @click=&quot;removeRows&quot;&gt; 批量删除 &lt;/n-button&gt; &lt;/n-space&gt; &lt;/template&gt; &lt;/BasicTable&gt; &lt;/n-card&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; h, reactive, ref, unref &#125; from &#x27;vue&#x27;import &#123; getHospSetPageList &#125; from &#x27;@/api/hospset&#x27;import &#123; BasicTable, TableAction &#125; from &#x27;@/components/Table&#x27;import &#123; createListColumns, createActions &#125; from &#x27;./columns&#x27;;import &#123; useDialog, useMessage &#125; from &#x27;naive-ui&#x27;;const dialog = useDialog()const message = useMessage()const actionRef = ref(null)const currentIndex = ref(1)// 选中的行const selections = ref([]);// 表格列属性const columns = createListColumns(&#123; currentIndex() &#123; return unref(currentIndex); &#125;, switchStatus: async (row) =&gt; &#123; const &#123; id, status &#125; = row; const update = status === 1 ? 0 : 1; try &#123; // 切换状态 row.status = update; &#125; catch (error) &#123; row.status = status &#125; &#125;,&#125;); const actionColumn = reactive(&#123; width: 140, title: &#x27;操作&#x27;, key: &#x27;action&#x27;, fixed: &#x27;right&#x27;, align: &#x27;center&#x27;, render(record) &#123; return h(TableAction, &#123; showLabel: false, actions: createActions(record, &#123; handleEdit, handleDelete &#125;), &#125;); &#125;,&#125;);// 数据请求const loadDataTable = async (res) =&gt; &#123; return await getHospSetPageList(&#123; ...res &#125;);&#125;function fetchSuccess() &#123; // 数据请求成功，设置索引 currentIndex.value = (actionRef.value.pagination.current - 1) * actionRef.value.pagination.pageSize;&#125;// 表格选中行事件function onCheckedRow(rowKeys) &#123; selections.value = rowKeys;&#125;// 刷新表格function reloadTable() &#123; actionRef.value.reload();&#125;// 编辑事件const handleEdit = (record) =&gt; &#123; &#125;// 删除事件const handleDelete = (record) =&gt; &#123; dialog.info(&#123; title: &#x27;提示&#x27;, content: `您想删除：$&#123;record.hosname&#125;`, positiveText: &#x27;确定&#x27;, negativeText: &#x27;取消&#x27;, onPositiveClick: async () =&gt; &#123; await deleteHospSet(record.id) reloadTable(); &#125;, onNegativeClick: () =&gt; &#123; &#125;, &#125;);&#125;// 批量删除事件const removeRows = () =&gt; &#123; const ids = unref(selections); if (ids.length === 0) &#123; message.warning(&#x27;请至少勾选一列&#x27;); return; &#125; dialog.warning(&#123; title: &#x27;提示&#x27;, content: `您要删除: $&#123;ids&#125;`, positiveText: &#x27;确定&#x27;, negativeText: &#x27;取消&#x27;, onPositiveClick: async () =&gt; &#123; await batchRemoveHospSet(ids); reloadTable(); &#125;, onNegativeClick: () =&gt; &#123;&#125;, &#125;);&#125;&lt;/script&gt; 行列编辑实现每个单元格编辑或者整行编辑，效果如图： 分页设置找到src/settings/componentSetting，修改其中的字段名，和后端返回的分页信息对应 export default &#123; table: &#123; apiSetting: &#123; // 当前页的字段名 pageField: &#x27;current&#x27;, // 每页数量字段名 sizeField: &#x27;size&#x27;, // 接口返回的数据字段名 listField: &#x27;records&#x27;, // 接口返回总页数字段名 totalField: &#x27;pages&#x27;, // 接口返回总数据个数 itemCountField: &#x27;total&#x27;, &#125;, //默认分页数量 defaultPageSize: 10, //可切换每页数量集合 pageSizes: [5, 10, 20, 30, 40], &#125;,&#125;; 表格列设置通过设置列的属性可以显示对应字段，以及列的样式信息等 edit: true：开启编辑功能, editRule: true：编辑时的校验规则，默认true为非空校验, editComponent: &#39;NInput&#39;：编辑时渲染的组件类型, columns.jsimport &#123; NSwitch &#125; from &quot;naive-ui&quot;;import &#123; h &#125; from &quot;vue&quot;;import &#123; DeleteOutlined, EditOutlined, SaveOutlined, CloseSquareOutlined &#125; from &#x27;@vicons/antd&#x27;const reg_tel = /^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d&#123;8&#125;$/export const createListColumns = (&#123; switchStatus &#125;) =&gt; &#123; return [ &#123; type: &#x27;selection&#x27;, key: &#x27;selection&#x27; &#125;, &#123; title: &#x27;医院名称&#x27;, key: &#x27;hosname&#x27;, edit: true, editRule: true, editComponent: &#x27;NInput&#x27;, &#125;, &#123; title: &#x27;医院编号&#x27;, key: &#x27;hoscode&#x27;, edit: true, editRule: true, editComponent: &#x27;NInput&#x27;, &#125;, &#123; title: &#x27;api基础路径&#x27;, key: &#x27;apiUrl&#x27;, width: 200, edit: true, editRule: true, editComponent: &#x27;NInput&#x27;, &#125;, &#123; title: &#x27;联系人姓名&#x27;, key: &#x27;contactsName&#x27;, edit: true, editRule: true, editComponent: &#x27;NInput&#x27;, &#125;, &#123; title: &#x27;联系人手机&#x27;, key: &#x27;contactsPhone&#x27;, edit: true, editRule: (text, _) =&gt; &#123; if (!reg_tel.test(text)) return &#x27;手机号格式错误&#x27; &#125;, editComponent: &#x27;NInput&#x27;, &#125;, &#123; title: &#x27;状态&#x27;, key: &#x27;status&#x27;, render(row) &#123; return h(NSwitch, &#123; value: row.status === 1 ? true : false, onClick: () =&gt; switchStatus(row), &#125;); &#125;, &#125;, ]&#125;export function createActions(record, &#123;handleSave, handleEdit, handleDelete, handleCancel&#125;) &#123; if (!record.editable) &#123; return [ &#123; label: &#x27;删除&#x27;, type: &#x27;error&#x27;, // 配置color会覆盖type color: &#x27;red&#x27;, icon: DeleteOutlined, onClick: handleDelete.bind(null, record) &#125;, &#123; label: &#x27;编辑&#x27;, type: &#x27;primary&#x27;, icon: EditOutlined, onClick: handleEdit.bind(null, record) &#125; ]; &#125; else &#123; return [ &#123; label: &#x27;保存&#x27;, type: &#x27;success&#x27;, icon: SaveOutlined, onClick: handleSave.bind(null, record), &#125;, &#123; label: &#x27;取消&#x27;, type: &#x27;warning&#x27;, icon: CloseSquareOutlined, onClick: handleCancel.bind(null, record), &#125;, ]; &#125;&#125; 页面使用&lt;template&gt; &lt;n-card :bordered=&quot;false&quot; class=&quot;proCard table&quot;&gt; &lt;BasicTable :columns=&quot;columns&quot; :request=&quot;loadDataTable&quot; @edit-end=&quot;cellEditEnd&quot; ref=&quot;actionRef&quot; :actionColumn=&quot;actionColumn&quot; :row-key=&quot;(row) =&gt; row.id&quot; :scroll-x=&quot;1000&quot; /&gt; &lt;/n-card&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; h, reactive, ref, unref &#125; from &#x27;vue&#x27;import &#123; getHospSetPageList, deleteHospSet, batchRemoveHospSet, lockHospSet, updateHospSet &#125; from &#x27;@/api/hospset&#x27;import &#123; BasicTable, TableAction &#125; from &#x27;@/components/Table&#x27;import &#123; createListColumns, createActions &#125; from &#x27;./columns&#x27;;import &#123; useDialog, useMessage &#125; from &#x27;naive-ui&#x27;;const dialog = useDialog()const message = useMessage()const actionRef = ref(null)// 表格列属性const columns = createListColumns(&#123; switchStatus: async (row) =&gt; &#123; const &#123; id, status &#125; = row; const update = status === 1 ? 0 : 1; try &#123; await lockHospSet(id, update) row.status = update; &#125; catch (error) &#123; row.status = status &#125; &#125;,&#125;);// 表格操作列属性const currentEditKeyRef = ref(&#x27;&#x27;);const actionColumn = reactive(&#123; width: 140, title: &#x27;操作&#x27;, key: &#x27;action&#x27;, fixed: &#x27;right&#x27;, align: &#x27;center&#x27;, render(record) &#123; return h(TableAction, &#123; showLabel: false, actions: createActions(record, &#123; handleSave, handleEdit, handleDelete, handleCancel &#125;), &#125;); &#125;,&#125;);// 数据请求const loadDataTable = async (res) =&gt; &#123; return await getHospSetPageList(&#123; ...res &#125;);&#125;// 刷新表格function reloadTable() &#123; actionRef.value.reload();&#125;// 单元格编辑提交事件const cellEditEnd = async (&#123; record, index, key, value &#125;) =&gt; &#123; const param = &#123; id: record.id &#125; param[key] = value try &#123; await updateHospSet(param) message.success(&#x27;保存成功&#x27;) &#125; catch (error) &#123; console.log(error); &#125;&#125;// 整行编辑保存事件const handleSave = async (record) =&gt; &#123; const pass = await record.onEdit?.(false, true); if (pass) &#123; currentEditKeyRef.value = &#x27;&#x27;; const &#123; id, hosname, hoscode, apiUrl, contactsName, contactsPhone &#125; = record; // 提交更新 try &#123; await updateHospSet(&#123; id, hosname, hoscode, apiUrl, contactsName, contactsPhone &#125;) message.success(&#x27;保存成功&#x27;) &#125; catch (error) &#123; console.log(error); &#125; &#125;&#125;// 开启整行编辑事件const handleEdit = (record) =&gt; &#123; currentEditKeyRef.value = record.key; record.onEdit?.(true);&#125;// 删除事件const handleDelete = (record) =&gt; &#123; dialog.info(&#123; title: &#x27;提示&#x27;, content: `您想删除：$&#123;record.hosname&#125;`, positiveText: &#x27;确定&#x27;, negativeText: &#x27;取消&#x27;, onPositiveClick: async () =&gt; &#123; await deleteHospSet(record.id) reloadTable(); &#125;, onNegativeClick: () =&gt; &#123; &#125;, &#125;);&#125;// 取消整行编辑事件const handleCancel = (record) =&gt; &#123; currentEditKeyRef.value = &#x27;&#x27;; record.onEdit?.(false, false);&#125;&lt;/script&gt; 详细使用详细的使用教程见： https://docs.naiveadmin.com/components/table.htmlNaive Ui Admin | BasicTable 表格组件"},{"title":"Activiti","path":"/wiki/cloudoa/03_function/activiti.html","content":"什么是工作流工作流（Workflow），就是通过计算机对业务流程自动化执行管理。它主要解决的事：使多个参与者之间按照某种预定的规则自动进行传递文档、信息或任务的过程，从而实现某个预期的业务目标，或者促使此目标的实现。通俗来讲，就是业务上一个完整的审批流程。例如员工的请假，出差，外出采购，合同审核等等，这些过程，都是一个工作流。 工作流引擎对于工作流的处理，如果采用原始的方式，我们需要拿着各种文件到各个负责人那里去签字，需要在多个部门之间不断审批，这种方式费时费力。而我们可以借助软件系统来协助我们处理这些审批流程，这样就出现了工作流系统，使用工作流系统后可以极大的提高工作效率。 在学习工作流的过程中，我们肯定看到过这个模型:填写请假单-&gt;部门经理审批-&gt;总经理审批-&gt;人事备案 （1）要实现上述的流程，我们自己可以通过字段标识来实现这个审批效果，在业务表中加个字段，比如填写请假单用1标识，部门经理用2标识，总经理用3标识，人事备案用4标识，好像看起来没啥问题，也实现了审批效果。可是一旦我们的流程出现了变化，这个时候我们就需要改动我们的代码了，这显然是不可取的，那么有没有专业的方式来实现工作流的管理呢? 并且可以做到业务流程变化之后，我们的程序可以不用改变，如果可以实现这样的效果，那么我们的业务系统的适应能力就得到了极大提升。在这样的背景下，就出现了工作流引擎。 为什么使用工作流引擎，能实现业务流程改变，不用修改代码，流程还能自动推进? （1）我们先来说说为什么流程改变，不用修改代码:我们的工作流引擎都实现了一个规范，这个规范要求我们的流程管理与状态字段无关，始终都是读取业务流程图的下一个节点。当业务更新的时候我们只需要更新业务流程图就行了。这就实现了业务流程改变，不用修改代码。 （2）再来说说流程自动推进，这个原理就更简单了，就拿上面的请假模型来说，工作流引擎会用一张表来记录当前处在的节点。当填写完请假单后肯定是要轮到部门经理来审批了，所以我们一旦完成了请假单填写那么这条记录将会被从这张表删除掉，并且会把下一个节点部门经理的信息插入到这张表中，当我们用部门经理的信息去这张表中查询的时候就能查出部门经理相关的审批的信息了，以此类推，这样层层递进，就实现了流程的自动递交了。 常见的工作流引擎主流的框架有：Activiti、jBPM、Camunda、Flowable、盘古BPM、云程 Activiti 7概述Activiti介绍activiti是一个工作流引擎，可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN进行定义，业务流程按照预先定义的流程进行执行。实现了系统的流程由activti进行管理，减少业务系统由于流程变更进行系统升级改造的工作流量，从而提高系统的健壮性，同时也减少了系统开发维护成本。 官方网站: https://www.activiti.org 建模语言BPMNBPM (Business Process Management) 即业务流程管理，是一种规范化的构造端到端的业务流程，以持续提高组织业务效率。 BPM 软件就是根据企业中业务环境的变化，推进人与人之间、人与系统之间以及系统与系统之间的整理及调整的经营方法与解决方案的 T 工具。使用 BPM 软件对企业内部及外部的业务流程的整个生命周期进行建模、自动化、管理监控和优化，可以降低企业成本，提高利润。 BPMN (Business Process Model AndNotation) 即业务流程模型和符号，是一套标准的业务流程建模符号，使用BPMN 提供的符号可以创建业务流程。Activit 就是使用 BPMN 进行流程建模、流程执行管理的。 BPMN2.0 是业务流程建模符号 2.0 的缩写，它由 Business Process Management nitiative 这个非营利协会创建并不断发展。BPMN2.0 是使用一些符号来明确业务流程设计流程图的一套符号规范，能增进业务建模时的沟通效率。目前 BPMN2.0 是最新的版本，它用于在 BPM 上下文中进行布局和可视化的沟通。 BPMN2.0 的基本符号主要包含： 事件 Event开始:表示一个流程的开始中间:发生的开始和结束事件之间，影响处理的流程结束:表示该过程结束 活动 Activities活动是工作或任务的一个通用术语。一个活动可以是一个任务，还可以是一个当前流程的子处理流程；其次，你还可以为活动指定不同的类型。常见的活动如下 用户任务（User Task） 服务任务（Service Task） 子流程（Sub Process） 网管 GateWay用于表示流程的分支与合并，有几种常用的网关需要了解 排他网关（Exclusive Gateway） 并行网关（Parallel Gateway） 包容网关（Inclusive Gateway） 事件网关（Event gateway） Activiti 使用流程第一步： 引入依赖并初始化数据库 既然activiti是一个框架，那么我们肯定是需要引入对应的iar包坐标的，具体参考代码中的。 第二步： 通过工具绘画流程图 使用activiti 流程建模工具(activity-designer)定义业务流程(.bpmn 文件)。bpmn 文件就是业务流程定义文件通过 xml 定义业务流程。 第三步： 流程定义部署 向activiti 部署业务流程定义 (.bpmn 文件)，使用 activiti 提供的 api向activiti 中部署.bpmn 文件通俗来讲，就是让activiti认识要使用的流程 第四步： 启动一个流程实例 (ProcessInstance) 启动一个流程实例表示开始一次业务流程的运行，比如员工请假流程部署完成，如果张三要请假就可以启动一个流程实例，如果李四要请假也启动一个流程实例，两个流程的执行互相不影响，就好比定义一个 java 类，实例化两个对象一样，部署的流程就好比 iava 类，启动一个流程实例就好比 new 一个iava 对象 第五步： 用户查询待办任务(Task) 因为现在系统的业务流程已经交给 activiti 管理，通过 activiti 就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些 activiti都我们管理了。实际上我们学习activiti也只是学习它的API怎么使用，因为很多功能activiti都已经封装好了，我们会调用就行了。 第六步：用户办理任务 用户查询待办任务后，就可以办理某个任务，如果这个任务办理完成还需要其他用户办理，比如请假单创建后还需要部分经历审批，这个过程也是由 activiti 帮我们完成了，不需要我们在代码中指定。 第七步：流程结束 当任务办理完成没有下一个任务节点了，这个流程实例就完成了。 Activiti ModelerActiviti官网：Get started | Activiti，下载Activiti 5.x Activiti setup使用Activiti 在线设计，需要安装Java 运行环境和Apache Tomcat。确保你已经正确设置了 JAVA_HOME 系统变量，设置方式取决于操作系统。 要让 Activiti Explore 和 REST Web 应用程序运行，只需将从 Activiti 下载页面下载的 WAR 复制到 Tomcat 安装目录中的文件夹中即可。默认情况下，Explore 使用内存中数据库以及示例进程、用户和组运行。 测试账号: UserId Password Security roles kermit kermit admin gonzo gonzo manager fozzie fozzie user 现在您可以访问以下Web应用程序 Webapp Name URL Description Activiti Explorer http://localhost:8080/activiti-explorer 进程引擎用户控制台。使用此工具启动新流程、分配任务、查看和声明任务等。该工具还允许管理Activiti引擎。 设计请假流程创建流程 来到流程设计工作区，点击右上角的新建模型 名称：leave描述：请假 设计如图的流程定义，注意图中红色部分的ID 设置审批人 点击王经理审批，找到下面的Assignment，在弹出窗户中的Assignee下填入wjl（sys_user表的用户昵称） 以同样的方式设置李人事经理的Assignee为lrsjl。 保存并退出设计器 导出模型在流程设计工作区的右上角，处理模型中选择导出模型 leave.bpmn20.xml Activiti 7我们将activiti 7引入项目 Activiti环境配置依赖pom.xml&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;7.1.0.M6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 说明：Activiti 7与Spring Boot整合后，默认集成了Spring Security安全框架，当前我们项目已经集成过了Spring Security，后续案例设置审批人时都必须是系统用户，Activiti会检查用户是否存在。 添加配置spring: activiti: database-schema-update: true db-history-used: true history-level: full check-process-definitions: true async-executor-activate: false 启动项目项目启动后，会自动创建数据库表 Activiti的运行支持必须要有这25张表的支持，主要是在业务流程运行过程中，记录参与流程的用户主体，用户组信息，以及流程的定义，流程执行时的信息，和流程的历史信息等等。 部署流程定义创建resources/processes，将我们设计的请假模型拷贝到此处，将leave.bpmn20.xml压缩成zip文件，名称为leave.zip，其中leave是流程定义的Key # Mac使用下面命令压缩，防止加入隐藏文件zip leave.zip leave.bpmn20.xml 可使用repositoryService进行流程部署 在上传流程文件zip包时，zip包名为流程定义Key ProcessServiceImpl.java@Overridepublic void publish(Long id) &#123; // 修改状态 ProcessTemplate processTemplate = baseMapper.selectById(id); // 获取定义文件的路径 String path = processTemplate.getProcessDefinitionPath(); if (StringUtils.isEmpty(path)) &#123; throw new BizException(&quot;文件路径为空&quot;); &#125; deployByZip(path); processTemplate.setStatus(1); baseMapper.updateById(processTemplate);&#125;private void deployByZip(String path) &#123; InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(path); ZipInputStream zipInputStream = new ZipInputStream(inputStream); // 流程部署 Deployment deployment = repositoryService.createDeployment() .addZipInputStream(zipInputStream) .deploy();&#125; 其中processTemplate为流程模板实体类，存放了流程定义文件的路径 对应的Controller接口为：ProcessTemplateController.publish 对应的发起请求的前端页面为：template.vue | 219行 启动流程实例启动流程实例就是新建一个审批流程，比如某个用户发起一个请假审批，这个时候就需要启动一个流程实例。 除了使用runtimeService启动流程实例外，还需要进行流程信息的保存等操作。 获取流程定义的Key，其被保存在processTemplate中。其实就是设计时指定的，也就是zip包的名称。 流程实例可以绑定一个业务ID，这里将我们的Process.id设定为业务ID 流程参数被设置为了用户填写的表单值。 流程实例启动成功，获取下一个审批人信息。可能有多个，循环做消息推送。 发起审批也是流程的一环节，需要记录到ProcessRecord表中。 ProcessServiceImpl.java@Overridepublic void startUp(ProcessFormVo processFormVo) &#123; // 获取用户信息 SysUser sysUser = sysUserService.getById(LoginUserInfoHelper.getUserId()); // 根据审批模版id，查询模板信息 LambdaQueryWrapper&lt;ProcessTemplate&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.select(ProcessTemplate::getId, ProcessTemplate::getName, ProcessTemplate::getProcessDefinitionKey) .eq(ProcessTemplate::getId, processFormVo.getProcessTemplateId()); ProcessTemplate processTemplate = processTemplateService.getOne(wrapper); // 保存流程信息 Process process = new Process(); BeanUtils.copyProperties(processFormVo, process); process.setStatus(1); String workNo = String.valueOf(System.currentTimeMillis()); process.setProcessCode(workNo); process.setUserId(LoginUserInfoHelper.getUserId()); process.setFormValues(processFormVo.getFormValues()); process.setTitle(sysUser.getName() + &quot;发起&quot; + processTemplate.getName() + &quot;申请&quot;); baseMapper.insert(process); // 启动流程实例 // 流程定义key String key = processTemplate.getProcessDefinitionKey(); // 业务流程id String businessId = String.valueOf(process.getId()); // 流程参数 HashMap&lt;String, Object&gt; variables = new HashMap&lt;&gt;(); JSONObject jsonObject = JSON.parseObject(processFormVo.getFormValues()); JSONObject formData = jsonObject.getJSONObject(&quot;formData&quot;); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(formData); variables.put(&quot;data&quot;, map); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(key, businessId, variables); // 查询下一个审批人 List&lt;Task&gt; taskList = this.getCurrentTaskList(processInstance.getId()); String names = taskList.stream().map(task -&gt; &#123; String assignee = task.getAssignee(); SysUser user = sysUserService.getUserByUsername(assignee); // 推送消息 messageService.pushPendingMessage(process, user, task.getId()); return user.getName(); &#125;).collect(Collectors.joining(&quot;,&quot;)); // 业务流程关联 process.setProcessInstanceId(processInstance.getId()); process.setDescription(&quot;等待&quot; + names + &quot;审批&quot;); baseMapper.updateById(process); processRecordService.record(process.getId(), 1, &quot;发起申请&quot;);&#125; 其中 LoginUserInfoHelper 是 ThreadLocal 变量，负责记录登陆用户的信息。 其中 processFormVo 是前端传过来的参数，保存了审批模板ID，表单值等数据。 其中 process 为流程实体类，存放了审批发起人，请假的表单数据，审批状态等过程数据。 其中 processRecord 为流程记录表，负责记录每一次的审批流程。例如请假有三个流程，则审批通过后会有三条记录。 其中 messageService 负责推送消息给下一步的处理人。 对应的Controller接口为：ProcessApiController.startUp 对应的发起请求的前端页面为：apply.vue | 40行 查看审批任务流程参与者均可查看审批任务详情，包括填写的表单数据、审批状态、审批进度等信息。 通过processInstanceId，即流程实例ID可以获取到当前进行的任务，从中可以获取到当前所有任务的审批人，通过循环与当前登陆用户比对，可以确定登陆用户是否是任务审批人。 ProcessServiceImpl.java@Overridepublic Map&lt;String, Object&gt; show(Long id) &#123; // 获取审批信息 Process process = baseMapper.selectById(id); if (process == null) return null; // 获取审批记录信息 LambdaQueryWrapper&lt;ProcessRecord&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(ProcessRecord::getProcessId, id); List&lt;ProcessRecord&gt; processRecords = processRecordService.list(wrapper); // 获取审批模版 ProcessTemplate processTemplate = processTemplateService.getById(process.getProcessTemplateId()); // 是否可以审批 List&lt;Task&gt; taskList = this.getCurrentTaskList(process.getProcessInstanceId()); boolean isApprove = false; for (Task task : taskList) &#123; String username = LoginUserInfoHelper.getUsername(); if (task.getAssignee().equals(username)) &#123; isApprove = true; break; &#125; &#125; // 封装map数据 HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;process&quot;, process); map.put(&quot;processRecordList&quot;, processRecords); map.put(&quot;processTemplate&quot;, processTemplate); map.put(&quot;isApprove&quot;, isApprove); return map;&#125; 其中processTemplate为流程模板实体类，存放了表单模版信息，便于前端展示数据用。 其中 process 为流程实体类，存放了审批发起人，请假的表单数据，审批状态等数据。 其中 processRecord 为流程记录表，负责记录每一次的审批流程。例如请假有三个流程，则审批通过后会有三条记录。用于展示审批进度。 对应的Controller接口为：ProcessApiController.show 对应的发起请求的前端页面为：show.vue | 84行 处理审批任务负责审批的人可以选择通过和拒绝当前审批任务 首先，判断审批人是通过还是拒绝了当前审批任务，如果通过则直接complete，否则执行驳回操作； 同时，将审批消息推送给发起人； 更新 Process 信息，同时记录本次流程到 oa_process_record表； 查询下一步的审批人，推送审批消息。 ProcessServiceImpl.java@Overridepublic void approve(ApprovalVo approvalVo) &#123; // 获取流程变量 String taskId = approvalVo.getTaskId(); Process process = baseMapper.selectById(approvalVo.getProcessId()); Map&lt;String, Object&gt; variables = taskService.getVariables(taskId); if (approvalVo.getStatus() == 1) &#123; // 审批通过 taskService.complete(taskId); &#125; else &#123; // 驳回 this.endTask(taskId); &#125; // 推送给发起人 messageService.pushProcessedMessage(process, approvalVo.getStatus()); // 记录审批过程信息 String description = approvalVo.getStatus() == 1 ? &quot;已通过&quot; : &quot;已拒绝&quot;; processRecordService.record(approvalVo.getProcessId(), approvalVo.getStatus(), description); // 查询下一个审批人 List&lt;Task&gt; taskList = this.getCurrentTaskList(process.getProcessInstanceId()); if (!CollectionUtils.isEmpty(taskList)) &#123; String names = taskList.stream().map(task -&gt; &#123; String assignee = task.getAssignee(); SysUser user = sysUserService.getUserByUsername(assignee); // 推送消息 messageService.pushPendingMessage(process, user, task.getId()); return user.getName(); &#125;).collect(Collectors.joining(&quot;,&quot;)); process.setDescription(&quot;等待&quot; + names + &quot;审批&quot;); process.setStatus(1); &#125; else &#123; if (approvalVo.getStatus() == 1) &#123; process.setDescription(&quot;审批完成（通过）&quot;); process.setStatus(2); &#125; else &#123; process.setDescription(&quot;审批完成（通过）&quot;); process.setStatus(-1); &#125; &#125; baseMapper.updateById(process);&#125;// 结束流程private void endTask(String taskId) &#123; // 获取任务对象 Task task = taskService.createTaskQuery().taskId(taskId).singleResult(); // 获取流程定义模型 BpmnModel bpmnModel = repositoryService.getBpmnModel(task.getProcessDefinitionId()); // 获取结束流程节点 List&lt;EndEvent&gt; endEventList = bpmnModel.getMainProcess().findFlowElementsOfType(EndEvent.class); if (CollectionUtils.isEmpty(endEventList)) &#123; return; &#125; FlowNode endFlowNode = (FlowNode) endEventList.get(0); // 当前流向节点 FlowNode currentFlowNode = (FlowNode) bpmnModel.getMainProcess().getFlowElement(task.getTaskDefinitionKey()); // 临时保留当前活动的原始流向 // List&lt;SequenceFlow&gt; originalSequenceFlowList = new ArrayList&lt;&gt;(currentFlowNode.getOutgoingFlows()); // 清理当前流向节点 currentFlowNode.getOutgoingFlows().clear(); // 创建新流向 SequenceFlow newSequenceFlow = new SequenceFlow(); newSequenceFlow.setId(&quot;newSequenceFlow&quot;); newSequenceFlow.setSourceFlowElement(currentFlowNode); newSequenceFlow.setTargetFlowElement(endFlowNode); // 当前节点指向新方向 ArrayList&lt;SequenceFlow&gt; newSequenceFlows = new ArrayList&lt;&gt;(); newSequenceFlows.add(newSequenceFlow); currentFlowNode.setOutgoingFlows(newSequenceFlows); taskService.complete(taskId);&#125; 其中 approvalVo 记录 流程ID，任务ID，审批状态。 对应的Controller接口为：ProcessApiController.approve 对应的发起请求的前端页面为：show.vue | 106行 查询已发起流程流程实例启动时，会保存到oa_process中，其中的用户就是发起人，直接查询oa_process表即可。 @Overridepublic IPage&lt;Process&gt; pageStarted(Page&lt;Process&gt; pageParam) &#123; LambdaQueryWrapper&lt;Process&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(Process::getUserId, LoginUserInfoHelper.getUserId()); return baseMapper.selectPage(pageParam, wrapper);&#125; 其中 pageParam 是分页信息。 对应的Controller接口为：ProcessApiController.pageStarted 对应的发起请求的前端页面为：list.vue | 172行 查询已处理流程根据当前登陆用户的uername（审批人）查询其任务，在流程设计时指定了审批人为sys_user.username。 通过historyService指定审批人，可查询当前审批人已经处理的任务；通过 Task 的流程实例ID关联查询流程表（oa_process），并转换为 ProcessVo 便于前端展示。 ProcessServiceImpl.java@Overridepublic IPage&lt;ProcessVo&gt; pageProcessed(Page&lt;Process&gt; pageParam) &#123; // 封装查询信息 HistoricTaskInstanceQuery query = historyService.createHistoricTaskInstanceQuery() .taskAssignee(LoginUserInfoHelper.getUsername()) .finished() .orderByTaskCreateTime().desc(); // 分页查询已完成的任务 int begin = (int) ((pageParam.getCurrent() - 1) * pageParam.getSize()); int size = (int) pageParam.getSize(); List&lt;HistoricTaskInstance&gt; list = query.listPage(begin, size); List&lt;ProcessVo&gt; processVoList = new ArrayList&lt;&gt;(); for (HistoricTaskInstance item : list) &#123; // 根据流程实例ID获取流程信息 LambdaQueryWrapper&lt;Process&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(Process::getProcessInstanceId, item.getProcessInstanceId()); Process process = baseMapper.selectOne(wrapper); // 转换 ProcessVo processVo = new ProcessVo(); BeanUtils.copyProperties(process, processVo); processVo.setTaskId(item.getId()); processVoList.add(processVo); &#125; IPage&lt;ProcessVo&gt; page = new Page&lt;&gt;(pageParam.getCurrent(), pageParam.getSize(), query.count()); page.setRecords(processVoList); return page;&#125; 其中 pageParam 是分页信息。 对应的Controller接口为：ProcessApiController.pageProcessed 对应的发起请求的前端页面为：list.vue | 167行 查询待处理流程根据username分页查询当前用户的待处理任务，通过任务的流程实例ID关联查询业务Key，即oa_process.id，随后查询出 Process 信息。 ProcessServiceImpl.java@Overridepublic IPage&lt;ProcessVo&gt; pagePending(Page&lt;Process&gt; pageParam) &#123; TaskQuery query = taskService.createTaskQuery() .taskAssignee(LoginUserInfoHelper.getUsername()) .orderByTaskCreateTime() .desc(); int begin = (int) ((pageParam.getCurrent() - 1) * pageParam.getSize()); int size = (int) pageParam.getSize(); List&lt;Task&gt; taskList = query.listPage(begin, size); List&lt;ProcessVo&gt; processVoList = new ArrayList&lt;&gt;(); for (Task task : taskList) &#123; ProcessInstance processInstance = runtimeService.createProcessInstanceQuery() .processInstanceId(task.getProcessInstanceId()) .singleResult(); String businessKey = processInstance.getBusinessKey(); if (businessKey == null) &#123; continue; &#125; Process process = baseMapper.selectById(Long.parseLong(businessKey)); ProcessVo processVo = new ProcessVo(); BeanUtils.copyProperties(process, processVo); processVo.setTaskId(task.getId()); processVoList.add(processVo); &#125; IPage&lt;ProcessVo&gt; page = new Page&lt;&gt;(pageParam.getCurrent(), pageParam.getSize(), query.count()); page.setRecords(processVoList); return page;&#125; 其中 pageParam 是分页信息。 对应的Controller接口为：ProcessApiController.pagePending 对应的发起请求的前端页面为：list.vue | 162行"},{"title":"表单设计器","path":"/wiki/cloudoa/03_function/form-create.html","content":"流程模版设计的一个环节就是：表单设计。本次表单渲染采用@form-create&#x2F;naive-ui，表单设计采用form-designer-naiveui。 form-create 是一个可以通过 JSON 生成具有动态渲染、数据收集、验证和提交功能的表单生成组件。支持3个UI框架，并且支持生成任何 Vue 组件。内置20种常用表单组件和自定义组件，再复杂的表单都可以轻松搞定。FormCreate Vue3版本文档 form-create-designer-naiveui 是基于 @form-create&#x2F;naive-ui vue3版本实现的表单设计器组件。可以通过拖拽的方式快速创建表单，提高开发者对表单的开发效率，节省开发者的时间。"},{"title":"Spring Security","path":"/wiki/cloudoa/03_function/springsecurity.html","content":"前端可以根据权限信息控制菜单和页面展示，操作按钮的显示。但这并不够，如果有人拿到了接口，绕过了页面直接操作数据，这是很危险的。所以我们需要在后端也加入权限控制，只有拥有操作权限，该接口才能被授权访问。 在进入Controller方法前判断当前用户是否拥有访问权限，可以通过Filter加AOP的方式实现认证和授权。本次介绍的是成熟的框架：Spring Security。其他框架还有Shiro等。 Spring Security简介Spring Security的重要核心功能功能是“认证”和“授权”，即用户认证（Authentication）和用户授权（Authorization）两部分： （1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求提供用户名和密码，系统通过校验用户名和密码来完成认证过程。 （2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，用的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。 Spring Security的特点： 和Spring无缝整合 全面的权限控制 专门为Web开发而设计 重量级 Spring Boot出现后，其为Spring Security提供了自动配置方案，可以使用少量的配置来使用Spring Security。如果你的项目是基于Spring Boot的，使用Spring Security无疑是很棒的选择！ Spring Security实现权限要对Web资源进行保护，最好的办法莫过于Filter 要对方法调用进行保护，最好的方法莫过于AOP Spring Security进行认证和鉴权的时候就是利用一系列的Filter进行拦截的。 如图所示，一个请求要想访问到API就会从左到右经过蓝线框里的过滤器，其中绿色部分是负责认证的过滤器，蓝色部分就是负责异常处理，橙色部分则是负责授权。经过一系列拦截最终访问到我们的API。 FilterSecurityInterceptor：是一个方法级的过滤器，基本位于过滤链的最底部。 ExceptionTranslationFilter：是一个异常过滤器，用来处理在认证授权过程中抛出的异常。 UsernamePasswordAuthenticationFilter：对/login的POST请求做拦截，校验表单中用户名、密码。 这里我们只需要重点关注两个过滤器即可：UsernamePasswordAuthenticationFilter负责登陆认证，FilterSecurityInterceptor负责权限授权。 说明：Spring Security的核心逻辑全在这一套过滤器中，过滤器里会调用各种组件完成功能，掌握了这些过滤器和组件你就掌握了Spring Security！这个框架的使用方式就是对这些过滤器和组件进行扩展。 用户认证流程 自定义组件根据认证流程，我们需要自定义以下组件： UserDetails loadUserByUsername passwordEncoder 1、登陆Filter，判断用户名和密码是否正确，生成token 2、认证解析token组件，判断请求头是否有token，如果有认证完成 3、在配置类配置相关认证类 代码实现 完整项目地址：Server | GitHub 依赖创建一个spring-security模块（module），可以放在项目的common模块下 创建完成，导入相关的Maven依赖 pom.xml&lt;dependencies&gt; &lt;!-- Spring Security依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 工具类ResponseUtil用于写会数据给前端 Importimportimport com.fasterxml.jackson.databind.ObjectMapper;import com.swx.common.pojo.R;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import javax.servlet.http.HttpServletResponse;import java.io.IOException; utils.ResponseUtil.javapublic class ResponseUtil &#123; public static void out(HttpServletResponse response, R r) &#123; ObjectMapper mapper = new ObjectMapper(); response.setStatus(HttpStatus.OK.value()); response.setContentType(MediaType.APPLICATION_JSON_VALUE); response.setCharacterEncoding(&quot;UTF-8&quot;); try &#123; mapper.writeValue(response.getWriter(), r); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; JwtHelperImportimportpackage com.swx.common.jwt;import io.jsonwebtoken.*;import org.springframework.util.StringUtils;import java.util.Date; jwt.JwtHelper.javapublic class JwtHelper &#123; private static long tokenExpiration = 60 * 60 * 1000; private static String tokenSignKey = &quot;sw-code&quot;; public static String createToken(Long userId, String username) &#123; return Jwts.builder() .setSubject(&quot;AUTH-USER&quot;) .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration)) .claim(&quot;userId&quot;, userId) .claim(&quot;username&quot;, username) .signWith(SignatureAlgorithm.HS512, tokenSignKey) .compressWith(CompressionCodecs.GZIP) .compact(); &#125; public static Long getUserId(String token) &#123; if (StringUtils.isEmpty(token)) return null; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token); Claims body = claimsJws.getBody(); String userId = body.get(&quot;userId&quot;).toString(); return Long.parseLong(userId); &#125; public static String getUsername(String token) &#123; if (StringUtils.isEmpty(token)) return null; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token); Claims body = claimsJws.getBody(); return (String) body.get(&quot;username&quot;); &#125;&#125; 自定义UserDetail继承UserDetail的User，其中sysUser是项目数据库的实体类 Importimportimport com.swx.model.system.SysUser;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.User;import java.util.Collection; custom.CustomUser.javapublic class CustomUser extends User &#123; private SysUser sysUser; public CustomUser(SysUser sysUser, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(sysUser.getUsername(), sysUser.getPassword(), authorities); this.sysUser = sysUser; &#125; public SysUser getSysUser() &#123; return sysUser; &#125; public void setSysUser(SysUser sysUser) &#123; this.sysUser = sysUser; &#125;&#125; 自定义解码器用于匹配前端传过来的密码和数据库中的密码是否一致，其中MD5.encrypt是自定义的MD5加密工具 MD5：MD5 | GitHub Importimportimport com.swx.common.utils.MD5;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component; custom.CustomMd5PasswordEncoder.java@Componentpublic class CustomMd5PasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence rawPassword) &#123; return MD5.encrypt(rawPassword.toString()); &#125; @Override public boolean matches(CharSequence rawPassword, String encodedPassword) &#123; return encodedPassword.equals(MD5.encrypt(rawPassword.toString())); &#125;&#125; 自定义UserDetailsService该类的实现类会查询项目的数据库，根据用户名获取用户信息，包括密码等，用于匹配和授权。 注意要继承org.springframework.security.core.userdetails.UserDetailsService Importimportimport org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Component; custom.UserDetailsService.java@Componentpublic interface UserDetailsService extends org.springframework.security.core.userdetails.UserDetailsService &#123; /** * 根据用户名获取用户对象，获取不到直接抛异常 */ @Override UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;&#125; 实现该类 该实现可以放到项目的service.impl中，就像项目其他Service的实现类一样 SysUserService：SysUserServiceImpl | GitHub SysMenuService：SysMenuServiceImpl | GitHub Permission：Permission | GitHub Importimportimport com.swx.auth.service.SysMenuService;import com.swx.auth.service.SysUserService;import com.swx.model.system.SysUser;import com.swx.security.custom.CustomUser;import com.swx.security.custom.UserDetailsService;import com.swx.vo.system.Permission;import org.springframework.security.authentication.DisabledException;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Collections;import java.util.List; impl.UserDetailsServiceImpl.java@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; private final SysUserService sysUserService; private final SysMenuService sysMenuService; public UserDetailsServiceImpl(SysUserService sysUserService, SysMenuService sysMenuService) &#123; this.sysUserService = sysUserService; this.sysMenuService = sysMenuService; &#125; /** * 根据用户名获取用户对象，获取不到直接抛异常 */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; // 根据用户名查询 SysUser sysUser = sysUserService.getUserByUsername(username); if (null == sysUser) &#123; throw new UsernameNotFoundException(&quot;用户名不存在！&quot;); &#125; if (sysUser.getStatus() == 0) &#123; throw new DisabledException(&quot;disable&quot;); &#125; // 查询权限列表 List&lt;Permission&gt; permissions = sysMenuService.queryUserAuthListByUserId(sysUser.getId()); // 封装Spring Security的权限类型 List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); permissions.forEach(permission -&gt; &#123; authorities.add(new SimpleGrantedAuthority(permission.getAuth().trim())); &#125;); return new CustomUser(sysUser, authorities); &#125;&#125; 拦截器TokenLoginFilter获得输入的用户名和密码，封装成框架要求的对象，调用认证方法。认证成功则将权限信息存入Redis，并返回Token给前端。 该类继承UsernamePasswordAuthenticationFilter，实现登陆的拦截校验。 Importimportimport com.alibaba.fastjson2.JSON;import com.fasterxml.jackson.databind.ObjectMapper;import com.swx.common.jwt.JwtHelper;import com.swx.common.pojo.R;import com.swx.common.pojo.ResultCode;import com.swx.common.utils.ResponseUtil;import com.swx.security.custom.CustomUser;import com.swx.vo.system.LoginVo;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.BadCredentialsException;import org.springframework.security.authentication.DisabledException;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import org.springframework.security.web.util.matcher.AntPathRequestMatcher;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap; filter.TokenLoginFilter.java/** * 获得输入的用户名和密码，封装成框架要求的对象，调用认证方法 */public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter &#123; private final RedisTemplate&lt;String, String&gt; redisTemplate; // 构造方法 public TokenLoginFilter(AuthenticationManager authenticationManager, RedisTemplate&lt;String, String&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; this.setAuthenticationManager(authenticationManager); this.setPostOnly(false); // 指定登陆接口及提交方式，可以指定任意路径 this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;/admin/system/index/login&quot;, &quot;POST&quot;)); &#125; // 登陆认证 // 获取输入的用户名和密码，调用方法认证 @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; try &#123; // 获取用户信息 LoginVo loginVo = new ObjectMapper().readValue(request.getInputStream(), LoginVo.class); // 封装对象 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginVo.getUsername(), loginVo.getPassword()); // 调用方法 return this.getAuthenticationManager().authenticate(authenticationToken); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; // 认证成功调用的方法 @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; // 获取当前用户 CustomUser customUser = (CustomUser) authResult.getPrincipal(); // 生成Token String token = JwtHelper.createToken(customUser.getSysUser().getId(), customUser.getSysUser().getUsername()); // 获取当前用户的权限数据，放到Redis中，key: username value: permissions redisTemplate.opsForValue().set( customUser.getUsername(), JSON.toJSONString(customUser.getAuthorities())); // 返回 HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;, token); ResponseUtil.out(response, R.success(map)); &#125; // 认证失败调用的方法 @Override protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123; // 封装错误信息，用于返回 R r = R.fail(ResultCode.LOGIN_AUTH_FAIL); Throwable ex = failed.getCause(); if (ex instanceof DisabledException) &#123; r.setResultCode(ResultCode.USER_DISABLE); &#125; else if (failed instanceof UsernameNotFoundException || failed instanceof BadCredentialsException) &#123; r.setResultCode(ResultCode.USER_LOGIN_ERROR); &#125; ResponseUtil.out(response, r); &#125;&#125; TokenAuthenticationFilter判断是否完成认证，将认证信息保存到Security上下文中 Importimportimport com.alibaba.fastjson2.JSON;import com.swx.common.jwt.JwtHelper;import com.swx.common.pojo.R;import com.swx.common.pojo.ResultCode;import com.swx.common.utils.ResponseUtil;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.util.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Map; filter.TokenAuthenticationFilter.java/** * 判断是否完成认证 */public class TokenAuthenticationFilter extends OncePerRequestFilter &#123; private final RedisTemplate&lt;String, String&gt; redisTemplate; public TokenAuthenticationFilter(RedisTemplate&lt;String, String&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; // 如果是登陆接口，直接放行 if (&quot;/admin/system/index/login&quot;.equals(request.getRequestURI())) &#123; chain.doFilter(request, response); return; &#125; try &#123; UsernamePasswordAuthenticationToken authentication = getAuthentication(request); if (null != authentication) &#123; SecurityContextHolder.getContext().setAuthentication(authentication); chain.doFilter(request, response); &#125; else &#123; ResponseUtil.out(response, R.fail(ResultCode.LOGIN_AUTH_FAIL)); &#125; &#125; catch (JwtException e) &#123; SecurityContextHolder.getContext().setAuthentication(null); R r = R.fail(ResultCode.TOKEN_INVALID); if (e instanceof UnsupportedJwtException) &#123; r.setResultCode(ResultCode.TOKEN_UNSUPPORTED); &#125; ResponseUtil.out(response, r); &#125; &#125; private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) &#123; String token = request.getHeader(&quot;Authorization&quot;); if (!StringUtils.isEmpty(token)) &#123; String username = JwtHelper.getUsername(token); if (!StringUtils.isEmpty(username)) &#123; // 从redis中获取权限数据 String authString = redisTemplate.opsForValue().get(username); if (!StringUtils.isEmpty(authString)) &#123; List&lt;Map&gt; mapList = JSON.parseArray(authString, Map.class); System.out.println(mapList); List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); mapList.forEach(map -&gt; &#123; String authority = (String) map.get(&quot;authority&quot;); authorities.add(new SimpleGrantedAuthority(authority)); &#125;); return new UsernamePasswordAuthenticationToken(username, null, authorities); &#125; else &#123; return new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList()); &#125; &#125; &#125; return null; &#125;&#125; 配置文件创建一个Spring Security的配置文件，开启相关的注解 Importimportimport com.swx.security.custom.CustomMd5PasswordEncoder;import com.swx.security.filter.TokenAuthenticationFilter;import com.swx.security.filter.TokenLoginFilter;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; config.WebSecurityConfig.java@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; private final UserDetailsService userDetailsService; private final CustomMd5PasswordEncoder customMd5PasswordEncoder; private final RedisTemplate&lt;String, String&gt; redisTemplate; public WebSecurityConfig(UserDetailsService userDetailsService, CustomMd5PasswordEncoder customMd5PasswordEncoder, RedisTemplate&lt;String, String&gt; redisTemplate) &#123; this.userDetailsService = userDetailsService; this.customMd5PasswordEncoder = customMd5PasswordEncoder; this.redisTemplate = redisTemplate; &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable() .cors().and() .authorizeRequests() .antMatchers(&quot;/admin/system/index/login&quot;).permitAll() .anyRequest().authenticated() .and() .addFilterBefore(new TokenAuthenticationFilter(redisTemplate), UsernamePasswordAuthenticationFilter.class) .addFilter(new TokenLoginFilter(authenticationManager(), redisTemplate)); http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(customMd5PasswordEncoder); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/favicon.icon&quot;, &quot;/swagger-resources/**&quot;, &quot;webjars/**&quot;, &quot;/v2/**&quot;, &quot;swagger-ui.html/**&quot;, &quot;doc.html&quot;); &#125;&#125; 食用教程可以在业务模块中导入pom信息 &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;spring-security&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 在需要授权的接口上加入注解，就像这样 RoleController.java@Api(tags = &quot;角色管理接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/admin/system/sysRole&quot;)public class SysRoleController &#123; private final SysRoleService sysRoleService; public SysRoleController(SysRoleService sysRoleService) &#123; this.sysRoleService = sysRoleService; &#125; @ApiOperation(&quot;为用户分配角色&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_assign&#x27;)&quot;) @PostMapping(&quot;/doAssign&quot;) public void doAssign(@RequestBody AssignRoleVo assignRoleVo) &#123; sysRoleService.doAssign(assignRoleVo); &#125; @ApiOperation(&quot;查询所有角色&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_list&#x27;)&quot;) @GetMapping(&quot;/findAll&quot;) public List&lt;SysRole&gt; findAll() &#123; return sysRoleService.list(); &#125; /** * * @param page 当前页 * @param limit 记录数 * @param sysRoleQueryVo 查询参数 * @return 分页信息 */ @ApiOperation(&quot;条件分页查询&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_list&#x27;)&quot;) @GetMapping(&quot;&#123;page&#125;/&#123;limit&#125;&quot;) public IPage&lt;SysRole&gt; pageQueryRole(@PathVariable Long page, @PathVariable Long limit, SysRoleQueryVo sysRoleQueryVo) &#123; // 自定义Page，修改current为page，和前端保持一致 CustomPage&lt;SysRole&gt; pageParam = new CustomPage&lt;&gt;(page, limit); LambdaQueryWrapper&lt;SysRole&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); String roleName = sysRoleQueryVo.getRoleName(); if (!StringUtils.isEmpty(roleName)) &#123; wrapper.like(SysRole::getRoleName, roleName); &#125; IPage&lt;SysRole&gt; iPage = sysRoleService.page(pageParam, wrapper); return iPage; &#125; @ApiOperation(&quot;添加角色&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_add&#x27;)&quot;) @PostMapping(&quot;&quot;) public void save(@RequestBody SysRole role) &#123; boolean save = sysRoleService.save(role); if (!save) &#123; throw new BizException(&quot;添加失败&quot;); &#125; &#125; /** * 根据id查询角色 * @param id 角色id * @return 角色 */ @ApiOperation(&quot;根据ID查询&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_list&#x27;)&quot;) @GetMapping(&quot;&#123;id&#125;&quot;) public SysRole get(@PathVariable Long id) &#123; return sysRoleService.getById(id); &#125; /** * 更新角色 * @param role 角色信息 */ @ApiOperation(&quot;更新角色&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_update&#x27;)&quot;) @PutMapping(&quot;&quot;) public void update(@RequestBody SysRole role) &#123; boolean update = sysRoleService.updateById(role); if (!update) &#123; throw new BizException(&quot;更新失败&quot;); &#125; &#125; @ApiOperation(&quot;根据id删除&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_remove&#x27;)&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public void delete(@PathVariable Long id) &#123; boolean delete = sysRoleService.removeById(id); if (!delete) &#123; throw new BizException(&quot;删除失败&quot;); &#125; &#125; @ApiOperation(&quot;批量删除&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system_role_remove&#x27;)&quot;) @DeleteMapping(&quot;batch&quot;) public void batchRemove(@RequestBody List&lt;Long&gt; ids) &#123; boolean delete = sysRoleService.removeByIds(ids); if (!delete) &#123; throw new BizException(&quot;删除失败&quot;); &#125; &#125;&#125;"},{"title":"微信公众号","path":"/wiki/cloudoa/03_function/wechat.html","content":"该部分内容包括： 公众号的申请、登陆以及绑定用户 公众号菜单的推送和删除 内网穿透工具的使用 公众号申请打开微信公众平台，登陆： https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/loginhttps://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login 菜单推送实现效果 工具依赖使用工具完成菜单推送、消息推送等功能。 &lt;dependency&gt; &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt; &lt;artifactId&gt;wx-java-mp-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt; 小程序配置拷贝微信公众平台的 appID 和 appsecret application-dev.yamlwx: mp: app-id: wxxxxxxxxxxxxxxxxx secret: xxxxxxxxxxxxxxxxxxxxxx URL设置公众号菜单的类型一共有三种： view：表示网页类型 click：表示点击类型 miniprogram：表示小程序类型 我们需要设置网页类型的跳转URL，可以在配置文件中固定 application-dev.yamlwechat: prefix: http://vvvckt.natappfree.cc/oa/# 代码实现MenuServiceImpl.java@Servicepublic class MenuServiceImpl extends ServiceImpl&lt;MenuMapper, Menu&gt; implements MenuService &#123; private final WxMpService wxMpService; @Value(&quot;$&#123;wechat.prefix&#125;&quot;) private String prefix; public MenuServiceImpl(WxMpService wxMpService) &#123; this.wxMpService = wxMpService; &#125; /** * 获取所有菜单 */ @Override public List&lt;Menu&gt; listMenu() &#123; List&lt;Menu&gt; menuList = baseMapper.selectList(null); List&lt;Menu&gt; parents = menuList.stream() .filter(menu -&gt; menu.getParentId() == 0) .collect(Collectors.toList()); ArrayList&lt;Menu&gt; menus = new ArrayList&lt;&gt;(); for (Menu menu : parents) &#123; List&lt;Menu&gt; children = menuList.stream() .filter(item -&gt; Objects.equals(item.getParentId(), menu.getId())) .collect(Collectors.toList()); menu.setChildren(children); menus.add(menu); &#125; return menus; &#125; /** * 同步菜单到微信公众号 */ @Override public void syncMenu() throws WxErrorException &#123; // 查询菜单数据，封装成微信官方格式 List&lt;Menu&gt; menuList = this.listMenu(); // 菜单 JSONArray buttonList = new JSONArray(); for (Menu menu : menuList) &#123; JSONObject button = new JSONObject(); button.put(&quot;name&quot;, menu.getName()); if (CollectionUtils.isEmpty(menu.getChildren())) &#123; button.put(&quot;type&quot;, menu.getType()); button.put(&quot;url&quot;, prefix + menu.getUrl()); &#125; else &#123; JSONArray subButton = new JSONArray(); for (Menu child : menu.getChildren()) &#123; JSONObject view = new JSONObject(); String type = child.getType(); view.put(&quot;type&quot;, type); view.put(&quot;name&quot;, child.getName()); if (type.equals(&quot;click&quot;)) &#123; // 点击类型 view.put(&quot;key&quot;, child.getMeunKey()); &#125; else &#123; // 网页或者小程序类型 view.put(&quot;url&quot;, prefix + child.getUrl()); &#125; subButton.add(view); &#125; button.put(&quot;sub_button&quot;, subButton); &#125; buttonList.add(button); &#125; // 菜单对象 JSONObject button = new JSONObject(); button.put(&quot;button&quot;, buttonList); // 推送 wxMpService.getMenuService().menuCreate(button.toString()); &#125; /** * 删除微信公众号菜单 */ @Override public void removeMenu() throws WxErrorException &#123; wxMpService.getMenuService().menuDelete(); &#125;&#125; MenuServiceImpl 包括查询菜单，同步菜单，删除菜单功能。 官方对自定义菜单格式要求如下: &#123; &quot;button&quot;:[ &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;今日歌曲&quot;, &quot;key&quot;:&quot;V1001_TODAY_MUSIC&quot; &#125;, &#123; &quot;name&quot;:&quot;菜单&quot;, &quot;sub_button&quot;:[ &#123; &quot;type&quot;:&quot;view&quot;, &quot;name&quot;:&quot;搜索&quot;, &quot;url&quot;:&quot;http://www.soso.com/&quot; &#125;, &#123; &quot;type&quot;:&quot;miniprogram&quot;, &quot;name&quot;:&quot;wxa&quot;, &quot;url&quot;:&quot;http://mp.weixin.qq.com&quot;, &quot;appid&quot;:&quot;wx286b93c14bbf93aa&quot;, &quot;pagepath&quot;:&quot;pages/lunar/index&quot; &#125;, &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;赞一下我们&quot;, &quot;key&quot;:&quot;V1001_GOOD&quot; &#125;] &#125;]&#125; 授权登陆创建登陆页面，负责判断是否需要授权以及获取token等信息。 授权唤起页面：首页(无token) &gt; 登陆页 &gt; 授权页(微信官方) &gt; 登陆页 &gt; 首页。 详细流程： 用户尝试进入首页面（其他需要授权的页面），在路由守卫判断token，不存在跳转到登陆页。 router.beforeEach((to) =&gt; &#123; if (to.meta.requireAuth &amp;&amp; !storage.get(ACCESS_TOKEN)) &#123; return &#123; path: &#x27;/login&#x27;, query: &#123; redirect: to.fullPath &#125;, &#125;; &#125;&#125;); 进入登陆页，尝试获取 URL 中的code参数，如果有参数，发起请求尝试获取token；没有参数，尝试获取token，如果有则说明已经登陆过（浏览器返回上一页导致），没有则请求授权URL。 let code = getRouteQuery().code;if (code) &#123; getUserInfo(code).then((res) =&gt; &#123; const &#123; token, openId &#125; = res; if (!token &amp;&amp; openId) &#123; // 未绑定 bindPhoneVo.openId = openId; show.value = true; &#125; else &#123; // 记录token storage.set(ACCESS_TOKEN, res.token); const redirect = storage.get(LAND_PAGE) || &#x27;/&#x27;; redirectTo(redirect); &#125; &#125;);&#125; function handleLogin() &#123; const token = storage.get(ACCESS_TOKEN); // 记录上一个页面地址 const &#123; redirect &#125; = getRouteQuery(); if (redirect) &#123; storage.set(LAND_PAGE, redirect); &#125; if (!token) &#123; // 跳转授权 const REDIRECT_URI = window.location.href; const REDIRECT_URI_EC = encodeURIComponent(REDIRECT_URI); jump2Auth(REDIRECT_URI_EC).then((res) =&gt; &#123; window.location.replace(res.redirectUrl); &#125;); &#125; // 点击返回进入的该页面，此时无code redirectTo(redirect);&#125; 完整的代码如下： Controller：WechatController Vue：login.vue 配置回调页面域名在公众平台 &gt; 网页服务 &gt; 网页账号 &gt; 修改，我们回调的页面是前端的登陆页面，这里填写前端页面的URI。 注意不要写http 获取code按照官方要求向其服务发送请求，携带redirect_url等参数，该请求会返回code等信息。 请求 URL 这里交给服务器进行拼接，Controller代码如下： @GetMapping(&quot;/authorize&quot;)public Map&lt;String, String&gt; authorize(@RequestParam(&quot;redirect_url&quot;) String returnUrl) &#123; String redirectURL = wxMpService.getOAuth2Service() .buildAuthorizationUrl(URLDecoder.decode(returnUrl), WxConsts.OAuth2Scope.SNSAPI_USERINFO, null); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;redirectUrl&quot;, redirectURL); return map;&#125; 前端拿到redirectUrl之后，直接发起请求即可 const REDIRECT_URI = window.location.href;const REDIRECT_URI_EC = encodeURIComponent(REDIRECT_URI);jump2Auth(REDIRECT_URI_EC).then((res) =&gt; &#123; window.location.replace(res.redirectUrl);&#125;); 这里直接将redirect_url设置为登陆页，即请求成功后重定向到登陆页。 获取openId有了code就可以获取openId和userInfo等信息： @GetMapping(&quot;/userInfo&quot;)public Map&lt;String, String&gt; userInfo(@RequestParam(&quot;code&quot;) String code) throws WxErrorException &#123; WxOAuth2AccessToken accessToken = wxMpService.getOAuth2Service().getAccessToken(code); String openId = accessToken.getOpenId(); WxOAuth2UserInfo wxMpUser = wxMpService.getOAuth2Service().getUserInfo(accessToken, null); SysUser sysUser = sysUserService.getOne(new LambdaQueryWrapper&lt;SysUser&gt;().eq(SysUser::getOpenId, openId)); String token = null; if (null != sysUser) &#123; // 已经绑定过了 token = JwtHelper.createToken(sysUser.getId(), sysUser.getUsername()); &#125; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;, token); map.put(&quot;openId&quot;, openId); return map;&#125; 如果绑定过了，会携带token返回 前端通过是否有 token 判断是否绑定，唤起绑定功能： getUserInfo(code).then((res) =&gt; &#123; const &#123; token, openId &#125; = res; if (!token &amp;&amp; openId) &#123; // 未绑定 bindPhoneVo.openId = openId; show.value = true; &#125; else &#123; loading.value = false; // 记录token storage.set(ACCESS_TOKEN, res.token); const redirect = storage.get(LAND_PAGE) || &#x27;/&#x27;; redirectTo(redirect); &#125;&#125;); 消息推送微信消息推送需要安装官方提供的模板，点击新增测试模板 模板设置待处理审批 &#123;&#123;first.DATA&#125;&#125;审批编号: &#123;&#123;keyword1.DATA&#125;&#125;提交时间: &#123;&#123;keyword2.DATA&#125;&#125;&#123;&#123;content.DATA&#125;&#125; 审批已处理 &#123;&#123;first.DATA&#125;&#125; 审批编号：&#123;&#123;keyword1.DATA&#125;&#125;提交时间：&#123;&#123;keyword2.DATA&#125;&#125;审批状态：&#123;&#123;keyword3.DATA&#125;&#125;当前审批人：&#123;&#123;keyword4.DATA&#125;&#125;&#123;&#123;content.DATA&#125;&#125; 代码实现MessageServiceImpl.java@Servicepublic class MessageServiceImpl implements MessageService &#123; private final WxMpService wxMpService; private final ProcessTemplateService processTemplateService; private final SysUserService sysUserService; @Value(&quot;$&#123;wechat.prefix&#125;&quot;) private String prefix; public MessageServiceImpl(WxMpService wxMpService, ProcessTemplateService processTemplateService, SysUserService sysUserService) &#123; this.wxMpService = wxMpService; this.processTemplateService = processTemplateService; this.sysUserService = sysUserService; &#125; /** * 推送待审批人员 * * @param process 流程ID * @param user 用户ID * @param taskId 任务ID */ @SneakyThrows @Override public void pushPendingMessage(Process process, SysUser user, String taskId) &#123; // 根据这些ID查询数据 ProcessTemplate processTemplate = processTemplateService.getOne( new LambdaQueryWrapper&lt;ProcessTemplate&gt;() .select(ProcessTemplate::getName) .eq(ProcessTemplate::getId, process.getProcessTemplateId())); SysUser submitUser = sysUserService.getOne( new LambdaQueryWrapper&lt;SysUser&gt;() .select(SysUser::getName) .eq(SysUser::getId, LoginUserInfoHelper.getUserId())); String openId = user.getOpenId(); if (openId == null) &#123; return; &#125; // 构建模板消息 WxMpTemplateMessage templateMessage = WxMpTemplateMessage.builder() .toUser(openId) // 消息接受人的openId .templateId(&quot;PJaBg1zM5JeOsyc8T-2YVrYchQawCTT6etOhrpVequU&quot;) // 模板ID .url(prefix + &quot;/show/&quot; + process.getId() + &quot;/&quot; + taskId + &quot;/0&quot;) .build(); JSONObject jsonObject = JSON.parseObject(process.getFormValues()); JSONObject formShowData = jsonObject.getJSONObject(&quot;formShowData&quot;); StringBuilder content = new StringBuilder(); for (Map.Entry&lt;String, Object&gt; entry : formShowData.entrySet()) &#123; content.append(entry.getKey()).append(&quot;: &quot;).append(entry.getValue()).append(&quot; &quot;); &#125; // 设置模板变量值 templateMessage.addData(new WxMpTemplateData(&quot;first&quot;, submitUser.getName() + &quot;提交&quot; + processTemplate.getName() + &quot;审批申请, 请注意查看。&quot;, &quot;#272727&quot;)); templateMessage.addData(new WxMpTemplateData(&quot;keyword1&quot;, process.getProcessCode(), &quot;#272727&quot;)); templateMessage.addData(new WxMpTemplateData(&quot;keyword2&quot;, new DateTime(process.getCreateTime()).toString(&quot;yyyy-MM-dd HH:mm:ss&quot;), &quot;#272727&quot;)); templateMessage.addData(new WxMpTemplateData(&quot;content&quot;, content.toString(), &quot;#272727&quot;)); // 发送消息 wxMpService.getTemplateMsgService().sendTemplateMsg(templateMessage); &#125; /** * 推送给审批发起人 * * @param process 流程ID * @param status 任务ID */ @SneakyThrows @Override public void pushProcessedMessage(Process process, Integer status) &#123; ProcessTemplate processTemplate = processTemplateService.getOne( new LambdaQueryWrapper&lt;ProcessTemplate&gt;() .select(ProcessTemplate::getName) .eq(ProcessTemplate::getId, process.getProcessTemplateId())); SysUser user = sysUserService.getById(process.getUserId()); SysUser currentUser = sysUserService.getById(LoginUserInfoHelper.getUserId()); String openId = user.getOpenId(); if (openId == null) &#123; return; &#125; // 构建模板消息 WxMpTemplateMessage templateMessage = WxMpTemplateMessage.builder() .toUser(openId) // 消息接受人的openId .templateId(&quot;FUinAm420s82h7nHRFB-cuZFgOxdVJTtv4faWn2xA74&quot;) // 模板ID .url(prefix + &quot;/show/&quot; + process.getId() + &quot;/0/0&quot;) .build(); JSONObject jsonObject = JSON.parseObject(process.getFormValues()); JSONObject formShowData = jsonObject.getJSONObject(&quot;formShowData&quot;); StringBuilder content = new StringBuilder(); for (Map.Entry&lt;String, Object&gt; entry : formShowData.entrySet()) &#123; content.append(entry.getKey()).append(&quot;: &quot;).append(entry.getValue()).append(&quot; &quot;); &#125; // 设置模板变量值 templateMessage.addData(new WxMpTemplateData(&quot;first&quot;, user.getName() + &quot;你发起的&quot; + processTemplate.getName() + &quot;审批申请已经被处理了，请注意查看。&quot;, &quot;#272727&quot;)); templateMessage.addData(new WxMpTemplateData(&quot;keyword1&quot;, process.getProcessCode(), &quot;#272727&quot;)); templateMessage.addData(new WxMpTemplateData(&quot;keyword2&quot;, new DateTime(process.getCreateTime()).toString(&quot;yyyy-MM-dd HH:mm:ss&quot;), &quot;#272727&quot;)); templateMessage.addData(new WxMpTemplateData(&quot;keyword3&quot;, status == 1 ? &quot;审批通过&quot; : &quot;审批拒绝&quot;, status == 1 ? &quot;#009966&quot; : &quot;#FF0033&quot;)); templateMessage.addData(new WxMpTemplateData(&quot;keyword4&quot;, currentUser.getName(), &quot;#272727&quot;)); templateMessage.addData(new WxMpTemplateData(&quot;content&quot;, content.toString(), &quot;#272727&quot;)); // 发送消息 wxMpService.getTemplateMsgService().sendTemplateMsg(templateMessage); &#125;&#125;"},{"title":"笔记简介","path":"/wiki/docker/01_introduce/index.html","content":"笔记基于B站遇见狂神说 Docker入门部分和 尚硅谷的Docker高级部分教程 Docker入门 Docker高级 从Docker历史，概念，到命令的详解 从使用到深入原理和网络，大量的实战，带你彻底掌握Docker！ 给你带来最全面的Docker讲解，学Docker，这一套课就够了！ 链接地址： 【狂神说Java】Docker最新超详细版教程通俗易懂https://www.bilibili.com/video/BV1og4y1q7M4 尚硅谷Docker实战教程（docker教程天花板）https://www.bilibili.com/video/BV1gr4y1U7CY"},{"title":"DockerFile","path":"/wiki/docker/03_advance/DockerFile.html","content":"Dockerfile就是用来创建docker镜像的构建文件——命令脚本。 案例 CentOS FROM scratchADD centos-7-x86_64-docker.tar.xz / LABEL \\ org.label-schema.schema-version=&quot;1.0&quot; \\ org.label-schema.name=&quot;CentOS Base Image&quot; \\ org.label-schema.vendor=&quot;CentOS&quot; \\ org.label-schema.license=&quot;GPLv2&quot; \\ org.label-schema.build-date=&quot;20201113&quot; \\ org.opencontainers.image.title=&quot;CentOS Base Image&quot; \\ org.opencontainers.image.vendor=&quot;CentOS&quot; \\ org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \\ org.opencontainers.image.created=&quot;2020-11-13 00:00:00+00:00&quot;RUN rm -rf /var/cache &amp;&amp; rm -rf /tmp/*CMD [&quot;/bin/bash&quot;] Docker指令基础知识： 每个保留关键字（指令）都必须是大写字母 从上到下顺序执行 #表示注释 每一个指令都会创建一个新的镜像层，并提交！ 命令 解释 FROM 基础镜像 MAINTAINER 镜像编写者，姓名+邮箱 RUN 运行 ADD 添加 WORKDIR 镜像工作目录 VOLUME 挂载的目录 EXPOSE 暴露端口 CMD 指定容器启动时要运行的命令，最后一个生效 ENTRYPOINT 指定容器启动时要运行的命令 ONBUILD 被继承时运行该指令，触发指令 COPY 类似ADD，将文件拷贝到镜像中 ENV 构建时设置环境变量 实战测试Docker Hub中99%的镜像都是从这个基础镜像过来的 FROM scratch，然后添加需要的软件和配置来进行构建 构建CentOS 创建一个自己的CentOS 添加vim、ifconfig命令，编写DockerFile文件 FROM centos:7MAINTAINER swcode&lt;2627311935@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;构建完成&quot;CMD /bin/bash 构建CentOS docker build -f mydockerfile -t mycentos:0.1 . 成功之后会打印 Successfully built d2a4569364a1Successfully tagged mycentos:0.1 测试运行 docker run -it mycentos:0.1pwdifconfig vim test.txt 查看镜像构建过程 docker history CMD和ENTRYPOINT CMD 和 ENTRYPOINT 区别 命令 描述 CMD 指定容器启动时要运行的命令，最后一个生效 ENTRYPOINT 指定容器启动时要运行的命令，可追加 测试CMD新建dockerfile FROM centos:7CMD [&quot;ls&quot;, &quot;-a&quot;] 构建 docker build -f dockerfile-cmd-test -t cmdtest . 尝试追加-l，无法执行，报错。 [root@swcode dockerfile]# docker run -it cmdtest -ldocker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.ERRO[0000] error waiting for container: context canceled 测试ENTRYPOINT新建dockerfile FROM centos:7ENTRYPOINT [&quot;ls&quot;, &quot;-a&quot;] 构建 docker build -f dockerfile-entrypoint-test -t entrypoint-test . 追加-l，成功执行。 [root@swcode dockerfile]# docker run -it entrypoint-test -ltotal 64drwxr-xr-x 1 root root 4096 Feb 15 08:17 .drwxr-xr-x 1 root root 4096 Feb 15 08:17 ..-rwxr-xr-x 1 root root 0 Feb 15 08:17 .dockerenv-rw-r--r-- 1 root root 12114 Nov 13 2020 anaconda-post.loglrwxrwxrwx 1 root root 7 Nov 13 2020 bin -&gt; usr/bin 构建Tomcat1、准备镜像文件 tomcat 压缩包，jdk的压缩包 2、编写dockerfile文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f。 touch readme.txtvim Dokcerfile 写入以下内容 FROM centos:7MAINTAINER swcode&lt;2627311935àqq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u351-linux-x64.tar /usr/localADD apache-tomcat-9.0.71.tar.gz /usr/localRUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_351ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.71ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.71ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.71/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.71/bin/logs/catalina.out 3、构建镜像 docker build -t diytomcat:1.0 . 4、启动镜像 docker run -d -p 9090:8080 --name swcode-tomcat -v /home/swcode/build/tomcat/test:/usr/local/apache-tomcat-9.0.71/webapps/test -v /home/swcode/build/tomcat/logs/:/usr/local/apache-tomcat-9.0.71/logs diytomcat:1.0 5、启动成功，访问ip:9090 6、发布项目 cd /home/swcode/build/tomcat/testmkdir WEB-INFvim web.xml 写入以下内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;4.0&quot;&gt;&lt;/web-app&gt; 创建首页面index.jsp cd /home/swcode/build/tomcat/testvim index.jsp 写入以下内容 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World!&lt;br/&gt; &lt;% out.println(&quot;项目发布成功&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 访问ip:9090/test 发布镜像发布到Docker Hub Docker Hub：https://hub.docker.com 1、注册账号、登陆 [root@swcode tomcat]# docker login --helpUsage: docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username 2、提交自己的镜像 docker push swcode/diytomcat:1.0 发布到阿里云小结"},{"title":"Docker网络","path":"/wiki/docker/03_advance/Docker网络.html","content":"docker network使用--help查看network使用方式 [root@swcode ~]# docker network --helpUsage: docker network COMMANDManage networksCommands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networks 使用ls查看所有网络 [root@swcode ~]# docker network lsNETWORK ID NAME DRIVER SCOPE0bfe49ec372b bridge bridge local4f6ec0890427 host host local2ca07ec568c5 none null local 使用inspect查看docker0 docker network inspect 0bfe49ec372b 可以看到docker0的网络详情，其包含了tomcat01、tomcat02、tomcat03[ &#123; &quot;Name&quot;: &quot;bridge&quot;, &quot;IPAM&quot;: &#123; &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot; &#125; ] &#125;, &quot;Containers&quot;: &#123; &quot;062f1a9677094d08ce8bddc6e0d41b6b1a395afe95fd1fbccbc129e912e6dab7&quot;: &#123; &quot;Name&quot;: &quot;tomcat03&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.4/16&quot;, &#125;, &quot;c1add455e03f33968ab0be978ea4d533c922cd9a4146c6a97f1c6b78e4dd511d&quot;: &#123; &quot;Name&quot;: &quot;tomcat02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, &#125;, &quot;f3d377a46406a15d05b45e4ee67492ac81043fd76d20c4d397f36ae0cb7fe7d2&quot;: &#123; &quot;Name&quot;: &quot;tomcat01&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &#125; &#125;] 理解docker0清空所有环境 docker rmi -f $(docker images -qa) docker0网卡 [root@swcode tomcat]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:16:3e:03:09:f5 brd ff:ff:ff:ff:ff:ff inet 172.31.193.36/20 brd 172.31.207.255 scope global dynamic eth0 valid_lft 315198125sec preferred_lft 315198125sec3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:47:54:0e:ef brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 1 是本机地址 2 是阿里云内网地址 3 是docker0地址 测试启动一个tomcat docker run -d -P --name tomcat01 tomcat 查看网卡，其中eth0@if31就是docker分配的 [root@swcode tomcat]# docker exec tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever30: eth0@if31: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 如果报错，先安装iproute2 docker exec tomcat01 apt updatedocker exec tomcat01 apt install -y iproute2 Linux可以ping通容器内部 [root@swcode tomcat]# ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.064 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.049 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.045 ms 原理 我们每启动一个docker容器，docker就会给容器分配一个ip 每一个安装了Docker的Linux主机都有一个网卡docker0 桥接模式，使用技术是veth-pair技术 再次使用ip addr查看网卡信息 [root@swcode tomcat]# ip addr1: ...2: ...3: ...31: vethd439d37@if30: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether 1a:6c:aa:da:11:3b brd ff:ff:ff:ff:ff:ff link-netnsid 0 当启动容器时，容器内和主机上会出现相对应的一对网卡信息，veth-pair充当一个桥梁，连接各种虚拟网络设备。 容器与容器连通创建tomcat02容器，ping容器tomcat01 docker run -d -P --name tomcat02 tomcatdocker exec tomcat02 apt updatedocker exec tomcat02 apt install -y iputils-ping[root@swcode tomcat]# docker exec tomcat02 ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.070 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.066 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.050 ms 结论：tomcat01和tomcat02是共用的一个路由器，docker0 所有容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP 容器删除，对应的网桥就没了！ 容器互联–link 使用容器名连通，而非ip 启动tomcat03容器 docker run -d -P --name tomcat03 --link tomcat02 tomcat 安装iproute2 docker exec tomcat03 apt updatedocker exec tomcat03 apt install -y iputils-ping 尝试tomcat03 ping tomcat02，成功 [root@swcode ~]# docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.075 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.044 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.048 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.048 ms 当我们使用tomcat02 ping tomcat03，失败 [root@swcode ~]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known 原因如下： 查看容器容器信息查看tomcat03的信息，有对应的Links信息docker inspect tomcat03&#123; &quot;Links&quot;: [ &quot;/tomcat02:/tomcat03/tomcat02&quot; ],&#125;查看tomcat02的信息，没有对应的信息docker inspect tomcat02&#123; &quot;Links&quot;: null&#125; 查看host信息查看tomcat03的host信息，可以看到tomcat02有域名的映射[root@swcode ~]# docker exec tomcat03 cat /etc/hosts127.0.0.1 localhost172.17.0.3 tomcat02 c1add455e03f172.17.0.4 062f1a967709查看tomcat02的host信息，发现没有tomcat03的域名的映射[root@swcode ~]# docker exec tomcat02 cat /etc/hosts127.0.0.1 localhost172.17.0.3 c1add455e03f --link就是在host配置中增加了一个172.17.0.3 tomcat02 c1add455e03f映射，不建议使用！ 自定义网络 使用自定义网络实现容器互联 查看所有网络 [root@swcode ~]# docker network lsNETWORK ID NAME DRIVER SCOPE0bfe49ec372b bridge bridge local4f6ec0890427 host host local2ca07ec568c5 none null local 网络模式 bridge：桥接模式 none：不配置网络 host：和宿主机共享网络 container：容器网络连通（用的少，局限大） 清空容器 docker rm -f $(docker ps -aq) 创建网络 docker network create 使用帮助命令查看 docker network create --help 创建命令 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet [root@swcode ~]# docker network lsNETWORK ID NAME DRIVER SCOPE0bfe49ec372b bridge bridge local4f6ec0890427 host host localf5c2b322c217 mynet bridge local2ca07ec568c5 none null local [root@swcode ~]# docker network inspect f5c2b322c217 [ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;f5c2b322c217623e9f4418fabe425fda8d958325d2af6a8b614afe2d92b6d584&quot;, &quot;Created&quot;: &quot;2023-02-16T19:55:37.392894743+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123;&#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;] 启动容器到指定网络默认的启动命令，使用的是默认的网络bridge docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat01 -net bridge tomcat 指定自定义的网络 docker run -d -P --name tomcat-net-01 --net mynet tomcatdocker run -d -P --name tomcat-net-02 --net mynet tomcat 查看自定义网络信息，其中已经有了两个容器 docker network inspect mynet &#123; &quot;Containers&quot;: &#123; &quot;60587bfd1a22715bc9b02ef0820358e4633603898902308541b4d33b713aad39&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-02&quot;, &quot;EndpointID&quot;: &quot;f1fb35b2a348ba7dc6a251d78871529fd42fb3615c382ab146e705aaaa038a90&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;9b8257928b66d11f9c3c2e6269ea3fd7df275b62e02c4b9504609648e54d0ad1&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-01&quot;, &quot;EndpointID&quot;: &quot;50e1a1eb9123cd5271e84fda995b89989356861ddefbd127f1c2875648b2118d&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;&#125; 测试互联安装ping工具，有的忽略 # 01docker exec -it tomcat-net-01 apt updatedocker exec -it tomcat-net-01 apt install -y iputils-ping# 02docker exec -it tomcat-net-02 apt updatedocker exec -it tomcat-net-02 apt install -y iputils-ping 01连通02 [root@swcode ~]# docker exec tomcat-net-01 ping tomcat-net-02PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.079 ms64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.045 ms64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.060 ms64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.048 ms 02连通01 [root@swcode ~]# docker exec tomcat-net-02 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.031 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.071 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.049 ms 网络连通 自定义网络之间的连接 启动容器启动到默认网络 docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat02 tomcat 查看默认网络 docker network inspect bridge &#123; &quot;Containers&quot;: &#123; &quot;42f031f8dfb55a1bd6d29c60bf2ca59a070bedff2a3628f5dc7911810f922363&quot;: &#123; &quot;Name&quot;: &quot;tomcat02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot; &#125;, &quot;6c5896c588bf848c1a7eda4086f66d8ae056c794a2de0b80a39d441b0f40ed0d&quot;: &#123; &quot;Name&quot;: &quot;tomcat01&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot; &#125; &#125;&#125; 异网容器连通 不同网络中容器之间连通 测试两个网络中容器之间的互联，失败。。。 docker exec -it tomcat-net-01 ping 172.17.0.2docker exec -it tomcat01 ping 192.168.0.2 docker network connect 查看帮助文档 [root@swcode ~]# docker network connect --helpUsage: docker network connect [OPTIONS] NETWORK CONTAINERConnect a container to a networkOptions: --alias strings Add network-scoped alias for the container --driver-opt strings driver options for the network --ip string IPv4 address (e.g., 172.30.100.104) --ip6 string IPv6 address (e.g., 2001:db8::33) --link list Add link to another container --link-local-ip strings Add a link-local address for the container 使用命令连通网络 docker network connect mynet tomcat01 查看mynet的变化，直接将tomcat01加到了mynet中 docker network inspect mynet &#123; &quot;Containers&quot;: &#123; &quot;60587bfd1a22715bc9b02ef0820358e4633603898902308541b4d33b713aad39&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot; &#125;, &quot;6c5896c588bf848c1a7eda4086f66d8ae056c794a2de0b80a39d441b0f40ed0d&quot;: &#123; &quot;Name&quot;: &quot;tomcat01&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.4/16&quot; &#125;, &quot;9b8257928b66d11f9c3c2e6269ea3fd7df275b62e02c4b9504609648e54d0ad1&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-01&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot; &#125; &#125;&#125; 查看tomcat01的hosts，发现tomcat01可通往mynat [root@swcode ~]# docker exec tomcat01 cat /etc/hosts127.0.0.1 localhost172.17.0.2 6c5896c588bf192.168.0.4 6c5896c588bf 测试tomcat-net-01 ping tomcat01 [root@swcode ~]# docker exec -it tomcat-net-01 ping tomcat01PING tomcat01 (192.168.0.4) 56(84) bytes of data.64 bytes from tomcat01.mynet (192.168.0.4): icmp_seq=1 ttl=64 time=0.033 ms64 bytes from tomcat01.mynet (192.168.0.4): icmp_seq=2 ttl=64 time=0.034 ms64 bytes from tomcat01.mynet (192.168.0.4): icmp_seq=3 ttl=64 time=0.043 ms tomcat01 ping tomcat-net-01 [root@swcode ~]# docker exec -it tomcat01 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.031 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.045 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.050 ms"},{"title":"Docker可视化工具","path":"/wiki/docker/02_quick_start/Docker可视化工具.html","content":"Portainer 轻量级可视化工具 官网：https://www.portainer.io/ 文档：https://docs.portainer.io 安装：https://docs.portainer.io/start/install-ce/server/docker/linux 部署首先，创建Portainer Server将用于存储其数据库的卷： docker volume create portainer_data 然后，下载并安装Portainer Server容器： docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest 默认情况下，Portainer生成并使用自签名的SSL证书来保护端口9443。或者，您可以在安装期间或安装完成后通过Portainer UI提供自己的SSL证书。 如果您出于遗留原因需要打开HTTP端口9000，请在docker run命令中添加以下内容： -P 9000:9000 现已安装Portainer Server。您可以检查Portainer Server容器是否已通过运行docker ps启动： root@server:~# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES de5b28eb2fa9 portainer/portainer-ce:latest &quot;/portainer&quot; 2 weeks ago Up 9 days 0.0.0.0:8000-&gt;8000/tcp, :::8000-&gt;8000/tcp, 0.0.0.0:9443-&gt;9443/tcp, :::9443-&gt;9443/tcp portainer 登录现在安装已经完成，您可以通过打开Web浏览器登录Portainer Server实例并前往： https://localhost:9443 如果需要，请将本地主机替换为相关的IP地址或FQDN，如果您之前更改了端口，请调整端口。 您将看到Portainer Server的初始设置页面。 初始化初始化步骤：https://docs.portainer.io/start/install-ce/server/setup CIG 重量级监控工具"},{"title":"Docker常用命令","path":"/wiki/docker/02_quick_start/Docker常用命令.html","content":"帮助命令docker version # 显示docker的版本docker info # 显示docker的系统信息，也包括镜像和容器的数量docker [命令] --help\t# 帮助命令 帮助文档地址：https://docs.docker.com/engine/reference/commandline 镜像命令docker images docker images | Docker Documentation 查看所有本地的主机上的镜像 [root@swcode ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest feb5d9fea6a5 16 months ago 13.3kB 标签 解释 REPOSITORY 镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像的id CREATED 镜像的创建时间 SIZE 镜像的大小 可选参数 -a, --all # 列出所有的镜像-q, --quiet # 只显示镜像的id docker search docker search | Docker Documentation 搜索镜像 Docker Hub的地址：https://hub.docker.com/ [root@swcode ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used… 13737 [OK] mariadb MariaDB Server is a … 5242 [OK] 可选参数 --filter=STARS=3000 # 搜索STARS大于3000的 docker pull docker pull | Docker Documentation 下载镜像 docker pull mysql[:tag] [root@swcode ~]# docker pull mysqlUsing default tag: latest\t# 不写 tag，默认就是 latestlatest: Pulling from library/mysql39fbafb6c7ef: Pull complete # 分层下载，docker image的核心 联合文件系统76e9f8ca4fd7: Pull complete 1fcdd923e548: Pull complete 15716fe15a39: Pull complete 95c8bb47c8b9: Pull complete b050c46cac02: Pull complete 7e19c22a3773: Pull complete a2abd6d528f1: Pull complete 6aca593545a5: Pull complete 8a262a30fc7f: Pull complete a1170ff1b1e9: Pull complete Digest: sha256:19b05df6eb4b7ed6f274c0552f053ff0c00842a40dcf05941225c429a716683d #签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest\t# 真实地址 真实地址 docker pull mysqldocker pull docker.io/library/mysql:latest 指定版本下载 docker pull mysql:5.7 docker rmi docker rmi | Docker Documentation 删除一个镜像 [root@swcode ~]# docker rmi -f 镜像id 删除多个镜像 [root@swcode ~]# docker rmi -f 镜像id 镜像id 镜像id 删除全部镜像 [root@swcode ~]# docker rmi -f $(docker images -aq) 容器命令注意：有了镜像才可以创建容器 下载一个CentOS镜像测试学习 docker pull centos docker run docker run | Docker Documentation 新建容器并启动 docker run [可选参数] image 参数 说明 –name&#x3D;”Name” 容器名字，区分容器 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器端口 -p 8080:8080 -P 随机指定端口 启动并进入容器 [root@swcode ~]# docker run -it centos /bin/bash[root@4196286a2ebf /]# 退出容器 [root@4196286a2ebf /]# exit docker ps docker ps | Docker Documentation 列出容器 [root@swcode ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 参数 描述 -a 列出当前正在运行的容器+历史运行过 -n&#x3D;? 列出最近创建的n个容器 -q 只显示容器ID 退出容器先进入容器 [root@swcode ~]# docker run -it centos /bin/bash[root@4196286a2ebf /]# 使用下面方式退出 exit\t# 停止并退出容器Ctrl + P + Q\t# 不停止退出 删除容器 docker rm | Docker Documentation 删除容器 docker rm 容器id\t# 无法删除正在运行的容器 强制删除所有容器 docker rm -f $(docker ps -aq)docker ps -a -q | xargs docker rm -f 启动和停止容器 docker start | Docker Documentation docker restart | Docker Documentation docker stop | Docker Documentation docker kill | Docker Documentation 启动已经停止的容器 docker start 容器id # 启动容器docker restart 容器id # 重启容器docker stop 容器id # 停止运行中的容器docker kill 容器id # 强制停止 常用其他命令后台启动容器[root@swcode ~]# docker run -d centos9dc577939aee390cda66c44d32656b6e369ad3685ce43083094b5da0a88dbf2a[root@swcode ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS 9dc577939aee centos &quot;/bin/bash&quot; 7 seconds ago Exited (0) 6 seconds ago 使用docker ps查看，发现centos已经停止。 docker容器使用后台运行，就必须要有一个前台进程，docker发现没有相应前台进程，就会自动停止 查看日志 docker logs | Docker Documentation docker logs -f -t --tail n 打印最后n行日志 参数 描述 -f 一直监听打印 -t 显示时间戳 –tail n 要显示的日志条数 查看容器中进程信息 docker top | Docker Documentation [root@swcode ~]# docker top 3e275c8c6acdUID PID PPID C STIME TTY TIME CMDroot 2718 2698 0 16:48 pts/0 00:00:00 /bin/bash 查看镜像的元数据 docker inspect | Docker Documentation docker inspect 3e275c8c6acd 点击查看元数据[ &#123; &quot;Id&quot;: &quot;3e275c8c6acdb662a9641ed98a6dd57911e39da2933608a327905be2f99968f9&quot;, &quot;Created&quot;: &quot;2023-01-29T08:48:35.874003235Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 2718, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2023-01-29T08:48:36.190774581Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/3e275c8c6acdb662a9641ed98a6dd57911e39da2933608a327905be2f99968f9/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/3e275c8c6acdb662a9641ed98a6dd57911e39da2933608a327905be2f99968f9/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/3e275c8c6acdb662a9641ed98a6dd57911e39da2933608a327905be2f99968f9/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/3e275c8c6acdb662a9641ed98a6dd57911e39da2933608a327905be2f99968f9/3e275c8c6acdb662a9641ed98a6dd57911e39da2933608a327905be2f99968f9-json.log&quot;, &quot;Name&quot;: &quot;/competent_johnson&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;CgroupnsMode&quot;: &quot;host&quot;, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/62d28c2661f3e2b0752edf8bd773c3257b99673815519b5eb9bbf084c5a34fb2-init/diff:/var/lib/docker/overlay2/5cc00ea5ad884604b11721369c550c113ea31ef73b1f919dc335777da7bad8c1/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/62d28c2661f3e2b0752edf8bd773c3257b99673815519b5eb9bbf084c5a34fb2/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/62d28c2661f3e2b0752edf8bd773c3257b99673815519b5eb9bbf084c5a34fb2/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/62d28c2661f3e2b0752edf8bd773c3257b99673815519b5eb9bbf084c5a34fb2/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;3e275c8c6acd&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: true, &quot;AttachStdout&quot;: true, &quot;AttachStderr&quot;: true, &quot;Tty&quot;: true, &quot;OpenStdin&quot;: true, &quot;StdinOnce&quot;: true, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;2896da3059dd45610c6f1944336b18ee71d836d22b83487ab4febdd5a217a789&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/2896da3059dd&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;7216c18e3946b0ee4b69eab6752b189289318ce460310d0324d03e97c620b43f&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;dc21a4da01fb418f9dc845b545b0355f01ea0e7fb81ade2d4d2ac3dd4ec2e842&quot;, &quot;EndpointID&quot;: &quot;7216c18e3946b0ee4b69eab6752b189289318ce460310d0324d03e97c620b43f&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 进入当前正在运行的容器方式一 docker exec | Docker Documentation docker exec -it 容器id bashShell 方式二 docker attach | Docker Documentation docker attach 容器id bashShell docker exec：进入容器后开启一个新的终端 docker attach：进入容器当前正在执行的终端 拷贝文件到主机 docker cp | Docker Documentation docker cp 容器id:容器路径 主机路径 案例 [root@swcode ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3e275c8c6acd centos &quot;/bin/bash&quot; 23 minutes ago Up 23 minutes competent_johnson# 进入docker容器[root@swcode ~]# docker attach 3e275c8c6acd# 在容器内创建文件[root@3e275c8c6acd home]# touch test.java[root@3e275c8c6acd home]# exitexit# 将文件拷贝到主机上[root@swcode ~]# docker cp 3e275c8c6acd:/home/test.java /home[root@swcode ~]# ll /home/total 0-rw-r--r-- 1 root root 0 Jan 29 17:12 test.java 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步 总结"},{"title":"Docker的安装","path":"/wiki/docker/02_quick_start/Docker的安装.html","content":"CentOS"},{"title":"Dockers镜像","path":"/wiki/docker/02_quick_start/Docker镜像.html","content":"镜像是什么镜像是一种轻量级、可执行的独立软件包 如何得到镜像： Docker Hub拉取 自己制作 Docker镜像加载原理UnionFSUnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite serveral directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。 Docker镜像加载原理Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs(root file system)，在bootfs之上。包含的就是典型Linux系统中的&#x2F;dev,&#x2F;proc,&#x2F;bin.&#x2F;etc等标准目录和文件。rootfs就是各种不同操作系统发行版，比如Ubuntu，CentOS等。 分层理解所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像之上，创建新的镜像层。 例子：假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。当镜像当前已经包含3个镜像层。 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！ 这一层就是我们通常说的容器层，容器之下的都叫镜像层！ 容器数据同步"},{"title":"Docker Compose","path":"/wiki/docker/04_high_level/Docker Compose.html","content":"Docker Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。 定义一个YAML格式的配置文件docker-compose.yml，写好对个容器之间的调用关系。然后，只要一个命令就能同时启动&#x2F;关闭这些容器。 Docker建议我们每个容器中只运行一个服务，因此需要docker compose多服务部署的工具。 安装ComposeReference地址：Reference | Docker Documentation Install地址： Manuals | Docker Documentation CentOS 安装举例：手动安装 DOCKER_CONFIG=$&#123;DOCKER_CONFIG:-/usr/local/lib/docker&#125;mkdir -p $DOCKER_CONFIG/cli-pluginscurl -SL https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose 第一行代码详见$&#123;&#125;的详细用法 下载慢的话可以使用国内镜像源 curl -SL https://get.daocloud.io/docker/compose/releases/download/v2.16.0/docker-compose-`uname -s`-`uname -m` -o $DOCKER_CONFIG/cli-plugins/docker-compose 如果还是慢，可在本地下载完成后，上传到/usr/local/lib/docker/cli-plugins/，并改名 mv docker-compose-linux-x86_64 docker-compose 添加可执行权限 sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose 查看是否安装成功 # docker compose versionDocker Compose version v2.16.0 Compose核心概念一文件 docker-compose.yml 两要素 服务（service）：一个个应用容器实例 工程（project）：一组关联的应用容器组成的完整单元，在文件中定义 Compose命令 命令 描述 docker compose -h 查看帮助 docker compose up 启动所有docker compose服务 docker compose up -d 启动所有docker compose服务并后台运行 docker compose down 停止并删除容器、网络、卷、镜像 docker compose exec id &#x2F;bin&#x2F;bash 进入容器实例内部，docker-compose.yml中的id docker compose ps 展示当前docker compose编排过的运行的容器 docker compose top 展示当前docker compose编排过的容器进程 docker compose logs id 查看容器输出日志 docker compose config 检查配置 docker compose config -q 检查配置，有问题才输出 docker compose restart 重启服务 docker compose start 启动服务 docker compose stop 停止服务 Compose实战准备项目项目下载地址： 数据库脚本使用user表作为案例，其脚本如下： CREATE TABLE `tb2023`.`t_user` ( `id` int UNSIGNED NOT NULL AUTO_INCREMENT, `username` varchar(50) NULL COMMENT &#x27;用户名&#x27;, `password` varchar(50) NULL COMMENT &#x27;密码&#x27;, `gender` tinyint NULL COMMENT &#x27;性别 0=女 1=男&#x27;, `version` int DEFAULT &#x27;1&#x27; COMMENT &#x27;乐观锁&#x27;, `deleted` tinyint unsigned DEFAULT &#x27;1&#x27; COMMENT &#x27;删除标志，默认0不删除 1删除&#x27;, `create_time` timestamp NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` timestamp NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)); 项目配置文件application.ymlserver: port: 8080spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://172.31.193.36:3306/tb2023?useSSL=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: 123456 redis: host: 172.31.193.36 port: 6379 password: 123456 lettuce: pool: max-active: 10 max-idle: 10 min-idle: 1 time-between-eviction-runs: 10s 从配置文件中可以看到项目包含了： MySQL Redis 注意：这里mysql和redis的IP地址固定了，使用的是Linux系统的IP地址，使用ip addr可查看eth0的IP。 构建镜像编写Dockerfile文件 DockerfileFROM openjdk:8COPY *.jar /app.jarCMD [&quot;--server.port=8080&quot;]EXPOSE 8080ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;] 使用maven打包项目，将Dockerfile和jar一块上传到服务器 打包镜像 docker build -t docker-spring-boot . 查看镜像 [root@swcode compose]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker-spring-boot latest 559521cb1212 10 seconds ago 573MBidea-demo latest 1e0b48277189 28 hours ago 544MB 不使用Compose单独启动MySQL容器启动MySQL容器 docker run -d -p 3306:3306 --name mysql8 --privileged=true -v /compose/mysql/conf:/etc/mysql/conf.d -v /compose/mysql/logs:/logs -v /compose/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:8 进入容器 docker exec -it mysql8 bash 登陆mysql，密码是123456 mysql -u root -p 创建数据库tb2023 create database tb2023; 创建t_user表 CREATE TABLE `tb2023`.`t_user` ( `id` int UNSIGNED NOT NULL AUTO_INCREMENT, `username` varchar(50) NULL COMMENT &#x27;用户名&#x27;, `password` varchar(50) NULL COMMENT &#x27;密码&#x27;, `gender` tinyint NULL COMMENT &#x27;性别 0=女 1=男&#x27;, `version` int DEFAULT &#x27;1&#x27; COMMENT &#x27;乐观锁&#x27;, `deleted` tinyint unsigned DEFAULT &#x27;1&#x27; COMMENT &#x27;删除标志，默认0不删除 1删除&#x27;, `create_time` timestamp NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` timestamp NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)); 单独启动Redis容器下载配置文件：https://redis.io/docs/management/config/ 修改以下几项 appendonly yes# bind 127.0.0.1requirepass 123456 启动Redis容器 docker run -p 6379:6379 --name redis708 --privileged=true -v /compose/redis/redis.conf:/etc/redis/redis.conf -v /compose/redis/data:/data -d redis:7.0.8 redis-server /etc/redis/redis.conf 查看是否启动成功 docker ps 单独启动项目容器启动项目 docker run -d -p 8080:8080 docker-spring-boot 查看是否启动成功 [root@swcode compose]# docker psCONTAINER ID IMAGE PORTS NAMES46f1c4741b04 docker-spring-boot 0.0.0.0:8080-&gt;8080/tcp priceless_bassi19e0fdd1a65f redis:7.0.8 0.0.0.0:6379-&gt;6379/tcp redis70869615c89a053 mysql:8 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql8 测试项目访问Swagger接口：http://ip:8080/swagger-ui/index.html 使用Compose编排docker-compose文件docker-compose.ymlversion: &quot;3&quot;services: microService: image: docker-spring-boot container_name: ms01 ports: - &quot;8080:8080&quot; volumes: - /compose/microService:/data networks: - ms01_net depends_on: - redis - mysql redis: image: redis:7.0.8 ports: - &quot;6379:6379&quot; volumes: - /compose/redis/redis.conf:/etc/redis/redis.conf - /compose/redis/data:/data networks: - ms01_net command: /usr/local/bin/redis-server /etc/redis/redis.conf mysql: image: mysql:8 environment: MYSQL_ROOT_PASSWORD: &#x27;123456&#x27; MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27; MYSQL_DATABASE: &#x27;tb2023&#x27; MYSQL_USER: &#x27;swcode&#x27; MYSQL_PASSWORD: &#x27;123456&#x27; ports: - &quot;3306:3306&quot; volumes: - /compose/mysql/data:/var/lib/mysql # 挂载数据 - /compose/mysql/conf:/etc/mysql/conf.d # 挂载配置文件 - /compose/mysql/db:/docker-entrypoint-initdb.d # 挂载配置文件 - /compose/mysql/logs:/logs # 挂载日志 networks: - ms01_net command: --default-authentication-plugin=mysql_native_password # 解决外部无法访问networks: ms01_net: 修改项目配置 通过服务名访问，IP无关 更改IP为服务名 application.ymlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://mysql:3306/tb2023?useSSL=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: 123456 redis: host: redis port: 6379 password: 123456 lettuce: pool: max-active: 10 max-idle: 10 min-idle: 1 time-between-eviction-runs: 10s 重新打包上传到服务器，重新构建 docker rmi -f docker-spring-bootdocker build -t docker-spring-boot . 启动所有容器项目清空所有容器 docker rm -f $(docker ps -aq) 创建配置文件/compose/redis/redis/redis.conf Redis配置文件，下载地址：https://redis.io/docs/management/config/。 修改以下几项 appendonly yesbind 0.0.0.0requirepass 123456 执行启动命令 docker-compose.yml所在目录docker compose up -d 查看运行的服务 [root@swcode compose]# docker psCONTAINER ID IMAGE PORTS NAMES06a1106838a6 docker-spring-boot 0.0.0.0:8080-&gt;8080/tcp ms0134559844510c redis:7.0.8 0.0.0.0:6379-&gt;6379/tcp compose-redis-1492dd67129a8 mysql:8 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp compose-mysql-1 测试项目访问Swagger接口：http://ip:8080/swagger-ui/index.html 停止项目docker compose stop"},{"title":"容器数据卷","path":"/wiki/docker/02_quick_start/容器数据卷.html","content":"什么是容器数据卷 什么是容器数据卷 卷就是目录或者文件，存在于一个或者多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能逃过Union file system 提供的一些持续存储或者共享数据的特性 卷的设计目的就是数据持久化，完全独立于容器的生存周期，因此docker不会在容器删除时删除其挂载的数据卷 将docker容器内的数据保存进宿主机的磁盘中 使用数据卷 方式一：直接使用命令挂载 -v docker run -it --privileged=true -v 主机目录:容器内目录 镜像名 使用命令查看挂载详情，找到Mounts docker inspect containerID 具名和匿名挂载 匿名挂载 -v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx 查看所有挂载目录命令 [root@swcode ~]# docker volume lsDRIVER VOLUME NAMElocal 85a3880d15ec86f9a8324f2bdc172fa6dc29e1fb2c8095be5634ea2e35bfddc5 VOLUME NAME是一串字符串，即为匿名挂载 具名挂载 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx 查看所有挂载目录命令 [root@swcode ~]# docker volume lsDRIVER VOLUME NAMElocal 85a3880d15ec86f9a8324f2bdc172fa6dc29e1fb2c8095be5634ea2e35bfddc5local juming-nginx juming-nginx就是卷名，这种就是具名挂载 查看具体目录 [root@swcode ~]# docker volume inspect juming-nginx[ &#123; &quot;CreatedAt&quot;: &quot;2023-02-02T17:00:15+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, &quot;Name&quot;: &quot;juming-nginx&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;] 所有的docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxx/_data 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！ -v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载-v /宿主机路径:容器内路径 # 路径挂载 拓展 通过ro和rw改变读写权限 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx 数据卷容器 容器数据同步"},{"title":"Kubernetes(K8S)","path":"/wiki/docker/04_high_level/Kubernetes.html","content":"left right Kubernetes 也称为 K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统。其学习笔记：Kubernetes学习笔记https://sx-code.github.io/wiki/kubernetes/"},{"title":"Redis集群部署","path":"/wiki/docker/05_practical/Redis集群部署.html","content":"三主三从，三个主机都有一个从机 创建网络docker network create redis --subnet 172.38.0.0/16 查看创建的网络 [root@swcode ~]# docker network lsNETWORK ID NAME DRIVER SCOPE0bfe49ec372b bridge bridge local9f161ce28618 redis bridge local 配置文件使用shell脚本创建6个配置文件，直接复制到命令行。 for port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone 启动容器使用shell脚本启动6个容器 for port in $(seq 1 6); \\do \\docker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \\-v /mydata/redis/node-$&#123;port&#125;/data:/data \\-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdone 创建集群进入容器内部 docker exec -it redis-1 /bin/sh 开启集群 我们使用的是Redis7.0.5版本，集群管理已经集成到了redis-cli中，格式如下： redis-cli --cluster create --cluster-replicas 1 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 命令说明： redid-cli --cluster或者./redis-trib.rb：代表集群操作命令 create：代表是创建集群 --replicas 1或者--cluster-replicas 1：指定集群中每个master的副本个数为1，此时节点总数 / (replicas + 1)得到的就是master的数量。因此节点列表中的前n个就是master，其他节点都是slave节点，随机分配到不同master 三个主机，三个从机。输入yes即可 &gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 使用cluster nodes查看集群节点信息 127.0.0.1:6379&gt; cluster nodesf7475f5c7f4c9a72fc9180d1493d9f6e419e5342 172.38.0.16:6379@16379 slave 7542db82e4f938492fb01467ed5aa82afc8887b1 0 1676615856000 6 connectedb1def78e500625b51dbf43fb569ee7519944ebdb 172.38.0.13:6379@16379 master - 0 1676615857572 3 connected 10923-163837542db82e4f938492fb01467ed5aa82afc8887b1 172.38.0.12:6379@16379 master - 0 1676615856470 2 connected 5461-1092221a38e75f20e71dd04854ab7e44251cc618f9ae6 172.38.0.11:6379@16379 myself,master - 0 1676615857000 1 connected 0-546097ec6c5ad97335c60d5735f5bb939931ae7ee667 172.38.0.15:6379@16379 slave 21a38e75f20e71dd04854ab7e44251cc618f9ae6 0 1676615857472 5 connecteda602a84a6e5435e7bbdb7fb9d59c4eb3ece2ac0f 172.38.0.14:6379@16379 slave b1def78e500625b51dbf43fb569ee7519944ebdb 0 1676615856000 4 connected 其中11、12、13为master，14、15、16为slave，且&lt;11, 15&gt;、&lt;12, 16&gt;、&lt;13, 14&gt;。 分片集群的搭建过程可查看： 搭建分片集群https://sx-code.github.io/2022/11/16/Redis安装系列教程/#搭建分片集群 测试测试GET&#x2F;SET在容器内部，使用-c连接Redis集群 redis-cli -c set一个值 127.0.0.1:6379&gt; set num 123OK 再set一个值，a计算得到的hash值为15495，该值所在的节点为redis-3，自动切换到了redis-3 127.0.0.1:6379&gt; set a 1-&gt; Redirected to slot [15495] located at 172.38.0.13:6379OK172.38.0.13:6379&gt; get一个值 172.38.0.13:6379&gt; get a&quot;1&quot; 再get一个值，可以看到已经切换到redis-1了 172.38.0.13:6379&gt; get num-&gt; Redirected to slot [2765] located at 172.38.0.11:6379&quot;123&quot;172.38.0.11:6379&gt; 测试容错上一步set a 1，存在了主节点redis-3 (13)上，我们关闭掉容器redis-3 docker stop redis-3 再次get，可以看到我们在redis-4上查到了a 172.38.0.11:6379&gt; get a-&gt; Redirected to slot [15495] located at 172.38.0.14:6379&quot;1&quot;172.38.0.14:6379&gt; 使用cluster nodes查看节点信息。redis-4成为master，redis-3宕机 172.38.0.14:6379&gt; cluster nodesa602a84a6e5435e7bbdb7fb9d59c4eb3ece2ac0f 172.38.0.14:6379@16379 myself,master - 0 1676616635000 7 connected 10923-16383b1def78e500625b51dbf43fb569ee7519944ebdb 172.38.0.13:6379@16379 master,fail - 1676616476060 1676616474558 3 connected"},{"title":"SpringBoot部署","path":"/wiki/docker/05_practical/SpringBoot部署.html","content":"构建Demo项目使用IDEA的Spring Initializr创建一个SpringBoot项目，添加Spring Web。 注意SpringBoot v3.0.0 以后最低支持JDK17，如果你使用JDK8，请降低版本到v3以下 贴出我的pom中部分配置 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;java.version&gt;8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写Hello World Controller @RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;Hello World!&quot;; &#125;&#125; 访问测试：http://localhost:8080/hello 打包应用使用maven打包项目 进入target目录，运行项目 java -jar demo-0.0.1-SNAPSHOT.jar 访问测试：http://localhost:8080/hello 编写dockerfile直接在IDEA中右键项目，新建文件Dockerfile，IDEA可以提示代码。 写入下面内容 FROM java:8COPY *.jar /app.jarCMD [&quot;--server.port=8080&quot;]EXPOSE 8080ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;] 构建镜像将编写的Dockerfile和target中的jar包上传到服务器上 [root@swcode idea]# lltotal 17224-rw-r--r-- 1 root root 17633212 Feb 17 15:46 demo-0.0.1-SNAPSHOT.jar-rw-r--r-- 1 root root 112 Feb 17 15:46 Dockerfile 构建镜像 docker build -t idea-demo . 如果构建过程中报错 manifest for java:8 not found: manifest unknown: manifest unknown 把Dockerfile文件里面的 FROM java:8 改为 FROM openjdk:8 查看创建的镜像 [root@swcode idea]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEidea-demo latest 1e0b48277189 6 seconds ago 544MBopenjdk 8 b273004037cc 6 months ago 526MB 发布运行运行镜像 docker run -d -P --name idea-springboot-web idea-demo 查看分配的端口，32776对应8080 [root@swcode idea]# docker psCONTAINER ID IMAGE PORTS NAMES3b753f588a29 idea-demo 0.0.0.0:32776-&gt;8080/tcp idea-springboot-web 访问项目 [root@swcode idea]# curl localhost:32776&#123;&quot;timestamp&quot;:&quot;2023-02-17T07:54:21.790+00:00&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;path&quot;:&quot;/&quot;&#125;[root@swcode idea]# curl localhost:32776/helloHello World! 浏览器输入：ip:32776/hello 即可访问"},{"title":"笔记简介","path":"/wiki/easypan/01_introduce/index.html","content":"介绍 Easy云盘项目是一个类似百度云网盘的云盘项目，主要包含下面的功能： 文件上传功能：包括生成文件md5、大文件切片上传、文件秒传、视频和图片文件转码等功能。 文件分享功能： 文件放回收站：文件删除后会进入回收站，可以恢复或者彻底删除。 文件预览功能：实现了常见功能的预览，包括：文档文件（docx, pdf, excel）、代码文件、图片文件、视频文件、音频文件。 后端技术：Spring Boot + Mybatis Plus + MySQL + Redis 前端技术：vite vue + axios + pinia + router + js 开发工具：IntelliJ IDEA、Visual Studio Code、ApiPost7 核心技术 文件转码 FFmpeg 文件预览 dplayer、vue-office、el-image-viewer 文件MD5 spark-md5 验证码 BufferedImage 项目预览 title:Easy云盘项目预览网址https://sx-code.github.io/wiki/easypan/01_introduce/href 页面展示"},{"title":"Docker部署","path":"/wiki/easypan/02_install/docker_install.html","content":"服务器端提供了docker-compose文件，方便快速搭建后台服务。"},{"title":"缓存服务","path":"/wiki/easypan/03_project-init/cache.html","content":"Redis缓存服务项目中的一些配置信息和验证码需要存放到Redis缓存中，为此项目引入Redis。 配置文件配置文件已经在初始化项目时加入到了application.properties中 配置类在config包下创建 RedisConfig RedisConfig@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; 工具方法创建com.swx.easypan.redis包，在该包下创建 RedisUtils 类，其内容如下： RedisUtils@Component(&quot;redisUtils&quot;)public class RedisUtils&lt;V&gt; &#123; @Resource private RedisTemplate&lt;String, V&gt; redisTemplate; private static final Logger logger = LoggerFactory.getLogger(RedisUtils.class); /** * 普通缓存放入 * * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, V value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; logger.error(&quot;设置redisKey:&#123;&#125;, value:&#123;&#125;失败&quot;, key, value); return false; &#125; &#125; /** * 有效期缓存放入 * * @param key 键 * @param value 值 * @param time 有效期 * @return true成功 false失败 */ public boolean setex(String key, V value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; logger.error(&quot;设置redisKey:&#123;&#125;, value:&#123;&#125;失败&quot;, key, value); return false; &#125; &#125; public V get(String key) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** * 删除缓存 * * @param key 键，可以传一个或多个 */ public void delete(String... key) &#123; if (key != null &amp;&amp; key.length &gt; 0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key)); &#125; &#125; &#125;&#125; Redis组件这里放一些常用的Redis操作 RedisComponent@Component(&quot;redisComponent&quot;)public class RedisComponent &#123; @Resource private RedisUtils&lt;Object&gt; redisUtils;&#125; 系统设置缓存项目系统有一些默认的设置需要保存到Redis中，提前做缓存 系统设置DTOSysSettingsDTO@JsonIgnoreProperties(ignoreUnknown = true)public class SysSettingsDTO implements Serializable &#123; private String registerMailTitle = &quot;邮箱验证码&quot;; private String registerEmailContent = &quot;您好，您的邮箱验证码是：%s, 15分钟有效&quot;; private Integer userInitSpace = 5; public String getRegisterMailTitle() &#123; return registerMailTitle; &#125; public void setRegisterMailTitle(String registerMailTitle) &#123; this.registerMailTitle = registerMailTitle; &#125; public String getRegisterEmailContent() &#123; return registerEmailContent; &#125; public void setRegisterEmailContent(String registerEmailContent) &#123; this.registerEmailContent = registerEmailContent; &#125; public Integer getUserInitSpace() &#123; return userInitSpace; &#125; public void setUserInitSpace(Integer userInitSpace) &#123; this.userInitSpace = userInitSpace; &#125;&#125; 定义常量静态常量，在com.swx.easypan.entity.constants包下的 Constants 类中定义常量 public class Constants &#123; public static final String REDIS_KEY_SYS_SETTING = &quot;easypan:syssetting:&quot;;&#125; 系统设置缓存从Redis缓存中获取设置信息，在RedisComponent 编写获取方法，如果没有新建一个。 @Component(&quot;redisComponent&quot;)public class RedisComponent &#123; @Resource private RedisUtils&lt;Object&gt; redisUtils; public SysSettingsDTO getSysSettingDto() &#123; SysSettingsDTO sysSettingsDto = (SysSettingsDTO) redisUtils.get(Constants.REDIS_KEY_SYS_SETTING); if (null == sysSettingsDto) &#123; sysSettingsDto = new SysSettingsDTO(); redisUtils.set(Constants.REDIS_KEY_SYS_SETTING, sysSettingsDto); &#125; return sysSettingsDto; &#125;&#125;"},{"title":"初始化项目","path":"/wiki/easypan/03_project-init/init.html","content":"项目工程结构项目采用普通的SpringBoot项目结构，其中common模块下是全局异常处理和统一返回结果。server模块则是整个项目的业务代码。 easypan├── common│ ├── common-util│ └── pom.xml├── learning-online-content└── server 根据项目结构创建出父工程easypan，删除其中的src目录，并两个子模块common和server 版本控制在父工程easypan的pom文件中添加版本依赖信息 pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;easypan&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;easypan&lt;/name&gt; &lt;description&gt;easypan&lt;/description&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;server&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;springboot.version&gt;2.6.1&lt;/springboot.version&gt; &lt;logback.version&gt;1.2.10&lt;/logback.version&gt; &lt;mysql.version&gt;8.0.30&lt;/mysql.version&gt; &lt;mybatis-plus.version&gt;3.4.1&lt;/mybatis-plus.version&gt; &lt;aspectjweaver.version&gt;1.9.4&lt;/aspectjweaver.version&gt; &lt;fastjson.version&gt;2.0.21&lt;/fastjson.version&gt; &lt;commons.lang3.version&gt;3.4&lt;/commons.lang3.version&gt; &lt;commons.codec.version&gt;1.9&lt;/commons.codec.version&gt; &lt;commons.io.version&gt;2.5&lt;/commons.io.version&gt; &lt;ws.schild.version&gt;3.3.1&lt;/ws.schild.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--邮件发送--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis Plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--切面--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;$&#123;aspectjweaver.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--apache common--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;$&#123;commons.lang3.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;$&#123;commons.codec.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons.io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--FFmpeg--&gt; &lt;dependency&gt; &lt;groupId&gt;ws.schild&lt;/groupId&gt; &lt;artifactId&gt;jave-all-deps&lt;/artifactId&gt; &lt;version&gt;$&#123;ws.schild.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.name&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 统一返回结果通过拦截Controller的返回结果和全局异常，将其封装成统一的格式，并使用RestController返回JSON形式的数据给前端。 &#123; &quot;code&quot;:20000, &quot;message&quot;:&quot;成功&quot;, &quot;data&quot;:&#123; &quot;info&quot;:&quot;测试成功&quot; &#125;&#125; 项目介绍地址： SpringBoot统一封装返回结果和异常情况 将GitHub代码下载到本地，将其中的common-util放到common模块下，作为其子模块。 业务代码工程引入依赖在server模块的pom文件中添加依赖信息 pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;common-util&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--邮件发送--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Mybatis Plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 日志版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--切面--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--apache common--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Mybatis-Plus自动生成代码 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 模版引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- FFmpeg --&gt; &lt;dependency&gt; &lt;groupId&gt;ws.schild&lt;/groupId&gt; &lt;artifactId&gt;jave-all-deps&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 启动类创建 EasyPanApplication EasyPanApplication@EnableAsync@EnableScheduling@EnableTransactionManagementpublic class EasyPanApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EasyPanApplication.class, args); &#125;&#125; 配置文件创建application.properties配置文件 # 应用服务 WEB 访问端口server.port=7090server.servlet.context-path=/api#session过期时间 60M 一个小时server.servlet.session.timeout=PT60M#处理faviconspring.mvc.favicon.enable=false#异常处理spring.mvc.throw-exception-if-no-handler-found=truespring.web.resources.add-mappings=falsespring.servlet.multipart.max-file-size=15MBspring.servlet.multipart.max-request-size=15MB#数据库配置spring.datasource.url=jdbc:mysql://127.0.0.1:3306/easypan?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=truespring.datasource.username=rootspring.datasource.password=swx852345spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.hikari.pool-name=HikariCPDatasourcespring.datasource.hikari.minimum-idle=5spring.datasource.hikari.idle-timeout=180000spring.datasource.hikari.maximum-pool-size=10spring.datasource.hikari.auto-commit=truespring.datasource.hikari.max-lifetime=1800000spring.datasource.hikari.connection-timeout=30000spring.datasource.hikari.connection-test-query=SELECT 1# mybatis plusmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImplmybatis-plus.global-config.db-config.logic-delete-value=1mybatis-plus.global-config.db-config.logic-not-delete-value=0mybatis-plus.mapper-locations=classpath:mapper/*.xml#发送邮件配置相关# 配置邮件服务器的地址 smtp.qq.comspring.mail.host=smtp.qq.com# 配置邮件服务器的端口（465或587）spring.mail.port=465# 配置用户的账号spring.mail.username=2627311935@qq.com# 配置用户的密码spring.mail.password=tykyolipdlapdifi# 配置默认编码spring.mail.default-encoding=UTF-8# SSL 连接配置spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory# 开启 debug，这样方便开发者查看邮件发送日志spring.mail.properties.mail.debug=true#邮件配置结束#Spring redis配置# Redis数据库索引（默认为0）spring.redis.database=0spring.redis.host=127.0.0.1spring.redis.port=6379spring.redis.password=swx852345# 连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=20# 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1# 连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=10# 连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0# 连接超时时间（毫秒）spring.redis.timeout=2000#项目目录project.folder=/Users/swcode/Documents/webser/web_app/easypan#日志级别配置log.root.level=info#超级管理员idadmin.emails=test@qq.com#是否是开发环境dev=false##qq登陆相关##qq.app.id=12333qq.app.key=2222222qq.url.authorization=https://graph.qq.com/oauth2.0/authorize?response_type=code&amp;client_id=%s&amp;redirect_uri=%s&amp;state=%sqq.url.access.token=https://graph.qq.com/oauth2.0/token?grant_type=authorization_code&amp;client_id=%s&amp;client_secret=%s&amp;code=%s&amp;redirect_uri=%sqq.url.openid=https://graph.qq.com/oauth2.0/me?access_token=%Sqq.url.user.info=https://graph.qq.com/user/get_user_info?access_token=%s&amp;oauth_consumer_key=%s&amp;openid=%sqq.url.redirect=http://easypan.wuhancoder.com/qqlogincalback 日志文件，logback-spring.xml logback-spring.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 minutes&quot;&gt; &lt;appender name=&quot;stdot&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss,GMT+8&#125; [%p][%c][%M][%L]-&gt; %m%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;log.path&quot; source=&quot;project.folder&quot;/&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;log.root.level&quot; source=&quot;log.root.level&quot;/&gt; &lt;property name=&quot;LOG_FOLDER&quot; value=&quot;logs&quot;/&gt; &lt;property name=&quot;LOG_FILE_NAME&quot; value=&quot;easypan.log&quot;/&gt; &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;FileNamePattern&gt;$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;.%d&#123;yyyyMMdd&#125;.%i&lt;/FileNamePattern&gt; &lt;cleanHistoryOnStart&gt;true&lt;/cleanHistoryOnStart&gt; &lt;TimeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;MaxFileSize&gt;20MB&lt;/MaxFileSize&gt; &lt;/TimeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;charset&gt;utf-8&lt;/charset&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss,GMT+8&#125; [%p][%c][%M][%L]-&gt; %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;append&gt;false&lt;/append&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;/appender&gt; &lt;root level=&quot;$&#123;log.root.level&#125;&quot;&gt; &lt;appender-ref ref=&quot;stdot&quot;/&gt; &lt;appender-ref ref=&quot;file&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 配置类创建com.swx.easypan.config包。 Mybatis Plus在com.swx.easypan.config包下创建Mybatis Plus的配置文件 MybatisPlusConfig@MapperScan(basePackages = &#123;&quot;com.swx.easypan.mapper&quot;&#125;)@EnableTransactionManagement@Configurationpublic class MybatisPlusConfig &#123; @Bean public MetaObjectHandler metaObjectHandler() &#123; return new MyMetaObjectHandler(); &#125; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 自动填充MyMetaObjectHandlerpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; boolean createTime = metaObject.hasSetter(&quot;createTime&quot;); boolean updateTime = metaObject.hasSetter(&quot;updateTime&quot;); if (updateTime) &#123; strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); &#125; if (createTime) &#123; strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now()); &#125; &#125; @Override public void updateFill(MetaObject metaObject) &#123; boolean updateTime = metaObject.hasSetter(&quot;updateTime&quot;); if (updateTime) &#123; strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); &#125; &#125;&#125; 配置文件变量类AppConfig@Component(&quot;appConfig&quot;)public class AppConfig &#123; @Value(&quot;$&#123;spring.mail.username&#125;&quot;) private String sendUsername; @Value(&quot;$&#123;admin.emails&#125;&quot;) private String emails; @Value(&quot;$&#123;project.folder&#125;&quot;) private String projectFolder; public String getSendUsername() &#123; return sendUsername; &#125; public String getEmails() &#123; return emails; &#125; public String getProjectFolder() &#123; return projectFolder; &#125;&#125; 代码生成在测试目录中创建代码生成器，运行后会在server模块中创建Mybatis Plus的基础代码 CodeGeneratorpublic class CodeGenerator &#123; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/server/src/main/java&quot;); gc.setAuthor(&quot;sw-code&quot;); gc.setOpen(false); // 是否打开文件资源管理器 gc.setFileOverride(false); // 是否覆盖 gc.setServiceName(&quot;%sService&quot;); // 去Service的I前缀 gc.setIdType(IdType.AUTO); // 主键策略 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql:///easypan?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;nullCatalogMeansCurrent=true&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;swx852345&quot;); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setParent(&quot;com.swx.easypan&quot;); pc.setEntity(&quot;pojo&quot;); pc.setMapper(&quot;mapper&quot;); pc.setService(&quot;service&quot;); pc.setController(&quot;controller&quot;); mpg.setPackageInfo(pc); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;file_share&quot;, &quot;file_info&quot;, &quot;user_info&quot;, &quot;email_code&quot;); // 加入要生成的表，逗号分隔 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); strategy.setLogicDeleteFieldName(&quot;deleted&quot;); // 逻辑删除 // 自动填充 TableFill createTime = new TableFill(&quot;create_time&quot;, FieldFill.INSERT); TableFill updateTime = new TableFill(&quot;update_time&quot;, FieldFill.INSERT_UPDATE); List&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(createTime); tableFills.add(updateTime); strategy.setTableFillList(tableFills); // 乐观锁 strategy.setVersionFieldName(&quot;version&quot;); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); mpg.execute(); &#125;&#125; 工具类创建包 com.swx.easypan.utils，以下工具方法都放在该包下 StringToolsStringToolspublic class StringTools &#123; /** * 生成随机数 * @param count 位数 */ public static String getRandomNumber(Integer count) &#123; return RandomStringUtils.random(count, false, true); &#125; public static String getRandomString(Integer count) &#123; return RandomStringUtils.random(count, true, true); &#125; public static String rename(String filename) &#123; return getFilename(filename) + &quot;_&quot; + getRandomString(Constants.LENGTH_5) + getFileSuffix(filename); &#125; public static String getFilename(String filename) &#123; int index = filename.lastIndexOf(&quot;.&quot;); if (index == -1) &#123; return filename; &#125; return filename.substring(0, index); &#125; public static String getFileSuffix(String filename) &#123; int index = filename.lastIndexOf(&quot;.&quot;); if (index == -1) &#123; return &quot;&quot;; &#125; return filename.substring(index); &#125;&#125; FileUtilsFileUtilspublic class FileUtils &#123; /** * response写入文件资源 * * @param response response * @param filePath 文件路径 */ public static void writeImage(HttpServletResponse response, String filePath) &#123; if (!StringUtils.hasText(filePath)) &#123; return; &#125; String imageSuffix = StringTools.getFileSuffix(filePath); imageSuffix = imageSuffix.replace(&quot;.&quot;, &quot;&quot;); String contentType = &quot;image/&quot; + imageSuffix; response.setContentType(contentType); response.setHeader(&quot;Cache-Control&quot;, &quot;max-age=2592000&quot;); FileUtil.readFile(response, filePath); &#125; /** * 写入下载文件 * * @param response response * @param request request * @param filename 文件名 * @param filePath 文件路径 */ public static void writeDownloadFile(HttpServletResponse response, HttpServletRequest request, String filename, String filePath) throws UnsupportedEncodingException &#123; response.setContentType(&quot;application/x-msdownload; character=UTF-8&quot;); if (request.getHeader(&quot;User-Agent&quot;).toLowerCase().indexOf(&quot;msie&quot;) &gt; 0) &#123; // IE浏览器 filename = URLEncoder.encode(filename, &quot;UTF-8&quot;); &#125; else &#123; filename = new String(filename.getBytes(&quot;UTF-8&quot;), &quot;ISO8859-1&quot;); &#125; response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=\\&quot;&quot; + filename + &quot;\\&quot;&quot;); FileUtil.readFile(response, filePath); &#125;&#125;"},{"title":"验证码服务","path":"/wiki/easypan/04_user/checkcode.html","content":"用户在登录和注册时需要验证码和邮箱验证码，为此需要提供一个验证码生成接口。 接口信息使用字节流的方式写回前端 值 路径地址 http://localhost:7090/api/checkCode 请求方式 GET 请求参数 Integer 返回结果 图片验证码DTO创建包com.swx.easypan.entity.dto，创建 CreateImageCode 实体类，将下面代码放入： CreateImageCodepublic class CreateImageCode &#123; // 图片高度 private int width = 160; // 图片宽度 private int height = 40; // 验证码字符个数 private int codeCount = 4; // 验证码干扰线数 private int lineCount = 20; // 验证码 private String code; // 验证码图片Buffer private BufferedImage buffImg; Random random = new Random(); public CreateImageCode() &#123; createImage(); &#125; public CreateImageCode(int width, int height) &#123; this.width = width; this.height = height; createImage(); &#125; public CreateImageCode(int width, int height, int codeCount) &#123; this.width = width; this.height = height; this.codeCount = codeCount; createImage(); &#125; public CreateImageCode(int width, int height, int codeCount, int lineCount) &#123; this.width = width; this.height = height; this.codeCount = codeCount; this.lineCount = lineCount; createImage(); &#125; private void createImage() &#123; int fontWidth = width / codeCount; // 字体的宽度 int fontHeight = height - 5; // 字体的高度 int codeY = height - 8; // 图像buffer buffImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = buffImg.getGraphics(); // 设置背景色 g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); // 设置字体 Font font = new Font(&quot;Fixedsys&quot;, Font.BOLD, fontHeight); g.setFont(font); // 设置干扰线 for (int i = 0; i &lt; lineCount; i++) &#123; int xs = random.nextInt(width); int ys = random.nextInt(height); int xe = xs + random.nextInt(width); int ye = ys + random.nextInt(height); g.setColor(getRandColor(1, 255)); g.drawLine(xs, ys, xe, ye); &#125; // 添加躁点 float yawpRate = 0.01f; // 噪声率 int area = (int) (yawpRate * width * height); for (int i = 0; i &lt; area; i++) &#123; int x = random.nextInt(width); int y = random.nextInt(height); buffImg.setRGB(x, y, random.nextInt(255)); &#125; // 得到随机字符 String str1 = randomStr(codeCount); this.code = str1; for (int i = 0; i &lt; codeCount; i++) &#123; String strRand = str1.substring(i, i + 1); g.setColor(getRandColor(1, 255)); g.drawString(strRand, i * fontWidth + 3, codeY); &#125; &#125; // 得到随机字符 private String randomStr(int n) &#123; String str1 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890&quot;; StringBuilder str2 = new StringBuilder(); int len = str1.length() - 1; double r; for (int i = 0; i &lt; n; i++) &#123; r = (Math.random()) * len; str2.append(str1.charAt((int) r)); &#125; return str2.toString(); &#125; // 得到随机颜色 private Color getRandColor(int fc, int bc) &#123; if (fc &gt; 255) fc = 255; if (bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125; // 得到随机字体 private Font getFont(int size) &#123; Random random = new Random(); Font[] fonts = new Font[5]; fonts[0] = new Font(&quot;Ravie&quot;, Font.PLAIN, size); fonts[1] = new Font(&quot;Antique Olive Compact&quot;, Font.PLAIN, size); fonts[2] = new Font(&quot;Fixedsys&quot;, Font.PLAIN, size); fonts[3] = new Font(&quot;Wide Latin&quot;, Font.PLAIN, size); fonts[4] = new Font(&quot;Gill Sans Ultra Bold&quot;, Font.PLAIN, size); return fonts[random.nextInt(5)]; &#125; public void write(OutputStream sos) throws IOException &#123; ImageIO.write(buffImg, &quot;png&quot;, sos); sos.close(); &#125; public String getCode() &#123; return code.toLowerCase(); &#125;&#125; 定义常量在com.swx.easypan.entity.constants包下的 Constants 类中定义常量 Constantspublic class Constants &#123; public static final Integer ZERO = 0; public static final String ZERO_STR = &quot;0&quot;; public static final Integer LENGTH_5 = 5; public static final Integer LENGTH_10 = 10; public static final Integer LENGTH_15 = 15; public static final Integer LENGTH_20 = 20; public static final Integer LENGTH_50 = 50; public static final Integer LENGTH_150 = 150; public static final String CHECK_CODE_KEY = &quot;check_code_key&quot;; public static final String CHECK_CODE_KEY_EMAIL = &quot;check_code_key_email&quot;;&#125; 定义Service找到 EmailCodeService，定义检查验证码方法： EmailCodeServicepublic interface EmailCodeService extends IService&lt;EmailCode&gt; &#123; void checkCode(String email, String code);&#125; 在 EmailCodeServiceImpl 中实现该方法： @Servicepublic class EmailCodeServiceImpl extends ServiceImpl&lt;EmailCodeMapper, EmailCode&gt; implements EmailCodeService &#123; @Override public void checkCode(String email, String code) &#123; LambdaQueryWrapper&lt;EmailCode&gt; wrapper = new LambdaQueryWrapper&lt;EmailCode&gt;().eq(EmailCode::getEmail, email).eq(EmailCode::getCode, code); EmailCode one = this.getOne(wrapper); if (null == one) &#123; throw new BizException(&quot;邮箱验证码错误&quot;); &#125; ZoneId zoneId = ZoneId.systemDefault(); long expire = System.currentTimeMillis() - one.getCreateTime().atZone(zoneId).toInstant().toEpochMilli(); if (one.getStatus() == 1 || expire &gt; Constants.LENGTH_15 * 60 * 1000) &#123; throw new BizException(&quot;邮箱验证码已失效&quot;); &#125; baseMapper.disableEmailCode(email); &#125;&#125; 定义Controller在 UserInfoController 下定义接口 @GetMapping(&quot;/checkCode&quot;)public void checkCode(HttpServletResponse response, HttpSession session, Integer type) throws IOException &#123; CreateImageCode vCode = new CreateImageCode(130, 38, 5, 10); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expires&quot;, 0); response.setContentType(&quot;image/jpeg&quot;); String code = vCode.getCode(); if (type == null || type == 0) &#123; session.setAttribute(Constants.CHECK_CODE_KEY, code); &#125; else &#123; session.setAttribute(Constants.CHECK_CODE_KEY_EMAIL, code); &#125; vCode.write(response.getOutputStream());&#125;"},{"title":"登陆拦截功能","path":"/wiki/easypan/04_user/gateway.html","content":"使用AOP实现登陆拦截，校验用户是否合法以及校验用户的身份。 自定义注解自定义注解 LoginValidator，放在com.swx.easypan.annotation包下，有些接口不需要拦截。 LoginValidator@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface LoginValidator &#123; boolean validated() default true; boolean checkAdmin() default false;&#125; AOP拦截使用AOP拦截加了 LoginValidator 注解的接口，放在com.swx.easypan.aspect包下 从请求中获取Session，再从Session中获取用户信息，如果失败则没有登陆 如果有用户信息，判断该接口注解是否需要管理员权限 @Aspect@Componentpublic class LoginAspect &#123; @Pointcut(&quot;@annotation(com.swx.easypan.annotation.LoginValidator) || @within(com.swx.easypan.annotation.LoginValidator)&quot;) private void pointCut() &#123;&#125; @Before(&quot;pointCut()&quot;) public void interceptorDo(JoinPoint point) &#123; Object target = point.getTarget(); // 获取方法方法上的LoginValidator注解 MethodSignature methodSignature = (MethodSignature) point.getSignature(); Method method = methodSignature.getMethod(); LoginValidator loginValidator = method.getAnnotation(LoginValidator.class); // 如果有，并且值为false，则不校验 if (loginValidator !=null &amp;&amp; !loginValidator.validated()) &#123; return; &#125; // 登陆校验 ServletRequestAttributes requestAttributes = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()); if (requestAttributes == null || requestAttributes.getResponse() == null) &#123; return; &#125; HttpServletRequest request = requestAttributes.getRequest(); HttpSession session = request.getSession(); SessionWebUserVO userVo = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); if (null == userVo) &#123; throw new BizException(ResultCode.LOGIN_AUTH_FAIL); &#125; if (loginValidator != null &amp;&amp; loginValidator.checkAdmin() &amp;&amp; !userVo.getIsAdmin()) &#123; throw new BizException(ResultCode.NO_PERMISSION); &#125; &#125;&#125;"},{"title":"账号密码登陆","path":"/wiki/easypan/04_user/login.html","content":"登陆功能采用Session方案，即登陆用户的信息存放在Session中。 接口信息 值 路径地址 http://localhost:7090/api/login 请求方式 POST 请求参数 LoginDTO 返回结果 SessionWebUserVO 实体类参数DTO 在包com.swx.easypan.entity.dto，下创建 LoginDTO 实体类，将下面代码放入： LoginDTO@Datapublic class LoginDTO &#123; @NotNull @Email private String email; @NotNull private String password; @NotNull private String checkCode;&#125; 视图VO 在包com.swx.easypan.entity.vo，下创建 SessionWebUserVO 实体类，将下面代码放入： SessionWebUserVO@Datapublic class SessionWebUserVO implements Serializable &#123; private String nickname; private String id; private Boolean isAdmin; private String avatar;&#125; 定义常量用户状态枚举常量，在com.swx.easypan.entity.enums包下创建 UserStatusEnum 枚举类： UserStatusEnumpublic enum UserStatusEnum &#123; ENABLE(1, &quot;启用&quot;), DISABLE(0, &quot;禁用&quot;); private Integer status; private String desc; UserStatusEnum(Integer status, String desc) &#123; this.status = status; this.desc = desc; &#125; public Integer status() &#123; return this.status; &#125; public String desc() &#123; return this.desc; &#125;&#125; 静态常量，Constants 类中定义常量 Constantspublic static final String SESSION_KEY = &quot;session_key&quot;; 定义Service找到 UserInfoService接口，在其中添加： UserInfoServicepublic interface UserInfoService extends IService&lt;UserInfo&gt; &#123; /** * 登陆 * * @param email 邮箱 * @param password 密码 * @return 部分信息 */ SessionWebUserVO login(String email, String password);&#125; 在 UserInfoServiceImpl 中实现该方法 UserInfoServiceImpl@Servicepublic class UserInfoServiceImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt; implements UserInfoService &#123; @Resource private AppConfig appConfig; @Override public SessionWebUserVO login(String email, String password) &#123; UserInfo userInfo = getOne(new LambdaQueryWrapper&lt;UserInfo&gt;().eq(UserInfo::getEmail, email)); if (null == userInfo || !userInfo.getPassword().equals(MD5.encrypt(password))) &#123; throw new BizException(&quot;账号或者密码错误&quot;); &#125; if (UserStatusEnum.DISABLE.status().equals(userInfo.getStatus())) &#123; throw new BizException(&quot;账号已禁用&quot;); &#125; UserInfo updateInfo = new UserInfo(); updateInfo.setLastLoginTime(LocalDateTime.now()); updateById(updateInfo); SessionWebUserVO sessionWebUserVO = new SessionWebUserVO(); sessionWebUserVO.setNickname(userInfo.getNickname()); sessionWebUserVO.setId(userInfo.getId()); sessionWebUserVO.setAvatar(userInfo.getQqAvatar()); // 判断登陆用户的email是否是管理员email sessionWebUserVO.setIsAdmin( ArrayUtils.contains(appConfig.getEmails().split(&quot;,&quot;), email)); // TODO: 初始化登陆用户的云盘空间 return sessionWebUserVO; &#125;&#125; 定义Controller在 UserInfoController 下定义登陆方法，登陆成功后将用户信息放入到Session中，并将验证码从Session中删除，防止验证码重复使用。 UserInfoController@RestController(&quot;userInfoController&quot;)@ResponseResult@Validatedpublic class UserInfoController &#123; private final UserInfoService userInfoService; public UserInfoController(UserInfoService userInfoService) &#123; this.userInfoService = userInfoService; &#125; @PostMapping(&quot;/login&quot;) public SessionWebUserVO login(HttpSession session, @Valid @RequestBody LoginDTO loginDto) &#123; try &#123; if (!loginDto.getCheckCode().equalsIgnoreCase((String) session.getAttribute(Constants.CHECK_CODE_KEY))) &#123; throw new BizException(&quot;图片验证码错误&quot;); &#125; SessionWebUserVO sessionWebUserVo = userInfoService.login(loginDto.getEmail(), loginDto.getPassword()); session.setAttribute(Constants.SESSION_KEY, sessionWebUserVo); return sessionWebUserVo; &#125; finally &#123; session.removeAttribute(Constants.CHECK_CODE_KEY); &#125; &#125;&#125;"},{"title":"用户注册服务","path":"/wiki/easypan/04_user/register.html","content":"用户注册时要发送验证码到邮箱，以此验证邮箱是否有效。因此该服务分为两部分，首先是发送邮箱验证码，并放入Redis缓存，其次是新增邮箱账户信息。 邮箱验证码接口信息使用字节流的方式写回前端 值 路径地址 http://localhost:7090/api/sendEmailCode 请求方式 POST 请求参数 email、checkCode、type 返回结果 定义Mapper将验证码置为无效 EmailCodeMapperpublic interface EmailCodeMapper extends BaseMapper&lt;EmailCode&gt; &#123; void disableEmailCode(@Param(&quot;email&quot;) String email);&#125; 在 EmailCodeMapper.xml 中实现接口，使用乐观锁 EmailCodeMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.easypan.mapper.EmailCodeMapper&quot;&gt; &lt;select id=&quot;disableEmailCode&quot;&gt; update email_code set status = 1 where email = #&#123;email&#125; and status = 0 &lt;/select&gt;&lt;/mapper&gt; 定义Service找到 EmailCodeService，定义发送验证码方法： public interface EmailCodeService extends IService&lt;EmailCode&gt; &#123; void sendEmailCode(String email, Integer type);&#125; 在 EmailCodeServiceImpl 实现该方法，发送的同时将验证码写入数据库 EmailCodeServiceImpl/** * &lt;p&gt; * 邮箱验证码服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-05-17 */@Servicepublic class EmailCodeServiceImpl extends ServiceImpl&lt;EmailCodeMapper, EmailCode&gt; implements EmailCodeService &#123; private final JavaMailSender javaMailSender; private final RedisComponent redisComponent; @Resource private AppConfig appConfig; public EmailCodeServiceImpl(JavaMailSender javaMailSender, RedisComponent redisComponent) &#123; this.javaMailSender = javaMailSender; this.redisComponent = redisComponent; &#125; @Override @Transactional(rollbackFor = Exception.class) public void sendEmailCode(String email, Integer type) &#123; String code = StringTools.getRandomNumber(Constants.LENGTH_5); // 发送验证码 sendMailCode(email, code); // 将之前的验证码置为无效 baseMapper.disableEmailCode(email); EmailCode emailCode = new EmailCode(); emailCode.setCode(code); emailCode.setEmail(email); emailCode.setStatus(Constants.ZERO); this.save(emailCode); &#125; private void sendMailCode(String toEmail, String code) &#123; try &#123; MimeMessage message = javaMailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(appConfig.getSendUsername()); helper.setTo(toEmail); SysSettingsDTO sysSettingsDto = redisComponent.getSysSettingDto(); helper.setSubject(sysSettingsDto.getRegisterMailTitle()); helper.setText(String.format(sysSettingsDto.getRegisterEmailContent(), code)); helper.setSentDate(new Date()); javaMailSender.send(message); &#125; catch (Exception e) &#123; throw new BizException(&quot;邮件发送失败&quot;); &#125; &#125;&#125; 定义Controller在 UserInfoController 下定义接口 UserInfoController@RestController(&quot;userInfoController&quot;)@ResponseResult@Validatedpublic class UserInfoController &#123; private final UserInfoService userInfoService; private final EmailCodeService emailCodeService; @Resource AppConfig appConfig; public UserInfoController(UserInfoService userInfoService, EmailCodeService emailCodeService) &#123; this.userInfoService = userInfoService; this.emailCodeService = emailCodeService; &#125; @PostMapping(&quot;/sendEmailCode&quot;) public void sendEmailCode(HttpSession session, @NotNull String email, @NotNull String checkCode, @NotNull Integer type) &#123; try &#123; if (!checkCode.equalsIgnoreCase((String) session.getAttribute(Constants.CHECK_CODE_KEY_EMAIL))) &#123; throw new BizException(&quot;图片验证码错误&quot;); &#125; // 0:注册 1：找回 if (type == 0) &#123; UserInfo userInfo = userInfoService.getOne(new LambdaQueryWrapper&lt;UserInfo&gt;().eq(UserInfo::getEmail, email)); if (null != userInfo) &#123; throw new BizException(&quot;邮箱已存在&quot;); &#125; &#125; emailCodeService.sendEmailCode(email, type); &#125; finally &#123; session.removeAttribute(Constants.CHECK_CODE_KEY_EMAIL); &#125; &#125;&#125; 用户注册服务接口信息 值 路径地址 http://localhost:7090/api/register 请求方式 POST 请求参数 RegisterDTO 返回结果 图片验证码DTO在包com.swx.easypan.entity.dto，下创建 RegisterDTO 实体类，将下面代码放入： @Datapublic class RegisterDTO &#123; @Email private String email; @NotNull private String nickname; @NotNull @Size(min = 8, max = 18, message = &quot;密码长度在8-18之间&quot;) private String password; @NotNull private String checkCode; @NotNull private String emailCode;&#125; 定义Mapper将验证码置为无效 EmailCodeMapperpublic interface EmailCodeMapper extends BaseMapper&lt;EmailCode&gt; &#123; void disableEmailCode(@Param(&quot;email&quot;) String email);&#125; 在 EmailCodeMapper.xml 中实现接口，使用乐观锁 EmailCodeMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.easypan.mapper.EmailCodeMapper&quot;&gt; &lt;select id=&quot;disableEmailCode&quot;&gt; update email_code set status = 1 where email = #&#123;email&#125; and status = 0 &lt;/select&gt;&lt;/mapper&gt; 定义Service找到 UserInfoService接口，在其中添加： UserInfoService/** * 注册 * * @param registerDto 注册信息 */void register(RegisterDTO registerDto); 在 UserInfoServiceImpl 中实现该方法，首先校验用户是否已经注册，然后校验其邮箱验证码，没有问题，则创建新用户，并初始化基础信息。 UserInfoServiceImpl@Servicepublic class UserInfoServiceImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt; implements UserInfoService &#123; private final EmailCodeService emailCodeService; private final RedisComponent redisComponent; @Resource private AppConfig appConfig; public UserInfoServiceImpl(EmailCodeService emailCodeService, RedisComponent redisComponent) &#123; this.emailCodeService = emailCodeService; this.redisComponent = redisComponent; &#125; /** * 注册 * * @param registerDto 注册信息 */ @Override @Transactional(rollbackFor = Exception.class) public void register(RegisterDTO registerDto) &#123; UserInfo emailUser = this.getOne(new LambdaQueryWrapper&lt;UserInfo&gt;().eq(UserInfo::getEmail, registerDto.getEmail())); if (null != emailUser) &#123; throw new BizException(&quot;邮箱账号已经存在&quot;); &#125; UserInfo nickNameUser = this.getOne(new LambdaQueryWrapper&lt;UserInfo&gt;().eq(UserInfo::getNickname, registerDto.getNickname())); if (null != nickNameUser) &#123; throw new BizException(&quot;邮箱昵称已经存在&quot;); &#125; // 校验邮箱验证码 emailCodeService.checkCode(registerDto.getEmail(), registerDto.getEmailCode()); String userId = StringTools.getRandomNumber(Constants.LENGTH_10); UserInfo userInfo = new UserInfo(); userInfo.setId(userId); userInfo.setNickname(registerDto.getNickname()); userInfo.setEmail(registerDto.getEmail()); userInfo.setPassword(MD5.encrypt(registerDto.getPassword())); userInfo.setUseSpace(0L); SysSettingsDTO sysSettingDto = redisComponent.getSysSettingDto(); userInfo.setTotalSpace(sysSettingDto.getUserInitSpace() * Constants.MB); this.save(userInfo); &#125;&#125; 定义Controller在 UserInfoController 下定义接口 UserInfoController@RestController(&quot;userInfoController&quot;)@ResponseResult@Validatedpublic class UserInfoController &#123; private final UserInfoService userInfoService; public UserInfoController(UserInfoService userInfoService) &#123; this.userInfoService = userInfoService; &#125; @PostMapping(&quot;/register&quot;) public void register(HttpSession session, @Valid @RequestBody RegisterDTO registerDto) &#123; try &#123; if (!registerDto.getCheckCode().equalsIgnoreCase((String) session.getAttribute(Constants.CHECK_CODE_KEY))) &#123; throw new BizException(&quot;图片验证码错误&quot;); &#125; userInfoService.register(registerDto); &#125; finally &#123; session.removeAttribute(Constants.CHECK_CODE_KEY); &#125; &#125;&#125;"},{"title":"获取用户信息","path":"/wiki/easypan/04_user/userinfo.html","content":"获取信息需要用户已经完成登陆操作，因此使用了登陆拦截，添加 @LoginValidator注解即可 获取用户信息在 UserInfoController 下定义获取登陆用户的信息方法 UserInfoController@GetMapping(&quot;getUserInfo&quot;)@LoginValidatorpublic SessionWebUserVO getUserInfo(HttpSession session) &#123; return (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY);&#125; 注销登录操作@PostMapping(&quot;/logout&quot;)@LoginValidatorpublic void logout(HttpSession session) &#123; session.invalidate();&#125; 重置密码功能接口信息请求参数和注册方法一致 值 路径地址 http://localhost:7090/api/resetPwd 请求方式 POST 请求参数 RegisterDTO 返回结果 定义Service找到 UserInfoService接口，在其中添加： UserInfoService/** * 重置密码 * * @param email 邮箱 * @param password 密码 * @param emailCode 邮箱验证码 */void resetPwd(String email, String password, String emailCode); 在 UserInfoServiceImpl 中实现该方法 UserInfoServiceImpl@Servicepublic class UserInfoServiceImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt; implements UserInfoService &#123; private final EmailCodeService emailCodeService; public UserInfoServiceImpl(EmailCodeService emailCodeService) &#123; this.emailCodeService = emailCodeService; &#125; /** * 重置密码 * * @param email 邮箱 * @param password 密码 * @param emailCode 邮箱验证码 */ @Override @Transactional(rollbackFor = Exception.class) public void resetPwd(String email, String password, String emailCode) &#123; UserInfo emailUser = this.getOne(new LambdaQueryWrapper&lt;UserInfo&gt;().eq(UserInfo::getEmail, email)); if (null == emailUser) &#123; throw new BizException(&quot;邮箱账号不存在&quot;); &#125; emailCodeService.checkCode(email, emailCode); emailUser.setPassword(MD5.encrypt(password)); updateById(emailUser); &#125;&#125; 定义Controller在 UserInfoController 下定义登陆方法，登陆成功后将用户信息放入到Session中，并将验证码从Session中删除，防止验证码重复使用。 UserInfoController@RestController(&quot;userInfoController&quot;)@ResponseResult@Validatedpublic class UserInfoController &#123; private final UserInfoService userInfoService; public UserInfoController(UserInfoService userInfoService) &#123; this.userInfoService = userInfoService; &#125; @PostMapping(&quot;/resetPwd&quot;) public void resetPwd(HttpSession session, @Valid @RequestBody RegisterDTO registerDto) &#123; try &#123; if (!registerDto.getCheckCode().equalsIgnoreCase((String) session.getAttribute(Constants.CHECK_CODE_KEY))) &#123; throw new BizException(&quot;图片验证码错误&quot;); &#125; userInfoService.resetPwd(registerDto.getEmail(), registerDto.getPassword(), registerDto.getEmailCode()); &#125; finally &#123; session.removeAttribute(Constants.CHECK_CODE_KEY); &#125; &#125;&#125; 更新用户密码接口信息 值 路径地址 http://localhost:7090/api/updatePassword 请求方式 POST 请求参数 password 返回结果 定义Controller在 UserInfoController 下定义更新用户密码，参数校验使用了Spring Validate。 UserInfoController@RestController(&quot;userInfoController&quot;)@ResponseResult@Validatedpublic class UserInfoController &#123; private final UserInfoService userInfoService; public UserInfoController(UserInfoService userInfoService) &#123; this.userInfoService = userInfoService; &#125; @PostMapping(&quot;/updatePassword&quot;) @LoginValidator public void updatePassword(HttpSession session, @Size(min = 8, max = 18, message = &quot;密码长度8-18&quot;) String password) &#123; SessionWebUserVO userVo = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); UserInfo userInfo = new UserInfo(); userInfo.setId(userVo.getId()); userInfo.setPassword(MD5.encrypt(password)); userInfoService.updateById(userInfo); &#125;&#125; 用户头像服务获取头像服务用户头像在部署系统中存储方式为工程目录+文件目录+头像目录+用户ID+头像文件后缀，即只需要知道用户的ID就可以找到头像所在目录，然后通过文件流的方式返回给前端。 接口信息请求参数和注册方法一致，通过文件流的方式写给前端 值 路径地址 http://localhost:7090/api/getAvatar/{userId} 请求方式 GET 请求参数 userId 返回结果 定义常量静态常量，Constants 类中定义常量 Constantspublic static final String FILE_FOLDER_FILE = &quot;/file/&quot;;public static final String FILE_FOLDER_TEMP = &quot;/file/temp/&quot;;public static final String FILE_FOLDER_AVATAR_NAME = &quot;avatar/&quot;;public static final String AVATAR_SUFFIX = &quot;.jpg&quot;;public static final String AVATAR_DEFAULT = &quot;default_avatar.jpg&quot;; 定义Controller在 UserInfoController 下定义获取头像方法，通过拼接目录和用户ID以及文件后缀，得到文件的路径，然后通过文件流的方式返回前端，如果没有则返回默认头像。 UserInfoController@RestController(&quot;userInfoController&quot;)@ResponseResult@Validatedpublic class UserInfoController &#123; @Resource AppConfig appConfig; @GetMapping(&quot;getAvatar/&#123;userId&#125;&quot;) public void getAvatar(HttpServletResponse response, @PathVariable @NotNull String userId) &#123; String avatarFolderName = Constants.FILE_FOLDER_FILE + Constants.FILE_FOLDER_AVATAR_NAME; File folder = new File(appConfig.getProjectFolder() + avatarFolderName); if (!folder.exists()) &#123; folder.mkdirs(); &#125; String avatarPath = appConfig.getProjectFolder() + avatarFolderName + userId + Constants.AVATAR_SUFFIX; File file = new File(avatarPath); if (!file.exists()) &#123; // 默认头像 String defaultAvatarPath = appConfig.getProjectFolder() + avatarFolderName + Constants.AVATAR_DEFAULT; File defaultAvatar = new File(defaultAvatarPath); if (!defaultAvatar.exists()) &#123; printNoDefaultImage(response); return; &#125; avatarPath = defaultAvatarPath; &#125; response.setContentType(&quot;image/jpg&quot;); FileUtil.readFile(response, avatarPath); &#125; private void printNoDefaultImage(HttpServletResponse response) &#123; response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.setStatus(HttpStatus.OK.value()); PrintWriter writer = null; try &#123; writer = response.getWriter(); writer.println(&quot;请在头像目录下放置默认头像default_avatar.jpg&quot;); writer.close(); &#125; catch (IOException e) &#123; throw new BizException(&quot;输出默认头像失败&quot;); &#125; &#125;&#125; 更新用户头像接口信息 值 路径地址 http://localhost:7090/api/updateUserAvatar 请求方式 POST 请求参数 MultipartFile 返回结果 定义Controller在 UserInfoController 下定义更新头像方法，接收到文件后，写入到头像目录，头像文件名为用户ID，后缀统一为JPG，更新成功后将Session中用户信息更新。 UserInfoController@RestController(&quot;userInfoController&quot;)@ResponseResult@Validatedpublic class UserInfoController &#123; private final UserInfoService userInfoService; public UserInfoController(UserInfoService userInfoService) &#123; this.userInfoService = userInfoService; &#125; @PostMapping(&quot;/updateUserAvatar&quot;) @LoginValidator public void updateUserAvatar(HttpSession session, MultipartFile avatar) &#123; SessionWebUserVO userVo = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); String baseFolder = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE; File targetFileFolder = new File(baseFolder + Constants.FILE_FOLDER_AVATAR_NAME); if (!targetFileFolder.exists()) &#123; targetFileFolder.mkdirs(); &#125; File targetFile = new File(targetFileFolder.getPath() + &quot;/&quot; + userVo.getId() + Constants.AVATAR_SUFFIX); try &#123; avatar.transferTo(targetFile); &#125; catch (IOException e) &#123; throw new BizException(&quot;头像更新失败&quot;); &#125; UserInfo userInfo = new UserInfo(); userInfo.setId(userVo.getId()); userInfo.setQqAvatar(&quot;&quot;); userInfoService.updateById(userInfo); userVo.setAvatar(null); session.setAttribute(Constants.SESSION_KEY, userVo); &#125;&#125;"},{"title":"用户空间服务","path":"/wiki/easypan/04_user/userspace.html","content":"用户空间缓存 用户的使用空间使用频率很高，除了保存在数据库中，还要缓存到Redis中，方便使用。 静态常量，在com.swx.easypan.entity.constants包下的 Constants 类中定义常量 public class Constants &#123; public static final Integer REDIS_KEY_EXPIRE_ONE_DAY= 60 * 60 * 24; public static final Integer REDIS_KEY_EXPIRE_ONE_HOUR = 60 * 60; public static final Integer REDIS_KEY_EXPIRE_FIVE_MIN = 5 * 60; public static final String REDIS_KEY_USER_SPACE_USE = &quot;easypan:user:spaceuse:&quot;;&#125; 从Redis缓存中获取和保存用户空间信息，在RedisComponent 编写获取和保存方法。 RedisComponent@Component(&quot;redisComponent&quot;)public class RedisComponent &#123; @Resource private RedisUtils&lt;Object&gt; redisUtils; public void saveUserSpaceUse(String userId, UserSpaceDTO userSpaceDto) &#123; redisUtils.setex(Constants.REDIS_KEY_USER_SPACE_USE + userId, userSpaceDto, Constants.REDIS_KEY_EXPIRE_ONE_DAY); &#125; public UserSpaceDTO getUserSpaceUse(String userId) &#123; return (UserSpaceDTO) redisUtils.get(Constants.REDIS_KEY_USER_SPACE_USE + userId); &#125;&#125; 获取用户空间用户的使用空间会缓存到Redis中，如果Redis中没有则会从数据库查询，查询用户所有的文件大小。 该部分需要先实现查询用户文件大小的接口，其在文件信息工程下。 接口信息 值 路径地址 http://localhost:7090/api/getUseSpace 请求方式 GET 请求参数 返回结果 UserSpaceDTO 返回结果DTO在包com.swx.easypan.entity.dto，创建 UserSpaceDTO 实体类，将下面代码放入： UserSpaceDTO@Datapublic class UserSpaceDTO implements Serializable &#123; private Long useSpace; private Long totalSpace; public UserSpaceDTO() &#123; &#125; public UserSpaceDTO(Long useSpace, Long totalSpace) &#123; this.useSpace = useSpace; this.totalSpace = totalSpace; &#125;&#125; 定义Service 该操作是涉及文件服务和用户服务，新增一层：用户文件服务 新建 UserFileService接口，在其中添加： UserFileServicepublic interface UserFileService &#123; /** * 获取用户使用空间 * * @param id 用户ID */ UserSpaceDTO getUseSpace(String id);&#125; 在 UserInfoServiceImpl 中实现该方法 UserFileServiceImpl@Servicepublic class UserFileServiceImpl implements UserFileService &#123; private final RedisComponent redisComponent; private final FileInfoService fileInfoService; private final UserInfoService userInfoService; public UserFileServiceImpl(RedisComponent redisComponent, FileInfoService fileInfoService, UserInfoService userInfoService) &#123; this.redisComponent = redisComponent; this.fileInfoService = fileInfoService; this.userInfoService = userInfoService; &#125; /** * 获取用户使用空间 * * @param id 用户ID */ @Override public UserSpaceDTO getUseSpace(String id) &#123; UserSpaceDTO spaceDTO = redisComponent.getUserSpaceUse(id); if (null == spaceDTO) &#123; spaceDTO = new UserSpaceDTO(); // 查询当前用户已经上传文件大小总和 Long useSpace = fileInfoService.getUseSpace(id); UserInfo userInfo = userInfoService.getById(id); spaceDTO.setUseSpace(useSpace); spaceDTO.setTotalSpace(userInfo.getTotalSpace()); redisComponent.saveUserSpaceUse(id, spaceDTO); &#125; return spaceDTO; &#125;&#125; 定义Controller在 UserInfoController 下定义登陆方法，登陆成功后将用户信息放入到Session中，并将验证码从Session中删除，防止验证码重复使用。 UserInfoController@RestController(&quot;userInfoController&quot;)@ResponseResult@Validatedpublic class UserInfoController &#123; private final UserInfoService userInfoService; public UserInfoController(UserInfoService userInfoService) &#123; this.userInfoService = userInfoService; &#125; @PostMapping(&quot;/login&quot;) public SessionWebUserVO login(HttpSession session, @Valid @RequestBody LoginDTO loginDto) &#123; try &#123; if (!loginDto.getCheckCode().equalsIgnoreCase((String) session.getAttribute(Constants.CHECK_CODE_KEY))) &#123; throw new BizException(&quot;图片验证码错误&quot;); &#125; SessionWebUserVO sessionWebUserVo = userInfoService.login(loginDto.getEmail(), loginDto.getPassword()); session.setAttribute(Constants.SESSION_KEY, sessionWebUserVo); return sessionWebUserVo; &#125; finally &#123; session.removeAttribute(Constants.CHECK_CODE_KEY); &#125; &#125;&#125; 更新用户空间定义Mapper找到 UserInfoMapper,定义更新用户空间的方法 public interface UserInfoMapper extends BaseMapper&lt;UserInfo&gt; &#123; Integer updateUserSpace(@Param(&quot;userId&quot;) String userId, @Param(&quot;useSpace&quot;) Long useSpace, @Param(&quot;totalSpace&quot;) Long totalSpace);&#125; 找到 UserInfoMapper.xml,实现更新用户空间的方法，该方法即可更新用户使用空间和用户总空间 UserInfoMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.easypan.mapper.UserInfoMapper&quot;&gt; &lt;update id=&quot;updateUserSpace&quot;&gt; update user_info &lt;set&gt; &lt;if test=&quot;useSpace!=null&quot;&gt; use_space = use_space + #&#123;useSpace&#125; &lt;/if&gt; &lt;if test=&quot;totalSpace!=null&quot;&gt; total_space = total_space + #&#123;totalSpace&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;userId&#125; &lt;if test=&quot;useSpace!=null&quot;&gt; and &lt;![CDATA[ (use_space + #&#123;useSpace&#125;) &lt;= total_space ]]&gt; &lt;/if&gt; &lt;if test=&quot;totalSpace!=null&quot;&gt; and &lt;![CDATA[ (total_space + #&#123;totalSpace&#125;) &gt;= use_space ]]&gt; &lt;/if&gt; &lt;/update&gt;&lt;/mapper&gt; 定义Service找到 UserInfoService接口，在其中添加： UserInfoService/** * 更新用户使用空间或者总空间 * * @param userId 用户ID * @param useSpace 使用空间 * @param totalSpace 总空间 * @return 是否更新成功 */Boolean updateUserSpace(String userId, Long useSpace, Long totalSpace); 在 UserInfoServiceImpl 中实现该方法 UserInfoServiceImpl@Overridepublic Boolean updateUserSpace(String userId, Long useSpace, Long totalSpace) &#123; Integer update = baseMapper.updateUserSpace(userId, useSpace, totalSpace); return update != null &amp;&amp; update &gt;= 1;&#125;"},{"title":"文件下载服务","path":"/wiki/easypan/05_file/download.html","content":"Redis缓存操作文件下载需要保存临时变量 静态常量，在com.swx.easypan.entity.constants包下的 Constants 类中定义常量 public class Constants &#123; public static final String REDIS_KEY_DOWNLOAD = &quot;easypan:download:&quot;;&#125; 从Redis缓存中获取和保存文件下载信息，在RedisComponent 编写获取和保存方法。 RedisComponent@Component(&quot;redisComponent&quot;)public class RedisComponent &#123; @Resource private RedisUtils&lt;Object&gt; redisUtils; // 保存下载文件信息 public void saveDownloadCode(String code, DownloadFileDTO fileDTO) &#123; redisUtils.setex(Constants.REDIS_KEY_DOWNLOAD + code, fileDTO, Constants.REDIS_KEY_EXPIRE_FIVE_MIN); &#125; // 获取下载文件信息 public DownloadFileDTO getDownloadCode(String code) &#123; return (DownloadFileDTO) redisUtils.get(Constants.REDIS_KEY_DOWNLOAD + code); &#125;&#125; 创建下载链接为了防止链接被无限使用，自己创建下载链接，附带code参数，控制链接有效性。 接口信息 值 路径地址 http://localhost:7090/api/file/createDownloadUrl/{id} 请求方式 GET 请求参数 id 返回结果 Map&lt;String, String&gt; 定义Service找到 FileInfoService，定义文件重命名方法 FileInfoService/** * 创建下载链接 * * @param userId 用户ID * @param id 文件ID */String createDownloadUrl(String userId, String id); 在 FileInfoServiceImpl 中，实现上述方法 FileInfoServiceImpl/** * 创建下载链接 * * @param userId 用户ID * @param id 文件ID */@Overridepublic String createDownloadUrl(String userId, String id) &#123; // 防小人 FileInfo fileInfo = getByMultiId(id, userId); if (fileInfo == null) &#123; throw new BizException(ResultCode.PARAM_IS_INVALID); &#125; if (FileFolderTypeEnums.FOLDER.getType().equals(fileInfo.getFolderType())) &#123; throw new BizException(ResultCode.PARAM_IS_INVALID); &#125; String code = StringTools.getRandomString(Constants.LENGTH_50); DownloadFileDTO fileDTO = new DownloadFileDTO(); fileDTO.setCode(code); fileDTO.setFilename(fileInfo.getFilename()); fileDTO.setFilePath(fileInfo.getFilePath()); // 保存到Redis redisComponent.saveDownloadCode(code, fileDTO); return code;&#125; 定义Controller在 FileInfoController 下定义文件重命名方法。 FileInfoController// 创建下载链接@GetMapping(&quot;/createDownloadUrl/&#123;id&#125;&quot;)public Map&lt;String, String&gt; createDownloadUrl(HttpSession session, @PathVariable(&quot;id&quot;) @NotEmpty String id) &#123; SessionWebUserVO user = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); // 需要校验登陆状态 String code = fileInfoService.createDownloadUrl(user.getId(), id); HashMap&lt;String, String&gt; data = new HashMap&lt;&gt;(); data.put(&quot;code&quot;, code); return data;&#125; 下载文件接口信息 值 路径地址 http://localhost:7090/api/file/download/{code} 请求方式 GET 请求参数 code 返回结果 字节流 定义Controller在 FileInfoController 下定义下载文件方法。根据code从Redis中获取文件信息，然后以字节流的形式返回给前端。 FileInfoController// 下载文件，无需登陆@LoginValidator(validated = false)@GetMapping(&quot;/download/&#123;code&#125;&quot;)public void download(HttpServletRequest request, HttpServletResponse response, @PathVariable @NotEmpty String code) throws UnsupportedEncodingException &#123; DownloadFileDTO fileDTO = redisComponent.getDownloadCode(code); if (null == fileDTO) &#123; return; &#125; String filePath = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + fileDTO.getFilePath(); String filename = fileDTO.getFilename(); FileUtils.writeDownloadFile(response, request, filename, filePath);&#125;"},{"title":"文件枚举类","path":"/wiki/easypan/05_file/enum.html","content":"所有的文件相关枚举在这里统一定义。 文件目录类型枚举类，在com.swx.easypan.entity.enums包下创建 FileFolderTypeEnums 枚举类： FileFolderTypeEnumspublic enum FileFolderTypeEnums &#123; FILE(0, &quot;文件&quot;), FOLDER(1, &quot;目录&quot;); private Integer type; private String desc; FileFolderTypeEnums(Integer type, String desc) &#123; this.type = type; this.desc = desc; &#125; public Integer getType() &#123; return type; &#125; public String getDesc() &#123; return desc; &#125;&#125; 文件类别枚举类，在com.swx.easypan.entity.enums包下创建 FileCategoryEnums 枚举类： FileCategoryEnumspublic enum FileCategoryEnums &#123; VIDEO(1, &quot;video&quot;, &quot;视频&quot;), MUSIC(2, &quot;music&quot;, &quot;音乐&quot;), IMAGE(3, &quot;image&quot;, &quot;图片&quot;), DOC(4, &quot;doc&quot;, &quot;文档&quot;), OTHER(5, &quot;other&quot;, &quot;其他&quot;); private final Integer category; private final String code; FileCategoryEnums(Integer category, String code, String desc) &#123; this.category = category; this.code = code; &#125; public static FileCategoryEnums getByCode(String code) &#123; for (FileCategoryEnums item : FileCategoryEnums.values()) &#123; if (item.getCode().equals(code)) &#123; return item; &#125; &#125; return null; &#125; public Integer getCategory() &#123; return category; &#125; public String getCode() &#123; return code; &#125;&#125; 文件删除状态枚举类，在com.swx.easypan.entity.enums包下创建 FileDelFlagEnums 枚举类： FileDelFlagEnumspublic enum FileDelFlagEnums &#123; USING(0, &quot;正常&quot;), RECYCLE(1, &quot;回收站&quot;), DEL(2, &quot;删除&quot;); private final Integer flag; private final String desc; FileDelFlagEnums(Integer flag, String desc) &#123; this.flag = flag; this.desc = desc; &#125; public Integer getFlag() &#123; return flag; &#125; public String getDesc() &#123; return desc; &#125;&#125; 文件状态枚举类，在com.swx.easypan.entity.enums包下创建 FileDelFlagEnums 枚举类： FileStatusEnumspublic enum FileStatusEnums &#123; TRANSFER(0, &quot;转码中&quot;), TRANSFER_FAIL(1, &quot;转码失败&quot;), USING(2, &quot;使用中&quot;); private final Integer status; private final String desc; FileStatusEnums(Integer status, String desc) &#123; this.status = status; this.desc = desc; &#125; public Integer getStatus() &#123; return status; &#125; public String getDesc() &#123; return desc; &#125;&#125; 文件类型枚举类，在com.swx.easypan.entity.enums包下创建 FileTypeEnums 枚举类： FileTypeEnumspublic enum FileTypeEnums &#123; VIDEO(FileCategoryEnums.VIDEO, 1, new String[]&#123;&quot;.mp4&quot;, &quot;.avi&quot;, &quot;.rmvb&quot;, &quot;.mkv&quot;, &quot;.mov&quot;, &quot;.flv&quot;&#125;, &quot;视频&quot;), MUSIC(FileCategoryEnums.MUSIC, 2, new String[]&#123;&quot;.mp3&quot;, &quot;.wav&quot;, &quot;.wma&quot;, &quot;.mp2&quot;, &quot;.flac&quot;, &quot;.midi&quot;, &quot;.ra&quot;, &quot;.ape&quot;, &quot;.aac&quot;, &quot;.cda&quot;&#125;, &quot;音频&quot;), IMAGE(FileCategoryEnums.IMAGE, 3, new String[]&#123;&quot;.jpeg&quot;, &quot;.jpg&quot;, &quot;.png&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.dds&quot;, &quot;.psd&quot;, &quot;.pdt&quot;, &quot;.webp&quot;, &quot;.xmp&quot;, &quot;.svg&quot;, &quot;.tiff&quot;&#125;, &quot;图片&quot;), PDF(FileCategoryEnums.DOC, 4, new String[]&#123;&quot;.pdf&quot;&#125;, &quot;pdf&quot;), WORD(FileCategoryEnums.DOC, 5, new String[]&#123;&quot;.doc&quot;, &quot;.docx&quot;&#125;, &quot;word&quot;), EXCEL(FileCategoryEnums.DOC, 6, new String[]&#123;&quot;.xlsx&quot;, &quot;.excel&quot;&#125;, &quot;excel&quot;), TXT(FileCategoryEnums.DOC, 7, new String[]&#123;&quot;.txt&quot;&#125;, &quot;文本&quot;), CODE(FileCategoryEnums.DOC, 8, new String[]&#123;&quot;.h&quot;, &quot;.c&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.c++&quot;, &quot;.cxx&quot;, &quot;.m&quot;, &quot;.o&quot;, &quot;.s&quot;, &quot;.dll&quot;, &quot;.cs&quot;, &quot;.java&quot;, &quot;.class&quot;, &quot;.js&quot;, &quot;.ts&quot;, &quot;.css&quot;, &quot;.scss&quot;, &quot;vue&quot;, &quot;.jsx&quot;, &quot;.sql&quot;, &quot;.md&quot;, &quot;.json&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.vue&quot;&#125;, &quot;代码&quot;), ZIP(FileCategoryEnums.OTHER, 9, new String[]&#123;&quot;.rar&quot;, &quot;.zip&quot;, &quot;.7z&quot;, &quot;.cab&quot;, &quot;.arj&quot;, &quot;.lzh&quot;, &quot;.tar&quot;, &quot;.gz&quot;, &quot;.ace&quot;, &quot;.uue&quot;, &quot;bz&quot;, &quot;.jar&quot;, &quot;.iso&quot;&#125;, &quot;视频&quot;), OTHER(FileCategoryEnums.OTHER, 10, new String[]&#123;&#125;, &quot;其他&quot;); private FileCategoryEnums category; private Integer type; private String[] suffixs; private String desc; FileTypeEnums(FileCategoryEnums category, Integer type, String[] suffix, String desc) &#123; this.category = category; this.type = type; this.suffixs = suffix; this.desc = desc; &#125; public static FileTypeEnums getBySuffix(String suffix) &#123; for (FileTypeEnums item : FileTypeEnums.values()) &#123; if (ArrayUtils.contains(item.getSuffixs(), suffix)) &#123; return item; &#125; &#125; return FileTypeEnums.OTHER; &#125; public static FileTypeEnums getByType(Integer type) &#123; for (FileTypeEnums item : FileTypeEnums.values()) &#123; if (item.getType().equals(type)) &#123; return item; &#125; &#125; return null; &#125; public FileCategoryEnums getCategory() &#123; return category; &#125; public Integer getType() &#123; return type; &#125; public String[] getSuffixs() &#123; return suffixs; &#125; public String getDesc() &#123; return desc; &#125;&#125; 时间格式枚举类 DateTimePatternEnumpublic enum DateTimePatternEnum &#123; YYYY_MM_DD_HH_MM_DD(&quot;yyyy-MM-dd HH:mm:ss&quot;), YYYY_MM_DD(&quot;yyyy-MM-dd&quot;), YYYYMM(&quot;yyyyMM&quot;); private String pattern; DateTimePatternEnum(String pattern) &#123; this.pattern = pattern; &#125; public String getPattern() &#123; return pattern; &#125;&#125;"},{"title":"获取文件列表","path":"/wiki/easypan/05_file/filelist.html","content":"文件按照格式设置大分类：视频、音乐、图片、文档、其他。 小分类分为：视频、音频、PDF、Word、Excel、文本、代码、压缩文件、其他。 找到com.swx.easypan.controller包下的 FileInfoController，修改代码如下： @RestController@RequestMapping(&quot;/file&quot;)@ResponseResult@LoginValidator@Validatedpublic class FileInfoController &#123;&#125; 获取文件列表接口信息 值 路径地址 http://localhost:7090/api/file/loadDataList 请求方式 GET 请求参数 FileInfoQuery、category 返回结果 Page 实体类查询参数DTO 在包com.swx.easypan.entity.query，创建 FileInfoQuery 实体类，将下面代码放入： FileInfoQuery/** * 文件信息参数 */@Datapublic class FileInfoQuery &#123; private Integer page = 1; private Integer limit = 20; private String orderBy = &quot;folder_type DESC, update_time DESC&quot;; /** * 用户ID */ private String userId; /** * 文件MD5值 */ private String fileMd5; /** * 文件父ID */ private String filePid; /** * 文件名 */ private String filename; /** * 文件分类 1:视频 2:音频 3:图片 4:文档 5:其他 */ private Integer fileCategory; /** * 0:正常 1:回收站 2:删除 */ private Integer deleted;&#125; 视图实体类 在包com.swx.easypan.entity.vo，创建 FileInfoVO 实体类，将下面代码放入： FileInfoVO@Datapublic class FileInfoVO &#123; /** * 文件ID */ private String id; /** * 文件父ID */ private String filePid; /** * 文件大小 */ private Long fileSize; /** * 文件名 */ private String filename; /** * 文件封面 */ private String fileCover; /** * 0文件 1目录 */ private Integer folderType; /** * 文件分类 1:视频 2:音频 3:图片 4:文档 5:其他 */ private Integer fileCategory; /** * 文件分类 1:视频 2:音频 3:图片 4:pdf 5:doc 6:excel 7:txt 9:压缩包 10:其他 */ private Integer fileType; /** * 0:转码中 1:转码失败 2:转码成功 */ private Integer status; /** * 最后更新时间 */ @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private LocalDateTime updateTime; /** * 回收时间 */ @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private LocalDateTime recoveryTime;&#125; 定义Mapper找到 FileInfoMapper,添加查询文件的方法 FileInfoMapperpublic interface FileInfoMapper extends BaseMapper&lt;FileInfo&gt; &#123; IPage&lt;FileInfo&gt; selectPageInfo(Page&lt;FileInfo&gt; pageParam, @Param(&quot;query&quot;) FileInfoQuery query);&#125; 找到 FileInfoMapper.xml,实现查询文件的方法，该方法复杂查询 FileInfoMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.easypan.mapper.FileInfoMapper&quot;&gt; &lt;select id=&quot;selectPageInfo&quot; parameterType=&quot;com.swx.easypan.entity.query.FileInfoQuery&quot; resultType=&quot;com.swx.easypan.pojo.FileInfo&quot;&gt; SELECT * FROM file_info fi &lt;where&gt; &lt;if test=&quot;query.userId != null&quot;&gt; and fi.user_id = #&#123;query.userId&#125; &lt;/if&gt; &lt;if test=&quot;query.fileMd5 != null and query.fileMd5 != &#x27;&#x27;&quot;&gt; and fi.file_md5 = #&#123;query.fileMd5&#125; &lt;/if&gt; &lt;if test=&quot;query.filePid != null and query.filePid != &#x27;&#x27;&quot;&gt; and fi.file_pid = #&#123;query.filePid&#125; &lt;/if&gt; &lt;if test=&quot;query.filename != null and query.filename != &#x27;&#x27;&quot;&gt; and fi.filename like CONCAT(&#x27;%&#x27;, #&#123;query.filename&#125;, &#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;query.fileCategory != null&quot;&gt; and fi.file_category = #&#123;query.fileCategory&#125; &lt;/if&gt; &lt;if test=&quot;query.deleted != null&quot;&gt; and fi.deleted = #&#123;query.deleted&#125; &lt;/if&gt; &lt;/where&gt; &lt;if test=&quot;query.orderBy != null and query.orderBy!= &#x27;&#x27;&quot;&gt; ORDER BY $&#123;query.orderBy&#125; &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; 定义Service找到 FileInfoService 接口，在其中添加： FileInfoServicepublic interface FileInfoService extends IService&lt;FileInfo&gt; &#123; IPage&lt;FileInfoVO&gt; pageInfo(Page&lt;FileInfo&gt; pageParam, FileInfoQuery query);&#125; 在 UserInfoServiceImpl 中实现该方法 FileInfoServiceImpl@Slf4j@Servicepublic class FileInfoServiceImpl extends ServiceImpl&lt;FileInfoMapper, FileInfo&gt; implements FileInfoService &#123; @Override public IPage&lt;FileInfoVO&gt; pageInfo(Page&lt;FileInfo&gt; pageParam, FileInfoQuery query) &#123; IPage&lt;FileInfo&gt; iPage = baseMapper.selectPageInfo(pageParam, query); List&lt;FileInfo&gt; records = iPage.getRecords(); List&lt;FileInfoVO&gt; fileInfoVOS = records.stream().map(item -&gt; &#123; FileInfoVO fileInfoVO = new FileInfoVO(); BeanUtils.copyProperties(item, fileInfoVO); return fileInfoVO; &#125;).collect(Collectors.toList()); IPage&lt;FileInfoVO&gt; page = new Page&lt;FileInfoVO&gt;(pageParam.getCurrent(), pageParam.getSize(), iPage.getTotal()); page.setRecords(fileInfoVOS); return page; &#125;&#125; 定义Controller在 FileInfoController 下定义查询方法，根据类别进行多条件的分页查询。 FileInfoController@RestController@RequestMapping(&quot;/file&quot;)@ResponseResult@LoginValidator@Validatedpublic class FileInfoController &#123; private final FileInfoService fileInfoService; public FileInfoController(FileInfoService fileInfoService) &#123; this.fileInfoService = fileInfoService; &#125; // 根据category，加载所有数据 @GetMapping(&quot;/loadDataList&quot;) public IPage&lt;FileInfoVO&gt; loadDataList(HttpSession session, FileInfoQuery query, String category) &#123; FileCategoryEnums categoryEnums = FileCategoryEnums.getByCode(category); if (null != categoryEnums) &#123; query.setFileCategory(categoryEnums.getCategory()); &#125; Page&lt;FileInfo&gt; pageParam = new Page&lt;&gt;(query.getPage(), query.getLimit()); query.setUserId(((SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY)).getId()); query.setDeleted(FileDelFlagEnums.USING.getFlag()); return fileInfoService.pageInfo(pageParam, query); &#125;&#125; 用户文件大小根据用户的ID查询该用户所有文件，累加所有文件大小。 定义Mapper找到 FileInfoMapper,添加查询用户文件大小的方法 FileInfoMapperLong selectUseSpace(@Param(&quot;userId&quot;) String userId); 找到 FileInfoMapper.xml,实现查询用户文件大小的方法。 FileInfoMapper.xml&lt;select id=&quot;selectUseSpace&quot; resultType=&quot;long&quot;&gt; SELECT IFNULL(SUM(file_size), 0) FROM file_info WHERE user_id = #&#123;userId&#125;&lt;/select&gt; 定义Service找到 FileInfoService 接口，在其中添加： FileInfoService/** * 查询用户使用的空间 * * @param userId 用户ID */Long getUseSpace(String userId); 在 UserInfoServiceImpl 中实现该方法 FileInfoServiceImpl/** * 查询用户使用的空间 * * @param userId 用户ID */@Overridepublic Long getUseSpace(String userId) &#123; return baseMapper.selectUseSpace(userId);&#125;"},{"title":"目录操作服务","path":"/wiki/easypan/05_file/folder.html","content":"新建目录接口信息 值 路径地址 http://localhost:7090/api/file/newFolder 请求方式 POST 请求参数 NewFolderDTO 返回结果 FileInfoVO 参数DTO在com.swx.easypan.entity.dto包下，创建 NewFolderDTO，新建目录参数 NewFolderDTO@JsonIgnoreProperties(ignoreUnknown = true)public class NewFolderDTO implements Serializable &#123; private static final long serialVersionUID = 1L; @NotEmpty private String filePid; @NotEmpty private String filename; public String getFilePid() &#123; return filePid; &#125; public void setFilePid(String filePid) &#123; this.filePid = filePid; &#125; public String getFilename() &#123; return filename; &#125; public void setFilename(String filename) &#123; this.filename = filename; &#125;&#125; 定义Service找到 FileInfoService，定义新建目录方法 FileInfoService/** * 新建目录 * * @param folderDTO 目录信息 * @param userId 用户ID */FileInfoVO newFolder(NewFolderDTO folderDTO, String userId); 在 FileInfoServiceImpl 中，实现上述方法 FileInfoServiceImpl@Overridepublic FileInfoVO newFolder(NewFolderDTO folderDTO, String userId) &#123; // 校验文件夹名 String rename = autoRename(folderDTO.getFilePid(), userId, folderDTO.getFilename()); // 构造属性 FileInfo fileInfo = new FileInfo(); fileInfo.setId(StringTools.getRandomString(Constants.LENGTH_10)); fileInfo.setUserId(userId); fileInfo.setFilename(rename); fileInfo.setFilePid(folderDTO.getFilePid()); fileInfo.setFolderType(FileFolderTypeEnums.FOLDER.getType()); fileInfo.setStatus(FileStatusEnums.USING.getStatus()); // 保存 this.save(fileInfo); // 返回 FileInfoVO fileInfoVO = new FileInfoVO(); BeanUtils.copyProperties(fileInfo, fileInfoVO); return fileInfoVO;&#125;/** * 当文件名字相同时，重命名文件 * * @param filePid 文件PID * @param userId 用户ID * @param filename 文件名 */private String autoRename(String filePid, String userId, String filename) &#123; int count = this.count(new LambdaQueryWrapper&lt;FileInfo&gt;() .eq(FileInfo::getUserId, userId) .eq(FileInfo::getFilePid, filePid) .eq(FileInfo::getDeleted, FileDelFlagEnums.USING.getFlag()) .eq(FileInfo::getFilename, filename)); if (count &gt; 0) &#123; filename = StringTools.rename(filename); &#125; return filename;&#125; 定义Controller在 FileInfoController 下定义新建文件夹方法。 FileInfoController// 新建文件夹@PostMapping(&quot;/newFolder&quot;)public FileInfoVO newFolder(HttpSession session, @RequestBody NewFolderDTO folderDTO) &#123; SessionWebUserVO user = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); return fileInfoService.newFolder(folderDTO, user.getId());&#125; 查询目录接口信息 值 路径地址 http://localhost:7090/api/file/getFolderInfo 请求方式 GET 请求参数 path 返回结果 List 定义Service找到 FileInfoService，定义根据ids获取目录信息方法 FileInfoService/** * 根据ids获取目录信息 * * @param ids ids */List&lt;FileInfoVO&gt; listFolderByIds(String[] ids); 在 FileInfoServiceImpl 中，实现上述方法 FileInfoServiceImpl/** * 根据ids获取目录信息 * * @param ids ids */@Overridepublic List&lt;FileInfoVO&gt; listFolderByIds(String[] ids) &#123; LambdaQueryWrapper&lt;FileInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.select(FileInfo::getId, FileInfo::getFilename).in(FileInfo::getId, Arrays.asList(ids)).last(&quot;order by field(id, \\&quot;&quot; + StringUtils.join(ids, &quot;\\&quot;,\\&quot;&quot;) + &quot;\\&quot;)&quot;); List&lt;FileInfo&gt; list = list(wrapper); List&lt;FileInfoVO&gt; fileInfoVOS = list.stream().map(item -&gt; &#123; FileInfoVO fileInfoVO = new FileInfoVO(); BeanUtils.copyProperties(item, fileInfoVO); return fileInfoVO; &#125;).collect(Collectors.toList()); return fileInfoVOS;&#125; 定义Controller在 FileInfoController 下定义新建文件夹方法。 FileInfoController// 获取目录信息@GetMapping(&quot;/getFolderInfo&quot;)public List&lt;FileInfoVO&gt; getFolderInfo(HttpSession session, @NotEmpty String path) &#123; SessionWebUserVO user = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); String[] ids = path.split(&quot;/&quot;); return fileInfoService.listFolderByIds(ids);&#125; 获取目录接口信息 值 路径地址 http://localhost:7090/api/file/loadAllFolder 请求方式 GET 请求参数 filePid 返回结果 List 定义Controller在 FileInfoController 下定义新建文件夹方法。 FileInfoController// 获取所有目录@GetMapping(&quot;/loadAllFolder&quot;)public List&lt;FileInfoVO&gt; loadAllFolder(HttpSession session, @NotEmpty String filePid) &#123; SessionWebUserVO user = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); LambdaQueryWrapper&lt;FileInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(FileInfo::getFilePid, filePid) .eq(FileInfo::getUserId, user.getId()) .eq(FileInfo::getFolderType, FileFolderTypeEnums.FOLDER.getType()); List&lt;FileInfo&gt; list = fileInfoService.list(wrapper); return list.stream().map(item -&gt; &#123; FileInfoVO fileInfoVO = new FileInfoVO(); BeanUtils.copyProperties(item, fileInfoVO); return fileInfoVO; &#125;).collect(Collectors.toList());&#125;"},{"title":"获取文件信息","path":"/wiki/easypan/05_file/info.html","content":"获取文件封面接口信息以字节流的方式写回前端 值 路径地址 http://localhost:7090/api/file/getImage/{imageFolder}/{imageName} 请求方式 GET 请求参数 imageFolder、imageName 返回结果 定义Controller在 FileInfoController 下定义查询方法，获取文件封面。 // 获取文件封面@GetMapping(&quot;/getImage/&#123;imageFolder&#125;/&#123;imageName&#125;&quot;)public void getImage(HttpServletResponse response, @PathVariable(&quot;imageFolder&quot;) @NotNull String imageFolder, @PathVariable(&quot;imageName&quot;) @NotNull String imageName) &#123; String imagePath = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + imageFolder + &quot;/&quot; + imageName; FileUtils.writeImage(response, imagePath);&#125; 获取视频文件接口信息以字节流的方式写回前端 值 路径地址 http://localhost:7090/api/file/ts/getVideoInfo/{id} 请求方式 GET 请求参数 id 返回结果 定义Service找到 FileInfoService，定义获取文件路径方法 FileInfoService/** * 获取文件路径 * * @param id 文件ID * @param userId 用户ID */String getFilePath(String id, String userId); 在 FileInfoServiceImpl 中实现该方法，如果获取的是.ts切片文件，则根据.ts文件名获取该文件ID，从数据库查询后，返回其所在目录；如果是视频文件，则返回其.m3u8文件；其他文件直接返回。 FileInfoServiceImpl/** * 获取文件路径 * * @param id 文件ID * @param userId 用户ID */@Overridepublic String getFilePath(String id, String userId) &#123; String filePath = null; if (id.endsWith(&quot;.ts&quot;)) &#123; String[] tsArray = id.split(&quot;_&quot;); String realFileId = tsArray[0]; FileInfo fileInfo = this.getOne(new LambdaQueryWrapper&lt;FileInfo&gt;().eq(FileInfo::getId, realFileId).eq(FileInfo::getUserId, userId)); String fileName = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + fileInfo.getFilePath(); String folderPath = StringTools.getFilename(fileName); filePath = folderPath + &quot;/&quot; + id; &#125; else &#123; FileInfo fileInfo = this.getOne(new LambdaQueryWrapper&lt;FileInfo&gt;().eq(FileInfo::getId, id).eq(FileInfo::getUserId, userId)); if (null == fileInfo) &#123; throw new BizException(&quot;文件不存在&quot;); &#125; if (FileCategoryEnums.VIDEO.getCategory().equals(fileInfo.getFileCategory())) &#123; String fileName = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + fileInfo.getFilePath(); String folderPath = StringTools.getFilename(fileName); filePath = folderPath + &quot;/&quot; + Constants.M3U8_NAME; &#125; else &#123; filePath = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + fileInfo.getFilePath(); &#125; &#125; return filePath;&#125; 定义Controller在 FileInfoController 下定义查询方法，获取文件封面。 // 获取文件封面@GetMapping(&quot;/getImage/&#123;imageFolder&#125;/&#123;imageName&#125;&quot;)public void getImage(HttpServletResponse response, @PathVariable(&quot;imageFolder&quot;) @NotNull String imageFolder, @PathVariable(&quot;imageName&quot;) @NotNull String imageName) &#123; String imagePath = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + imageFolder + &quot;/&quot; + imageName; FileUtils.writeImage(response, imagePath);&#125; 获取文件接口信息以字节流的方式写回前端 值 路径地址 http://localhost:7090/api/file/getFile/{id} 请求方式 GET 请求参数 id 返回结果 定义Controller在 FileInfoController 下定义查询方法，获取文件流。 // 获取文件@GetMapping(&quot;/getFile/&#123;id&#125;&quot;)public void getFile(HttpSession session, HttpServletResponse response, @PathVariable(&quot;id&quot;) @NotBlank String id) &#123; SessionWebUserVO user = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); String filePath = fileInfoService.getFilePath(id, user.getId()); FileUtil.readFile(response, filePath);&#125;"},{"title":"文件回收站服务","path":"/wiki/easypan/05_file/recycle.html","content":"文件删除时并非真正的删除，将文件状态置为RECYCLE状态，如果是目录，将其中的文件置为DEL状态，目录则置为RECYCLE，回收站查询时只查询RECYCLE状态的文件和目录。 接口信息 值 路径地址 http://localhost:7090/api/file/delFile/{ids} 请求方式 GET 请求参数 ids 返回结果 定义Mapper找到 FileInfoMapper 接口，在其中添加如下方法定义，批量更新文件的删除和回收状态 FileInfoMapperInteger updateFileDelFlagBatch(@Param(&quot;bean&quot;) FileInfo fileInfo, @Param(&quot;userId&quot;) String userId, @Param(&quot;pidList&quot;) List&lt;String&gt; delFilePidList, @Param(&quot;idList&quot;) List&lt;String&gt; idList, @Param(&quot;oldDelFlag&quot;) Integer oldDelFlag); 找到 FileInfoMapper.xml 文件，实现上述方法 FileInfoMapper.xml&lt;update id=&quot;updateFileDelFlagBatch&quot;&gt; UPDATE file_info &lt;set&gt; &lt;if test=&quot;bean.filePid != null&quot;&gt; file_pid = #&#123;bean.filePid&#125;, &lt;/if&gt; &lt;if test=&quot;bean.recoveryTime != null&quot;&gt; recovery_time = #&#123;bean.recoveryTime&#125;, &lt;/if&gt; &lt;if test=&quot;bean.deleted != null&quot;&gt; deleted = #&#123;bean.deleted&#125;, &lt;/if&gt; &lt;if test=&quot;bean.updateTime != null&quot;&gt; update_time = #&#123;bean.updateTime&#125; &lt;/if&gt; &lt;/set&gt; WHERE user_id = #&#123;userId&#125; &lt;if test=&quot;pidList != null&quot;&gt; and file_pid in(&lt;foreach collection=&quot;pidList&quot; separator=&quot;,&quot; item=&quot;item&quot;&gt;#&#123;item&#125;&lt;/foreach&gt;) &lt;/if&gt; &lt;if test=&quot;idList != null&quot;&gt; and id in(&lt;foreach collection=&quot;idList&quot; separator=&quot;,&quot; item=&quot;item&quot;&gt;#&#123;item&#125;&lt;/foreach&gt;) &lt;/if&gt; &lt;if test=&quot;oldDelFlag != null&quot;&gt; and deleted = #&#123;oldDelFlag&#125; &lt;/if&gt;&lt;/update&gt; 定义Service找到 FileInfoService 接口，在其中添加： FileInfoService/** * 将文件移入回收站 * * @param userId 用户ID * @param ids 文件IDS，逗号分隔 */void removeFile2RecycleBatch(String userId, String ids); 在 UserInfoServiceImpl 中实现该方法 FileInfoServiceImpl/** * 将文件移入回收站 * * @param userId 用户ID * @param ids 文件IDS，逗号分隔 */@Overridepublic void removeFile2RecycleBatch(String userId, String ids) &#123; // 查询文件是否已经在回收站 LambdaQueryWrapper&lt;FileInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(FileInfo::getUserId, userId) .eq(FileInfo::getDeleted, FileDelFlagEnums.USING.getFlag()) .in(StringUtils.isNotEmpty(ids), FileInfo::getId, Arrays.asList(ids.split(&quot;,&quot;))); List&lt;FileInfo&gt; dbFileList = list(wrapper); if (dbFileList.isEmpty()) &#123; return; &#125; // 递归删除文件 ArrayList&lt;String&gt; delFilePidList = new ArrayList&lt;&gt;(); for (FileInfo fileInfo : dbFileList) &#123; findAllSubFolderList(delFilePidList, userId, fileInfo.getId(), FileDelFlagEnums.USING.getFlag()); &#125; if (!delFilePidList.isEmpty()) &#123; // 目录下的文件，非选中文件直接删除，即deleted置为2 FileInfo delFileInfo = new FileInfo(); delFileInfo.setDeleted(FileDelFlagEnums.DEL.getFlag()); // 根据Pid删除文件，即删除目录下的所有文件 baseMapper.updateFileDelFlagBatch(delFileInfo, userId, delFilePidList, null, FileDelFlagEnums.USING.getFlag()); &#125; // 将选中的文件更新为回收站，即deleted置为1 List&lt;String&gt; recIds = Arrays.asList(ids.split(&quot;,&quot;)); FileInfo recFileInfo = new FileInfo(); recFileInfo.setDeleted(FileDelFlagEnums.RECYCLE.getFlag()); recFileInfo.setRecoveryTime(LocalDateTime.now()); baseMapper.updateFileDelFlagBatch(recFileInfo, userId, null, recIds, FileDelFlagEnums.USING.getFlag());&#125;// 递归查找当前目录下的子目录public void findAllSubFolderList(List&lt;String&gt; idList, String userId, String id, Integer delFlag) &#123; idList.add(id); // 查找当前目录下的所有子目录 LambdaQueryWrapper&lt;FileInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(FileInfo::getUserId, userId) .eq(FileInfo::getFilePid, id) .eq(FileInfo::getDeleted, delFlag) .eq(FileInfo::getFolderType, FileFolderTypeEnums.FOLDER.getType()); List&lt;FileInfo&gt; fileInfoList = list(wrapper); for (FileInfo fileInfo : fileInfoList) &#123; findAllSubFolderList(idList, userId, fileInfo.getId(), delFlag); &#125;&#125; 定义Controller在 FileInfoController 下定义删除文件方法，将文件移入回收站，不释放使用空间。 FileInfoController// 删除文件@DeleteMapping(&quot;/delFile/&#123;ids&#125;&quot;)public void delFile(HttpSession session, @PathVariable(&quot;ids&quot;) @NotEmpty String ids) &#123; SessionWebUserVO user = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); // 需要校验登陆状态 fileInfoService.removeFile2RecycleBatch(user.getId(), ids);&#125;"},{"title":"文件转码服务","path":"/wiki/easypan/05_file/transfer.html","content":"分片文件上传之后需要进行合并操作， 视频文件合并之后需要进行切割同时生成索引文件.m3u8和切片.ts，同时生成视频缩略图 图片文件同样需要生成缩略图 FFmpegFFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。 安装FFmpeg本次视频的切片使用的是FFmpeg工具，使用Maven方式，无需在机器上部署FFmpeg，其Maven依赖如下： &lt;!--FFmpeg--&gt;&lt;dependency&gt; &lt;groupId&gt;ws.schild&lt;/groupId&gt; &lt;artifactId&gt;jave-all-deps&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 视频操作新建com.swx.easypan.utils包，并在该包下创建 FfmpegUtil,添加如下方法 FfmpegUtilpublic class FfmpegUtil &#123; private static final Logger logger = LoggerFactory.getLogger(ProcessUtils.class); /** * 生成index.ts * * @param videoFilePath 视频路径 * @param tsPath ts文件路径 */ public static void transfer2ts(String videoFilePath, String tsPath) &#123; // &quot;ffmpeg -y -i %s -vcodec copy -acodec copy -vbsf h264_mp4toannexb %s&quot; try &#123; ProcessWrapper ffmpeg = new DefaultFFMPEGLocator().createExecutor(); ffmpeg.addArgument(&quot;-y&quot;); ffmpeg.addArgument(&quot;-i&quot;); ffmpeg.addArgument(videoFilePath); ffmpeg.addArgument(&quot;-vcodec&quot;); ffmpeg.addArgument(&quot;copy&quot;); ffmpeg.addArgument(&quot;-acodec&quot;); ffmpeg.addArgument(&quot;copy&quot;); ffmpeg.addArgument(&quot;-vbsf&quot;); ffmpeg.addArgument(&quot;h264_mp4toannexb&quot;); ffmpeg.addArgument(tsPath); ffmpeg.execute(); try (BufferedReader br = new BufferedReader(new InputStreamReader(ffmpeg.getErrorStream()))) &#123; blockFfmpeg(br); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;ts文件生成失败&quot;, e); throw new BizException(&quot;视频转换失败&quot;); &#125; &#125; /** * 视频切片 * * @param tsPath ts文件路径 * @param m3u8Path index.m3u8路径 * @param tsFolder 切片文件目录路径 * @param fileId 文件ID */ public static void cutTs(String tsPath, String m3u8Path, String tsFolder, String fileId) &#123; // &quot;ffmpeg -i %s -c copy -map 0 -f segment -segment_list %s -segment_time 30 %s/%s_%%4d.ts&quot; try &#123; ProcessWrapper ffmpeg = new DefaultFFMPEGLocator().createExecutor(); ffmpeg.addArgument(&quot;-i&quot;); ffmpeg.addArgument(tsPath); ffmpeg.addArgument(&quot;-c&quot;); ffmpeg.addArgument(&quot;copy&quot;); ffmpeg.addArgument(&quot;-map&quot;); ffmpeg.addArgument(&quot;0&quot;); ffmpeg.addArgument(&quot;-f&quot;); ffmpeg.addArgument(&quot;segment&quot;); ffmpeg.addArgument(&quot;-segment_list&quot;); ffmpeg.addArgument(m3u8Path); ffmpeg.addArgument(&quot;-segment_time&quot;); ffmpeg.addArgument(&quot;30&quot;); ffmpeg.addArgument(String.format(&quot;%s/%s_%%4d.ts&quot;, tsFolder, fileId)); ffmpeg.execute(); try (BufferedReader br = new BufferedReader(new InputStreamReader(ffmpeg.getErrorStream()))) &#123; blockFfmpeg(br); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;文件切片失败&quot;, e); throw new BizException(&quot;视频转换失败&quot;); &#125; &#125; /** * 获取视频缩略图 * * @param sourceFile 视频文件地址 * @param width 缩略图宽度 * @param targetFile 缩略图地址 */ public static void createTargetThumbnail(File sourceFile, Integer width, File targetFile) &#123; // &quot;ffmpeg -i %s -y -vframes 1 -vf scale=%d:%d/a %s&quot; try &#123; ProcessWrapper ffmpeg = new DefaultFFMPEGLocator().createExecutor(); ffmpeg.addArgument(&quot;-i&quot;); ffmpeg.addArgument(sourceFile.getAbsoluteFile().toString()); ffmpeg.addArgument(&quot;-y&quot;); ffmpeg.addArgument(&quot;-vframes&quot;); ffmpeg.addArgument(&quot;1&quot;); ffmpeg.addArgument(&quot;-vf&quot;); ffmpeg.addArgument(String.format(&quot;scale=%d:%d/a&quot;, width, width)); ffmpeg.addArgument(targetFile.getAbsoluteFile().toString()); ffmpeg.execute(); try (BufferedReader br = new BufferedReader(new InputStreamReader(ffmpeg.getErrorStream()))) &#123; blockFfmpeg(br); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;生成封面失败&quot;, e); throw new BizException(&quot;生成封面失败&quot;); &#125; &#125; /** * 等待命令执行成功，退出 * * @param br * @throws IOException */ private static void blockFfmpeg(BufferedReader br) throws IOException &#123; String line; // 该方法阻塞线程，直至合成成功 while ((line = br.readLine()) != null) &#123; doNothing(line); &#125; &#125; private static void doNothing(String line) &#123; // logger.info(&quot;ffmpeg命令执行中————&#123;&#125;&quot;, line); &#125;&#125; 图片操作在 FfmpegUtil 中添加图片处理方法，生成图片缩略图 FfmpegUtilpublic static Boolean createThumbnailWidthFFmpeg(File sourceFile, Integer width, File targetFile, Boolean delSource) &#123; try &#123; BufferedImage src = ImageIO.read(sourceFile); int sourceW = src.getWidth(); // 小于指定高宽不要压缩 if (sourceW &lt; width) &#123; return false; &#125; compressImage(sourceFile, width, targetFile, delSource); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125;&#125;/** * 压缩图片，获取图片缩略图 * * @param sourceFile 源图片地址 * @param width 图片压缩宽度 * @param targetFile 缩略图 * @param delSource 是否删除原图 */public static void compressImage(File sourceFile, Integer width, File targetFile, Boolean delSource) &#123; // String cmd = &quot;ffmpeg -i %s -vf scale=%d:-1 %s -y&quot; try &#123; ProcessWrapper ffmpeg = new DefaultFFMPEGLocator().createExecutor(); ffmpeg.addArgument(&quot;-i&quot;); ffmpeg.addArgument(sourceFile.getAbsoluteFile().toString()); ffmpeg.addArgument(&quot;-vf&quot;); ffmpeg.addArgument(String.format(&quot;scale=%d:-1&quot;, width)); ffmpeg.addArgument(targetFile.getAbsolutePath()); ffmpeg.addArgument(&quot;-y&quot;); ffmpeg.execute(); try (BufferedReader br = new BufferedReader(new InputStreamReader(ffmpeg.getErrorStream()))) &#123; blockFfmpeg(br); &#125; if (delSource) &#123; FileUtils.deleteDirectory(sourceFile); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;压缩图片失败&quot;, e); throw new BizException(&quot;生成封面失败&quot;); &#125;&#125; 定义常量静态常量，在com.swx.easypan.entity.constants包下的 Constants 类中定义常量 Constantspublic class Constants &#123; public static final String FILE_FOLDER_FILE = &quot;/file/&quot;; public static final String FILE_FOLDER_TEMP = &quot;/file/temp/&quot;; public static final String IMAGE_PNG_SUFFIX = &quot;.png&quot;; public static final String TS_NAME = &quot;index.ts&quot;; public static final String M3U8_NAME = &quot;index.m3u8&quot;;&#125; 文件转码找到 FileInfoServiceImpl，定义 转码方法 transferFile，添加@Async异步注解 FileInfoServiceImplpublic class FileInfoServiceImpl extends ServiceImpl&lt;FileInfoMapper, FileInfo&gt; implements FileInfoService &#123; private final AppConfig appConfig; @Async public void transferFile(String fileId, String userId) &#123; boolean transferSuccess = true; String targetFilePath = null; String cover = null; FileInfo fileInfo = getByMultiId(fileId, userId); if (fileInfo == null || !FileStatusEnums.TRANSFER.getStatus().equals(fileInfo.getStatus())) &#123; return; &#125; try &#123; // 临时目录 String tempFolderName = appConfig.getProjectFolder() + Constants.FILE_FOLDER_TEMP; String currentUserFolderName = userId + fileId; File fileFolder = new File(tempFolderName + currentUserFolderName); String fileSuffix = StringTools.getFileSuffix(fileInfo.getFilename()); String month = fileInfo.getCreateTime().format(DateTimeFormatter.ofPattern(DateTimePatternEnum.YYYYMM.getPattern())); // 目标目录 String targetFolderName = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE; File targetFolder = new File(targetFolderName + &quot;/&quot; + month); if (!targetFolder.exists()) &#123; targetFolder.mkdirs(); &#125; // 真实文件名 String realFilename = currentUserFolderName + fileSuffix; targetFilePath = targetFolder.getPath() + &quot;/&quot; + realFilename; // 合并文件 union(fileFolder.getPath(), targetFilePath, fileInfo.getFilename(), true); // 视频文件切割 Integer fileType = fileInfo.getFileType(); // 文件缩略图 if (FileTypeEnums.VIDEO.getType().equals(fileType)) &#123; cutFile4Video(fileId, targetFilePath); // 视频缩略图 cover = month + &quot;/&quot; + currentUserFolderName + Constants.IMAGE_PNG_SUFFIX; String coverPath = targetFolderName + &quot;/&quot; + cover; FfmpegUtil.createTargetThumbnail(new File(targetFilePath), Constants.LENGTH_150, new File(coverPath)); &#125; else if (FileTypeEnums.IMAGE.getType().equals(fileType)) &#123; // 图片缩略图 cover = month + &quot;/&quot; + realFilename.replace(&quot;.&quot;, &quot;_.&quot;); String coverPath = targetFolderName + &quot;/&quot; + cover; Boolean created = FfmpegUtil.createThumbnailWidthFFmpeg(new File(targetFilePath), Constants.LENGTH_150, new File(coverPath), false); if (!created) &#123; FileUtils.copyFile(new File(targetFilePath), new File(coverPath)); &#125; &#125; &#125; catch (Exception e) &#123; log.error(&quot;文件转码失败， 文件ID: &#123;&#125;, userId: &#123;&#125;&quot;, fileId, userId, e); transferSuccess = false; &#125; finally &#123; // 更新文件Size和封面 FileInfo updateInfo = new FileInfo(); if (targetFilePath == null) &#123; updateInfo.setFileSize(0L); &#125; else &#123; updateInfo.setFileSize(new File(targetFilePath).length()); &#125; updateInfo.setFileCover(cover); updateInfo.setStatus(transferSuccess ? FileStatusEnums.USING.getStatus() : FileStatusEnums.TRANSFER_FAIL.getStatus()); updateByMultiId(updateInfo, fileId, userId); &#125; &#125; /** * 多主键更新 * * @param id 文件ID * @param userId 用户ID */ private Boolean updateByMultiId(FileInfo fileInfo, String id, String userId) &#123; return update(fileInfo, new LambdaUpdateWrapper&lt;FileInfo&gt;().eq(FileInfo::getId, id).eq(FileInfo::getUserId, userId)); &#125; /** * 多主键查询 * * @param id 文件ID * @param userId 用户ID */ private FileInfo getByMultiId(String id, String userId) &#123; return getOne(new LambdaQueryWrapper&lt;FileInfo&gt;().eq(FileInfo::getId, id).eq(FileInfo::getUserId, userId)); &#125; /** * 文件合并 * * @param dirPath 分片所在目录 * @param toFilePath 合并目标文件 * @param filename 合并文件名 * @param delSource 是否删除分片文件 */ private void union(String dirPath, String toFilePath, String filename, Boolean delSource) &#123; File dir = new File(dirPath); if (!dir.exists()) &#123; throw new BizException(&quot;目录不存在&quot;); &#125; File[] files = dir.listFiles(); File targetFile = new File(toFilePath); RandomAccessFile writeFile = null; try &#123; writeFile = new RandomAccessFile(targetFile, &quot;rw&quot;); byte[] b = new byte[1024 * 10]; for (int i = 0; i &lt; files.length; i++) &#123; int len = -1; File chunkFile = new File(dirPath + &quot;/&quot; + i); try (RandomAccessFile readFile = new RandomAccessFile(chunkFile, &quot;r&quot;)) &#123; while ((len = readFile.read(b)) != -1) &#123; writeFile.write(b, 0, len); &#125; &#125; catch (Exception e) &#123; log.error(&quot;合并分片失败&quot;, e); throw new BizException(&quot;合并分片失败&quot;); &#125; &#125; &#125; catch (Exception e) &#123; log.error(&quot;合并文件:&#123;&#125;失败&quot;, filename, e); throw new BizException(&quot;合并文件&quot; + filename + &quot;出错了&quot;); &#125; finally &#123; if (null != writeFile) &#123; try &#123; writeFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (delSource &amp;&amp; dir.exists()) &#123; try &#123; FileUtils.deleteDirectory(dir); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 视频文件切片 * * @param fileId 文件ID * @param videoFilePath 分片到目录 */ private void cutFile4Video(String fileId, String videoFilePath) &#123; // 创建同名切片目录 File tsFolder = new File(videoFilePath.substring(0, videoFilePath.lastIndexOf(&quot;.&quot;))); if (!tsFolder.exists()) &#123; tsFolder.mkdirs(); &#125; // 生成ts String tsPath = tsFolder + &quot;/&quot; + Constants.TS_NAME; FfmpegUtil.transfer2ts(videoFilePath, tsPath); // 生成索引文件.m3u8和切片.ts文件 String indexTs = tsFolder.getPath() + &quot;/&quot; + Constants.M3U8_NAME; FfmpegUtil.cutTs(tsPath, indexTs, tsFolder.getPath(), fileId); // 删除index.ts new File(tsPath).delete(); &#125;&#125;"},{"title":"分片上传文件","path":"/wiki/easypan/05_file/upload.html","content":"分片文件上传的逻辑比较复杂，为了方便代码阅读这里写一下大致流程 从前端接收文件和文件的分片信息，生成文件ID； 如果是第一个分片，进行如下步骤： 根据文件MD5查询数据库是否已经存在该文件； 如果存在则为秒传，此时判断用户的剩余空间是否充足； 如果空间充足，则保存文件到数据库，即另存一份信息为当前用户上传的文件。 判断用户的空间是否充足，不充足直接返回错误信息； 空间充足，将分片文件保存到临时目录，同时记录文件上传的累积大小到Redis，此时上传状态为上传中； 当上传到最后一个分片时，将文件信息保存到数据库（文件状态设置为转码中），同时更新Redis和数据库中用户的空间使用情况，此时上传状态为完成； 使用异步方式进行文件合并。 接口信息 值 路径地址 http://localhost:7090/api/file/uploadFile 请求方式 POST 请求参数 MultipartFile、FileUploadDTO 返回结果 UploadResultVO 实体类查询参数DTO 在包com.swx.easypan.entity.dto，创建 FileUploadDTO 实体类，将下面代码放入： FileUploadDTO@Datapublic class FileUploadDTO &#123; private String id; @NotEmpty private String filename; private String filePid; @NotEmpty private String fileMd5; // 当前分片 @NotNull private Integer chunkIndex; // 总分片数量 @NotNull private Integer chunks;&#125; 视图实体类 在包com.swx.easypan.entity.vo，创建 UploadResultVO 实体类，将下面代码放入： UploadResultVO@JsonIgnoreProperties(ignoreUnknown = true)public class UploadResultVO implements Serializable &#123; private String id; private String status; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getStatus() &#123; return status; &#125; public void setStatus(String status) &#123; this.status = status; &#125;&#125; Redis缓存操作文件上传过程中需要保存临时变量和用户的 文件上传过程中需要保存临时变量 静态常量，在com.swx.easypan.entity.constants包下的 Constants 类中定义常量 public class Constants &#123; public static final String REDIS_KEY_USER_FILE_TEMP_SIZE = &quot;easypan:user:file:temp:&quot;;&#125; 从Redis缓存中获取和保存文件临时信息，在RedisComponent 编写获取和保存方法。 RedisComponent@Component(&quot;redisComponent&quot;)public class RedisComponent &#123; @Resource private RedisUtils&lt;Object&gt; redisUtils; public void saveFileTempSize(String userId, String fileId, Long fileSize) &#123; Long currentSize = getFileTempSize(userId, fileId); String key = Constants.REDIS_KEY_USER_FILE_TEMP_SIZE + userId + fileId; redisUtils.setex(key, currentSize + fileSize, Constants.REDIS_KEY_EXPIRE_ONE_HOUR); &#125; // 获取临时文件大小 public Long getFileTempSize(String userId, String fileId) &#123; Object sizeObj = redisUtils.get(Constants.REDIS_KEY_USER_FILE_TEMP_SIZE + userId + fileId); if (sizeObj == null) &#123; return 0L; &#125; if (sizeObj instanceof Integer) &#123; return ((Integer) sizeObj).longValue(); &#125; else if (sizeObj instanceof Long) &#123; return (Long) sizeObj; &#125; return 0L; &#125;&#125; 定义Service文件信息Service 基础的文件信息操作 找到 FileInfoService，定义保存文件信息方法 FileInfoServicepublic interface FileInfoService extends IService&lt;FileInfo&gt; &#123; /** * 保存文件信息 * * @param userId 文件用户ID * @param fileId 文件ID * @param fileDTO 文件信息 */ boolean saveFileInfo(String userId, String fileId, FileUploadDTO fileDTO); /** * 从文件保存文件，即保存秒传文件 * * @param userId 当前用户 * @param fileId 当前文件ID * @param fileDTO 当前文件信息 * @param dbFile 已存在文件信息 */ boolean saveFileInfoFromFile(String userId, String fileId, FileUploadDTO fileDTO, FileInfo dbFile);&#125; 在 FileInfoServiceImpl 中，实现上述方法 FileInfoServiceImpl@Slf4j@Servicepublic class FileInfoServiceImpl extends ServiceImpl&lt;FileInfoMapper, FileInfo&gt; implements FileInfoService &#123; @Override public boolean saveFileInfo(String userId, String fileId, FileUploadDTO fileDTO) &#123; String month = DateFormatUtils.format(new Date(), DateTimePatternEnum.YYYYMM.getPattern()); String fileSuffix = StringTools.getFileSuffix(fileDTO.getFilename()); FileTypeEnums fileTypeEnums = FileTypeEnums.getBySuffix(fileSuffix); String realFileName = userId + fileId + fileSuffix; FileInfo fileInfo = new FileInfo(); fileInfo.setId(fileId); fileInfo.setUserId(userId); fileInfo.setFileMd5(fileDTO.getFileMd5()); fileInfo.setFilename(autoRename(fileDTO.getFilePid(), userId, fileDTO.getFilename())); fileInfo.setFilePath(month + &quot;/&quot; + realFileName); fileInfo.setFilePid(fileDTO.getFilePid()); fileInfo.setFileCategory(fileTypeEnums.getCategory().getCategory()); fileInfo.setFileType(fileTypeEnums.getType()); fileInfo.setStatus(FileStatusEnums.TRANSFER.getStatus()); fileInfo.setFolderType(FileFolderTypeEnums.FILE.getType()); return save(fileInfo); &#125; @Override public boolean saveFileInfoFromFile(String userId, String fileId, FileUploadDTO fileDTO, FileInfo dbFile) &#123; dbFile.setId(fileId); dbFile.setFilePid(fileDTO.getFilePid()); dbFile.setUserId(userId); dbFile.setStatus(FileStatusEnums.USING.getStatus()); dbFile.setFileMd5(fileDTO.getFileMd5()); dbFile.setDeleted(FileDelFlagEnums.USING.getFlag()); dbFile.setFilename(autoRename(fileDTO.getFilePid(), userId, fileDTO.getFilename())); return save(dbFile); &#125;&#125; 用户文件Service文件上传的操作涉及文件服务和用户服务，所以这里新加一层用户文件服务，解决循环依赖的问题。 新建 UserFileService，定义上传文件接口 UserFileService/** * 用户文件服务 */public interface UserFileService &#123; UploadResultVO uploadFile(String userId, MultipartFile file, FileUploadDTO fileDTO) throws IOException;&#125; 新建 UserFileServiceImpl 类实现用户文件接口 UserFileServiceImpl@Servicepublic class UserFileServiceImpl implements UserFileService &#123; private final RedisComponent redisComponent; private final FileInfoService fileInfoService; private final UserInfoService userInfoService; private final AppConfig appConfig; private final FileInfoServiceImpl fileInfoServiceImpl; public UserFileServiceImpl(RedisComponent redisComponent, FileInfoService fileInfoService, UserInfoService userInfoService, AppConfig appConfig, FileInfoServiceImpl fileInfoServiceImpl) &#123; this.redisComponent = redisComponent; this.fileInfoService = fileInfoService; this.userInfoService = userInfoService; this.appConfig = appConfig; this.fileInfoServiceImpl = fileInfoServiceImpl; &#125; @Override @Transactional(rollbackFor = Exception.class) public UploadResultVO uploadFile(String userId, MultipartFile file, FileUploadDTO fileDTO) throws IOException &#123; UploadResultVO resultVO = new UploadResultVO(); File tempFileFolder = null; try &#123; // 生成文件ID String fileId = fileDTO.getId(); if (!StringUtils.hasText(fileId)) &#123; fileId = StringTools.getRandomString(Constants.LENGTH_10); &#125; resultVO.setId(fileId); // 查询用户已使用空间 UserSpaceDTO userSpaceUse = redisComponent.getUserSpaceUse(userId); if (userSpaceUse == null) &#123; userSpaceUse = getUseSpace(userId); &#125; if (fileDTO.getChunkIndex() == 0) &#123; List&lt;FileInfo&gt; dbFileList = fileInfoService.list(new LambdaQueryWrapper&lt;FileInfo&gt;() .eq(FileInfo::getFileMd5, fileDTO.getFileMd5()) .eq(FileInfo::getStatus, FileStatusEnums.USING.getStatus())); if (!dbFileList.isEmpty()) &#123; // 服务器存在该文件，直接秒传 FileInfo dbFile = dbFileList.get(0); // 判断文件大小 if (dbFile.getFileSize() + userSpaceUse.getUseSpace() &gt; userSpaceUse.getTotalSpace()) &#123; throw new BizException(ResultCode.OUT_OF_SPACE); &#125; boolean save = fileInfoService.saveFileInfoFromFile(userId, fileId, fileDTO, dbFile); if (!save) &#123; throw new BizException(&quot;文件保存失败&quot;); &#125; resultVO.setStatus(UploadStatusEnums.UPLOAD_SECONDS.getCode()); // 更新空间使用情况 updateUserSpace(userId, dbFile.getFileSize(), userSpaceUse); return resultVO; &#125; &#125; // 判断磁盘空间 Long currentTempSize = redisComponent.getFileTempSize(userId, fileId); if (file.getSize() + currentTempSize + userSpaceUse.getUseSpace() &gt; userSpaceUse.getTotalSpace()) &#123; throw new BizException(ResultCode.OUT_OF_SPACE); &#125; // 暂存临时目录 String tempFolderName = appConfig.getProjectFolder() + Constants.FILE_FOLDER_TEMP; String currentUserFolderName = userId + fileId; tempFileFolder = new File(tempFolderName + currentUserFolderName); if (!tempFileFolder.exists()) &#123; tempFileFolder.mkdirs(); &#125; File newFile = new File(tempFileFolder.getPath() + &quot;/&quot; + fileDTO.getChunkIndex()); file.transferTo(newFile); if (fileDTO.getChunkIndex() &lt; fileDTO.getChunks() - 1) &#123; resultVO.setStatus(UploadStatusEnums.UPLOADING.getCode()); // 保存临时大小 redisComponent.saveFileTempSize(userId, fileId, file.getSize()); return resultVO; &#125; redisComponent.saveFileTempSize(userId, fileId, file.getSize()); // 最后一个分片上传完成，记录是数据库，异步合并 // 写入数据库 fileInfoService.saveFileInfo(userId, fileId, fileDTO); // 更新用户使用空间 Long totalSize = redisComponent.getFileTempSize(userId, fileId); updateUserSpace(userId, totalSize, userSpaceUse); // 上传完成 resultVO.setStatus(UploadStatusEnums.UPLOAD_FINISH.getCode()); String finalFileId = fileId; // 异步合并 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() &#123; @Override public void afterCommit() &#123; fileInfoServiceImpl.transferFile(finalFileId, userId); &#125; &#125;); return resultVO; &#125; catch (Exception e) &#123; if (tempFileFolder != null) &#123; FileUtils.deleteDirectory(tempFileFolder); &#125; throw e; &#125; &#125; /** * 更新用户空间，累加更新 * * @param userId 用户ID * @param fileSize 文件大小 * @param userSpaceDTO Redis */ private void updateUserSpace(String userId, Long fileSize, UserSpaceDTO userSpaceDTO) &#123; Boolean update = userInfoService.updateUserSpace(userId, fileSize, null); if (!update) &#123; throw new BizException(ResultCode.OUT_OF_SPACE); &#125; userSpaceDTO.setUseSpace(userSpaceDTO.getUseSpace() + fileSize); redisComponent.saveUserSpaceUse(userId, userSpaceDTO); &#125;&#125; 定义Controller在 FileInfoController 下定义上传方法，分片上传。 FileInfoController@RestController@RequestMapping(&quot;/file&quot;)@ResponseResult@LoginValidator@Validatedpublic class FileInfoController &#123; private final UserFileService userFileService; public FileInfoController(UserFileService userFileService) &#123; this.userFileService = userFileService; &#125; // 上传文件 @PostMapping(&quot;/uploadFile&quot;) public UploadResultVO uploadFile(HttpSession session, MultipartFile file, FileUploadDTO fileDTO) throws IOException &#123; SessionWebUserVO user = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); return userFileService.uploadFile(user.getId(), file, fileDTO); &#125;&#125;"},{"title":"文件彻底删除","path":"/wiki/easypan/06_recycle/del.html","content":"彻底删除不同于移入回收站，其会恢复用户的使用空间，并直接从数据库删除。当然这里也可以将状态置为DEL，回收站也无法查询到。 定义Mapper找到 FileInfoMapper 接口，在其中添加如下方法定义，批量更新文件的删除和回收状态 FileInfoMapperInteger delFileBatch(@Param(&quot;userId&quot;) String userId, @Param(&quot;pidList&quot;) List&lt;String&gt; delFilePidList, @Param(&quot;idList&quot;) List&lt;String&gt; idList, @Param(&quot;oldDelFlag&quot;) Integer oldDelFlag); 找到 FileInfoMapper.xml 文件，实现上述方法 FileInfoMapper.xml&lt;delete id=&quot;delFileBatch&quot;&gt; delete from file_info &lt;where&gt; &lt;if test=&quot;userId != null&quot;&gt; and user_id = #&#123;userId&#125; &lt;/if&gt; &lt;if test=&quot;pidList != null&quot;&gt; and file_pid in(&lt;foreach collection=&quot;pidList&quot; separator=&quot;,&quot; item=&quot;item&quot;&gt;#&#123;item&#125;&lt;/foreach&gt;) &lt;/if&gt; &lt;if test=&quot;idList != null&quot;&gt; and id in(&lt;foreach collection=&quot;idList&quot; separator=&quot;,&quot; item=&quot;item&quot;&gt;#&#123;item&#125;&lt;/foreach&gt;) &lt;/if&gt; &lt;if test=&quot;oldDelFlag != null&quot;&gt; and deleted = #&#123;oldDelFlag&#125; &lt;/if&gt; &lt;/where&gt;&lt;/delete&gt; 定义ServiceFileInfoService这里定义批量删除文件的方法，找到 FileInfoService 接口，在其中添加： FileInfoService/** * 批量删除文件 * * @param userId 用户ID * @param delFilePidList 根据pid删除 * @param idList 根据id删除 * @param oldDelFlag 旧状态 */Boolean delFileBatch(String userId, List&lt;String&gt; delFilePidList, List&lt;String&gt; idList, Integer oldDelFlag); 在 UserInfoServiceImpl 中实现该方法 @Overridepublic Boolean delFileBatch(String userId, List&lt;String&gt; delFilePidList, List&lt;String&gt; idList, Integer oldDelFlag) &#123; Integer deleted = baseMapper.delFileBatch(userId, delFilePidList, idList, oldDelFlag); return deleted != null &amp;&amp; deleted &gt; 0;&#125; UserFileService彻底删除设计到更新用户信息表，这里将方法写在 UserFileService 中： UserFileService/** * 批量删除文件 * * @param userId 用户ID * @param ids 需要删除的文件ID，逗号分隔 * @param isAdmin 是否是管理员 */void delFileBatch(String userId, String ids, Boolean isAdmin); 在 UserFileServiceImpl 中实现该方法。 UserFileServiceImpl@Override@Transactional(rollbackFor = Exception.class)public void delFileBatch(String userId, String ids, Boolean isAdmin) &#123; List&lt;String&gt; idList = Arrays.asList(ids.split(&quot;,&quot;)); LambdaQueryWrapper&lt;FileInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(FileInfo::getUserId, userId) .eq(FileInfo::getDeleted, FileDelFlagEnums.RECYCLE.getFlag()) .in(!idList.isEmpty(), FileInfo::getId, idList); List&lt;FileInfo&gt; fileInfoList = fileInfoService.list(wrapper); List&lt;String&gt; delFileSubFolderFileList = new ArrayList&lt;&gt;(); // 找到所选文件子目录文件ID for (FileInfo fileInfo : fileInfoList) &#123; if (FileFolderTypeEnums.FOLDER.getType().equals(fileInfo.getFolderType())) &#123; fileInfoServiceImpl.findAllSubFolderList(delFileSubFolderFileList, userId, fileInfo.getId(), FileDelFlagEnums.DEL.getFlag()); &#125; &#125; // 删除所选文件子目录中的文件 if (!delFileSubFolderFileList.isEmpty()) &#123; fileInfoService.delFileBatch(userId, delFileSubFolderFileList, null, isAdmin ? null : FileDelFlagEnums.DEL.getFlag()); &#125; // 删除所选文件 fileInfoService.delFileBatch(userId, null, idList, isAdmin ? null : FileDelFlagEnums.RECYCLE.getFlag()); // 更新数据库 Long useSpace = fileInfoService.getUseSpace(userId); UserInfo userInfo = new UserInfo(); userInfo.setId(userId); userInfo.setUseSpace(useSpace); userInfoService.updateById(userInfo); // 更新Redis UserSpaceDTO userSpaceUse = redisComponent.getUserSpaceUse(userId); userSpaceUse.setUseSpace(useSpace); redisComponent.saveUserSpaceUse(userId, userSpaceUse);&#125; 定义Controller在 RecycleController 下定义彻底删除文件方法。 RecycleController// 彻底删除文件@DeleteMapping (&quot;/delFile/&#123;ids&#125;&quot;)public void delFile(HttpSession session, @PathVariable(&quot;ids&quot;) @NotEmpty String ids) &#123; SessionWebUserVO user = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); userFileService.delFileBatch(user.getId(), ids, false);&#125;"},{"title":"获取回收站文件","path":"/wiki/easypan/06_recycle/list.html","content":"文件删除时并非真正的删除，将文件状态置为RECYCLE状态，如果是目录，将其中的文件置为DEL状态，目录则置为RECYCLE，查询时只查询RECYCLE状态的文件和目录。 找到com.swx.easypan.controller包下的 RecycleController，修改代码如下： RecycleController@LoginValidator@Validated@RestController@ResponseResult@RequestMapping(&quot;/recycle&quot;)public class RecycleController &#123;&#125; 只查询RECYCLE状态的文件和目录。 接口信息 值 路径地址 http://localhost:7090/api/recycle/loadRecycleList 请求方式 POST 请求参数 FileInfoQuery 返回结果 FileInfoVO 实体类 参数和返回结果实体类，在文件信息工程中有用到，这里直接复用即可 定义Service Service直接使用获取文件列表的fileInfoService.pageInfo()即可，变更查询条件。 定义ControllerRecycleController@LoginValidator@Validated@RestController@ResponseResult@RequestMapping(&quot;/recycle&quot;)public class RecycleController &#123; private final FileInfoService fileInfoService; public RecycleController(FileInfoService fileInfoService) &#123; this.fileInfoService = fileInfoService; &#125; // 加载所有回收站数据 @GetMapping(&quot;/loadRecycleList&quot;) public IPage&lt;FileInfoVO&gt; loadRecycleList(HttpSession session, FileInfoQuery query) &#123; Page&lt;FileInfo&gt; pageParam = new Page&lt;&gt;(query.getPage(), query.getLimit()); query.setUserId(((SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY)).getId()); query.setDeleted(FileDelFlagEnums.RECYCLE.getFlag()); query.setOrderBy(&quot;recovery_time desc&quot;); return fileInfoService.pageInfo(pageParam, query); &#125;&#125;"},{"title":"文件恢复服务","path":"/wiki/easypan/06_recycle/recover.html","content":"文件恢复，当是单独文件时置为USING即可，当是目录时，除了本身外，还需要将其中的子目录置为USING 文件恢复时，其原本的父目录可能已经被删除，这里就不再去判断，而是采用另一种方案：将恢复文件的父目录统一设置为根目录。 接口信息 值 路径地址 http://localhost:7090/api/recycle/recoverFile/{ids} 请求方式 PUT 请求参数 ids 返回结果 定义Service找到 FileInfoService 接口，在其中添加： FileInfoService/** * 批量恢复文件 * * @param userId 用户ID * @param ids 需要恢复的文件ID，逗号分隔 */void recoverFileBatch(String userId, String ids); 在 UserInfoServiceImpl 中实现该方法 FileInfoServiceImpl@Override@Transactional(rollbackFor = Exception.class)public void recoverFileBatch(String userId, String ids) &#123; List&lt;String&gt; idList = Arrays.asList(ids.split(&quot;,&quot;)); LambdaQueryWrapper&lt;FileInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(FileInfo::getUserId, userId) .eq(FileInfo::getDeleted, FileDelFlagEnums.RECYCLE.getFlag()) .in(!ids.isEmpty(), FileInfo::getId, idList); List&lt;FileInfo&gt; fileInfoList = list(wrapper); ArrayList&lt;String&gt; delFileSubFolderFileIdList = new ArrayList&lt;&gt;(); for (FileInfo fileInfo : fileInfoList) &#123; if (FileFolderTypeEnums.FOLDER.getType().equals(fileInfo.getFolderType())) &#123; // 查询目录下的所有文件 findAllSubFolderList(delFileSubFolderFileIdList, userId, fileInfo.getId(), FileDelFlagEnums.DEL.getFlag()); &#125; &#125; // 查询所有根目录的文件 List&lt;FileInfo&gt; rootFileList = list(new LambdaQueryWrapper&lt;FileInfo&gt;().eq(FileInfo::getUserId, userId) .eq(FileInfo::getDeleted, FileDelFlagEnums.USING.getFlag()) .eq(FileInfo::getFilePid, Constants.ZERO_STR)); Map&lt;String, FileInfo&gt; rootFileMap = rootFileList.stream().collect(Collectors.toMap(FileInfo::getFilename, Function.identity(), (a, b) -&gt; b)); // 将目录下所有删除的文件更新为使用中 if (!delFileSubFolderFileIdList.isEmpty()) &#123; FileInfo fileInfo = new FileInfo(); fileInfo.setDeleted(FileDelFlagEnums.USING.getFlag()); baseMapper.updateFileDelFlagBatch(fileInfo, userId, delFileSubFolderFileIdList, null, FileDelFlagEnums.DEL.getFlag()); &#125; // 将所选文件更新为正常，且父级目录设置为根目录 FileInfo fileInfo = new FileInfo(); fileInfo.setDeleted(FileDelFlagEnums.USING.getFlag()); fileInfo.setFilePid(Constants.ZERO_STR); fileInfo.setUpdateTime(LocalDateTime.now()); baseMapper.updateFileDelFlagBatch(fileInfo, userId, null, idList, FileDelFlagEnums.RECYCLE.getFlag()); // 将所选文件重命名 for (FileInfo info : fileInfoList) &#123; FileInfo rootFileInfo = rootFileMap.get(info.getFilename()); // 文件名已存在，重命名 if (null != rootFileInfo) &#123; FileInfo updateInfo = new FileInfo(); updateInfo.setFilename(StringTools.rename(info.getFilename())); updateByMultiId(updateInfo, info.getId(), userId); &#125; &#125;&#125; 定义Controller在 RecycleController 下定义恢复文件方法。 RecycleController// 恢复文件@PutMapping(&quot;/recoverFile/&#123;ids&#125;&quot;)public void recoverFile(HttpSession session, @PathVariable(&quot;ids&quot;) @NotEmpty String ids) &#123; SessionWebUserVO user = (SessionWebUserVO) session.getAttribute(Constants.SESSION_KEY); fileInfoService.recoverFileBatch(user.getId(), ids);&#125;"},{"title":"笔记简介","path":"/wiki/kubernetes/01_introduce/index.html","content":"笔记基于B站黑马Java的Kubernetes教程 Kubernetes(K8S) 入门进阶实战完整教程，黑马程序员K8S全套教程（基础+高级）Kubernetes(K8S)是Google在2014年发布的一个开源项目，用于自动化容器化应用程序的部署、扩展和管理。Kubernetes通常结合docker容器工作，并且整合多个运行着docker容器的主机集群。 链接地址： Kubernetes(K8S) 入门进阶实战完整教程，黑马程序员K8S全套教程（基础+高级）https://www.bilibili.com/video/BV1Qv41167ck"},{"title":"Kubernetes介绍","path":"/wiki/kubernetes/02_quick_start/01_Kubernetes介绍.html","content":"应用部署方式演变 传统部署：直接将应用程序部署在物理机上 虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境 容器化部署：与虚拟化类似，但是共享了操作系统 容器化部署方式带来很多的便利，但是也出现了一些问题，不如说： 一个容器故障停机了，怎么样让另外一个容器立刻启动替补停机的容器 当并发访问量变大的时候，怎么样做到横向扩展容器数量 这些容器管理问题被统称为容器编排问题，为了解决这些容器编排问题，就产生了一些容器编排工具 Swarm：Docker自己的容器编排工具 Mesos：Apache的一个统一管理工具，需要和Marathon结合使用 Kubernetes：Google开源的容器编排工具 Kubernetes简介Kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌容器严格保密十几年的秘密武器——Borge系统的一个开源版本，与2014年9月发布第一个版本，2015年7月发布第一个正式版本。 Kubernetes的本质是一组服务器集群，他可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。他的目的就是实现资源管理的自动化，主要提供如下的主要功能： 自我修复：一单某一个容器奔溃，能够在1秒中左右迅速启动新的容器 弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整 服务发现：服务可以通过自动发现的形式找到它所依赖的服务 负载均衡：如果一个服务启动了多个容器，能够自动实现请求的负载均衡 版本回退：如果发现新发布的程序版本有问题，可以立即会退给到原来的版本 存储编排：可以根据容器自身的需求自动创建存储卷 Kubernetes组件一个Kubernetes集群主要是由控制点(master)、工作节点(node)构成，每个节点上都会安装不同的组件。 master：集群的控制平面，负责集群的决策 ApiServer：资源操作的唯一入口，接收用户输入的命令。提供认证、授权、API注册发现等机制 Scheduler：负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上 ControllerManager：负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等。 Etcd：负责存储集群中各种资源对象的信息 node：集群的数据平面，负责为容器提供运行环境 Kubelet：负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器 KubeProxy：负责提供集群内部的服务发现和负责均衡 Docker：负责节点上容器的各种操作 下面，以部署一个Nginx服务来说明Kubernetes系统各个组件调用关系。 首先要明确，一旦kubernetes环境启动后，master和node都会将自身的信息存储到etcd数据库中 一个nginx服务的安装请求会首先被发送到master节点的apiServer组件 apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上 此时，他会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer apiServer调用controller-manager去调度Node节点安装nginx服务 kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod pod是kubelet的最小操作单元，容器必须跑在pod中至此， 一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对node产生访问的代理 这样外界用户就可以访问集群中的nginx服务了 Kubernetes概念Master：集群控制节点，每个集群需要至少一个master节点负责集群的管控 Node：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行 Pod：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod可以1个或者多个容器 Controller：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod数量等等 Service：pod对外服务的统一入口，下面可以维护着同一类的多个pod Label：标签，用于对pod进行分类，同一类pod会拥有相同的标签 NameSpace：命名空间，用来隔离pod的运行环境"},{"title":"集群环境搭建","path":"/wiki/kubernetes/02_quick_start/02_集群环境搭建.html","content":"环境规划集群类型kubernetes集群大体上分为两类：一主多从和多主多从 一主多从：一台Master节点和多台Node节点，搭建简单，但是有单机故障风险，适合用于测试环境 多主多从：多台Master节点和多台Node节点，搭建麻烦，安全性高，适合用于生产环境 说明：为了测试简单，本次搭建的是一主多从类型的集群 安装方式kubernetes有很多种部署方式，目前主流的方式有kubeadm、minikube、二进制包 minikube：一个用于快速搭建单节点kubernetes的工具 kubeadm：一个用于快速搭建kubernetes集群的工具 二进制包：从官网下载每个组件的二进制包，依次去安装，此方式对于理解kubernetes组件更加有效 说明：现在需要安装kubernetes的集群环境，但是又不想过于麻烦，所以选择kubeadm方式 主机规划 作用 IP地址 操作系统 配置 Master 192.168.52.101 CentOS7.9 基础设施服务器 2核CPU 2G内存 20G硬盘 Node1 192.168.52.102 CentOS7.9 基础设施服务器 2核CPU 2G内存 20G硬盘 Node2 192.168.52.103 CentOS7.9 基础设施服务器 2核CPU 2G内存 20G硬盘 环境搭建​ 本次环境搭建需要安装三台linux系统（一主二从），内置CentOS7.5系统，然后在每台linux中分别安装docker（18.06.3）、kubeadm（1.17.4）、kubelet（1.17.4）、kubectl（1.17.4）程序。 主机安装安装虚拟机过程注意下面选项设置： 操作系统：CPU（2C）\t内存（2G）\t硬盘（20G） 语言选择：中文简体 软件选择：基础设施服务器 分区选择：自动分区 网络配置：按照下面配置网络地址信息 网络地址: 按需填写 #每台主机不一样，分别为100、101、102子网掩码: 255.255.255.0默认网关: 按需填写DNS: 233.5.5.5 使用VMware虚拟三台主机 准备镜像，推荐使用完整镜像。这里我选择的是最小镜像。 Mac OS Mac版本的VMware叫做VMware Fusion 打开VMware Fusion，找到 文件 &gt; 新建，选择下载的镜像文件，创建名为master的主机 进入图形化界面后， 找到网络和主机名； 选中以太网，点击左下角配置； 找到IPV4，点击Add，填入信息。IP地址前三位和网关保持一致。 DNS服务器，可以在Mac设置&gt;网络中找到 网关的获取方式 cd /Library/Preferences/VMware\\ Fusion/vmnet8cat nat.conf 找到这些信息，其中ip就是网关地址。我们的IP地址前三位和网关段保持一致192.168.52. nat.conf# NAT gateway addressip = 192.168.52.2netmask = 255.255.255.0 配置完成后点击保存，左上角打开以太网，主机名改为master并应用，点击完成。 之后点击开始安装，安装过程中，可以设置root用户密码。 安装上述步骤分别安装node1、node2，其配置如下 ip: 192.168.52.101\t# node1ip: 192.168.52.102\t# node2 Windows 待补充。。。 环境初始化1）检查操作系统的版本，版本要大于等于7.5 [root@master ~]# cat /etc/redhat-release CentOS Linux release 7.9.2009 (Core) 2）主机名解析 为了方便后面集群点之间的直接调用，在这配置一下主机名解析，企业中推荐使用内部DNS服务器 /etc/hosts192.168.52.100\tmaster192.168.52.101\tnode1192.168.52.102\tnode1 3）时间同步 kubernetes要求集群中的节点时间必须精确一致，这里直接使用chronyd服务从网络同步时间 企业中建议配置内部的时间同步服务器 systemctl start chronydsystemctl enable chronyddate 4）禁用iptables和firewall服务 kubernetes和docker在运行中会产生大量的iptables规则，为了不让系统规则跟它们混淆，直接关闭系统的规则 systemctl stop firewalldsystemctl disable firewalld# 最小化安装没有iptablessystemctl stop iptablessystemctl disable iptables 5）禁用selinux selinux是linux系统下的一个安全服务，如果不关闭它，在安装集群中会出现各种各样的问题 /etc/selinux/configsed -i &#x27;s/=enforcing/=disabled/&#x27; /etc/selinux/config 6）禁用swap分区 swap分区指的是虚拟内存分区，它的作用是在物理内存使用完成后，将磁盘空间虚拟成内存来使用 启用swap设备会对系统的性能产生非常负面的影响，因此kubernetes要求每个阶段都要禁用swap设备 但是如果因为某些原因确实不能关闭swap分区，就需要在集群安装过程中通过明确的参数进行配置说明 /etc/fstabsed -i &#x27;s/\\/dev\\/mapper\\/centos-swap/# \\/dev\\/mapper\\/centos-swap/&#x27; /etc/fstab 7）修改linux的内核参数 /etc/sysctl.d/kubernetes.confcat &lt;&lt;EOF &gt; /etc/sysctl.d/kubernetes.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1EOF 重新加载配置 sysctl -p 加载网桥过滤模块 modprobe br_netfilter 查看网桥过滤模块是否加载成功 lsmod | grep br_netfilter 8）配置ipvs功能 在kubernetes中service有两种代理模型，一种是基于iptables的，一种是基于ipvs的 两种比较：ipvs的性能要高一些，但是如果使用，需要手动载入ipvs模块 安装ipset和ipvsadm yum install ipset ipvsadm -y 添加需要加载的模块写入脚本文件 cat &lt;&lt;EOF &gt; /etc/sysconfig/modules/ipvs.modules#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOF 添加执行权限 chmod +x /etc/sysconfig/modules/ipvs.modules 执行脚本文件 /bin/bash /etc/sysconfig/modules/ipvs.modules 查看对应模块是否加载成功 lsmod | grep -e ip_vs -e nf_conntrack_ipv4 看见模块，即为加载成功 nf_conntrack_ipv4 15053 0 nf_defrag_ipv4 12729 1 nf_conntrack_ipv4ip_vs_sh 12688 0 ip_vs_wrr 12697 0 ip_vs_rr 12600 0 ip_vs 145458 6 ip_vs_rr,ip_vs_sh,ip_vs_wrrnf_conntrack 139264 2 ip_vs,nf_conntrack_ipv4libcrc32c 12644 3 xfs,ip_vs,nf_conntrack 9）配置日志选项 systemd-journald用于检索systemd的日志，是systemd自带的日志系统。设置rsyslogd和systemd journald mkdir /var/log/journalmkdir /etc/systemd/journald.conf.d 写入配置信息 cat &gt; /etc/systemd/journald.conf.d/99-prophet.conf &lt;&lt; EOF[Journal]Storage=persistentCompress=yesSyncIntervalSec=5mRateLimitInterval=30sRateLimitBurst=1000SystemMaxUse=10GSystemMaxFileSize=200MMaxRetentionSec=2weekForwardToSyslog=noEOF 重启服务 systemctl restart systemd-journald 10）重启服务器 上面步骤完成之后，需要重启linux服务器 reboot 安装docker1、导入阿里云的镜像仓库 yum-config-manager \\--add-repo \\http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 未找到yum-config-manager，需要先安装一下yum-config-manager yum -y install yum-utils 2、查看镜像源中支持的docker版本 yum list docker-ce --showduplicates 3、安装指定版本的docker-ce 必须制定--setopt=obsoletes=0，否则yum会自动安装更高版本 yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y 注意：选择其他版本可能需要配置额外的参数，需要搜索一下如何配置！！！ 4、添加一个配置文件 Docker在默认情况下使用的Cgroup Driver为cgroupfs，而kubernetes推荐使用systemd来代替cgroupfs mkdir /etc/docker cat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123; &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;], &quot;registry-mirrors&quot;: [&quot;http://kn0t2bca.mirror.aliyuns.com&quot;], &quot;log-driver&quot;:&quot;json-file&quot;, &quot;log-opts&quot;:&#123; &quot;max-size&quot;:&quot;100m&quot; &#125;&#125;EOF 5、启动docker systemctl restart dockersystemctl enable docker 6、检查docker状态和版本 docker version 安装kubernetes组件1、切换镜像源，添加下面配置 /etc/yum.repos.d/kubernetes.repocat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 2、安装kubeadm、kubectl和kubelet yum -y install --setopt=obsoletes=0 kubeadm-1.17.4-0 kubectl-1.17.4-0 kubelet-1.17.4-0 3、配置kubelet的cgroup /etc/sysconfig/kubeletcat &lt;&lt;EOF &gt;&gt; /etc/sysconfig/kubeletKUBELET_CGROUP_ARGS=&quot;--cgroup-driver=systemd&quot;KUBE_PROXY_MODE=&quot;ipvs&quot;EOF 4、设置kubelet开启自启 systemctl enable kubelet 准备集群镜像在安装kubernetes集群之前，必须要提前准备好集群所需要的镜像，所需镜像可以通过下面命令查看 kubeadm config images list 下载镜像，此镜像在kubernetes的仓库中，由于网络原因，无法连接，下面提供了一种替代方案 images=(\tkube-apiserver:v1.17.4\tkube-controller-manager:v1.17.4\tkube-scheduler:v1.17.4\tkube-proxy:v1.17.4\tpause:3.1\tetcd:3.4.3-0\tcoredns:1.6.5)for imageName in $&#123;images[@]&#125; ; do docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageNamedone 注意k8s前面没有换行，只是一个空格而已 查看镜像是否拉取成功，名字是否为官方镜像 [root@master ~]# docker imagesREPOSITORY TAG IMAGE ID SIZEk8s.gcr.io/kube-proxy v1.17.4 6dec7cfde1e5 116MBk8s.gcr.io/kube-controller-manager v1.17.4 7f997fcf3e94 161MBk8s.gcr.io/kube-apiserver v1.17.4 2e1ba57fe95a 171MBk8s.gcr.io/kube-scheduler v1.17.4 5db16c1c7aff 94.4MBk8s.gcr.io/coredns 1.6.5 70f311871ae1 41.6MBk8s.gcr.io/etcd 3.4.3-0 303ce5db0e90 288MBk8s.gcr.io/pause 3.1 da86e6ba6ca1 742kB 集群初始化下面开始对集群进行初始化，并将node节点加入到集群中 下面的操作只需在master节点执行即可 创建集群 kubeadm init \\--kubernetes-version=v1.17.4 \\--pod-network-cidr=10.244.0.0/16 \\--service-cidr=10.96.0.0/12 \\--apiserver-advertise-address=192.168.52.100 注意192.168.52.100更改为自己master的IP，版本号要和之前拉取的一致，其它按我写的就行。 当你看到图片中的那句话，恭喜你安装成功 按照其提示，执行下面的命令 mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 加入node节点，执行它提示的命令 查看集群节点信息，NotReady是因为网络没准备好 [root@master ~]# kubectl get nodesNAME STATUS ROLES AGE VERSIONmaster NotReady master 11m v1.17.4node1 NotReady &lt;none&gt; 64s v1.17.4node2 NotReady &lt;none&gt; 14s v1.17.4 安装网络插件kubernetes支持多种网络插件，比如flannel、calico、canal等等，任选一种使用即可，本次选择flannel 下面的操作依旧只在master节点执行即可，插件使用的是DaemonSet的控制器，他会在每个节点都运行 获取flannel的配置文件，下载慢或者失败的可以先下载下来，之后上传到服务器。 wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 使用配置文件启动flannel kubectl create -f kube-flannel.yml 稍等片刻，再次查看集群的节点状态 [root@master ~]# kubectl get nodesNAME STATUS ROLES AGE VERSIONmaster Ready master 20m v1.17.4node1 Ready &lt;none&gt; 9m31s v1.17.4node2 Ready &lt;none&gt; 8m41s v1.17.4 服务部署接下来在kubernetes集群中部署一个nginx程序，测试集群是否在正常工作。 部署nginx kubectl create deployment nginx --image=nginx:1.14-alpine 暴露端口 kubectl expose deployment nginx --port=80 --type=NodePort 查看服务状态，暴露的端口为80:30001 [root@master ~]# kubectl get pods,svcNAME READY STATUS RESTARTS AGEpod/nginx-6867cdf567-5hwql 0/1 ContainerCreating 0 32sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 25mservice/nginx NodePort 10.106.132.238 &lt;none&gt; 80:30001/TCP 7s root@master ~]# kubectl get podNAME READY STATUS RESTARTS AGEnginx-6867cdf567-5hwql 1/1 Running 0 106s 浏览器访问 192.168.52.100:30001"},{"title":"资源管理","path":"/wiki/kubernetes/02_quick_start/03_资源管理.html","content":"主要介绍yaml语法和kubernetes的资源管理方式 资源管理介绍在kubernetes中，所有的内容都抽为资源，用户需要通过操作系统资源来管理kubernetes。 kubernetes本质上就是一个集群系统，用户可以在集群中部署各种服，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将制定的程序跑在容器中 kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在Pod中，而kubernetes一般不也不会直接管理Pod，而是通过Pod控制器来管理。 Pod可以提供服务之后，就要考虑如何访问Pod中的服务，kubernetes提供了Service资源实现这个功能。 当然，如果Pod程序的数据需要持久化，kubernetes还提供了各种存储系统。 学习kubernetes的核心，就是学习如何对集群上的Pod、Pod控制器、Service、存储等各种资源操作 资源管理方式命令式对象管理：直接使用命令去操作kubernetes资源 kubectl run nginx-pod --image=nginx:1.17.1 --port=80 命令式对象配置：通过命令配置和配置文件去操作kubernetes资源 kubectl create/patch -f nginx-pod.yaml 声明式对象配置：通过apply命令和配置文件去操作kubetrnetes资源 kubectl apply -f nginx-pod.yaml # 创建和更新 类型 操作对象 适用环境 优点 缺点 命令式对象管理 对象 测试 简单 智能操作活动对象，无法审计、跟踪 命令式对象配置 文件 开发 可以审计、跟踪 项目大时，配置文件多，操作麻烦 声明式对象配置 目录 开发 支持目录操作 意外情况下难以调试 命令式对象管理kubectl命令​\tkubectl时kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能在集群上进行容器化应用的安装部署。kubectl命令的语法如下： kubectl [comand] [type] [name] [flags] comand：指定要对资源执行的操作，例如create、get、delete type：指定资源类型，比如deployment、pos、service name：指定资源的名称，名称大小写敏感 flags：指定额外的可选参数 例如，查看所有pod kubectl get pods 例如，查看某个pod kubectl get pod pod_name [-o wide] 例如，查看某个pod，以yaml&#x2F;json格式展示 kubectl get pod pod_name -o yaml/json 资源类型kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看： kubectl api-resources 经常使用的资源有下面这些： 资源分类 资源名称 缩写 资源作用 集群级别资源 nodes no 集群组成部分 namespaces ns 隔离pod pod资源 pods po 装在容器 pod资源控制器 replicationcontrollers rc 控制pod资源 replicasets rs 控制pod资源 deployments deploy 控制pod资源 daemonsets ds 控制pod资源 jobs 控制pod资源 cronjobs cj 控制pod资源 horizontalpodautoscalers hpa 控制pod资源 statefulsets sts 控制pod资源 服务发现资源 services svs 统一pod对外接口 ingress ing 统一pod对外接口 存储资源 volumeattachments 存储 persistentvolumes pv 存储 persistentvolumeclaims pvc 存储 配置资源 configmaps cm 配置 secrets 配置 操作kubernetes允许对资源进行多种操作，可以通过--help查看详细的操作命令 kubectl --help 经常使用的操作如下： 命令分类 命令 翻译 命令作用 基本命令 create 创建 创建一个资源 edit 编辑 编辑一个资源 get 获取 获取一个资源 patch 更新 更新一个资源 delete 删除 删除一个资源 explain 解释 展示资源文档 运行和调试 run 运行 在集群中运行一个指定的镜像 expose 暴露 暴露资源为Service describe 描述 显示资源内部信息 logs 日志 输出容器在pod中的日志 attach 缠绕 进入运行中的容器 exec 执行 执行容器中的一个命令 cp 复制 在Pod内外复制文件 rollout 首次展示 管理资源的发布 scale 规模 扩(缩)容Pod的数量 autoscale 自动调整 自动调整Pod的数量 高级命令 apply rc 通过文件对资源进行配置 label 标签 更新资源上的标签 其他命令 cluster-info 集群信息 显示集群信息 version 版本 显示当前Server和Client的版本 案例 下面以一个namespace &#x2F; pod的创建和删除简单演示一下命令的使用 创建一个namespace kubectl create namespace dev 获取namespace kubectl get ns 在namespace下创建并运行一个nginx的Pod kubectl run pod --image=nginx -n dev 查看创建的pod kubectl get pod -n dev 删除指定的pod [root@master ~]# kubectl delete pod pod-864f9875b9-dlxwz -n devpod &quot;pod-864f9875b9-dlxwz&quot; deleted 删除指定的namespace kubectl delete ns dev 命令式对象配置命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源 1）创建配置文件，内容如下 nginxpod.yamlapiVersion: v1kind: Namespacemetadata: name: dev---apiVersion: v1kind: Podmetadata: name: nginxpod namespace: devspec: containers: - name: nginx-containers image: nginx:1.17.1 2）执行create命令，创建资源： kubectl create -f nginxpod.yaml 3）执行get命令，查看资源： kubectl get -f nginxpod.yaml 4）执行delete命令，删除资源 kubectl delete -f nginxpod.yaml 声明式对象配置声明式对象配置和命令式配置很相似，但它只有一个命令 apply 创建资源 kubectl apply -f nginxpod.yaml 更新资源，资源没有变动 [root@master ~]# kubectl apply -f nginxpod.yamlnamespace/dev unchangedpod/nginxpod unchanged 小结 扩展：kubectl可以在node节点上运行吗？ ​\tkubectl的运行时需要进行配置的，它的配置文件是$HOME&#x2F;.kube，如果想要在node节点运行此命令，需要将master上的.kube文件复制到node节点上，即在master节点上执行下面操作： scp -r $HOME/.kube node1:$HOME/ 使用推荐：三种方式应该怎么用？ 创建&#x2F;更新资源 使用声明式对象配置 kubectl apply -f XXX.yaml 删除资源 使用命令式对象配置 kubectl delete -f XXX.yaml 查询资源 使用命令式对象管理 kubectl get(describe) 资源名"},{"title":"实战入门","path":"/wiki/kubernetes/02_quick_start/04_实战入门.html","content":"对Namespace、Pod、Label、Deployment、Service资源的使用及介绍，意在边使用边了解、学习。 NamespaceNamespace是kubernentes系统中的一种非常重要的资源。它的主要作用是用来实现多套环境的资源隔离或者多租户的资源隔离。 默认情况下，kubernetes集群中的所有Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行相互的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的“组”，以方便不同的组的资源进行隔离使用和管理。 可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。 kubernetes子集群启动之后，会默认创建几个namespace 查看namespace [root@master ~]# kubectl get nsNAME STATUS AGEdefault Active 2d # 所有未指定Namespace的对象都会被分配到在default的命名空间kube-node-lease Active 2d # 集群节点之间的心跳维护\tv1.13开始引入kube-public Active 2d # 此命名空间下的资源可以被所有人访问（包括未认证用户）kube-system Active 2d # 所有由Kubernetes系统创建的资源都处于这个命名空间 下面来看namespace资源的具体操作： 查看查看具体的namespace [root@master ~]# kubectl get ns defaultNAME STATUS AGEdefault Active 2d 查看namespace具体信息 [root@master ~]# kubectl describe ns defaultName: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Status: Active # Active表示命名空间正在使用中 Terminating表示正在删除命名空间# ResourceQuota 针对namespace做的资源限制# LimitRange针对namespace中的每个组件做的资源限制No resource quota.No LimitRange resource. 创建创建一个namespace [root@master ~]# kubectl create ns devnamespace/dev created 删除[root@master ~]# kubectl delete ns devnamespace &quot;dev&quot; deleted 配置方式创建一个yaml文件 ns-dev.yamlapiVersion: v1kind: Namespacemetadata: name: dev 使用命令可以创建、删除 kubectl create -f ns-dev.yamlkubectl delete -f ns-dev.yaml PodPod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中 Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。 kubernetes在集群启动之后，集群中的个组件也都是以Pod方式运行的。可以通过下面命令查看： [root@master ~]# kubectl get pods -n kube-systemNAME READY STATUS RESTARTS AGEcoredns-6955765f44-67n2l 1/1 Running 3 2d20hcoredns-6955765f44-6w2pt 1/1 Running 3 2d20hetcd-master 1/1 Running 3 2d20hkube-apiserver-master 1/1 Running 3 2d20hkube-controller-manager-master 1/1 Running 3 2d20hkube-proxy-v6hr4 1/1 Running 3 2d20hkube-proxy-w4jm2 1/1 Running 3 2d20hkube-proxy-xdvtr 1/1 Running 3 2d20hkube-scheduler-master 1/1 Running 3 2d20h 创建并运行kubernetes没有使用单独运行Pod的命令，都是通过Pod控制器来实现的 kubectl run (pod控制器名称) [参数]--image # 指定Pod的镜像--port # 指定端口--namespace\t# 指定namespace 例如： [root@master ~]# kubectl run nginx --image=nginx:1.17.1 --port=80 --namespace devdeployment.apps/nginx created 查看Pod信息获取Pod信息 [root@master ~]# kubectl get pods -n devNAME READY STATUS RESTARTS AGEnginx-64777cd554-gjdxm 1/1 Running 0 12m 查看指定Pod详细信息 [root@master ~]# kubectl describe pod nginx-64777cd554-gjdxm -n devName: nginx-64777cd554-gjdxmNamespace: devPriority: 0Node: node2/192.168.52.133Start Time: Fri, 24 Feb 2023 14:24:54 +0800Labels: pod-template-hash=64777cd554 run=nginxAnnotations: &lt;none&gt;Status: RunningIP: 10.244.2.7IPs: IP: 10.244.2.7Controlled By: ReplicaSet/nginx-64777cd554Containers: nginx: Container ID: docker://b345c9a0661fd8035f403593f1c6d2d03c754445232ca90efa4fda7650b96ebf Image: nginx:1.17.1 Image ID: docker-pullable://nginx@sha256:b4b9b3eee194703fc2fa8afa5b7510c77ae70cfba567af1376a573a967c03dbb Port: 80/TCP Host Port: 0/TCP State: Running Started: Fri, 24 Feb 2023 14:24:55 +0800 Ready: True Restart Count: 0 Environment: &lt;none&gt; Mounts: /var/run/secrets/kubernetes.io/serviceaccount from default-token-xp9r4 (ro)Conditions: Type Status Initialized True Ready True ContainersReady True PodScheduled True Volumes: default-token-xp9r4: Type: Secret (a volume populated by a Secret) SecretName: default-token-xp9r4 Optional: falseQoS Class: BestEffortNode-Selectors: &lt;none&gt;Tolerations: node.kubernetes.io/not-ready:NoExecute for 300s node.kubernetes.io/unreachable:NoExecute for 300sEvents: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled &lt;unknown&gt; default-scheduler Successfully assigned dev/nginx-64777cd554-gjdxm to node2 Normal Pulled 6m48s kubelet, node2 Container image &quot;nginx:1.17.1&quot; already present on machine Normal Created 6m48s kubelet, node2 Created container nginx Normal Started 6m47s kubelet, node2 Started container nginx 访问指定Pod获取Pod [root@master ~]# kubectl get pods -n dev -o wideNAME READY STATUS RESTARTS AGE IP NODE nginx-64777cd554-gjdxm 1/1 Running 0 16m 10.244.2.7 node2 访问Pod [root@master ~]# curl 10.244.2.7:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 删除指定Pod删除指定Pod [root@master ~]# kubectl delete pod nginx-64777cd554-gjdxm -n devpod &quot;nginx-64777cd554-gjdxm&quot; deleted 再次查看Pod，发现又产生了一个 [root@master ~]# kubectl get pods -n devNAME READY STATUS RESTARTS AGEnginx-64777cd554-gftqq 1/1 Running 0 41s 这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发生Pod死亡，会立即重建，此时想要删除Pod，必须删除Pod控制器。 新版本已更改，在自定义namespace中执行RUN命令，不会自动创建Deployment，即删除之后不会重建 使用CREATE命令，会自动创建Deployment。在默认命名空间执行RUN命令则会创建pod控制器 [root@master ~]# kubectl get deploy -n devNAME READY UP-TO-DATE AVAILABLE AGEnginx 1/1 1 1 21m 接下来，删除此Pod控制器 [root@master ~]# kubectl delete deploy nginx -n devdeployment.apps &quot;nginx&quot; deleted 稍等片刻，再查询Pod，发现Pod被删除了 [root@master ~]# kubectl get pods -n devNo resources found in dev namespace. 配置方式创建一个yaml文件，内容如下 pod-nginx.yamlapiVersion: v1kind: Podmetadata: name: nginx namespace: devspec: containers: - image: nginx:1.17.1 imagePullPolicy: IfNotPresent name: pod ports: - name: nginx-port containerPort: 80 protocol: TCP 使用下面命令创建删除 kubectl create -f pod-nginx.yamlkubectl delete -f pod-nginx.yaml 使用该方式创建的pod也没有Deployment LabelLabel是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。 Label的特点： 一个Label会以key&#x2F;value键值对的形式附加到各种对象上，如Node、Pod、Service等等 一个资源对象可以定义任意数量的Label，同一个Label也可以被添加到任意数量的资源对象上去 Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除 可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。 一些常用的Label如下： 版本标签：&quot;version&quot;:&quot;release&quot;、”version&quot;:&quot;stable&quot;…… 环境标签：&quot;environment&quot;:&quot;dev&quot;、&quot;environment&quot;:&quot;test&quot;、&quot;environment&quot;:&quot;pro&quot; 架构标签：&quot;tier&quot;:&quot;frontend&quot;、&quot;tier&quot;:&quot;backend&quot; 标签定义完毕之后，还要考虑标签的选择，这就要使用到Label Selector，即： Label用于给某个资源对象定义标识 Label Selector用于查询和筛选拥有某些标签的资源对象 当前有两种Label Selector： 基于等式的Label Selector name &#x3D; slave：选择所有包含Label中key&#x3D;”name”，且value&#x3D;”slave”的对象 env !&#x3D; production：选择所哟包括Label中的key&#x3D;”env”，且value!&#x3D;”production”的对象 基于集合的Label Selector name in (master, slave)：选择所有包含Label中key&#x3D;”name”且value&#x3D;”master”或”slave”的对象 name not in (frontend)：选择所有包含Label中key&#x3D;”name”且value不等于”frontend”的对象 标签的选择可以使用多个，此时将多个Label Selector进行组合，使用逗号分隔即可。例如 name=slave, env!=productionname not in (frontend), env!=production 添加标签查看pod资源的标签 [root@master ~]# kubectl get pod -n dev --show-labelsNAME READY STATUS RESTARTS AGE LABELSnginx 1/1 Running 0 21s &lt;none&gt; 为pod资源打标签 [root@master ~]# kubectl label pod nginx version=2.0 -n devpod/nginx labeled 再次查看 [root@master ~]# kubectl get pod -n dev --show-labelsNAME READY STATUS RESTARTS AGE LABELSnginx 1/1 Running 0 2m23s version=2.0 更新标签更新并再次查看： [root@master ~]# kubectl label pod nginx -n dev version=3.0 --overwritepod/nginx labeled[root@master ~]# kubectl get pod -n dev --show-labelsNAME READY STATUS RESTARTS AGE LABELSnginx 1/1 Running 0 5m21s version=3.0 筛选标签列出所有标签 [root@master ~]# kubectl get pods -n dev --show-labelsNAME READY STATUS RESTARTS AGE LABELSnginx 1/1 Running 0 9m5s version=3.0nginx01 1/1 Running 0 82s version=1.0nginx02 1/1 Running 0 54s &lt;none&gt; 筛选标签，-l &quot;version=3.0&quot; [root@master ~]# kubectl get pods -l &quot;version=3.0&quot; -n dev --show-labelsNAME READY STATUS RESTARTS AGE LABELSnginx 1/1 Running 0 9m58s version=3.0[root@master ~]# kubectl get pods -l &quot;version!=3.0&quot; -n dev --show-labelsNAME READY STATUS RESTARTS AGE LABELSnginx01 1/1 Running 0 3m15s version=1.0nginx02 1/1 Running 0 2m47s &lt;none&gt; 去除标签使用labelName-删除标签： [root@master ~]# kubectl get pods -n dev --show-labelsNAME READY STATUS RESTARTS AGE LABELSnginx 1/1 Running 0 12m tier=back,version=3.0nginx01 1/1 Running 0 5m8s version=1.0nginx02 1/1 Running 0 4m40s &lt;none&gt;[root@master ~]# kubectl label po nginx -n dev tier-pod/nginx labeled[root@master ~]# kubectl get pods -n dev --show-labelsNAME READY STATUS RESTARTS AGE LABELSnginx 1/1 Running 0 13m version=3.0nginx01 1/1 Running 0 6m11s version=1.0nginx02 1/1 Running 0 5m43s &lt;none&gt; 配置方式创建一个yaml文件，内容如下 pod-nginx.yamlapiVersion: v1kind: Podmetadata: name: nginx namespace: dev labels: version: &quot;3.0&quot; env: &quot;test&quot;spec: containers: - image: nginx:1.17.1 imagePullPolicy: IfNotPresent name: pod ports: - name: nginx-port containerPort: 80 protocol: TCP 使用下面命令更新标签 kubectl apply -f pod-nginx.yaml Deployment​\t在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试重启或重建pod。 ​\t在kubernetes中Pod控制器到的种类有很多，这里只介绍一种：Deployment 命令操作命令格式 kubectl run deployment名称 [参数]# --image 指定pod的镜像# --port 指定端口# --replicas\t指定创建pod数量# --namespace 创建Deployment 新版本K8s(1.18以上)，在自定义namespace中执行RUN命令不会创建pod控制器，应使用CREATE命令。 在默认命名空间执行RUN命令则会创建pod控制器： kubectl create deployment nginx --image=nginx --replicas=3 -n dev 使用命令创建pod kubectl run nginx --image=nginx:1.17.1 --port=80 --replicas=3 -n dev 查看Deployment使用describe查看详细信息： [root@master ~]# kubectl describe deploy nginx -n devName: nginxNamespace: devCreationTimestamp: Sat, 25 Feb 2023 10:10:16 +0800Labels: run=nginxAnnotations: deployment.kubernetes.io/revision: 1Selector: run=nginxReplicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailableStrategyType: RollingUpdateMinReadySeconds: 0RollingUpdateStrategy: 25% max unavailable, 25% max surgePod Template: Labels: run=nginx Containers: nginx: Image: nginx:1.17.1 Port: 80/TCP Host Port: 0/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailableOldReplicaSets: &lt;none&gt;NewReplicaSet: nginx-64777cd554 (3/3 replicas created)Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 4m18s deployment-controller Scaled up replica set nginx-64777cd554 to 3 查看pod的label [root@master ~]# kubectl get pods -n dev --show-labelsNAME LABELSnginx-64777cd554-8d4gr pod-template-hash=64777cd554,run=nginxnginx-64777cd554-dw5rr pod-template-hash=64777cd554,run=nginxnginx-64777cd554-gnhwg pod-template-hash=64777cd554,run=nginx 删除Deployment删除deployment之后，pods也会被删除 [root@master ~]# kubectl delete deploy nginx -n devdeployment.apps &quot;nginx&quot; deleted 配置方式创建一个yaml文件，内容如下 deploy-nginx.yamlapiVersion: apps/v1kind: Deploymentmetadata: name: nginx namespace: devspec: replicas: 3 selector: matchLabels: run: nginx template: # pod模板 metadata: labels: run: nginx spec: containers: - image: nginx:1.17.1 name: nginx ports: - containerPort: 80 protocol: TCP 使用下面命令创建删除 kubectl create -f deploy-nginx.yamlkubectl delete -f deploy-nginx.yaml Service通过前面的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。 虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题： Pod IP会随着Pod重建产生变化 Pod IP仅仅是集群内可见的虚拟IP，外部无法访问 这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。 Service可以看作是一组同类Pod对外访问接口。借助Service，应用可以方便地实现服务发现和负载均衡。 创建集群内部能访问的Service暴露Service kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev 查看Service [root@master ~]# kubectl get svc svc-nginx1 -n dev -o wideNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORsvc-nginx1 ClusterIP 10.108.19.184 &lt;none&gt; 80/TCP 2m36s run=nginx 访问Service [root@master ~]# curl 10.108.19.184:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 创建集群外部能访问的Service上面创建的Service的type类型为ClusterIP，这个IP地址只能在集群内部可访问 如果需要创建外部可以访问的Service，需要修改type为NodePort kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev 查看Service [root@master ~]# kubectl get svc -n dev -o wideNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORsvc-nginx1 ClusterIP 10.108.19.184 &lt;none&gt; 80/TCP 7m50s run=nginxsvc-nginx2 NodePort 10.111.68.23 &lt;none&gt; 80:31076/TCP 26s run=nginx 访问： http://192.168.52.100:31076 删除Service[root@master ~]# kubectl delete svc svc-nginx1 -n devservice &quot;svc-nginx1&quot; deleted 配置方式创建一个yaml文件，内容如下： sac-nginx.yamlapiVersion: v1kind: Servicemetadata: name: svc-nginx namespace: devspec: clusterIP: 10.109.179.231 ports: - port: 80 protocol: TCP targetPort: 80 selector: run: nginx type: ClusterIP 使用下面命令创建删除 kubectl create -f svc-nginx.yamlkubectl delete -f svc-nginx.yaml 小结 小结 ​\t至此，已经掌握了Namespace、Pod、Deployment、Service资源的基本操作，有了这些操作，就可以在kubernetes集群中实现一个服务的简单部署和访问了，但是如果想要更好的使用kubernetes，就需要深入学习这几种资源的细节和原理。"},{"title":"笔记简介","path":"/wiki/leadnews/01_introduce/index.html","content":"前置知识储备 SpringBoot灵活使用的程度 SpringCloud入门程度 Nacos基本使用程度 项目功能类似于今日头条，是一个新闻资讯类项目 技术栈基础层 服务层"},{"title":"添加网关","path":"/wiki/leadnews/03_project/add_gateway.html","content":"网关的功能 服务工程结构 添加依赖在leadnews-gateway模块中添加网关依赖： pom.xml&lt;dependencies&gt; &lt;!-- gateway --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jwt --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 完善工程删除leadnews-gateway下的src目录，创建leadnews-app-gateway子模块 子模块的src下创建包com.swx.app.gateway 创建启动类 AppGatewayApplication@SpringBootApplication@EnableDiscoveryClientpublic class AppGatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AppGatewayApplication.class, args); &#125;&#125; 配置文件在resources下创建bootstrap.yaml bootstrap.yamlserver: port: 51601spring: application: name: leadnews-app-gateway cloud: nacos: discovery: server-addr: xxx.xxx.xxx.xxx:8848 config: server-addr: xxx.xxx.xxx.xxx:8848 file-extension: yml 其他配置信息使用Nacos配置中心配置，配置完成点击发布即可 spring: cloud: gateway: globalcors: cors-configurations: &#x27;[/**]&#x27;: # 匹配所有请求 allowedOrigins: &#x27;*&#x27; # 跨域处理，允许所有的域 allowedMethods: # 支持的方法 - GET - POST - PUT - DELETE routes: - id: user uri: lb://leadnews-user predicates: - Path=/user/** filters: - StripPrefix= 1 启动项目启动AppGatewayApplication网关服务 使用接口测试工具访问： http://localhost:51601/user/api/v1/login/login_auth 51601：是配置的网关端口 &#x2F;user：是配置的网关前缀，路由时会去掉该前缀"},{"title":"接口文档","path":"/wiki/leadnews/03_project/api_doc.html","content":"knife4jknife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍! gitee地址：https://gitee.com/xiaoym/knife4j 官方文档：https://doc.xiaominfo.com/ 效果演示：http://knife4j.xiaominfo.com/doc.html 核心功能 文档说明 在线调试 个性化配置 离线文档 接口排序 集成knife4j 在leadnews-common模块中引入如下依赖 pom.xml&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 同时在父工程引入版本信息 pom.xml&lt;properties&gt; &lt;knife4j.version&gt;3.0.3&lt;/knife4j.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;knife4j.version&#125;&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 创建配置文件 Knife4jConfiguration@Configuration@EnableSwagger2@EnableKnife4j@Import(BeanValidatorPluginsConfiguration.class)public class Knife4jConfiguration &#123; @Bean(value = &quot;defaultApi2&quot;) public Docket defaultApi2() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .groupName(&quot;1.0&quot;) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.swx&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;头条新闻API文档&quot;) .description(&quot;头条新闻API文档&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; @EnableKnife4j：该注解是Knife4j提供的增强注解，UI提供了例如动态参数、参数过滤、接口排序等增强功能 配置自动装配，在META-INF/spring.factories中添加自动装配类 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.swx.common.knife4j.Knife4jConfiguration 浏览器访问地址：http://localhost:port/doc.html"},{"title":"APP端文章详情","path":"/wiki/leadnews/03_project/app_article.html","content":"文章详情的两种实现方案 方案一：动态渲染 方案二：静态模版展示 Freemarket概述FreeMarker 是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。 技术选型对比 技术 说明 Jsp Jsp 为 Servlet 专用，不能单独进行使用 Velocity Velocity从2010年更新完 2.0 版本后，7年没有更新。Spring Boot 官方在 1.4 版本后对此也不在支持 thmeleaf 新技术，功能较为强大，但是执行的效率比较低 freemarker 性能好，强大的模板语言、轻量 指令语法基础指令注释，即&lt;#-- --&gt;，介于其之间的内容会被freemarker忽略 &lt;#--我是一个freemarker注释--&gt; 插值（Interpolation）：即$&#123;..&#125;部分,freemarker会用真实的值代替$&#123;..&#125; Hello $&#123;name&#125; FTL指令：和HTML标记类似，名字前加#予以区分，Freemarker会解析标签中的表达式或逻辑。 &lt;# &gt;FTL指令&lt;/#&gt; 文本，仅文本信息，这些不是freemarker的注释、插值、FTL指令的内容会被freemarker忽略解析，直接输出内容。 &lt;#--freemarker中的普通文本--&gt;我是一个普通的文本 List指令&lt;#list&gt;&lt;/#list&gt;&lt;#list stus as stu&gt; &lt;tr&gt; &lt;td&gt;$&#123;stu_index+1&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.money&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/#list&gt; $&#123;k_index&#125;：得到循环的下标，使用方法是在stu后边加”_index”，它的值是从0开始 Map指令获取map中的值 map[&#x27;keyname&#x27;].propertymap.keyname.property&lt;#list userMap?keys as key&gt;\tkey:$&#123;key&#125;--value:$&#123;userMap[&quot;$&#123;key&#125;&quot;]&#125;&lt;/#list&gt; if指令&lt;#if expression&gt;&lt;#else&gt;&lt;/#if&gt; 需求：在list集合中判断学生为小红的数据字体显示为红色。 &lt;#if stu.name=&#x27;小红&#x27;&gt; &lt;tr style=&quot;color: red&quot;&gt; &lt;td&gt;$&#123;stu_index&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.money&#125;&lt;/td&gt; &lt;/tr&gt;&lt;#else &gt; &lt;tr&gt; &lt;td&gt;$&#123;stu_index&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.money&#125;&lt;/td&gt;\t&lt;/tr&gt;&lt;/#if&gt; 在freemarker中，判断是否相等，&#x3D;与&#x3D;&#x3D;是一样的 运算符算术运算符 FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括: ① 加法： + ② 减法： - ③ 乘法： ***** ④ 除法： &#x2F; 求模 (求余)： % 比较运算符 比较运算符 说明 &#x3D;或者&#x3D;&#x3D; 判断两个值是否相等 !&#x3D; 判断两个值是否不等 &gt;或者gt 判断左边值是否大于右边值 &gt;&#x3D;或者gte 判断左边值是否大于等于右边值 &lt;或者lt 判断左边值是否小于右边值 &lt;&#x3D;或者lte 判断左边值是否小于等于右边值 &#x3D;和!&#x3D;可以用于字符串、数值和日期来比较是否相等 &#x3D;和!&#x3D;两边必须是相同类型的值,否则会产生错误 字符串 “x” 、”x “ 、”X”比较是不等的.因为FreeMarker是精确比较 gt代替&gt;, FreeMarker会把&gt;解释成FTL标签的结束字符,可使用括号避免这种情况,如:&lt;#if (x&gt;y)&gt; 逻辑运算符 逻辑与：**&amp;&amp;** 逻辑或：**||** 逻辑非：**!** 空值处理1、判断某变量是否存在使用 “??” 用法为:variable??,如果该变量存在,返回true,否则返回false &lt;#if stus??&gt;\t&lt;#list stus as stu&gt; ...... &lt;/#list&gt;&lt;/#if&gt; 2、缺失变量默认值使用 “!” 使用!要以指定一个默认值，当变量为空时显示默认值 例：$&#123;name!&#39;&#39;&#125;表示如果name为空显示空字符串。 如果是嵌套对象则建议使用’()’括起来 例：$&#123;(stu.name)!&#39;&#39;&#125;表示，如果stu或name为空默认显示空字符串。 内建函数内建函数语法格式： 变量+?+函数名称 1、集合的大小 $&#123;集合名?size&#125; 2、日期格式化 显示年月日: $&#123;today?date&#125;显示时分秒：$&#123;today?time&#125;显示日期+时间：$&#123;today?datetime&#125;自定义格式化：$&#123;today?string(&quot;yyyy年MM月&quot;)&#125; 3、内建函数c model.addAttribute(&quot;point&quot;, 102920122); point是数字型，使用${point}会显示这个数字的值，每三位使用逗号分隔。 如果不想显示为每三位分隔的数字，可以使用c函数将数字型转成字符串输出 $&#123;point?c&#125; 4、将json字符串转成对象 &lt;#assign text=&quot;&#123;&#x27;bank&#x27;:&#x27;工商银行&#x27;,&#x27;account&#x27;:&#x27;10101920201920212&#x27;&#125;&quot; /&gt;&lt;#assign data=text?eval /&gt;开户行：$&#123;data.bank&#125; 账号：$&#123;data.account&#125; 输出静态化文件使用freemarker原生Api将页面生成html文件 application.yamlspring: suffix: .ftl template-loader-path: classpath:/templates 测试 public class FreemarkerTest &#123; @Autowired private Configuration configuration; public void test() throws IOException &#123; Template template = configuration.getTemplate(&quot;test.ftl&quot;); // arg1: 模型数据，arg2: 输出流 template.process(getData(), new FileWriter(&quot;/temp/test.html&quot;)); &#125; private Map&lt;String, Object&gt; getData() &#123; Map&lt;String, Object&gt; model = new HashMap&lt;&gt;(); map.put(&quot;test&quot;, &quot;test&quot;); map.put(&quot;date&quot;, new Date()); return map; &#125;&#125; MinIO简介对象存储的方式对比 存储方式 优点 缺点 服务器磁盘 开发便捷，成本低 扩展困难 分布式文件系统 容易实现扩容 复杂度高 第三方存储 开发简单，功能强大，免维护 收费 分布式文件系统 存储方式 优点 缺点 FastDFS 1. 主备服务，高可用 2. 支持主从文件，支持自定义扩展名 3. 支持动态扩容 1. 没有完备官方文档，近几年没有更新 2. 环境搭建较为麻烦 MinIO 1. 性能高，准硬件条件下它能达到55GB&#x2F;s的读、35GB&#x2F;s的写速率 2. 部署自带管理界面 3. MinIO.Inc运营的开源项目，社区活跃度高 4. 提供了所有主流开发语言的SDK 1. 不支持动态增加节点 MinIO基于Apache License v2.0开源协议的对象存储服务，可以做为云存储的解决方案用来保存海量的图片，视频，文档。 uGolang语言实现，配置简单，单行命令可以运行起来。 uMinIO兼容亚马逊S3云存储服务接口，适合于存储大容量非结构化的数据，一个对象文件可以是任意大小，从几kb到最大5T不等。 u官网文档：http://docs.minio.org.cn/docs/ 食用教程①：拉取镜像 docker pull minio/minio ②：创建容器 docker run -p 9000:9000 -p 9001:9001 \\\t--name minio \\\t-d --restart=always \\\t-e &quot;MINIO_ACCESS_KEY=minio&quot; \\\t-e &quot;MINIO_SECRET_KEY=minio123&quot; \\\t-v /home/data:/data \\\t-v /home/config:/root/.minio \\\tminio/minio server /data \\\t--console-address &quot;:9001&quot; ③：访问minio系统 http://ip:9001 快速入门目标：把list.html文件上传到minio中，并且可以在浏览器中访问 public static void main(String[] args) &#123; FileInputStream fileInputStream = null; try &#123; fileInputStream = new FileInputStream(&quot;D:\\\\list.html&quot;);; //1.创建minio链接客户端 MinioClient minioClient = MinioClient.builder() .credentials(&quot;minio&quot;, &quot;minio123&quot;) .endpoint(&quot;http://192.168.200.130:9000&quot;) .build(); //2.上传 PutObjectArgs putObjectArgs = PutObjectArgs.builder() .object(&quot;list.html&quot;)//文件名 .contentType(&quot;text/html&quot;)//文件类型 .bucket(&quot;leadnews&quot;)//桶名词 与minio创建的名词一致 .stream(fileInputStream, fileInputStream.available(), -1) //文件流 .build(); minioClient.putObject(putObjectArgs); System.out.println(&quot;http://192.168.200.130:9000/leadnews/list.html&quot;); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125;&#125; 封装MinIO为starter创建子模块file-starter 引入依赖 pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;7.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建包com.swx.file 创建包config，并在包下创建两个配置文件 MinIOConfig config.MinIOConfig@Configuration@EnableConfigurationProperties(&#123;MinIOConfigProperties.class&#125;)//当引入FileStorageService接口时@ConditionalOnClass(FileStorageService.class)public class MinIOConfig &#123; @Autowired private MinIOConfigProperties minIOConfigProperties; @Bean public MinioClient buildMinioClient() &#123; return MinioClient .builder() .credentials(minIOConfigProperties.getAccessKey(), minIOConfigProperties.getSecretKey()) .endpoint(minIOConfigProperties.getEndpoint()) .build(); &#125;&#125; ConfigurationProperties ConfigurationProperties@Data@ConfigurationProperties(prefix = &quot;minio&quot;) // 文件上传 配置前缀file.osspublic class MinIOConfigProperties implements Serializable &#123; private String accessKey; private String secretKey; private String bucket; private String endpoint; private String readPath;&#125; 创建包service和service.impl，创建接口类FileStorageService FileStorageService/** * @author itheima */public interface FileStorageService &#123; /** * 上传图片文件 * @param prefix 文件前缀 * @param filename 文件名 * @param inputStream 文件流 * @return 文件全路径 */ public String uploadImgFile(String prefix, String filename,InputStream inputStream); /** * 上传html文件 * @param prefix 文件前缀 * @param filename 文件名 * @param inputStream 文件流 * @return 文件全路径 */ public String uploadHtmlFile(String prefix, String filename,InputStream inputStream); /** * 删除文件 * @param pathUrl 文件全路径 */ public void delete(String pathUrl); /** * 下载文件 * @param pathUrl 文件全路径 * @return * */ public byte[] downLoadFile(String pathUrl);&#125; 实现接口 @Slf4j@EnableConfigurationProperties(MinIOConfigProperties.class)@Import(MinIOConfig.class)public class MinIOFileStorageService implements FileStorageService &#123; private final MinioClient minioClient; private final MinIOConfigProperties minIOConfigProperties; private final static String separator = &quot;/&quot;; public MinIOFileStorageService(MinioClient minioClient, MinIOConfigProperties minIOConfigProperties) &#123; this.minioClient = minioClient; this.minIOConfigProperties = minIOConfigProperties; &#125; /** * @param dirPath * @param filename yyyy/mm/dd/file.jpg * @return */ public String builderFilePath(String dirPath,String filename) &#123; StringBuilder stringBuilder = new StringBuilder(50); if(!StringUtils.isEmpty(dirPath))&#123; stringBuilder.append(dirPath).append(separator); &#125; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;); String todayStr = sdf.format(new Date()); stringBuilder.append(todayStr).append(separator); stringBuilder.append(filename); return stringBuilder.toString(); &#125; /** * 上传图片文件 * @param prefix 文件前缀 * @param filename 文件名 * @param inputStream 文件流 * @return 文件全路径 */ @Override public String uploadImgFile(String prefix, String filename,InputStream inputStream) &#123; String filePath = builderFilePath(prefix, filename); try &#123; PutObjectArgs putObjectArgs = PutObjectArgs.builder() .object(filePath) .contentType(&quot;image/jpg&quot;) .bucket(minIOConfigProperties.getBucket()).stream(inputStream,inputStream.available(),-1) .build(); minioClient.putObject(putObjectArgs); StringBuilder urlPath = new StringBuilder(minIOConfigProperties.getReadPath()); urlPath.append(separator+minIOConfigProperties.getBucket()); urlPath.append(separator); urlPath.append(filePath); return urlPath.toString(); &#125;catch (Exception ex)&#123; log.error(&quot;minio put file error.&quot;,ex); throw new RuntimeException(&quot;上传文件失败&quot;); &#125; &#125; /** * 上传html文件 * @param prefix 文件前缀 * @param filename 文件名 * @param inputStream 文件流 * @return 文件全路径 */ @Override public String uploadHtmlFile(String prefix, String filename,InputStream inputStream) &#123; String filePath = builderFilePath(prefix, filename); try &#123; PutObjectArgs putObjectArgs = PutObjectArgs.builder() .object(filePath) .contentType(&quot;text/html&quot;) .bucket(minIOConfigProperties.getBucket()).stream(inputStream,inputStream.available(),-1) .build(); minioClient.putObject(putObjectArgs); StringBuilder urlPath = new StringBuilder(minIOConfigProperties.getReadPath()); urlPath.append(separator+minIOConfigProperties.getBucket()); urlPath.append(separator); urlPath.append(filePath); return urlPath.toString(); &#125;catch (Exception ex)&#123; log.error(&quot;minio put file error.&quot;,ex); ex.printStackTrace(); throw new RuntimeException(&quot;上传文件失败&quot;); &#125; &#125; /** * 删除文件 * @param pathUrl 文件全路径 */ @Override public void delete(String pathUrl) &#123; String key = pathUrl.replace(minIOConfigProperties.getEndpoint()+&quot;/&quot;,&quot;&quot;); int index = key.indexOf(separator); String bucket = key.substring(0,index); String filePath = key.substring(index+1); // 删除Objects RemoveObjectArgs removeObjectArgs = RemoveObjectArgs.builder().bucket(bucket).object(filePath).build(); try &#123; minioClient.removeObject(removeObjectArgs); &#125; catch (Exception e) &#123; log.error(&quot;minio remove file error. pathUrl:&#123;&#125;&quot;,pathUrl); e.printStackTrace(); &#125; &#125; /** * 下载文件 * @param pathUrl 文件全路径 * @return 文件流 * */ @Override public byte[] downLoadFile(String pathUrl) &#123; String key = pathUrl.replace(minIOConfigProperties.getEndpoint()+&quot;/&quot;,&quot;&quot;); int index = key.indexOf(separator); String bucket = key.substring(0,index); String filePath = key.substring(index+1); InputStream inputStream = null; try &#123; inputStream = minioClient.getObject(GetObjectArgs.builder().bucket(minIOConfigProperties.getBucket()).object(filePath).build()); &#125; catch (Exception e) &#123; log.error(&quot;minio down file error. pathUrl:&#123;&#125;&quot;,pathUrl); e.printStackTrace(); &#125; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] buff = new byte[100]; int rc = 0; while (true) &#123; try &#123; if (!((rc = inputStream.read(buff, 0, 100)) &gt; 0)) break; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; byteArrayOutputStream.write(buff, 0, rc); &#125; return byteArrayOutputStream.toByteArray(); &#125;&#125; 自动装配 创建/resources/META-INF/spring.factories，写入如下内容： org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.swx.file.service.impl.MinIOFileStorageService 使用教程 public class MinIOTest &#123; @Autowired private FileStorageService fileStorageService; public void test() thorws FileNotFoundException &#123; FileInputStream fileInputStream = new FileInputStream(&quot;/temp/test.html&quot;); String url = fileStorageService.uploadHtmlFile(&quot;&quot;, &quot;test.html&quot;); System.out.println(url); &#125;&#125; 集成Freemarket和MinIO1.在article微服务中添加MinIO和freemarker的支持 pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-file-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 记得在父工程的pom文件中添加版本依赖 将如下配置加入到leadnews-article的Nacos配置中，发布： minio: accessKey: minio secretKey: minio123 bucket: leadnews endpoint: http://ip:9000 readPath: http://ip:9000 2.下载模板文件（article.ftl）拷贝到article微服务下 下载地址：https://wwab.lanzoue.com/ic4iE14ki4qj 3.下载模版文件，解压后将plugins目录手动上传到MinIO中 下载地址：https://wwab.lanzoue.com/ic4iE14ki4qj 在MinIO中创建Buckets名字为leadnews，并将Access Ploicy设置为Public 在leadnews中上传plugins目录 生成静态模版创建测试类，后续添加时会在项目中创建静态模版，这里先使用测试类生成 ArticleFreemarkerTest@SpringBootTest(classes = ArticleApplication.class)@RunWith(SpringRunner.class)public class ArticleFreemarkerTest &#123; @Autowired private ApArticleContentMapper apArticleContentMapper; @Autowired Configuration configuration; @Autowired private FileStorageService fileStorageService; @Autowired private ApArticleMapper apArticleMapper; @Test public void createStaticUrlTest() throws Exception &#123; // 1. 获取文章内容 ApArticleContent apArticleContent = apArticleContentMapper.selectOne( Wrappers.&lt;ApArticleContent&gt;lambdaQuery().eq(ApArticleContent::getArticleId, 1383827787629252610L)); // 文章内容通过freemarker生成html文件 Template template = configuration.getTemplate(&quot;article.ftl&quot;); StringWriter out = new StringWriter(); // 数据模型 HashMap&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;content&quot;, JSONArray.parseArray(apArticleContent.getContent())); // 合成 template.process(params, out); // 把html文件上传到minio中 InputStream is = new ByteArrayInputStream(out.toString().getBytes()); String url = fileStorageService.uploadHtmlFile(&quot;&quot;, apArticleContent.getArticleId() + &quot;.html&quot;, is); // 修改ap_article表，保存static_url字段 ApArticle article = new ApArticle(); article.setId(apArticleContent.getArticleId()); article.setStaticUrl(url); apArticleMapper.updateById(article); &#125;&#125;"},{"title":"APP端文章列表","path":"/wiki/leadnews/03_project/app_articles.html","content":"文章列表有三种布局：无图、单图、多图 每页默认展示10条文章信息 文章列表可以切换不同频道，查看不同种类文章 下拉刷新加载最新文章，以本页文章最大时间为基础 上拉加载更多数据，以本页文章最小时间为基础 数据库 表名称 说明 ap_article 文章信息表，存储已发布的文章 ap_article_config APP已发布文章配置表 ap_article_content APP已发布文章内容表 ap_author APP文章作者信息表 ap_collection APP收藏信息表 下载数据库脚本文件leadnews_article.sql： https://wwab.lanzoue.com/imHFv14kidfc 或者执行下面命令创建 CREATE DATABASE IF NOT EXISTS leadnews_article DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;USE leadnews_article;SET NAMES utf8;/*Navicat MySQL Data TransferSource Server : localhostSource Server Version : 50721Source Host : localhost:3306Source Database : leadnews_articleTarget Server Type : MYSQLTarget Server Version : 50721File Encoding : 65001Date: 2021-04-19 15:05:13*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for ap_article-- ----------------------------DROP TABLE IF EXISTS `ap_article`;CREATE TABLE `ap_article` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;标题&#x27;, `author_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;文章作者的ID&#x27;, `author_name` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;作者昵称&#x27;, `channel_id` int(10) unsigned DEFAULT NULL COMMENT &#x27;文章所属频道ID&#x27;, `channel_name` varchar(10) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;频道名称&#x27;, `layout` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;文章布局\\r 0 无图文章\\r 1 单图文章\\r 2 多图文章&#x27;, `flag` tinyint(3) unsigned DEFAULT NULL COMMENT &#x27;文章标记\\r 0 普通文章\\r 1 热点文章\\r 2 置顶文章\\r 3 精品文章\\r 4 大V 文章&#x27;, `images` varchar(1000) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;文章图片\\r 多张逗号分隔&#x27;, `labels` varchar(500) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;文章标签最多3个 逗号分隔&#x27;, `likes` int(5) unsigned DEFAULT NULL COMMENT &#x27;点赞数量&#x27;, `collection` int(5) unsigned DEFAULT NULL COMMENT &#x27;收藏数量&#x27;, `comment` int(5) unsigned DEFAULT NULL COMMENT &#x27;评论数量&#x27;, `views` int(5) unsigned DEFAULT NULL COMMENT &#x27;阅读数量&#x27;, `province_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;省市&#x27;, `city_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;市区&#x27;, `county_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;区县&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `publish_time` datetime DEFAULT NULL COMMENT &#x27;发布时间&#x27;, `sync_status` tinyint(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;同步状态&#x27;, `origin` tinyint(1) unsigned DEFAULT &#x27;0&#x27; COMMENT &#x27;来源&#x27;, `static_url` varchar(150) COLLATE utf8mb4_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1383828014629179394 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;文章信息表，存储已发布的文章&#x27;;-- ------------------------------ Records of ap_article-- ----------------------------INSERT INTO `ap_article` VALUES (&#x27;1302862387124125698&#x27;, &#x27;什么是Java语言&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl9V2CqAZe18AAOoOOsvWPc041.png&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 14:52:54&#x27;, &#x27;2020-09-07 14:56:18&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302864436297482242&#x27;, &#x27;Java语言跨平台原理&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl9V2n6AArZsAAGMmaPdt7w502.png&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 15:01:02&#x27;, &#x27;2020-09-07 15:01:02&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302864730402078722&#x27;, &#x27;我是一个测试标题&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892wqAANwOAAJW8oQUlAc087.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 15:02:12&#x27;, &#x27;2020-09-07 15:02:12&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302865008438296577&#x27;, &#x27;过山车故障20名游客倒挂空中&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;3&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892wqAANwOAAJW8oQUlAc087.jpg,group1/M00/00/00/wKjIgl892xmAG_yjAAB6OkkuJd4819.jpg,group1/M00/00/00/wKjIgl892wKAZLhtAASZUi49De0836.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 15:03:19&#x27;, &#x27;2020-09-07 15:03:19&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302865306489733122&#x27;, &#x27;武汉高校开学典礼万人歌唱祖国&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;3&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892vuAXr_MAASCMYD0yzc919.jpg,group1/M00/00/00/wKjIgl892xGANV6qAABzWOH8KDY775.jpg,group1/M00/00/00/wKjIgl892wqAANwOAAJW8oQUlAc087.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 15:04:30&#x27;, &#x27;2020-09-07 15:04:30&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302865474094120961&#x27;, &#x27;天降铁球砸死女婴整栋楼被判赔&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892tyAFc60AAMUNUuOKPA619.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 15:05:10&#x27;, &#x27;2020-09-07 15:05:10&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302977178887004162&#x27;, &#x27;央视曝光境外医疗豪华旅游套路&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;0&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892wqAANwOAAJW8oQUlAc087.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 22:29:02&#x27;, &#x27;2020-09-07 22:29:02&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302977458215067649&#x27;, &#x27;10多名陌生人合力托举悬窗女童&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892vOASiunAAGzs3UZ1Cg252.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 22:30:09&#x27;, &#x27;2020-09-07 22:30:09&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302977558807060482&#x27;, &#x27;杨澜回应一秒变脸&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892wKAZLhtAASZUi49De0836.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 22:30:33&#x27;, &#x27;2020-09-07 22:30:33&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302977754114826241&#x27;, &#x27;黄龄工作室发视频回应&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;4&#x27;, &#x27;Python&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892vuAXr_MAASCMYD0yzc919.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-07 22:31:19&#x27;, &#x27;2020-09-07 22:31:19&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302977754114826242&#x27;, &#x27;黄龄工作室发视频回应&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;4&#x27;, &#x27;Python&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892vuAXr_MAASCMYD0yzc919.jpg&#x27;, &#x27;&#x27;, null, null, null, null, null, null, null, &#x27;2020-09-07 22:31:19&#x27;, &#x27;2020-09-07 22:31:19&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1302977754114826243&#x27;, &#x27;黄龄工作室发视频回应&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;4&#x27;, &#x27;Python&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl892vuAXr_MAASCMYD0yzc919.jpg&#x27;, &#x27;&#x27;, null, null, null, null, null, null, null, &#x27;2020-09-07 22:31:19&#x27;, &#x27;2020-09-07 22:31:19&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1303156149041758210&#x27;, &#x27;全国抗击新冠肺炎疫情表彰大会&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;group1/M00/00/00/wKjIgl9W6iOAD2doAAFY4E1K7-g384.png&#x27;, null, null, null, null, null, null, null, null, &#x27;2020-09-08 10:20:12&#x27;, &#x27;2020-09-08 10:20:12&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1383827787629252610&#x27;, &#x27;Kafka文件的存储机制&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/4a498d9cf3614570ac0cb2da3e51c164.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2021-04-19 01:00:29&#x27;, &#x27;2021-04-19 00:20:17&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1383827888816836609&#x27;, &#x27;为什么项目经理不喜欢重构？&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/4a498d9cf3614570ac0cb2da3e51c164.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2021-04-19 01:00:54&#x27;, &#x27;2021-04-19 00:19:09&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1383827911810011137&#x27;, &#x27;Base64编解码原理&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/b44c65376f12498e873223d9d6fdf523.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2021-04-19 01:00:59&#x27;, &#x27;2021-04-19 00:17:42&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1383827952326987778&#x27;, &#x27;工作线程数是不是设置的越大越好&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/a3f0bc438c244f788f2df474ed8ecdc1.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2021-04-19 01:01:09&#x27;, &#x27;2021-04-19 00:16:52&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1383827976310018049&#x27;, &#x27;小白如何辨别其真与伪&amp;好与坏？&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/1818283261e3401892e1383c1bd00596.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2021-04-19 01:01:14&#x27;, &#x27;2021-04-19 00:14:58&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1383827995813531650&#x27;, &#x27;学IT，为什么要学项目课程？&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;3&#x27;, null, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/7d0911a41a3745efa8509a87f234813c.jpg,http://192.168.200.130:9000/leadnews/2021/4/20210418/c7c3d36d25504cf6aecdcd5710261773.jpg,http://192.168.200.130:9000/leadnews/2021/4/20210418/e8113ad756a64ea6808f91130a6cd934.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2021-04-19 01:01:19&#x27;, &#x27;2021-04-19 00:10:48&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);INSERT INTO `ap_article` VALUES (&#x27;1383828014629179393&#x27;, &#x27;“真”项目课程对找工作有什么帮助？&#x27;, &#x27;4&#x27;, &#x27;admin&#x27;, &#x27;1&#x27;, &#x27;java&#x27;, &#x27;1&#x27;, null, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/7d0911a41a3745efa8509a87f234813c.jpg&#x27;, null, null, null, null, null, null, null, null, &#x27;2021-04-19 01:01:24&#x27;, &#x27;2021-04-19 00:08:05&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, null);-- ------------------------------ Table structure for ap_article_config-- ----------------------------DROP TABLE IF EXISTS `ap_article_config`;CREATE TABLE `ap_article_config` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `article_id` bigint(20) unsigned DEFAULT NULL COMMENT &#x27;文章ID&#x27;, `is_comment` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;是否可评论&#x27;, `is_forward` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;是否转发&#x27;, `is_down` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;是否下架&#x27;, `is_delete` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;是否已删除&#x27;, PRIMARY KEY (`id`) USING BTREE, KEY `idx_article_id` (`article_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1383828014645956610 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;APP已发布文章配置表&#x27;;-- ------------------------------ Records of ap_article_config-- ----------------------------INSERT INTO `ap_article_config` VALUES (&#x27;1302862387933626369&#x27;, &#x27;1302862387124125698&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302864437425750018&#x27;, &#x27;1302864436297482242&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302864731203190785&#x27;, &#x27;1302864730402078722&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302865009533009922&#x27;, &#x27;1302865008438296577&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302865307408285697&#x27;, &#x27;1302865306489733122&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302865475297886209&#x27;, &#x27;1302865474094120961&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302977180199821313&#x27;, &#x27;1302977178887004162&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302977459322363905&#x27;, &#x27;1302977458215067649&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302977559788527618&#x27;, &#x27;1302977558807060482&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302977754882383873&#x27;, &#x27;1302977754114826241&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302977754882383874&#x27;, &#x27;1302977754114826242&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1302977754882383875&#x27;, &#x27;1302977754114826243&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1303156149909979137&#x27;, &#x27;1303156149041758210&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1383827787704750082&#x27;, &#x27;1383827787629252610&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1383827888829419522&#x27;, &#x27;1383827888816836609&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1383827911822594049&#x27;, &#x27;1383827911810011137&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1383827952326987779&#x27;, &#x27;1383827952326987778&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1383827976322600962&#x27;, &#x27;1383827976310018049&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1383827995821920257&#x27;, &#x27;1383827995813531650&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `ap_article_config` VALUES (&#x27;1383828014645956609&#x27;, &#x27;1383828014629179393&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);-- ------------------------------ Table structure for ap_article_content-- ----------------------------DROP TABLE IF EXISTS `ap_article_content`;CREATE TABLE `ap_article_content` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `article_id` bigint(20) unsigned DEFAULT NULL COMMENT &#x27;文章ID&#x27;, `content` longtext COLLATE utf8mb4_unicode_ci COMMENT &#x27;文章内容&#x27;, PRIMARY KEY (`id`) USING BTREE, KEY `idx_article_id` (`article_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1383828014650150915 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;APP已发布文章内容表&#x27;;-- ------------------------------ Records of ap_article_content-- ----------------------------INSERT INTO `ap_article_content` VALUES (&#x27;1302862388957036545&#x27;, &#x27;1302862387124125698&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。\\ \\ 2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：https://www.oracle.com\\ Java语言共同创始人之一：詹姆斯·高斯林 （James Gosling），被称为“Java之父”\\ \\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl9V2CqAZe18AAOoOOsvWPc041.png\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;Java语言发展历史\\ \\ - 1995年Sun公司推出Java语言\\ - 1996年发布Java 1.0版本\\ - 1997年发布Java 1.1版本\\ - 1998年发布Java 1.2版本\\ - 2000年发布Java 1.3版本\\ - 2002年发布Java 1.4版本\\ - 2004年发布Java 5.0版本\\ - 2006年发布Java 6.0版本\\ - 2009年Oracle甲骨文公司收购Sun公司\\ - 2011年发布Java 7.0版本\\ - 2014年发布Java 8.0版本\\ - 2017年9月发布Java 9.0版本\\ - 2018年3月发布Java 10.0版本\\ - 2018年9月发布Java 11.0版本\\ \\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;Java 语言的三个版本\\ \\ - JavaSE：标准版，用于桌面应用的开发，是其他两个版本的基础。\\ - 学习JavaSE的目的, 是为了就业班要学习的JavaEE打基础.\\ \\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl9V2F6AdQxAAAGyaOdp4gk784.png\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;- JavaEE：企业版，用于Web方向的网站开发\\ - 网站：网页 + 后台服务器\\ \\ Java语言主要应用在互联网程序的开发领域。常见的互联网程序比如天猫、京东、物流系统、网银系统等，以及服务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。\\ \\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1302864438885367810&#x27;, &#x27;1302864436297482242&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;Java虚拟机——JVM\\ \\ - JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在JVM 之上。\\ - 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。\\ \\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl9V2n6AArZsAAGMmaPdt7w502.png\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。\\ \\ 问题1: Java 是如何实现跨平台的呢？\\ \\ - 答：因为在不同操作系统中都安装了对应版本的 JVM 虚拟机\\ - 注意: Java程序想要运行, 必须依赖于JVM虚拟机.\\ \\ 问题2: JVM 本身是否允许跨平台呢？\\ \\ - 答：不允许，允许跨平台的是 Java 程序，而不是虚拟机。\\ \\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1302864732679585794&#x27;, &#x27;1302864730402078722&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;这些都是测试这些都是测试这些都是测试这些都是测试这些都是测试这些都是测试\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl892wqAANwOAAJW8oQUlAc087.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;这些都是测试这些都是测试这些都是测试这些都是测试\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1302865011026182145&#x27;, &#x27;1302865008438296577&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl892uyAR12rAADi7UxPXeM267.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中过山车故障20名游客倒挂空中\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1302865308704325633&#x27;, &#x27;1302865306489733122&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl892vuAXr_MAASCMYD0yzc919.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国武汉高校开学典礼万人歌唱祖国v\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1302865476799447041&#x27;, &#x27;1302865474094120961&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl892tyAFc60AAMUNUuOKPA619.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔天降铁球砸死女婴整栋楼被判赔vv\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1302977181835599873&#x27;, &#x27;1302977178887004162&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路央视曝光境外医疗豪华旅游套路\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl892wqAANwOAAJW8oQUlAc087.jpg\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1302977460907810818&#x27;, &#x27;1302977458215067649&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;510多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl892vOASiunAAGzs3UZ1Cg252.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl892uyAR12rAADi7UxPXeM267.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童v\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童10多名陌生人合力托举悬窗女童v\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1302977561034235906&#x27;, &#x27;1302977558807060482&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl892wKAZLhtAASZUi49De0836.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸杨澜回应一秒变脸\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1302977755742216193&#x27;, &#x27;1302977754114826241&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;3黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl892vuAXr_MAASCMYD0yzc919.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应黄龄工作室发视频回应\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1303156151151493121&#x27;, &#x27;1303156149041758210&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130/group1/M00/00/00/wKjIgl9W6iOAD2doAAFY4E1K7-g384.png\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;全国抗击新冠肺炎疫情表彰大会开始15家“文化会客厅”展现产业发展的集群效应全球疫情简报:印度新冠确诊病例超420万 升至全球第二中方提出《全球数据安全倡议》\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1383827787742498817&#x27;, &#x27;1383827787629252610&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/4a498d9cf3614570ac0cb2da3e51c164.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1383827888833613826&#x27;, &#x27;1383827888816836609&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;经常听到开发人员抱怨 ，“这么烂的代码，我来重构一下！”，“这代码怎么能这么写呢？谁来重构一下？”，“这儿有个坏味道，重构吧！”\\ \\ 作为一名项目经理，每次听到“重构”两个字，既想给追求卓越代码的开发人员点个赞，同时又会感觉非常紧张，为什么又要重构？马上就要上线了，怎么还要改？是不是应该阻止开发人员做重构？\\ \\ 重构几乎是开发人员最喜欢的一项实践了，可项目经理们却充满了顾虑，那么为什么项目经理不喜欢重构呢？\\ \\ 老功能被破坏\\ 不止一次遇到这样的场景，某一天一个老功能突然被破坏了，项目经理们感到奇怪，产品这块儿的功能已经很稳定了，也没有在这部分开发什么新功能，为什么突然出问题了呢？\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/e8113ad756a64ea6808f91130a6cd934.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/4a498d9cf3614570ac0cb2da3e51c164.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1383827911826788353&#x27;, &#x27;1383827911810011137&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;我在面试过程中，问过很多高级java工程师，是否了解Base64？部分人回答了解，部分人直接回答不了解。而说了解的那部分人却回答不上来它的原理。\\ \\ Base64 的由来\\ Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。它是一种基于用64个可打印字符来表示二进制数据的表示方法。它通常用作存储、传输一些二进制数据编码方法！也是MIME（多用途互联网邮件扩展，主要用作电子邮件标准）中一种可打印字符表示二进制数据的常见编码方法！它其实只是定义用可打印字符传输内容一种方法，并不会产生新的字符集！\\ \\ 传统的邮件只支持可见字符的传送，像ASCII码的控制字符就 不能通过邮件传送。这样用途就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情 况下，做一种扩展方案来支持二进制文件的传送。把不可打印的字符也能用可打印字符来表示，问题就解决了。Base64编码应运而生，Base64就是一种 基于64个可打印字符来表示二进制数据的表示方法。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/b44c65376f12498e873223d9d6fdf523.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1383827952335376385&#x27;, &#x27;1383827952326987778&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;根据经验来看，jdk api 一般推荐的线程数为CPU核数的2倍。但是有些书籍要求可以设置为CPU核数的8倍，也有的业务设置为CPU核数的32倍。\\ “工作线程数”的设置依据是什么，到底设置为多少能够最大化CPU性能，是本文要讨论的问题。\\ \\ 工作线程数是不是设置的越大越好\\ 显然不是的。使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。\\ 一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。\\ Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。\\ 一个Java应用总是从main()方法开始运行，main()方法运行在一个线程内，它被称为主线程。\\ 一旦创建一个新的线程，就产生一个新的调用栈。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/a3f0bc438c244f788f2df474ed8ecdc1.jpg\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1383827976322600963&#x27;, &#x27;1383827976310018049&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;通过上篇《IT培训就业艰难，行业乱象频发，如何破解就业难题?》一文，相信大家已初步了解“项目课程”对程序员能否就业且高薪就业的重要性。\\ \\ 因此，小白在选择IT培训机构时，关注的重点就在于所学“项目课程”能否真正帮你增加就业筹码。当然，前提必须是学到“真”项目。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/1818283261e3401892e1383c1bd00596.jpg\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1383827995834503170&#x27;, &#x27;1383827995813531650&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;在选择IT培训机构时，你应该有注意到，很多机构都将“项目课程”作为培训中的重点。那么，为什么要学习项目课程?为什么项目课程才是IT培训课程的核心?\\ \\ 1\\ \\ 在这个靠“技术经验说话”的IT行业里，假如你是一个计算机或IT相关专业毕业生，在没有实际项目开发经验的情况下，“找到第一份全职工作”可能是你职业生涯中遇到的最大挑战。\\ \\ 为什么说找第一份工作很难?\\ \\ 主要在于：实际企业中用到的软件开发知识和在学校所学的知识是完全不同的。假设你已经在学校和同学做过周期长达2-3个月的项目，但真正工作中的团队协作与你在学校中经历的协作也有很多不同。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/e8113ad756a64ea6808f91130a6cd934.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;在实际团队中，每一位成员彼此团结一致，为项目的交付而努力，这也意味着你必须要理解好在项目中负责的那部分任务，在规定时间交付还需确保你负责的功能，在所有环境中都能很好地发挥作用，而不仅仅是你的本地机器。\\ \\ 这需要你对项目中的每一行代码严谨要求。学校练习的项目中，对bug的容忍度很大，而在实际工作中是绝对不能容忍的。项目中的任何一个环节都涉及公司利益，任何一个bug都可能影响公司的收入及形象。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/c7c3d36d25504cf6aecdcd5710261773.jpg\\&quot;&#125;]&#x27;);INSERT INTO `ap_article_content` VALUES (&#x27;1383828014650150914&#x27;, &#x27;1383828014629179393&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;找工作，企业重点问的是项目经验，更是HR筛选的“第一门槛”，直接决定了你是否有机会进入面试环节。\\ \\ 项目经验更是评定“个人能力/技能”真实性的“证据”，反映了求职者某个方面的实际动手能力、对某个领域或某种技能的掌握程度。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/7d0911a41a3745efa8509a87f234813c.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;很多经过培训期望快速上岗的程序员，靠着培训机构“辅导”顺利经过面试官对于“项目经验”的考核上岗后，在面对“有限时间”“复杂业务”“新项目需求”等多项标签加持的工作任务，却往往不知从何下手或开发进度极其缓慢。最终结果就是：熬不过试用期。\\ \\ 从而也引发了企业对于“培训出身程序员”的“有色眼光”。你甚至也一度怀疑“IT培训班出来的人真的不行吗?”\\&quot;&#125;]&#x27;);-- ------------------------------ Table structure for ap_author-- ----------------------------DROP TABLE IF EXISTS `ap_author`;CREATE TABLE `ap_author` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `name` varchar(20) DEFAULT NULL COMMENT &#x27;作者名称&#x27;, `type` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;0 爬取数据\\r 1 签约合作商\\r 2 平台自媒体人\\r &#x27;, `user_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;社交账号ID&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `wm_user_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;自媒体账号&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `idx_type_name` (`type`,`name`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 COMMENT=&#x27;APP文章作者信息表&#x27;;-- ------------------------------ Records of ap_author-- ----------------------------INSERT INTO `ap_author` VALUES (&#x27;1&#x27;, &#x27;zhangsan&#x27;, &#x27;2&#x27;, &#x27;1&#x27;, &#x27;2020-03-19 23:43:54&#x27;, null);INSERT INTO `ap_author` VALUES (&#x27;2&#x27;, &#x27;lisi&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2020-03-19 23:47:44&#x27;, null);INSERT INTO `ap_author` VALUES (&#x27;3&#x27;, &#x27;wangwu&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;2020-03-19 23:50:09&#x27;, null);INSERT INTO `ap_author` VALUES (&#x27;4&#x27;, &#x27;admin&#x27;, &#x27;2&#x27;, &#x27;4&#x27;, &#x27;2020-03-30 16:36:41&#x27;, null);-- ------------------------------ Table structure for ap_collection-- ----------------------------DROP TABLE IF EXISTS `ap_collection`;CREATE TABLE `ap_collection` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `entry_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;实体ID&#x27;, `article_id` bigint(20) unsigned DEFAULT NULL COMMENT &#x27;文章ID&#x27;, `type` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;点赞内容类型\\r 0文章\\r 1动态&#x27;, `collection_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `published_time` datetime DEFAULT NULL COMMENT &#x27;发布时间&#x27;, PRIMARY KEY (`id`) USING BTREE, KEY `idx_user_type` (`entry_id`,`article_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;APP收藏信息表&#x27;;-- ------------------------------ Records of ap_collection-- ----------------------------INSERT INTO `ap_collection` VALUES (&#x27;1&#x27;, &#x27;1&#x27;, &#x27;1303156149041758210&#x27;, &#x27;0&#x27;, &#x27;2020-04-07 23:46:47&#x27;, &#x27;2020-04-07 23:46:50&#x27;); 表的拆分垂直分表：将一个表的字段分散到多个表中，每个表存储其中一部分字段 优势： 减少IO争抢，减少锁表的几率，查看文章概述与文章详情互不影响。 充分发挥高频数据的操作效率，对文章概述数据操作的高效率不会被操作文章详情数据的低效率拖累。 拆分规则： 把不常用的字段单独放在一张表 把text，blob等大字段拆分出来单独放在一张表中 经常组合查询的字段单独放在一张表中 接口定义 加载首页 接口路径 &#x2F;api&#x2F;v1&#x2F;article&#x2F;load &#x2F;api&#x2F;v1&#x2F;article&#x2F;loadmore &#x2F;api&#x2F;v1&#x2F;article&#x2F;loadnew 请求方式 POST POST POST 参数 ArticleHomeDTO ArticleHomeDTO ArticleHomeDTO 响应结果 R R R ArticleHomeDTO@Datapublic class ArticleHomeDTO implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 最大时间 */ Date maxBehotTime; /** * 最小时间 */ Date minBehotTime; /** * 分页size */ Integer size; /** * 频道ID */ String tag;&#125; 搭建项目在leadnews-service中创建子模块leadnews-article 项目结构如下： leadnews-service├── leadnews-user├── leadnews-article│ ├── src│ │ ├── main│ │ │ ├──/java/com.swx.article│ │ │ │ ├── config│ │ │ │ ├── controller.v1│ │ │ │ ├── mapper│ │ │ │ ├── service│ │ │ │ └── ArticleApplication.java│ │ │\t└── resource│ │\t│ ├── bootstrap.yaml│ │ │ └── logback.xml│ │ └── test│ └── pom.xml└── pom.xml 创建启动类 ArticleApplication@SpringBootApplication@EnableDiscoveryClient@MapperScan(&quot;com.swx.article.mapper&quot;)public class ArticleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ArticleApplication.class, args); &#125;&#125; 配置文件添加mybatis分页插件 config.MyBatisPlusConfig@Configurationpublic class MyBatisPlusConfig &#123; /** * 分页插件配置 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 创建配置文件resources/bootstrap.yaml bootstrap.yamlserver: port: 51802spring: application: name: leadnews-article cloud: nacos: discovery: server-addr: xxx.xxx.xxx.xxx:8848 config: server-addr: xxx.xxx.xxx.xxx:8848 file-extension: yml 其他配置信息使用Nacos配置中心配置，配置完成点击发布即可 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/leadnews_article?serverTimezone=GMT%2B8&amp;useSSL=false&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: xxxxxxmybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.model.article.pojo 编写Mapper定义接口 mapper.ApArticleMapper/** * &lt;p&gt; * 文章信息表，存储已发布的文章 Mapper 接口 * &lt;/p&gt; * * @author sw-code * @since 2023-08-05 */public interface ApArticleMapper extends BaseMapper&lt;ApArticle&gt; &#123; /** * 加载文章列表 * * @param dto 查询参数 * @param type 1. 加载更多 2.加载最新 * @return 查询结果 */ public List&lt;ApArticle&gt; loadArticleList(@Param(&quot;dto&quot;) ArticleHomeDTO dto, @Param(&quot;type&quot;) Short type);&#125; 实现xml文件 ApArticleMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.article.mapper.ApArticleMapper&quot;&gt; &lt;resultMap id=&quot;resultMap&quot; type=&quot;com.swx.model.article.pojo.ApArticle&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot;/&gt; &lt;result column=&quot;author_id&quot; property=&quot;authorId&quot;/&gt; &lt;result column=&quot;author_name&quot; property=&quot;authorName&quot;/&gt; &lt;result column=&quot;channel_id&quot; property=&quot;channelId&quot;/&gt; &lt;result column=&quot;channel_name&quot; property=&quot;channelName&quot;/&gt; &lt;result column=&quot;layout&quot; property=&quot;layout&quot;/&gt; &lt;result column=&quot;flag&quot; property=&quot;flag&quot;/&gt; &lt;result column=&quot;images&quot; property=&quot;images&quot;/&gt; &lt;result column=&quot;labels&quot; property=&quot;labels&quot;/&gt; &lt;result column=&quot;likes&quot; property=&quot;likes&quot;/&gt; &lt;result column=&quot;collection&quot; property=&quot;collection&quot;/&gt; &lt;result column=&quot;comment&quot; property=&quot;comment&quot;/&gt; &lt;result column=&quot;views&quot; property=&quot;views&quot;/&gt; &lt;result column=&quot;province_id&quot; property=&quot;ProvinceId&quot;/&gt; &lt;result column=&quot;city_id&quot; property=&quot;cityId&quot;/&gt; &lt;result column=&quot;county_id&quot; property=&quot;countyId&quot;/&gt; &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot;/&gt; &lt;result column=&quot;publish_time&quot; property=&quot;publishTime&quot;/&gt; &lt;result column=&quot;sync_status&quot; property=&quot;syncStatus&quot;/&gt; &lt;result column=&quot;static_url&quot; property=&quot;staticUrl&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;loadArticleList&quot; resultMap=&quot;resultMap&quot;&gt; SELECT aa.* FROM `ap_article` aa LEFT JOIN leadnews_article.ap_article_config aac on aa.id = aac.article_id &lt;where&gt; and aac.is_delete != -1 and aac.is_down != -1 # loadmore &lt;if test=&quot;type != null and type == 1&quot;&gt; and aa.publish_time &lt;![CDATA[&lt;]]&gt; #&#123;dto.minBehotTime&#125; &lt;/if&gt; # loadnew &lt;if test=&quot;type != null and type == 2&quot;&gt; and aa.publish_time &lt;![CDATA[&gt;]]&gt; #&#123;dto.maxBehotTime&#125; &lt;/if&gt; &lt;if test=&quot;dto.tag != &#x27;__all__&#x27;&quot;&gt; and aa.channel_id &lt;![CDATA[&gt;]]&gt; #&#123;dto.tag&#125; &lt;/if&gt; &lt;/where&gt; ORDER BY aa.publish_time desc LIMIT #&#123;dto.size&#125; &lt;/select&gt;&lt;/mapper&gt; 编写Service定义接口 ApArticleService/** * &lt;p&gt; * 文章信息表，存储已发布的文章 服务类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-05 */public interface ApArticleService extends IService&lt;ApArticle&gt; &#123; /** * 加载文章列表 * @param dto 参数 * @param type 1加载跟多 2加载最新 */ public List&lt;ApArticle&gt; load(ArticleHomeDTO dto, Short type);&#125; 实现接口方法 ApArticleServiceImpl/** * &lt;p&gt; * 文章信息表，存储已发布的文章 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-05 */@Service@Slf4jpublic class ApArticleServiceImpl extends ServiceImpl&lt;ApArticleMapper, ApArticle&gt; implements ApArticleService &#123; private final ApArticleMapper articleMapper; public ApArticleServiceImpl(ApArticleMapper articleMapper) &#123; this.articleMapper = articleMapper; &#125; /** * 加载文章列表 * * @param dto 参数 * @param type 1加载跟多 2加载最新 */ @Override public List&lt;ApArticle&gt; load(ArticleHomeDTO dto, Short type) &#123; // 校验参数 Integer size = dto.getSize(); if (size == null || size == 0) &#123; size = ArticleConstants.DEFAULT_PAGE_SIZE; &#125; // 分页值不超过50 dto.setSize(Math.min(size, ArticleConstants.MAX_PAGE_SIZE)); if (type == null) &#123; type = ArticleConstants.LOAD_TYPE_LOAD_MORE; &#125; else if (!type.equals(ArticleConstants.LOAD_TYPE_LOAD_MORE) &amp;&amp; !type.equals(ArticleConstants.LOAD_TYPE_LOAD_NEW)) &#123; type = ArticleConstants.LOAD_TYPE_LOAD_MORE; &#125; if (!StringUtils.hasText(dto.getTag())) &#123; dto.setTag(ArticleConstants.DEFAULT_TAG); &#125; if (dto.getMaxBehotTime() == null) dto.setMaxBehotTime(new Date()); if (dto.getMinBehotTime() == null) dto.setMinBehotTime(new Date()); // 返回查询结果 return articleMapper.loadArticleList(dto, type); &#125;&#125; 编写Controllerpackage com.swx.article.controller.v1;/** * &lt;p&gt; * 文章信息表，存储已发布的文章 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-05 */@RestController@ResponseResult@RequestMapping(&quot;/api/v1/article&quot;)public class ArticleHomeController &#123; private final ApArticleService apArticleService; public ArticleHomeController(ApArticleService apArticleService) &#123; this.apArticleService = apArticleService; &#125; /** * 加载首页 * @param dto 查询参数 */ @PostMapping(&quot;/load&quot;) public List&lt;ApArticle&gt; load(@RequestBody ArticleHomeDTO dto) &#123; return apArticleService.load(dto, ArticleConstants.LOAD_TYPE_LOAD_MORE); &#125; /** * 加载更多 * @param dto 查询参数 */ @PostMapping(&quot;/loadmore&quot;) public List&lt;ApArticle&gt; loadMore(@RequestBody ArticleHomeDTO dto) &#123; return apArticleService.load(dto, ArticleConstants.LOAD_TYPE_LOAD_MORE); &#125; /** * 加载最新 * @param dto 查询参数 */ @PostMapping(&quot;/loadnew&quot;) public List&lt;ApArticle&gt; loadNew(@RequestBody ArticleHomeDTO dto) &#123; return apArticleService.load(dto, ArticleConstants.LOAD_TYPE_LOAD_NEW); &#125;&#125; 配置网关在Nacos控制台配置列表中找到leadnews-app-gateway配置，添加如下内容： routes: - id: article uri: lb://leadnews-article predicates: - Path=/article/** filters: - StripPrefix= 1 访问网关时应该带上artcile http://article/api/v1/..."},{"title":"登陆功能","path":"/wiki/leadnews/03_project/app_login.html","content":"数据库关于app端用户相关的内容较多，可以单独设置一个库leadnews_user 表名称 说明 ap_user APP用户信息表 ap_user_fan APP用户粉丝信息表 ap_user_follow APP用户关注信息表 ap_user_realname APP实名认证信息表 下载数据库文件： leadnews_user.sqlhttps://wwab.lanzoue.com/i0yBJ14kii7e 数据库创建命令 leadnews_user.sqlCREATE DATABASE IF NOT EXISTS leadnews_user DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;USE leadnews_user;SET NAMES utf8;/*Navicat MySQL Data TransferSource Server : localhostSource Server Version : 50721Source Host : localhost:3306Source Database : leadnews_userTarget Server Type : MYSQLTarget Server Version : 50721File Encoding : 65001Date: 2021-04-12 13:58:42*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for ap_user-- ----------------------------DROP TABLE IF EXISTS `ap_user`;CREATE TABLE `ap_user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `salt` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;密码、通信等加密盐&#x27;, `name` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;用户名&#x27;, `password` varchar(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;密码,md5加密&#x27;, `phone` varchar(11) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;手机号&#x27;, `image` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;头像&#x27;, `gender` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;0 男\\r 1 女\\r 2 未知&#x27;, `is_certification` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;0 未\\r 1 是&#x27;, `is_identity_authentication` tinyint(1) DEFAULT NULL COMMENT &#x27;是否身份认证&#x27;, `status` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;0正常\\r 1锁定&#x27;, `flag` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;0 普通用户\\r 1 自媒体人\\r 2 大V&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;注册时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;APP用户信息表&#x27;;-- ------------------------------ Records of ap_user-- ----------------------------INSERT INTO `ap_user` VALUES (&#x27;1&#x27;, &#x27;abc&#x27;, &#x27;zhangsan&#x27;, &#x27;abc&#x27;, &#x27;13511223453&#x27;, null, &#x27;1&#x27;, null, null, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2020-03-19 23:22:07&#x27;);INSERT INTO `ap_user` VALUES (&#x27;2&#x27;, &#x27;abc&#x27;, &#x27;lisi&#x27;, &#x27;abc&#x27;, &#x27;13511223454&#x27;, &#x27;&#x27;, &#x27;1&#x27;, null, null, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2020-03-19 23:22:07&#x27;);INSERT INTO `ap_user` VALUES (&#x27;3&#x27;, &#x27;sdsa&#x27;, &#x27;wangwu&#x27;, &#x27;wangwu&#x27;, &#x27;13511223455&#x27;, null, null, null, null, null, &#x27;1&#x27;, null);INSERT INTO `ap_user` VALUES (&#x27;4&#x27;, &#x27;123abc&#x27;, &#x27;admin&#x27;, &#x27;81e158e10201b6d7aee6e35eaf744796&#x27;, &#x27;13511223456&#x27;, null, &#x27;1&#x27;, null, null, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2020-03-30 16:36:32&#x27;);INSERT INTO `ap_user` VALUES (&#x27;5&#x27;, &#x27;123&#x27;, &#x27;suwukong&#x27;, &#x27;suwukong&#x27;, &#x27;13511223458&#x27;, null, &#x27;1&#x27;, null, null, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2020-08-01 11:09:57&#x27;);INSERT INTO `ap_user` VALUES (&#x27;6&#x27;, null, null, null, null, null, null, null, null, null, null, null);-- ------------------------------ Table structure for ap_user_fan-- ----------------------------DROP TABLE IF EXISTS `ap_user_fan`;CREATE TABLE `ap_user_fan` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;用户ID&#x27;, `fans_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;粉丝ID&#x27;, `fans_name` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;粉丝昵称&#x27;, `level` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;粉丝忠实度\\r 0 正常\\r 1 潜力股\\r 2 勇士\\r 3 铁杆\\r 4 老铁&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `is_display` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;是否可见我动态&#x27;, `is_shield_letter` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;是否屏蔽私信&#x27;, `is_shield_comment` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;是否屏蔽评论&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;APP用户粉丝信息表&#x27;;-- ------------------------------ Records of ap_user_fan-- ------------------------------ ------------------------------ Table structure for ap_user_follow-- ----------------------------DROP TABLE IF EXISTS `ap_user_follow`;CREATE TABLE `ap_user_follow` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;用户ID&#x27;, `follow_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;关注作者ID&#x27;, `follow_name` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;粉丝昵称&#x27;, `level` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;关注度\\r 0 偶尔感兴趣\\r 1 一般\\r 2 经常\\r 3 高度&#x27;, `is_notice` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;是否动态通知&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;APP用户关注信息表&#x27;;-- ------------------------------ Records of ap_user_follow-- ------------------------------ ------------------------------ Table structure for ap_user_realname-- ----------------------------DROP TABLE IF EXISTS `ap_user_realname`;CREATE TABLE `ap_user_realname` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;账号ID&#x27;, `name` varchar(20) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT &#x27;用户名称&#x27;, `idno` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;资源名称&#x27;, `font_image` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;正面照片&#x27;, `back_image` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;背面照片&#x27;, `hold_image` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;手持照片&#x27;, `live_image` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;活体照片&#x27;, `status` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;状态\\r 0 创建中\\r 1 待审核\\r 2 审核失败\\r 9 审核通过&#x27;, `reason` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;拒绝原因&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `submited_time` datetime DEFAULT NULL COMMENT &#x27;提交时间&#x27;, `updated_time` datetime DEFAULT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;APP实名认证信息表&#x27;;-- ------------------------------ Records of ap_user_realname-- ----------------------------INSERT INTO `ap_user_realname` VALUES (&#x27;1&#x27;, &#x27;1&#x27;, &#x27;zhangsan&#x27;, &#x27;512335455602781278&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbHSAQlqFAAXIZNzAq9E126.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbF6AR16RAAZB2e1EsOg460.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbDeAH2qoAAbD_WiUJfk745.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9ba9qANVEdAAS25KJlEVE291.jpg&#x27;, &#x27;9&#x27;, &#x27;&#x27;, &#x27;2019-07-30 14:34:28&#x27;, &#x27;2019-07-30 14:34:30&#x27;, &#x27;2019-07-12 06:48:04&#x27;);INSERT INTO `ap_user_realname` VALUES (&#x27;2&#x27;, &#x27;2&#x27;, &#x27;lisi&#x27;, &#x27;512335455602781279&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbHSAQlqFAAXIZNzAq9E126.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbF6AR16RAAZB2e1EsOg460.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbDeAH2qoAAbD_WiUJfk745.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9ba9qANVEdAAS25KJlEVE291.jpg&#x27;, &#x27;1&#x27;, &#x27;&#x27;, &#x27;2019-07-11 17:21:18&#x27;, &#x27;2019-07-11 17:21:20&#x27;, &#x27;2019-07-12 06:48:04&#x27;);INSERT INTO `ap_user_realname` VALUES (&#x27;3&#x27;, &#x27;3&#x27;, &#x27;wangwu6666&#x27;, &#x27;512335455602781276&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbHSAQlqFAAXIZNzAq9E126.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbF6AR16RAAZB2e1EsOg460.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbDeAH2qoAAbD_WiUJfk745.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9ba9qANVEdAAS25KJlEVE291.jpg&#x27;, &#x27;9&#x27;, &#x27;&#x27;, &#x27;2019-07-11 17:21:18&#x27;, &#x27;2019-07-11 17:21:20&#x27;, &#x27;2019-07-12 06:48:04&#x27;);INSERT INTO `ap_user_realname` VALUES (&#x27;5&#x27;, &#x27;5&#x27;, &#x27;suwukong&#x27;, &#x27;512335455602781279&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbHSAQlqFAAXIZNzAq9E126.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbF6AR16RAAZB2e1EsOg460.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9bbDeAH2qoAAbD_WiUJfk745.jpg&#x27;, &#x27;http://161.189.111.227/group1/M00/00/00/rBFwgF9ba9qANVEdAAS25KJlEVE291.jpg&#x27;, &#x27;1&#x27;, &#x27;&#x27;, &#x27;2020-08-01 11:10:31&#x27;, &#x27;2020-08-01 11:10:34&#x27;, &#x27;2020-08-01 11:10:36&#x27;); 搭建项目删除leadnews-service中的src文件，创建子模块leadnews-user 项目结构如下： leadnews-service├── leadnews-user│ ├── src│ │ ├── main│ │ │ ├──/java/com.swx.user│ │ │ │ ├── config│ │ │ │ ├── controller.v1│ │ │ │ ├── mapper│ │ │ │ ├── service│ │ │ │ └── UserApplication.java│ │ │\t└── resource│ │\t│ ├── bootstrap.yaml│ │ │ └── logback.xml│ │ └── test│ └── pom.xml└── pom.xml 添加依赖在父工程的pom文件中添加如下依赖 pom.xml&lt;properties&gt; &lt;leadnew-feign-api.version&gt;0.0.1-SNAPSHOT&lt;/leadnew-feign-api.version&gt; &lt;spring.alibaba.version&gt;2.2.5.RELEASE&lt;/spring.alibaba.version&gt; &lt;mybatis-plus.version&gt;3.4.1&lt;/mybatis-plus.version&gt; &lt;mysql-version&gt;8.0.30&lt;/mysql-version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt;\t&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-feign-api&lt;/artifactId&gt; &lt;version&gt;$&#123;leadnew-feign-api.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在leadnews-model模块中添加如下依赖： pom.xml&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 在leadnews-service模块中添加如下依赖： pom.xml&lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-common&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-model&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-feign-api&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 完善项目在leadnews-service模块的子模块leadnews-user中创建包com.swx.user 创建启动类 UserApplication@SpringBootApplication@EnableDiscoveryClient@MapperScan(&quot;com.swx.user.mapper&quot;)public class UserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserApplication.class, args); &#125;&#125; 配置文件创建配置文件resources/bootstrap.yaml bootstrap.yamlserver: port: 51801spring: application: name: leadnews-user cloud: nacos: discovery: server-addr: xxx.xxx.xxx.xxx:8848 config: server-addr: xxx.xxx.xxx.xxx:8848 file-extension: yml 其他配置信息使用Nacos配置中心配置，配置完成点击发布即可 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/leadnews_user?serverTimezone=GMT%2B8&amp;useSSL=false&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: xxxxxxmybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.model.user.pojo 配置输入日志，在resources下创建logback.xml logback.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration&gt; &lt;!-- 定义日志文件的存储地址，使用绝对路径 --&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;/Users/swcode/Documents/IdeaProjects/server-log&quot; /&gt; &lt;!-- 控制台输出设置 --&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;endcoder&gt; &lt;!-- 格式化输出：%d表示日期。 %thread表示线程名，%-5level：表示级别从左显示5个字符，%msg：消息日志，%n：换行符 --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;utf8&lt;/charset&gt; &lt;/endcoder&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志 --&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 日志输出的文件名 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/leadnews.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;endcoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/endcoder&gt; &lt;/appender&gt; &lt;!-- 异步输出 --&gt; &lt;appender name=&quot;ASYNC&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt; &lt;!-- 不丢失日志，默认的，如果队列的80%已满，则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度，该值会影响性能，默认值为256 --&gt; &lt;queueSize&gt;512&lt;/queueSize&gt; &lt;!-- 添加附加的appender，最多只能添加一个 --&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/appender&gt; &lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.springframework.boot&quot; level=&quot;DEBUG&quot; /&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; 接口定义 说明 接口路径 &#x2F;api&#x2F;v1&#x2F;login&#x2F;login_auth 请求方式 POST 参数 LoginDto 响应结果 R &#123; &quot;host&quot;: null, &quot;code&quot;: 200, &quot;message&quot;: &quot;操作成功&quot;, &quot;data&quot;: &#123; &quot;user&quot;: &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;admin&quot;, &quot;phone&quot;: &quot;13511223456&quot; &#125;, &quot;token&quot;: &quot;....&quot; &#125;&#125; 创建实体类在leadnews-model模块下创建com.swx.model.user包 在user.pojo包下创建ApUser mojo.ApUser/** * &lt;p&gt; * APP用户信息表 * &lt;/&gt; * * @author swcode */@Data@TableName(&quot;ap_user&quot;)public class ApUser implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 主键 */ @TableId(value = &quot;id&quot;, type = IdType.AUTO) private Integer id; /** * 密码、通信加密盐 */ @TableField(&quot;salt&quot;) private String salt; /** * 用户名 */ @TableField(&quot;name&quot;) private String name; /** * 密码，md5加密 */ @TableField(&quot;password&quot;) private String password; /** * 手机号 */ @TableField(&quot;phone&quot;) private String phone; /** * 头像 */ @TableField(&quot;image&quot;) private String image; /** * 性别 0 男 1 女 2 未知 */ @TableField(&quot;gender&quot;) private Integer gender; /** * 是否认证 0 未 1 是 */ @TableField(&quot;is_certification&quot;) private Integer isCertification; /** * 是否身份认证 */ @TableField(&quot;is_identity_authentication&quot;) private Integer isIdentityAuthentication; /** * 账号状态 0正常 1锁定 */ @TableField(&quot;status&quot;) private Integer status; /** * 用户标识 0 普通用户 1 自媒体人 2 大V */ @TableField(&quot;flag&quot;) private Integer flag; /** * 注册时间 */ @TableField(&quot;created_time&quot;) private Date createdTime;&#125; 在user.dto包下创建LoginDTO user.dto.LoginDTO@Datapublic class LoginDTO implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 手机号 */ private String phone; /** * 密码 */ private String password; public LoginDTO() &#123; &#125; public LoginDTO(String phone, String password) &#123; this.phone = phone; this.password = password; &#125;&#125; 在user.vo包下创建ApUserVo vo.ApUserVo@Datapublic class ApUserVo &#123; private Integer id; private String name; private String phone; private String image;&#125; 创建Mapper创建com.swx.user.mapper包，在该包下创建ApUserMapper ApUserMapper@Mapperpublic interface ApUserMapper extends BaseMapper&lt;ApUser&gt; &#123; &#125; 创建Service创建com.swx.user.service包，在该包下创建ApUserService ApUserServicepublic interface ApUserService extends IService&lt;ApUser&gt; &#123; /** * APP端登陆功能 * @param loginDTO 登陆信息 * @return 用户信息 */ public Map&lt;String, Object&gt; login(LoginDTO loginDTO);&#125; 创建com.swx.user.service.impl包，在该包下创建ApUserServiceImpl ApUserServiceImpl@Servicepublic class ApUserServiceImpl extends ServiceImpl&lt;ApUserMapper, ApUser&gt; implements ApUserService &#123; @Override public Map&lt;String, Object&gt; login(LoginDTO loginDTO) &#123; if (StringUtils.isBlank(loginDTO.getPhone()) &amp;&amp; StringUtils.isBlank(loginDTO.getPassword())) &#123; // 1. 正常登陆，用户名密码 // 1.1 根据手机号查询用户信息 ApUser dbUser = getOne(Wrappers.&lt;ApUser&gt;lambdaQuery().eq(ApUser::getPhone, loginDTO.getPhone())); if (dbUser == null) &#123; throw new BizException(ResultCodeEnum.DATA_NOT_EXIST.code(), &quot;用户信息不存在&quot;); &#125; // 1.2 比对密码 String salt = dbUser.getSalt(); String password = loginDTO.getPassword(); String saltPwd = DigestUtils.md5DigestAsHex((password + salt).getBytes()); if (!saltPwd.equals(dbUser.getPassword())) &#123; throw new BizException(ResultCodeEnum.LOGIN_PWD_ERROR); &#125; // 1.3 返回数据 token ApUserVo userVo = new ApUserVo(); BeanUtils.copyProperties(dbUser, userVo); HashMap&lt;String, Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;token&quot;, &quot;&quot;); data.put(&quot;user&quot;, userVo); return data; &#125; else &#123; HashMap&lt;String, Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;token&quot;, &quot;&quot;); return data; &#125; &#125;&#125; 创建Controller创建com.swx.user.controller包，在该包下创建ApUserLoginController ApUserLoginController@ResponseResult@RestController@RequestMapping(&quot;/api/v1/login&quot;)public class ApUserLoginController &#123; private final ApUserService apUserService; public ApUserLoginController(ApUserService apUserService) &#123; this.apUserService = apUserService; &#125; @PostMapping(&quot;/login_auth&quot;) public Map&lt;String, Object&gt; login(@RequestBody LoginDTO loginDTO) &#123; return apUserService.login(loginDTO); &#125; &#125;"},{"title":"集成前端项目","path":"/wiki/leadnews/03_project/app_project.html","content":"下载前端项目项目下载地址： app_web.ziphttp://test.com 解压后放到nginx目录下的html文件 nginx├── html│ ├── app-web│ ├── 50x.html│ └── index.html 使用Nginx 配置Nginx文件 在nginx安装的conf目录下心间文件夹leadnews.conf，并创建headnews-app.conf文件，内容如下： Mac的Nginx配置文件路径：/usr/local/etc/nginx/nginx.conf upstream leadnews-app-gateway &#123; server localhost:51601;&#125;server &#123; listen 8801; location / &#123; root html/app-web/; index index.html; &#125; location ~/app/(.*) &#123; proxy_pass http://leadnews-app-gateway/$1; proxy_set_header HOST $host; # 不改变源请求头的值 proxy_pass_request_body\ton; # 开启获取请求体 proxy_pass_request_headers\ton;\t# 开启获取请求头 proxy_set_header X-Real-IP $remote_addr; # 记录真实发出请求的客户端IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 记录代理信息 &#125;&#125; 在nginx.conf中引入leadnews-app.conf worker_processes 1; events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 引入自定义配置文件 include leadnews.conf/*.conf;&#125; 启动项目进入bin目录，使用下面命令启动 ./nginx 重启命令 ./nginx -s reload Mac命令：brew services stop nginx 访问项目访问链接：http://localhost:8801/ 可以测试登陆网关和服务是否正常。"},{"title":"APP端文章搜索","path":"/wiki/leadnews/03_project/app_search.html","content":"ElasticSearch拉取ElasticSearch镜像 docker pull elasticsearch:7.4.0 创建ElasticSearch容器 docker run -id --name elasticsearch \\-p 9200:9200 -p 9300:9300 \\-v /usr/share/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\-e &quot;discovery.type=single-node&quot; elasticsearch:7.4.0 配置中文分词器 ik 下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases 上传到服务器的/usr/share/elasticsearch/plugins，解压到新建目录analysis-ik 创建索引和映射&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;publishTime&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;, &quot;layout&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;images&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;staticUrl&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;authorId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;authorName&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot; &#125; &#125; &#125;&#125; 初始化索引库查询文章信息，批量导入到ES索引库中 实现搜索接口新增文章索引文章搜索记录用户的搜索记录，需要给每一个用户都保存一份，数据量较大，要求加载速度快，通常这样的数据存在MongoDB更合适，不建议直接存储到关系型数据库中 MongoDB拉取镜像 docker pull mongo 创建容器 docker run -di --name mongo-service \\\t--restart=always -p 27017:27017 \\\t-v ~/data/mongodata:/data mongo 集成MongoDB依赖： pom.xml&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 配置 spring: data: mongodb: host: xxxx.xxxx.xxxx port: 27017 database: leadnews-hostory 映射 @Document(&quot;ap_associate_words&quot;)public class ApAssociateWords implements Serializable &#123; private static final long serialVersionUID = 1L; private String id; private String associateWords; private Date createTime;&#125; 保存搜索记录查询搜索记录删除搜索记录关键字联想词通常是网上搜索频率较高的一些词，通常在企业中有两部分来源： 第一：自己维护搜索词，通过分析用户搜索频率较高的词，按照排名作为搜索词 第二：第三方获取，关键词规划师（百度）、5118、爱站网"},{"title":"认证过滤器","path":"/wiki/leadnews/03_project/auth_filter.html","content":"认证过程在Gateway网关层面实现。在网关中添加过滤器，获取携带的Token信息，验证该Token是否合法；Token合法则放行，否则拦截。如果系统需要获取Token中的信息（例如userId等），可以将其放在Http中。 全局过滤器实现jwt校验 在com.swx.app.gateway模块下创建包com.swx.app.gateway.filter 创建过滤器类 AuthorizeFilter@Componentpublic class AuthorizeFilter implements Ordered, GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 1. 获取Request和Response对象 ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); // 2. 判断是否是登陆 if (request.getURI().getPath().contains(&quot;/login&quot;)) &#123; return chain.filter(exchange); &#125; // 3. 获取Token String token = request.getHeaders().getFirst(&quot;token&quot;); // 4. 判断Token是否存在 if (!StringUtils.hasText(token)) &#123; response.setStatusCode(HttpStatus.UNAUTHORIZED); return response.setComplete(); &#125; // 5. 判断Token是否有效 Claims claimsBody = AppJwtUtil.getClaimsBody(token); int result = AppJwtUtil.verifyToken(claimsBody); if (result == 1 || result == 2) &#123; response.setStatusCode(HttpStatus.UNAUTHORIZED); return response.setComplete(); &#125; // 6. 放行 return chain.filter(exchange); &#125; /** * 优先级设置，值越小，优先级越高 * @return */ @Override public int getOrder() &#123; return 0; &#125;&#125; 工具类 utils.AppJwtUtilpublic class AppJwtUtil &#123; // TOKEN的有效期一天（S） private static final int TOKEN_TIME_OUT = 3_600; // 加密KEY private static final String TOKEN_ENCRY_KEY = &quot;Nvz9Vywt6NuTM7l07RoWvN86M84frPcZuj83SHwpM3S6k2GdPq4QQOjS1IZHIjWt&quot;; // 最小刷新间隔(S) private static final int REFRESH_TIME = 300; // 生产ID public static String getToken(Long id) &#123; Map&lt;String, Object&gt; claimMaps = new HashMap&lt;&gt;(); claimMaps.put(&quot;id&quot;, id); long currentTime = System.currentTimeMillis(); return Jwts.builder() .setId(UUID.randomUUID().toString()) .setIssuedAt(new Date(currentTime)) //签发时间 .setSubject(&quot;system&quot;) //说明 .setIssuer(&quot;heima&quot;) //签发者信息 .setAudience(&quot;app&quot;) //接收用户 .compressWith(CompressionCodecs.GZIP) //数据压缩方式 .signWith(generalKey(), SignatureAlgorithm.HS512) //加密方式 .setExpiration(new Date(currentTime + TOKEN_TIME_OUT * 1000)) //过期时间戳 .addClaims(claimMaps) //cla信息 .compact(); &#125; /** * 获取token中的claims信息 * * @param token * @return */ private static Jws&lt;Claims&gt; getJws(String token) &#123; return Jwts.parser() .setSigningKey(generalKey()) .parseClaimsJws(token); &#125; /** * 获取payload body信息 * * @param token * @return */ public static Claims getClaimsBody(String token) &#123; try &#123; return getJws(token).getBody(); &#125; catch (ExpiredJwtException e) &#123; return null; &#125; &#125; /** * 获取hearder body信息 * * @param token * @return */ public static JwsHeader getHeaderBody(String token) &#123; return getJws(token).getHeader(); &#125; /** * 是否过期 * * @param claims * @return -1：有效，0：有效，1：过期，2：过期 */ public static int verifyToken(Claims claims) &#123; if (claims == null) &#123; return 1; &#125; try &#123; claims.getExpiration() .before(new Date()); // 需要自动刷新TOKEN if ((claims.getExpiration().getTime() - System.currentTimeMillis()) &gt; REFRESH_TIME * 1000) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; catch (ExpiredJwtException ex) &#123; return 1; &#125; catch (Exception e) &#123; return 2; &#125; &#125; /** * 由字符串生成加密key * * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getEncoder().encode(TOKEN_ENCRY_KEY.getBytes()); return Keys.hmacShaKeyFor(encodedKey); &#125;&#125;"},{"title":"代码生成器","path":"/wiki/leadnews/03_project/code_generator.html","content":"代码生成器在每个service子模块的test中都可以创建一个，记得更改包和数据库配置。 使用Mybatis-Plus的代码生成器需要添加如下依赖，放在所有service的父模块 pom.xml&lt;!-- 代码生成器 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 工具类 注意包生成的路径和包名即可 public class CodeGenerate &#123; public static void OnMac() &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setAuthor(&quot;sw-code&quot;); gc.setOpen(false); // 是否打开文件资源管理器 gc.setFileOverride(true); // 是否覆盖 gc.setServiceName(&quot;%sService&quot;); // 去Service的I前缀 gc.setSwagger2(false); // 实体属性 Swagger2 注解 gc.setIdType(IdType.AUTO); // 主键策略 gc.setDateType(DateType.ONLY_DATE); // 定义生成的实体类中日期类型 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql:///leadnews_schedule?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;nullCatalogMeansCurrent=true&quot;); // dsc.setSchemaName(&quot;public&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;swx852345&quot;); mpg.setDataSource(dsc); /* * 包配置 * 简单来讲 就是写绝对路径 */ PackageConfig pc = new PackageConfig(); // pc.setModuleName(&quot;code&quot;); pc.setParent(&quot;com.swx&quot;); //指定生成文件的绝对路径 Map&lt;String, String&gt; pathInfo = new HashMap&lt;&gt;(); String packageName = &quot;schedule&quot;; String currentModulePath = &quot;/leadnews-service/leadnews-schedule&quot;; String parentPath = &quot;/src/main/java/com/swx&quot;; String otherPath = currentModulePath + &quot;/src/main/java/com/swx/&quot; + packageName; String entityPackageName = &quot;schedule&quot;; pc.setEntity(&quot;model.&quot; + entityPackageName + &quot;.pojo&quot;); pc.setMapper(packageName + &quot;.mapper&quot;); pc.setService(packageName + &quot;.service&quot;); pc.setServiceImpl(packageName + &quot;.service.impl&quot;); pc.setController(packageName + &quot;.controller.v1&quot;); String entityPath = projectPath.concat(&quot;/leadnews-model&quot;).concat(parentPath).concat(&quot;/model/&quot; + entityPackageName + &quot;/pojo&quot;); String mapper_path = projectPath.concat(otherPath).concat(&quot;/mapper&quot;); String mapper_xml_path = projectPath.concat(currentModulePath).concat(&quot;/src/main/resources/mapper&quot;); String service_path = projectPath.concat(otherPath).concat(&quot;/service&quot;); String service_impl_path = projectPath.concat(otherPath).concat(&quot;/service/impl&quot;); String controller_path = projectPath.concat(otherPath).concat(&quot;/controller/v1&quot;); pathInfo.put(&quot;entity_path&quot;,entityPath); pathInfo.put(&quot;mapper_path&quot;,mapper_path); pathInfo.put(&quot;xml_path&quot;,mapper_xml_path); pathInfo.put(&quot;service_path&quot;,service_path); pathInfo.put(&quot;service_impl_path&quot;,service_impl_path); pathInfo.put(&quot;controller_path&quot;,controller_path); pc.setPathInfo(pathInfo); mpg.setPackageInfo(pc); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;taskinfo&quot;, &quot;taskinfo_logs&quot;); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 字段注解 strategy.setEntityTableFieldAnnotationEnable(true); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); mpg.execute(); &#125; public static void main(String[] args) &#123; OnMac(); &#125;&#125;"},{"title":"延迟队列服务","path":"/wiki/leadnews/03_project/delay_task.html","content":"延迟任务 什么是延迟任务定时任务：有固定周期的，有明确的触发时间 延迟任务：没有固定的开始时间，它常常是由一个事件触发的，而在这个事件触发之后的一段时间内触发另一个事件，任务可以立即执行，也可以延迟 场景一：订单下单之后30分钟后，如果用户没有付钱，则系统自动取消订单；如果期间下单成功，任务取消 场景二：接口对接出现网络问题，1分钟后重试，如果失败，2分钟重试，直到出现阈值终止 技术对比DelayQueue JDK自带DelayQueue 是一个支持延时获取元素的阻塞队列， 内部采用优先队列 PriorityQueue 存储元素，同时元素必须实现 Delayed 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素 使用DelayQueue作为延迟任务，如果程序挂掉之后，任务都是放在内存，消息会丢失，如何保证数据不丢失 RabbitMQ实现延迟任务 TTL：Time To Live (消息存活时间) 死信队列：Dead Letter Exchange(死信交换机)，当消息成为Dead message后，可以重新发送另一个交换机（死信交换机） redis实现 zset数据类型的去重有序（分数排序）特点进行延迟。例如：时间戳(毫秒值)作为score进行排序 例如： 生产者添加到4个任务到延迟队列中，时间毫秒值分别为97、98、99、100。当前时间的毫秒值为90，消费者端进行监听，如果当前时间的毫秒值匹配到了延迟队列中的毫秒值就立即消费。 创建服务首先创建leadnews-schedule模块，在模块中创建com.swx.schedule包 创建启动类 ScheduleApplication@SpringBootApplicationpublic class ScheduleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ScheduleApplication.class, args); &#125;&#125; 配置文件 bootstrap.yamlserver: port: 51701spring: application: name: leadnews-schedule cloud: nacos: discovery: server-addr: xxx.xxx.xxx.xxx:8848 config: server-addr: xxx.xxx.xxx.xxx:8848 file-extension: yml 在Nacos配置中心添加如下配置：http://ip:8848/nacos spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/leadnews_schedule?serverTimezone=GMT%2B8&amp;useSSL=false&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: xxxxxxxxmybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.model.schedule.pojo 代码生成使用代码生成器生成基础代码： CodeGeneratepublic class CodeGenerate &#123; public static void OnMac() &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setAuthor(&quot;sw-code&quot;); gc.setOpen(false); // 是否打开文件资源管理器 gc.setFileOverride(true); // 是否覆盖 gc.setServiceName(&quot;%sService&quot;); // 去Service的I前缀 gc.setSwagger2(false); // 实体属性 Swagger2 注解 gc.setIdType(IdType.ASSIGN_ID); // 主键策略 gc.setDateType(DateType.ONLY_DATE); // 定义生成的实体类中日期类型 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql:///leadnews_schedule?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;nullCatalogMeansCurrent=true&quot;); // dsc.setSchemaName(&quot;public&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;swx852345&quot;); mpg.setDataSource(dsc); /* * 包配置 * 简单来讲 就是写绝对路径 */ PackageConfig pc = new PackageConfig(); // pc.setModuleName(&quot;code&quot;); pc.setParent(&quot;com.swx&quot;); //指定生成文件的绝对路径 Map&lt;String, String&gt; pathInfo = new HashMap&lt;&gt;(); String packageName = &quot;schedule&quot;; String parentPath = &quot;/src/main/java/com/swx&quot;; String otherPath =&quot;/leadnews-service/leadnews-schedule/src/main/java/com/swx/&quot; + packageName; String entityPackageName = &quot;schedule&quot;; pc.setEntity(&quot;model.&quot; + entityPackageName + &quot;.pojo&quot;); pc.setMapper(packageName + &quot;.mapper&quot;); pc.setService(packageName + &quot;.service&quot;); pc.setServiceImpl(packageName + &quot;.service.impl&quot;); pc.setController(packageName + &quot;.controller.v1&quot;); String entityPath = projectPath.concat(&quot;/leadnews-model&quot;).concat(parentPath).concat(&quot;/model/&quot; + entityPackageName + &quot;/pojo&quot;); String mapper_path = projectPath.concat(otherPath).concat(&quot;/mapper&quot;); String mapper_xml_path = projectPath.concat(&quot;/leadnews-service/leadnews-schedule&quot;).concat(&quot;/src/main/resources/mapper&quot;); String service_path = projectPath.concat(otherPath).concat(&quot;/service&quot;); String service_impl_path = projectPath.concat(otherPath).concat(&quot;/service/impl&quot;); String controller_path = projectPath.concat(otherPath).concat(&quot;/controller/v1&quot;); pathInfo.put(&quot;entity_path&quot;,entityPath); pathInfo.put(&quot;mapper_path&quot;,mapper_path); pathInfo.put(&quot;xml_path&quot;,mapper_xml_path); pathInfo.put(&quot;service_path&quot;,service_path); pathInfo.put(&quot;service_impl_path&quot;,service_impl_path); pathInfo.put(&quot;controller_path&quot;,controller_path); pc.setPathInfo(pathInfo); mpg.setPackageInfo(pc); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;taskinfo&quot;, &quot;taskinfo_logs&quot;); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 字段注解 strategy.setEntityTableFieldAnnotationEnable(true); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); mpg.execute(); &#125; public static void main(String[] args) &#123; OnMac(); &#125;&#125; 生成之后，可以把Service全部删掉，用不到 Blob数据注意修改数据库BLOB类似数据对应的java类型 /** * 参数 */@TableField(&quot;parameters&quot;)private byte[] parameters; 乐观锁添加TaskinfoLogs实体类的乐观锁注解 @Data@EqualsAndHashCode(callSuper = false)@TableName(&quot;taskinfo_logs&quot;)public class TaskinfoLogs implements Serializable &#123; ....; /** * 版本号,用乐观锁 */ @Version @TableField(&quot;version&quot;) private Integer version; ....;&#125; 添加配置文件 config.MyBatisPlusConfig@Configuration@MapperScan(&quot;com.swx.schedule.mapper&quot;)public class MyBatisPlusConfig &#123; /** * 乐观所支持 */ @Bean public MybatisPlusInterceptor optimisticLockerInnerInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor; &#125;&#125; Redis实现延迟任务实现思路 安装Redis使用Docker安装redis docker pull redis 创建容器 docker run -d --name redis --restart=always -p 6379:6379 redis --requirepass &quot;leadnews&quot; 集成Redis引入Redis相关依赖 pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--redis依赖commons-pool这个依赖一定要添加 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在Nacos中添加配置信息 spring: redis: host: xxx.xxx.xxx.xxx password: leadnews port: 6379 枚举常量任务状态枚举类 TaskLogStatuspublic enum TaskLogStatus &#123; SCHEDULED(0, &quot;初始化状态&quot;), EXECUTED(1, &quot;已执行状态&quot;), CANCELLED(2, &quot;已取消状态&quot;); private int status; private String desc; TaskLogStatus(int status, String desc) &#123; this.status = status; this.desc = desc; &#125; public int status() &#123; return status; &#125; public String desc() &#123; return desc; &#125;&#125; 常量类 ScheduleConstantspublic class ScheduleConstants &#123; public static final String REDIS_KEY_FUTURE = &quot;future_&quot;; // 延迟任务的Redis前缀 public static final String REDIS_KEY_TOPIC = &quot;topic_&quot;; // 立即执行的Redis前缀 public static final String FUTURE_TASK_SYNC = &quot;FUTURE_TASK_SYNC&quot;; public static final Integer DEFAULT_TIME_MINUTE = 5; // 预设任务时间 public static final Integer LOCK_TIME_MILLISECONDS = 1000 * 30;&#125; 添加任务 添加小于当前时间的到List中，即立即审核 添加大于当前时间但小于当前时间加5分钟的放到ZSet中，即延迟审核 所有的任务均保存到数据库中，当大于当前时间加5分钟只会在数据库中，后期刷新到Redis中 创建TaskService接口，定义添加任务方法： TaskServicepublic interface TaskService &#123; /** * 添加延迟任务 * * @param task 任务 * @return 任务ID */ public long addTask(Task task);&#125; 实现该接口和添加任务的方法： TaskServiceImpl@Slf4j@Servicepublic class TaskServiceImpl implements TaskService &#123; private final TaskinfoMapper taskinfoMapper; private final TaskinfoLogsMapper taskinfoLogsMapper; private final CacheService cacheService; public TaskServiceImpl(TaskinfoMapper taskinfoMapper, TaskinfoLogsMapper taskinfoLogsMapper, CacheService cacheService) &#123; this.taskinfoMapper = taskinfoMapper; this.taskinfoLogsMapper = taskinfoLogsMapper; this.cacheService = cacheService; &#125; /** * 添加延迟任务 * * @param task 任务 * @return 任务ID */ @Override @Transactional(rollbackFor = RuntimeException.class) public long addTask(Task task) &#123; // 添加任务到数据库中 boolean success = addTaskToDb(task); if (!success) &#123; throw new RuntimeException(&quot;事务添加到数据库失败&quot;); &#125; // 添加任务到Redis addTaskToRedis(task); return task.getTaskId(); &#125; /** * 把任务添加到Redis中 * * @param task */ private void addTaskToRedis(Task task) &#123; String key = task.getTaskType() + &quot;_&quot; + task.getPriority(); // 获取5分钟之后的时间 Calendar instance = Calendar.getInstance(); instance.add(Calendar.MINUTE, ScheduleConstants.DEFAULT_TIME_MINUTE); long nextScheduleTime = instance.getTimeInMillis(); // 执行时间小于等于当前时间，即立即执行 if (task.getExecuteTime() &lt;= System.currentTimeMillis()) &#123; cacheService.lLeftPush(ScheduleConstants.REDIS_KEY_TOPIC + key, JSON.toJSONString(task)); &#125; else if (task.getExecuteTime() &lt;= nextScheduleTime) &#123; // 如果任务的执行时间大于当前时间 &amp;&amp; 小于预设时间（未来5分钟），存入zset中 cacheService.zAdd(ScheduleConstants.REDIS_KEY_FUTURE + key, JSON.toJSONString(task), task.getExecuteTime()); &#125; &#125; /** * 添加任务到数据库 * * @param task 任务 * @return 是否添加成功 */ private boolean addTaskToDb(Task task) &#123; // 保存任务表 Taskinfo taskinfo = new Taskinfo(); BeanUtils.copyProperties(task, taskinfo); taskinfo.setExecuteTime(new Date(task.getExecuteTime())); int insert = taskinfoMapper.insert(taskinfo); // 回填taskID task.setTaskId(taskinfo.getTaskId()); // 保存日志数据 TaskinfoLogs taskinfoLogs = new TaskinfoLogs(); BeanUtils.copyProperties(taskinfo, taskinfoLogs); taskinfoLogs.setVersion(1); taskinfoLogs.setStatus(TaskLogStatus.SCHEDULED.status()); int insert1 = taskinfoLogsMapper.insert(taskinfoLogs); return insert &gt; 0 &amp;&amp; insert1 &gt; 0; &#125;&#125; 取消任务场景：第三接口网络不通，使用延迟任务进行重试，当达到阈值以后，取消任务。 根据taskid删除任务,修改任务日志状态为 2(取消) 删除redis中对应的任务数据，包括list和zset 定义抽象方法 TaskService/** * 取消任务 * * @param taskId 任务ID * @return 是否取消成功 */public boolean cancelTask(long taskId); 实现该方法 TaskServiceImpl/** * 取消任务 * * @param taskId 任务ID * @return 是否取消成功 */@Override@Transactional(rollbackFor = Exception.class)public boolean cancelTask(long taskId) &#123; // 删除任务更新日志 Task task = updateDb(taskId, TaskLogStatus.CANCELLED.status()); if (task == null) return false; // 删除redis数据 removeTaskFromCache(task); return true;&#125;/** * 删除任务，更新任务日志 * * @param taskId 任务ID * @param status 状态 */private Task updateDb(long taskId, int status) &#123; // 删除任务 taskinfoMapper.deleteById(taskId); // 更新任务日志 TaskinfoLogs taskinfoLogs = taskinfoLogsMapper.selectById(taskId); if (taskinfoLogs == null) &#123; return null; &#125; taskinfoLogs.setStatus(status); taskinfoLogsMapper.updateById(taskinfoLogs); Task task = new Task(); BeanUtils.copyProperties(taskinfoLogs, task); task.setExecuteTime(taskinfoLogs.getExecuteTime().getTime()); return task;&#125;/** * 删除Redis中的数据 * * @param task 任务 */private void removeTaskFromCache(Task task) &#123; String key = task.getTaskType() + &quot;_&quot; + task.getPriority(); // 执行时间小于等于当前时间，即立即执行 if (task.getExecuteTime() &lt;= System.currentTimeMillis()) &#123; cacheService.lRemove(ScheduleConstants.REDIS_KEY_TOPIC + key, 0, JSON.toJSONString(task)); &#125; else &#123; cacheService.zRemove(ScheduleConstants.REDIS_KEY_FUTURE + key); &#125;&#125; 消费任务 从Redis的list中pop数据 删除任务并且修改日志状态 定义抽象方法 TaskService/** * 按照类型和优先级拉取任务 * * @param type 类型 * @param priority 优先级 * @return 任务 */public Task poll(int type, int priority); 实现抽象方法 /** * 按照类型和优先级拉取任务 * * @param type 类型 * @param priority 优先级 * @return 任务 */@Override@Transactional(rollbackFor = Exception.class)public Task poll(int type, int priority) &#123; // 从Redis中拉取数据 String key = type + &quot;_&quot; + priority; String taskJson = cacheService.lRightPop(ScheduleConstants.REDIS_KEY_TOPIC + key); if (!StringUtils.hasText(taskJson)) &#123; return null; &#125; Task task = JSON.parseObject(taskJson, Task.class); // 修改数据库信息 updateDb(task.getTaskId(), TaskLogStatus.EXECUTED.status()); return task;&#125; 定时刷新将ZSet中的数据定时刷新到List中去，进行消费 TaskServiceImpl/** * 未来数据定时刷新，每分钟一次 */@Scheduled(cron = &quot;0 */1 * * * ?&quot;)public void refresh() &#123; String token = cacheService.tryLock(ScheduleConstants.FUTURE_TASK_SYNC, ScheduleConstants.LOCK_TIME_MILLISECONDS); if (StringUtils.hasText(token)) &#123; log.info(&quot;未来数据定时刷新--定时任务&quot;); // 获取所有未来数据的集合key Set&lt;String&gt; futureKeys = cacheService.scan(ScheduleConstants.REDIS_KEY_FUTURE + &quot;*&quot;); for (String futureKey : futureKeys) &#123; // 获取当前数据的key String topicKey = ScheduleConstants.REDIS_KEY_TOPIC + futureKey.split(ScheduleConstants.REDIS_KEY_FUTURE)[1]; // 按照key和分值查询符合条件的数据 Set&lt;String&gt; tasks = cacheService.zRangeByScore(futureKey, 0, System.currentTimeMillis()); if (!tasks.isEmpty()) &#123; cacheService.refreshWithPipeline(futureKey, topicKey, tasks); log.info(&quot;成功的将&quot; + futureKey + &quot;刷新到了&quot; + topicKey); &#125; &#125; &#125;&#125; 延迟任务抢占如果有两个schedule服务启动，没太服务器都会去执行refresh定时任务，会出现任务抢占的现象。 分布式锁：控制分布式系统有序的去对共享资源进行操作，通过互斥来保证数据的一致性 分布式锁的解决方案： 方案 说明 数据库 基于表的唯一索引 zookeeper 根据zookeeper中的临时有序节点排序 redis 使用SETNX命令完成 使用Redis实现锁 CacheService/** * 加锁 * * @param name key * @param expire 过期时间 */public String tryLock(String name, long expire) &#123; name = name + &quot;_lock&quot;; String token = UUID.randomUUID().toString(); RedisConnectionFactory factory = stringRedisTemplate.getConnectionFactory(); RedisConnection connection = factory.getConnection(); try &#123; // set key value [Ex seconds] [PX milliseconds] [NX/XX] Boolean result = connection.set( name.getBytes(), token.getBytes(), Expiration.from(expire, TimeUnit.MILLISECONDS), RedisStringCommands.SetOption.SET_IF_ABSENT // NX ); if (result != null &amp;&amp; result) &#123; return token; &#125; &#125; finally &#123; RedisConnectionUtils.releaseConnection(connection, factory, false); &#125; return null;&#125; 修改定时刷新逻辑 TaskServiceImpl/** * 未来数据定时刷新，每分钟一次 */@Scheduled(cron = &quot;0 */1 * * * ?&quot;)public void refresh() &#123; String token = cacheService.tryLock(ScheduleConstants.FUTURE_TASK_SYNC, ScheduleConstants.LOCK_TIME_MILLISECONDS); if (StringUtils.hasText(token)) &#123; log.info(&quot;未来数据定时刷新--定时任务&quot;); // 获取所有未来数据的集合key Set&lt;String&gt; futureKeys = cacheService.scan(ScheduleConstants.REDIS_KEY_FUTURE + &quot;*&quot;); for (String futureKey : futureKeys) &#123; // 获取当前数据的key String topicKey = ScheduleConstants.REDIS_KEY_TOPIC + futureKey.split(ScheduleConstants.REDIS_KEY_FUTURE)[1]; // 按照key和分值查询符合条件的数据 Set&lt;String&gt; tasks = cacheService.zRangeByScore(futureKey, 0, System.currentTimeMillis()); if (!tasks.isEmpty()) &#123; cacheService.refreshWithPipeline(futureKey, topicKey, tasks); log.info(&quot;成功的将&quot; + futureKey + &quot;刷新到了&quot; + topicKey); &#125; &#125; &#125;&#125; 常量定义 ScheduleConstantspublic static final String FUTURE_TASK_SYNC = &quot;FUTURE_TASK_SYNC;public static final Integer LOCK_TIME_MILLISECONDS = 1000 * 30; 数据库任务同步到RedisTaskServiceImpl/** * 数据库任务定时同步到Redis */@PostConstruct@Scheduled(cron = &quot;0 */5 * * * ?&quot;)public void reloadData() &#123; // 清除缓存中的数据 clearCache(); // 查询符合条件的任务，小于未来5分钟的数据 Calendar instance = Calendar.getInstance(); instance.add(Calendar.MINUTE, ScheduleConstants.DEFAULT_TIME_MINUTE); List&lt;Taskinfo&gt; taskinfos = taskinfoMapper.selectList(Wrappers.&lt;Taskinfo&gt;lambdaQuery().lt(Taskinfo::getExecuteTime, instance.getTime())); // 把任务添加到redis if (taskinfos!=null&amp;&amp; !taskinfos.isEmpty()) &#123; for (Taskinfo taskinfo : taskinfos) &#123; Task task = new Task(); BeanUtils.copyProperties(taskinfo, task); task.setExecuteTime(taskinfo.getExecuteTime().getTime()); addTaskToRedis(task); &#125; &#125; log.info(&quot;数据库的任务同步到了Redis&quot;);&#125;/** * 清理缓存中的数据 */public void clearCache() &#123; Set&lt;String&gt; topicKeys = cacheService.scan(ScheduleConstants.REDIS_KEY_TOPIC + &quot;*&quot;); Set&lt;String&gt; futureKeys = cacheService.scan(ScheduleConstants.REDIS_KEY_FUTURE + &quot;*&quot;); cacheService.delete(topicKeys); cacheService.delete(futureKeys);&#125;&#125; 对外提供服务在leadnews-feign-api模块中创建包com.swx.apis.schedule 在该包下创建IScheduleClient接口，内容如下： IScheduleClient@FeignClient(&quot;leadnews-schedule&quot;)public interface IScheduleClient &#123; /** * 添加延迟任务 * * @param task 任务 * @return 任务ID */ @PostMapping(&quot;/api/v1/task/add&quot;) public R addTask(@RequestBody Task task); /** * 取消任务 * * @param taskId 任务ID * @return 是否取消成功 */ @GetMapping(&quot;/api/v1/task/&#123;taskId&#125;&quot;) public R cancelTask(@PathVariable(&quot;taskId&quot;) long taskId); /** * 按照类型和优先级拉取任务 * * @param type 类型 * @param priority 优先级 * @return 任务 */ @GetMapping(&quot;/api/v1/task/&#123;type&#125;/&#123;priority&#125;&quot;) public R poll(@PathVariable(&quot;type&quot;) int type, @PathVariable(&quot;priority&quot;) int priority);&#125; 在leadnews-schedule模块中实现该方法 feign.ScheduleClient@RestControllerpublic class ScheduleClient implements IScheduleClient &#123; private final TaskService taskService; public ScheduleClient(TaskService taskService) &#123; this.taskService = taskService; &#125; /** * 添加延迟任务 * * @param task 任务 * @return 任务ID */ @Override @PostMapping(&quot;/api/v1/task/add&quot;) public R addTask(@RequestBody Task task) &#123; return R.success(taskService.addTask(task)); &#125; /** * 取消任务 * * @param taskId 任务ID * @return 是否取消成功 */ @Override @GetMapping(&quot;/api/v1/task/&#123;taskId&#125;&quot;) public R cancelTask(@PathVariable(&quot;taskId&quot;) long taskId) &#123; return R.success(taskService.cancelTask(taskId)); &#125; /** * 按照类型和优先级拉取任务 * * @param type 类型 * @param priority 优先级 * @return 任务 */ @Override @GetMapping(&quot;/api/v1/task/&#123;type&#125;/&#123;priority&#125;&quot;) public R poll(@PathVariable(&quot;type&quot;) int type, @PathVariable(&quot;priority&quot;) int priority) &#123; return R.success(taskService.poll(type, priority)); &#125;&#125; 异步调用服务调用添加任务调用之前，在leadnews-wemedia模块中定义WmNewsTaskService WmNewsTaskServicepublic interface WmNewsTaskService &#123; /** * 添加任务到延迟队列中 * * @param id 文章ID * @param publishTime 发布时间，即任务执行时间 */ public void addNewsToTask(Integer id, Date publishTime);&#125; 实现这个接口 @Slf4j@Servicepublic class WmNewsTaskServiceImpl implements WmNewsTaskService &#123; private final IScheduleClient scheduleClient; public WmNewsTaskServiceImpl(IScheduleClient scheduleClient) &#123; this.scheduleClient = scheduleClient; &#125; /** * 添加任务到延迟队列中 * * @param id 文章ID * @param publishTime 发布时间，即任务执行时间 */ @Override @Async public void addNewsToTask(Integer id, Date publishTime) &#123; log.info(&quot;添加任务到延迟服务中----begin&quot;); Task task = new Task(); task.setExecuteTime(publishTime.getTime()); task.setTaskType(TaskTypeEnum.NEWS_SCAN_TIME.taskType()); task.setPriority(TaskTypeEnum.NEWS_SCAN_TIME.priority()); WmNews wmNews = new WmNews(); wmNews.setId(id); task.setParameters(ProtostuffUtil.serialize(wmNews)); scheduleClient.addTask(task); log.info(&quot;添加任务到延迟服务中----end&quot;); &#125;&#125; 找到发布文章的方法，将调用异步审核改为调用异步添加队列 WmNewsSubmitServiceImpl@Override@Transactional(rollbackFor = Exception.class)public void submitNews(WmNewsDTO dto) &#123; ....; // 异步调用自动审核 // wmNewsAutoScanService.autoScanWmNews(wmNews.getId()); // 添加到任务队列中 wmNewsTaskService.addNewsToTask(wmNews.getId(), wmNews.getPublishTime());&#125; 调用拉取任务在WmNewsTaskService接口中添加如下方法： WmNewsTaskService/** * 消费任务 */public void scanNewsByTask(); 实现该方法，这个方法没有主动调用，使用定时任务： WmNewsTaskServiceImpl/** * 消费任务，每秒拉取一次 */@Override@Scheduled(fixedRate = 1000)public void scanNewsByTask() &#123; log.info(&quot;消费任务，审核文章&quot;); R result = scheduleClient.poll(TaskTypeEnum.NEWS_SCAN_TIME.taskType(), TaskTypeEnum.NEWS_SCAN_TIME.priority()); if (result == null) &#123; log.error(&quot;拉取任务失败&quot;); return; &#125; if (result.getCode().equals(ResultCodeEnum.SUCCESS.code()) &amp;&amp; result.getData() != null) &#123; Task task = JSON.parseObject(JSON.toJSONString(result.getData()), Task.class); WmNews wmNews = ProtostuffUtil.deserialize(task.getParameters(), WmNews.class); wmNewsAutoScanService.autoScanWmNews(wmNews.getId()); &#125;&#125; 在WemediaApplication添加注解@EnableScheduling WemediaApplication@SpringBootApplication@EnableDiscoveryClient@MapperScan(&quot;com.swx.wemedia.mapper&quot;)@EnableFeignClients(basePackages = &quot;com.swx.apis&quot;)@EnableAsync // 开启异步任务@EnableScheduling // 开启调度任务public class WemediaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WemediaApplication.class, args); &#125;&#125;"},{"title":"初始化工程","path":"/wiki/leadnews/03_project/init_project.html","content":"项目父工程及其子模块 版本控制在父工程的pom中添加版本依赖信息。基础配置，后面会陆续完善 pom.xml&lt;properties&gt;\t&lt;java.version&gt;11&lt;/java.version&gt;\t&lt;spring.boot.version&gt;2.7.8&lt;/spring.boot.version&gt;\t&lt;reflections.version&gt;0.9.11&lt;/reflections.version&gt;\t&lt;fastjson.version&gt;2.0.32&lt;/fastjson.version&gt;\t&lt;leadnew-common.version&gt;0.0.1-SNAPSHOT&lt;/leadnew-common.version&gt;\t&lt;leadnew-model.version&gt;0.0.1-SNAPSHOT&lt;/leadnew-model.version&gt;\t&lt;spring.cloud.version&gt;Hoxton.SR10&lt;/spring.cloud.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt;\t&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-common&lt;/artifactId&gt; &lt;version&gt;$&#123;leadnew-common.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-model&lt;/artifactId&gt; &lt;version&gt;$&#123;leadnew-model.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.reflections&lt;/groupId&gt; &lt;artifactId&gt;reflections&lt;/artifactId&gt; &lt;version&gt;$&#123;reflections.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt;\t&lt;/dependencies&gt;&lt;/dependencyManagement&gt; 异常和返回结果统一处理添加依赖信息在leadnews-common模块中添加如下的依赖信息 pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-model&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在leadnews-model模块中添加如下的依赖信息 pom.xml&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 创建实体类和枚举类在leadnews-model模块中创建包com.swx.model.common.dto和com.swx.model.common.enums 创建消息提示枚举 enums.ResultCodeEnumpublic enum ResultCodeEnum &#123; /* 成功状态码 */ SUCCESS(20000, &quot;成功&quot;), /* Token 50~100 */ TOKEN_INVALID(50, &quot;无效TOKEN&quot;), TOKEN_EXPIRE(51, &quot;TOKEN已过期&quot;), TOKEN_REQUIRE(50, &quot;TOKEN是必须的&quot;), /* 参数错误 500~1000 */ SERVER_ERROR(500, &quot;服务器内部错误&quot;), PARAM_REQUIRE(501, &quot;缺少参数&quot;), PARAM_INVALID(502, &quot;无效参数&quot;), PARAM_TIMAGE_FORMAT_ERROR(503, &quot;图片格式有误&quot;), /* 数据错误 1000~2000 */ DATA_EXIST(1000, &quot;数据已经存在&quot;), AP_USER_DATA_NOT_EXIST(1001, &quot;ApUser数据不存在&quot;), DATA_NOT_EXIST(1002, &quot;数据不存在&quot;), /* 数据错误 300~3500 */ NO_OPERATOR_AUTH(3000, &quot;无权操作&quot;), NEED_ADMIN(3001, &quot;需要管理员权限&quot;); private Integer code; private String message; private ResultCodeEnum(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer code() &#123; return this.code; &#125; public String message() &#123; return this.message; &#125;&#125; 创建返回结果实体类 dto.R/** * 返回结果实体类 */@Datapublic class R implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 返回码 */ private Integer code; /** * 返回消息 */ private String message; /** * 返回数据 */ private Object data; public R() &#123; &#125; public R(ResultCodeEnum resultCode, Object data) &#123; this.code = resultCode.code(); this.message = resultCode.message(); this.data = data; &#125; private void setResultCode(ResultCodeEnum resultCode) &#123; this.code = resultCode.code(); this.message = resultCode.message(); &#125; // 返回成功 public static R success() &#123; R result = new R(); result.setResultCode(ResultCodeEnum.SUCCESS); return result; &#125; // 返回成功 public static R success(Object data) &#123; R result = new R(); result.setResultCode(ResultCodeEnum.SUCCESS); result.setData(data); return result; &#125; // 返回失败 public static R fail(Integer code, String message) &#123; R result = new R(); result.setCode(code); result.setMessage(message); return result; &#125; // 返回失败 public static R fail(ResultCodeEnum resultCode) &#123; R result = new R(); result.setResultCode(resultCode); return result; &#125;&#125; 创建返回分页结果实体类 dto.PageR/** * 返回分页结果实体类 */@Datapublic class PageR extends R implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer current; private Integer size; private Integer total; public PageR() &#123; &#125; public PageR(Integer current, Integer size, Integer total) &#123; this.current = current; this.size = size; this.total = total; &#125;&#125; 创建错误结果实体类 dto.ErrorResult/** * 异常结果包装类 * @author sw-code * */public class ErrorResult &#123; private Integer code; private String message; private String exception; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public String getException() &#123; return exception; &#125; public void setException(String exception) &#123; this.exception = exception; &#125; public static ErrorResult fail(ResultCodeEnum resultCode, Throwable e, String message) &#123; ErrorResult errorResult = ErrorResult.fail(resultCode, e); errorResult.setMessage(message); return errorResult; &#125; public static ErrorResult fail(ResultCodeEnum resultCode, Throwable e) &#123; ErrorResult errorResult = new ErrorResult(); errorResult.setCode(resultCode.code()); errorResult.setMessage(resultCode.message()); errorResult.setException(e.getClass().getName()); return errorResult; &#125; public static ErrorResult fail(Integer code, String message) &#123; ErrorResult errorResult = new ErrorResult(); errorResult.setCode(code); errorResult.setMessage(message); return errorResult; &#125;&#125; 创建自定义异常类 dto.BizExceptionpublic class BizException extends RuntimeException &#123; /** * 错误码 */ private Integer code; /** * 错误信息 */ private String message; public BizException() &#123; super(); &#125; public BizException(ResultCodeEnum resultCode) &#123; super(resultCode.message()); this.code = resultCode.code(); this.message = resultCode.message(); &#125; public BizException(ResultCodeEnum resultCode, Throwable cause) &#123; super(resultCode.message(), cause); this.code = resultCode.code(); this.message = resultCode.message(); &#125; public BizException(String message) &#123; super(message); this.code = -1; this.message = message; &#125; public BizException(Integer code, String message) &#123; super(message); this.code = code; this.message = message; &#125; public BizException(Integer code, String message, Throwable cause) &#123; super(message, cause); this.code = code; this.message = message; &#125; @Override public synchronized Throwable fillInStackTrace() &#123; return this; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 创建自定义注解使用注解的Controller自动统一封装 在leadnews-common模块中创建com.swx.common.exception，并在该包下创建annotation包 创建自定义注解类 annotation.ResponseResult@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.TYPE, ElementType.METHOD&#125;)@Documentedpublic @interface ResponseResult &#123;&#125; 创建拦截器在com.swx.common.exception下创建interceptor包 拦截器会拦截添加了自定义注解的类或者方法，完成统一封装 interceptor.ResponseResultInterceptor@Componentpublic class ResponseResultInterceptor implements HandlerInterceptor &#123; //标记名称 public static final String RESPONSE_RESULT_ANN = &quot;RESPONSE-RESULT-ANN&quot;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO Auto-generated method stub if (handler instanceof HandlerMethod) &#123; final HandlerMethod handlerMethod = (HandlerMethod) handler; final Class&lt;?&gt; clazz = handlerMethod.getBeanType(); final Method method = handlerMethod.getMethod(); // 判断是否在类对象上添加了注解 if (clazz.isAnnotationPresent(ResponseResult.class)) &#123; // 设置此请求返回体，需要包装，往下传递，在ResponseBodyAdvice接口进行判断 request.setAttribute(RESPONSE_RESULT_ANN, clazz.getAnnotation(ResponseResult.class)); &#125; else if (method.isAnnotationPresent(ResponseResult.class)) &#123; request.setAttribute(RESPONSE_RESULT_ANN, method.getAnnotation(ResponseResult.class)); &#125; &#125; return true; &#125;&#125; 注册拦截器在com.swx.common.exception下创建config包 config.WebAppConfig@Configurationpublic class WebAppConfig implements WebMvcConfigurer &#123; // SpringMVC 需要手动添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; ResponseResultInterceptor interceptor = new ResponseResultInterceptor(); registry.addInterceptor(interceptor); WebMvcConfigurer.super.addInterceptors(registry); &#125;&#125; 异常和返回值处理类在com.swx.common.exception下创建handler包 创建全局异常处理类 handler.GlobalExceptionHandler/** * 全局异常处理类 * @RestControllerAdvice(@ControllerAdvice)，拦截异常并统一处理 * @author sw-code * */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(&quot;GlobalExceptionHandler.class&quot;); /** * 处理自定义的业务异常 * @param e\t异常对象 * @param request\trequest * @return\t错误结果 */ @ExceptionHandler(BizException.class) public ErrorResult bizExceptionHandler(BizException e, HttpServletRequest request) &#123; logger.error(&quot;发生业务异常！原因是: &#123;&#125;&quot;, e.getMessage()); return ErrorResult.fail(e.getCode(), e.getMessage()); &#125; // 拦截抛出的异常，@ResponseStatus：用来改变响应状态码 @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Throwable.class) public ErrorResult handlerThrowable(Throwable e, HttpServletRequest request) &#123; logger.error(&quot;发生未知异常！原因是: &quot;, e); ErrorResult error = ErrorResult.fail(ResultCodeEnum.SERVER_ERROR, e); return error; &#125; // 参数校验异常 @ExceptionHandler(BindException.class) public ErrorResult handleBindExcpetion(BindException e, HttpServletRequest request) &#123; logger.error(&quot;发生参数校验异常！原因是：&quot;,e); ErrorResult error = ErrorResult.fail(ResultCodeEnum.PARAM_INVALID, e, e.getAllErrors().get(0).getDefaultMessage()); return error; &#125; @ExceptionHandler(MethodArgumentNotValidException.class) public ErrorResult handleMethodArgumentNotValidException(MethodArgumentNotValidException e, HttpServletRequest request) &#123; logger.error(&quot;发生参数校验异常！原因是：&quot;,e); ErrorResult error = ErrorResult.fail(ResultCodeEnum.PARAM_INVALID,e,e.getBindingResult().getAllErrors().get(0).getDefaultMessage()); return error; &#125;&#125; 创建返回值处理类 handler.ResponseResultHandler/** * 使用 @ControllerAdvice &amp; ResponseBodyAdvice * 拦截Controller方法默认返回参数，统一处理返回值/响应体 */@ControllerAdvicepublic class ResponseResultHandler implements ResponseBodyAdvice&lt;Object&gt; &#123; // 标记名称 public static final String RESPONSE_RESULT_ANN = &quot;RESPONSE-RESULT-ANN&quot;; // 判断是否要执行 beforeBodyWrite 方法，true为执行，false不执行，有注解标记的时候处理返回值 @Override public boolean supports(MethodParameter arg0, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; arg1) &#123; ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = sra.getRequest(); // 判断请求是否有包装标记 ResponseResult responseResultAnn = (ResponseResult) request.getAttribute(RESPONSE_RESULT_ANN); return responseResultAnn == null ? false : true; &#125; // 对返回值做包装处理，如果属于异常结果，则需要再包装 @Override public Object beforeBodyWrite(Object body, MethodParameter arg1, MediaType arg2, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; arg3, ServerHttpRequest arg4, ServerHttpResponse arg5) &#123; if (body instanceof ErrorResult) &#123; ErrorResult error = (ErrorResult) body; return R.fail(error.getCode(), error.getMessage()); &#125; else if (body instanceof R) &#123; return (R) body; &#125; else if (body instanceof String) &#123; return body; &#125; return R.success(body); &#125;&#125; 自动装配在 leadnews-common模块的resources包下创建META-INF目录，目录中创建spring.factories文件，内容如下，当其他模块引入该模块时，会自动装配指定的类 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.swx.common.exception.config.WebAppConfig, \\ com.swx.common.exception.handler.GlobalExceptionHandler, \\ com.swx.common.exception.handler.ResponseResultHandler 测试在 leadnews-service模块中添加如下依赖信息 pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-common&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建com.swx.service包，并在该包下创建启动类 ServiceApplication@SpringBootApplicationpublic class ServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceApplication.class, args); &#125;&#125; 创建controller包，并创建测试Controller，内容如下： controller.TestController@ResponseResult@RestController@RequestMapping(&quot;/test&quot;)public class TestController &#123; @GetMapping(&quot;&quot;) public Map&lt;String, String&gt; test() &#123; HashMap&lt;String, String&gt; data = new HashMap&lt;&gt;(); data.put(&quot;data&quot;, &quot;01&quot;); return data; &#125;&#125; 使用了自定义的@ResponseResult注解，该类下的方法返回值会被统一处理 使用浏览器访问：http://localhost:8080/test &#123;&quot;code&quot;:20000,&quot;message&quot;:&quot;成功&quot;,&quot;data&quot;:&#123;&quot;data&quot;:&quot;01&quot;&#125;&#125;"},{"title":"笔记简介","path":"/wiki/learning-online/01-introduce/index.html","content":"《学成在线》项目采用的是SpringBoot+springcloud当下最流行的微服务为项目架构，配合spring cloud alibaba nacos作为项目的注册和配置中心。新课程采用快速开发的模式，主要解决真实企业开发的一些应用场景。深入挖掘技术和业务的解决方案，做到更加的通用，能举一反三，充分满足互联网行业中复杂的微服务技术要求。 技术栈 Spring Boot + Mybatis Spring Cloud + Gateway Nacos 注册和配置中心 XXL-JOB 分布式任务调度 Freemarker 生成静态内容页面 MySQL + Redis + Elasticsearch + MinIO 做内容检索和缓存 Spring Security + JWT做登陆认证授权 项目亮点 使用 Nacos 做服务注册和配置中心 使用 Gateway 统一路由微服务 树型表的查询的两种方式：使用 WITH 递归查询；使用LEFT JOIN 查询 统一返回结果处理、全局异常拦截 JSR303参数校验 图片和视频分片上传，上传文件到MinIO，使用MinIO合并分片文件 使用 FFmpeg 转码文件 使用 Freemarker 生成静态内容页面 使用 MySQL + Redis + Elasticsearch + MinIO 做内容检索和缓存 项目大纲 本项目包括了用户端、机构端、运营端、核心模块包括：内容管理、媒资管理、课程搜索、订单支付、选课管理、认证授权等。 本项目主要包括三类用户角色：学生、教学机构老师、平台运营人员。 主要讲解下边的业务流程： 教学机构的老师登陆教学管理平台，编辑课程信息，发布自己的课程。 平台运营人员登陆平台审核课程、视频等信息，审核通过后课程方可发布。 用户登陆门户网站搜索课程、浏览课程信息、免费课程直接选课学习，付费课程需要购买课程，支付订单后方可学习。 查看课程编辑与发布流程 学生选课流程 项目预览"},{"title":"自媒体后台管理","path":"/wiki/leadnews/03_project/media_manage.html","content":"数据库下载数据库文件，创建leadnews_wemedia数据库，执行下载的SQL脚本 leadnews_wemedia.sqlhttps://wwab.lanzoue.com/iGNOX14n4s9a 或，使用脚本创建leadnews_wemedia数据库 /*Navicat MySQL Data TransferSource Server : localhostSource Server Version : 50721Source Host : localhost:3306Source Database : leadnews_wemediaTarget Server Type : MYSQLTarget Server Version : 50721File Encoding : 65001Date: 2021-04-26 11:33:55*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for wm_channel-- ----------------------------DROP TABLE IF EXISTS `wm_channel`;CREATE TABLE `wm_channel` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(10) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;频道名称&#x27;, `description` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;频道描述&#x27;, `is_default` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;是否默认频道&#x27;, `status` tinyint(1) unsigned DEFAULT NULL, `ord` tinyint(3) unsigned DEFAULT NULL COMMENT &#x27;默认排序&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;频道信息表&#x27;;-- ------------------------------ Records of wm_channel-- ----------------------------INSERT INTO `wm_channel` VALUES (&#x27;0&#x27;, &#x27;其他&#x27;, &#x27;其他&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;12&#x27;, &#x27;2021-04-18 10:55:41&#x27;);INSERT INTO `wm_channel` VALUES (&#x27;1&#x27;, &#x27;java&#x27;, &#x27;后端框架&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2021-04-18 12:25:30&#x27;);INSERT INTO `wm_channel` VALUES (&#x27;2&#x27;, &#x27;Mysql&#x27;, &#x27;轻量级数据库&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;4&#x27;, &#x27;2021-04-18 10:55:41&#x27;);INSERT INTO `wm_channel` VALUES (&#x27;3&#x27;, &#x27;Vue&#x27;, &#x27;阿里前端框架&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;5&#x27;, &#x27;2021-04-18 10:55:41&#x27;);INSERT INTO `wm_channel` VALUES (&#x27;4&#x27;, &#x27;Python&#x27;, &#x27;未来的语言&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;6&#x27;, &#x27;2021-04-18 10:55:41&#x27;);INSERT INTO `wm_channel` VALUES (&#x27;5&#x27;, &#x27;Weex&#x27;, &#x27;向未来致敬&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;7&#x27;, &#x27;2021-04-18 10:55:41&#x27;);INSERT INTO `wm_channel` VALUES (&#x27;6&#x27;, &#x27;大数据&#x27;, &#x27;不会，则不要说自己是搞互联网的&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;10&#x27;, &#x27;2021-04-18 10:55:41&#x27;);-- ------------------------------ Table structure for wm_fans_statistics-- ----------------------------DROP TABLE IF EXISTS `wm_fans_statistics`;CREATE TABLE `wm_fans_statistics` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;主账号ID&#x27;, `article` int(11) unsigned DEFAULT NULL COMMENT &#x27;子账号ID&#x27;, `read_count` int(11) unsigned DEFAULT NULL, `comment` int(11) unsigned DEFAULT NULL, `follow` int(11) unsigned DEFAULT NULL, `collection` int(11) unsigned DEFAULT NULL, `forward` int(11) unsigned DEFAULT NULL, `likes` int(11) unsigned DEFAULT NULL, `unlikes` int(11) unsigned DEFAULT NULL, `unfollow` int(11) unsigned DEFAULT NULL, `burst` varchar(40) COLLATE utf8mb4_unicode_ci DEFAULT NULL, `created_time` date DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`) USING BTREE, UNIQUE KEY `idx_user_id_time` (`user_id`,`created_time`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;自媒体粉丝数据统计表&#x27;;-- ------------------------------ Records of wm_fans_statistics-- ------------------------------ ------------------------------ Table structure for wm_material-- ----------------------------DROP TABLE IF EXISTS `wm_material`;CREATE TABLE `wm_material` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;自媒体用户ID&#x27;, `url` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;图片地址&#x27;, `type` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;素材类型\\r 0 图片\\r 1 视频&#x27;, `is_collection` tinyint(1) DEFAULT NULL COMMENT &#x27;是否收藏&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=72 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;自媒体图文素材信息表&#x27;;-- ------------------------------ Records of wm_material-- ----------------------------INSERT INTO `wm_material` VALUES (&#x27;67&#x27;, &#x27;1102&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/04/26/a73f5b60c0d84c32bfe175055aaaac40.jpg&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;2021-04-26 00:14:01&#x27;);INSERT INTO `wm_material` VALUES (&#x27;68&#x27;, &#x27;1102&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/04/26/d4f6ef4c0c0546e69f70bd3178a8c140.jpg&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;2021-04-26 00:18:20&#x27;);INSERT INTO `wm_material` VALUES (&#x27;69&#x27;, &#x27;1102&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/04/26/5ddbdb5c68094ce393b08a47860da275.jpg&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;2021-04-26 00:18:27&#x27;);INSERT INTO `wm_material` VALUES (&#x27;70&#x27;, &#x27;1102&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/04/26/9f8a93931ab646c0a754475e0c4b0a98.jpg&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;2021-04-26 00:18:34&#x27;);INSERT INTO `wm_material` VALUES (&#x27;71&#x27;, &#x27;1102&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/04/26/ef3cbe458db249f7bd6fb4339e593e55.jpg&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;2021-04-26 00:18:39&#x27;);-- ------------------------------ Table structure for wm_news-- ----------------------------DROP TABLE IF EXISTS `wm_news`;CREATE TABLE `wm_news` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;自媒体用户ID&#x27;, `title` varchar(36) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;标题&#x27;, `content` longtext COLLATE utf8mb4_unicode_ci COMMENT &#x27;图文内容&#x27;, `type` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;文章布局\\r 0 无图文章\\r 1 单图文章\\r 3 多图文章&#x27;, `channel_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;图文频道ID&#x27;, `labels` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `submited_time` datetime DEFAULT NULL COMMENT &#x27;提交时间&#x27;, `status` tinyint(2) unsigned DEFAULT NULL COMMENT &#x27;当前状态\\r 0 草稿\\r 1 提交（待审核）\\r 2 审核失败\\r 3 人工审核\\r 4 人工审核通过\\r 8 审核通过（待发布）\\r 9 已发布&#x27;, `publish_time` datetime DEFAULT NULL COMMENT &#x27;定时发布时间，不定时则为空&#x27;, `reason` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;拒绝理由&#x27;, `article_id` bigint(20) unsigned DEFAULT NULL COMMENT &#x27;发布库文章ID&#x27;, `images` longtext COLLATE utf8mb4_unicode_ci COMMENT &#x27;//图片用逗号分隔&#x27;, `enable` tinyint(1) unsigned DEFAULT &#x27;1&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=6232 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;自媒体图文内容信息表&#x27;;-- ------------------------------ Records of wm_news-- ----------------------------INSERT INTO `wm_news` VALUES (&#x27;6225&#x27;, &#x27;1102&#x27;, &#x27;“真”项目课程对找工作有什么帮助？&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;找工作，企业重点问的是项目经验，更是HR筛选的“第一门槛”，直接决定了你是否有机会进入面试环节。\\ \\ 项目经验更是评定“个人能力/技能”真实性的“证据”，反映了求职者某个方面的实际动手能力、对某个领域或某种技能的掌握程度。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/7d0911a41a3745efa8509a87f234813c.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;很多经过培训期望快速上岗的程序员，靠着培训机构“辅导”顺利经过面试官对于“项目经验”的考核上岗后，在面对“有限时间”“复杂业务”“新项目需求”等多项标签加持的工作任务，却往往不知从何下手或开发进度极其缓慢。最终结果就是：熬不过试用期。\\ \\ 从而也引发了企业对于“培训出身程序员”的“有色眼光”。你甚至也一度怀疑“IT培训班出来的人真的不行吗?”\\&quot;&#125;]&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;项目课程&#x27;, &#x27;2021-04-19 00:08:10&#x27;, &#x27;2021-04-19 00:08:10&#x27;, &#x27;9&#x27;, &#x27;2021-04-19 00:08:05&#x27;, &#x27;审核成功&#x27;, &#x27;1383828014629179393&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/7d0911a41a3745efa8509a87f234813c.jpg&#x27;, &#x27;1&#x27;);INSERT INTO `wm_news` VALUES (&#x27;6226&#x27;, &#x27;1102&#x27;, &#x27;学IT，为什么要学项目课程？&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;在选择IT培训机构时，你应该有注意到，很多机构都将“项目课程”作为培训中的重点。那么，为什么要学习项目课程?为什么项目课程才是IT培训课程的核心?\\ \\ 1\\ \\ 在这个靠“技术经验说话”的IT行业里，假如你是一个计算机或IT相关专业毕业生，在没有实际项目开发经验的情况下，“找到第一份全职工作”可能是你职业生涯中遇到的最大挑战。\\ \\ 为什么说找第一份工作很难?\\ \\ 主要在于：实际企业中用到的软件开发知识和在学校所学的知识是完全不同的。假设你已经在学校和同学做过周期长达2-3个月的项目，但真正工作中的团队协作与你在学校中经历的协作也有很多不同。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/e8113ad756a64ea6808f91130a6cd934.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;在实际团队中，每一位成员彼此团结一致，为项目的交付而努力，这也意味着你必须要理解好在项目中负责的那部分任务，在规定时间交付还需确保你负责的功能，在所有环境中都能很好地发挥作用，而不仅仅是你的本地机器。\\ \\ 这需要你对项目中的每一行代码严谨要求。学校练习的项目中，对bug的容忍度很大，而在实际工作中是绝对不能容忍的。项目中的任何一个环节都涉及公司利益，任何一个bug都可能影响公司的收入及形象。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/c7c3d36d25504cf6aecdcd5710261773.jpg\\&quot;&#125;]&#x27;, &#x27;3&#x27;, &#x27;1&#x27;, &#x27;项目课程&#x27;, &#x27;2021-04-19 00:13:58&#x27;, &#x27;2021-04-19 00:13:58&#x27;, &#x27;9&#x27;, &#x27;2021-04-19 00:10:48&#x27;, &#x27;审核成功&#x27;, &#x27;1383827995813531650&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/7d0911a41a3745efa8509a87f234813c.jpg,http://192.168.200.130:9000/leadnews/2021/4/20210418/c7c3d36d25504cf6aecdcd5710261773.jpg,http://192.168.200.130:9000/leadnews/2021/4/20210418/e8113ad756a64ea6808f91130a6cd934.jpg&#x27;, &#x27;1&#x27;);INSERT INTO `wm_news` VALUES (&#x27;6227&#x27;, &#x27;1102&#x27;, &#x27;小白如何辨别其真与伪&amp;好与坏？&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;通过上篇《IT培训就业艰难，行业乱象频发，如何破解就业难题?》一文，相信大家已初步了解“项目课程”对程序员能否就业且高薪就业的重要性。\\ \\ 因此，小白在选择IT培训机构时，关注的重点就在于所学“项目课程”能否真正帮你增加就业筹码。当然，前提必须是学到“真”项目。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/1818283261e3401892e1383c1bd00596.jpg\\&quot;&#125;]&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;小白&#x27;, &#x27;2021-04-19 00:15:05&#x27;, &#x27;2021-04-19 00:15:05&#x27;, &#x27;9&#x27;, &#x27;2021-04-19 00:14:58&#x27;, &#x27;审核成功&#x27;, &#x27;1383827976310018049&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/1818283261e3401892e1383c1bd00596.jpg&#x27;, &#x27;1&#x27;);INSERT INTO `wm_news` VALUES (&#x27;6228&#x27;, &#x27;1102&#x27;, &#x27;工作线程数是不是设置的越大越好&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;根据经验来看，jdk api 一般推荐的线程数为CPU核数的2倍。但是有些书籍要求可以设置为CPU核数的8倍，也有的业务设置为CPU核数的32倍。\\ “工作线程数”的设置依据是什么，到底设置为多少能够最大化CPU性能，是本文要讨论的问题。\\ \\ 工作线程数是不是设置的越大越好\\ 显然不是的。使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。\\ 一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。\\ Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。\\ 一个Java应用总是从main()方法开始运行，main()方法运行在一个线程内，它被称为主线程。\\ 一旦创建一个新的线程，就产生一个新的调用栈。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/a3f0bc438c244f788f2df474ed8ecdc1.jpg\\&quot;&#125;]&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;11&#x27;, &#x27;2021-04-19 00:16:57&#x27;, &#x27;2021-04-19 00:16:57&#x27;, &#x27;9&#x27;, &#x27;2021-04-19 00:16:52&#x27;, &#x27;审核成功&#x27;, &#x27;1383827952326987778&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/a3f0bc438c244f788f2df474ed8ecdc1.jpg&#x27;, &#x27;1&#x27;);INSERT INTO `wm_news` VALUES (&#x27;6229&#x27;, &#x27;1102&#x27;, &#x27;Base64编解码原理&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;我在面试过程中，问过很多高级java工程师，是否了解Base64？部分人回答了解，部分人直接回答不了解。而说了解的那部分人却回答不上来它的原理。\\ \\ Base64 的由来\\ Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。它是一种基于用64个可打印字符来表示二进制数据的表示方法。它通常用作存储、传输一些二进制数据编码方法！也是MIME（多用途互联网邮件扩展，主要用作电子邮件标准）中一种可打印字符表示二进制数据的常见编码方法！它其实只是定义用可打印字符传输内容一种方法，并不会产生新的字符集！\\ \\ 传统的邮件只支持可见字符的传送，像ASCII码的控制字符就 不能通过邮件传送。这样用途就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情 况下，做一种扩展方案来支持二进制文件的传送。把不可打印的字符也能用可打印字符来表示，问题就解决了。Base64编码应运而生，Base64就是一种 基于64个可打印字符来表示二进制数据的表示方法。\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/b44c65376f12498e873223d9d6fdf523.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文\\&quot;&#125;]&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;11&#x27;, &#x27;2021-04-19 00:17:44&#x27;, &#x27;2021-04-19 00:17:44&#x27;, &#x27;9&#x27;, &#x27;2021-04-19 00:17:42&#x27;, &#x27;审核成功&#x27;, &#x27;1383827911810011137&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/b44c65376f12498e873223d9d6fdf523.jpg&#x27;, &#x27;1&#x27;);INSERT INTO `wm_news` VALUES (&#x27;6230&#x27;, &#x27;1102&#x27;, &#x27;为什么项目经理不喜欢重构？&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;经常听到开发人员抱怨 ，“这么烂的代码，我来重构一下！”，“这代码怎么能这么写呢？谁来重构一下？”，“这儿有个坏味道，重构吧！”\\ \\ 作为一名项目经理，每次听到“重构”两个字，既想给追求卓越代码的开发人员点个赞，同时又会感觉非常紧张，为什么又要重构？马上就要上线了，怎么还要改？是不是应该阻止开发人员做重构？\\ \\ 重构几乎是开发人员最喜欢的一项实践了，可项目经理们却充满了顾虑，那么为什么项目经理不喜欢重构呢？\\ \\ 老功能被破坏\\ 不止一次遇到这样的场景，某一天一个老功能突然被破坏了，项目经理们感到奇怪，产品这块儿的功能已经很稳定了，也没有在这部分开发什么新功能，为什么突然出问题了呢？\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/e8113ad756a64ea6808f91130a6cd934.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/4a498d9cf3614570ac0cb2da3e51c164.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文\\&quot;&#125;]&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;11&#x27;, &#x27;2021-04-19 00:19:23&#x27;, &#x27;2021-04-19 00:19:23&#x27;, &#x27;9&#x27;, &#x27;2021-04-19 00:19:09&#x27;, &#x27;审核成功&#x27;, &#x27;1383827888816836609&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/4a498d9cf3614570ac0cb2da3e51c164.jpg&#x27;, &#x27;1&#x27;);INSERT INTO `wm_news` VALUES (&#x27;6231&#x27;, &#x27;1102&#x27;, &#x27;Kafka文件的存储机制&#x27;, &#x27;[&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制Kafka文件的存储机制\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;image\\&quot;,\\&quot;value\\&quot;:\\&quot;http://192.168.200.130:9000/leadnews/2021/4/20210418/4a498d9cf3614570ac0cb2da3e51c164.jpg\\&quot;&#125;,&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;value\\&quot;:\\&quot;请在这里输入正文\\&quot;&#125;]&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;11&#x27;, &#x27;2021-04-19 00:58:47&#x27;, &#x27;2021-04-19 00:58:47&#x27;, &#x27;9&#x27;, &#x27;2021-04-19 00:20:17&#x27;, &#x27;审核成功&#x27;, &#x27;1383827787629252610&#x27;, &#x27;http://192.168.200.130:9000/leadnews/2021/4/20210418/4a498d9cf3614570ac0cb2da3e51c164.jpg&#x27;, &#x27;1&#x27;);-- ------------------------------ Table structure for wm_news_material-- ----------------------------DROP TABLE IF EXISTS `wm_news_material`;CREATE TABLE `wm_news_material` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `material_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;素材ID&#x27;, `news_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;图文ID&#x27;, `type` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;引用类型\\r 0 内容引用\\r 1 主图引用&#x27;, `ord` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;引用排序&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=281 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;自媒体图文引用素材信息表&#x27;;-- ------------------------------ Records of wm_news_material-- ----------------------------INSERT INTO `wm_news_material` VALUES (&#x27;255&#x27;, &#x27;61&#x27;, &#x27;6232&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;256&#x27;, &#x27;61&#x27;, &#x27;6232&#x27;, &#x27;1&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;263&#x27;, &#x27;61&#x27;, &#x27;6231&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;264&#x27;, &#x27;61&#x27;, &#x27;6231&#x27;, &#x27;1&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;265&#x27;, &#x27;57&#x27;, &#x27;6230&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;266&#x27;, &#x27;61&#x27;, &#x27;6230&#x27;, &#x27;0&#x27;, &#x27;1&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;267&#x27;, &#x27;61&#x27;, &#x27;6230&#x27;, &#x27;1&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;268&#x27;, &#x27;58&#x27;, &#x27;6229&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;269&#x27;, &#x27;58&#x27;, &#x27;6229&#x27;, &#x27;1&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;270&#x27;, &#x27;62&#x27;, &#x27;6228&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;271&#x27;, &#x27;62&#x27;, &#x27;6228&#x27;, &#x27;1&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;272&#x27;, &#x27;66&#x27;, &#x27;6227&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;273&#x27;, &#x27;66&#x27;, &#x27;6227&#x27;, &#x27;1&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;274&#x27;, &#x27;57&#x27;, &#x27;6226&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;275&#x27;, &#x27;64&#x27;, &#x27;6226&#x27;, &#x27;0&#x27;, &#x27;1&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;276&#x27;, &#x27;65&#x27;, &#x27;6226&#x27;, &#x27;1&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;277&#x27;, &#x27;64&#x27;, &#x27;6226&#x27;, &#x27;1&#x27;, &#x27;1&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;278&#x27;, &#x27;57&#x27;, &#x27;6226&#x27;, &#x27;1&#x27;, &#x27;2&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;279&#x27;, &#x27;65&#x27;, &#x27;6225&#x27;, &#x27;0&#x27;, &#x27;0&#x27;);INSERT INTO `wm_news_material` VALUES (&#x27;280&#x27;, &#x27;65&#x27;, &#x27;6225&#x27;, &#x27;1&#x27;, &#x27;0&#x27;);-- ------------------------------ Table structure for wm_news_statistics-- ----------------------------DROP TABLE IF EXISTS `wm_news_statistics`;CREATE TABLE `wm_news_statistics` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_id` int(11) unsigned DEFAULT NULL COMMENT &#x27;主账号ID&#x27;, `article` int(11) unsigned DEFAULT NULL COMMENT &#x27;子账号ID&#x27;, `read_count` int(11) unsigned DEFAULT NULL COMMENT &#x27;阅读量&#x27;, `comment` int(11) unsigned DEFAULT NULL COMMENT &#x27;评论量&#x27;, `follow` int(11) unsigned DEFAULT NULL COMMENT &#x27;关注量&#x27;, `collection` int(11) unsigned DEFAULT NULL COMMENT &#x27;收藏量&#x27;, `forward` int(11) unsigned DEFAULT NULL COMMENT &#x27;转发量&#x27;, `likes` int(11) unsigned DEFAULT NULL COMMENT &#x27;点赞量&#x27;, `unlikes` int(11) unsigned DEFAULT NULL COMMENT &#x27;不喜欢&#x27;, `unfollow` int(11) unsigned DEFAULT NULL COMMENT &#x27;取消关注量&#x27;, `burst` varchar(40) COLLATE utf8mb4_unicode_ci DEFAULT NULL, `created_time` date DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`) USING BTREE, UNIQUE KEY `idx_user_id_time` (`user_id`,`created_time`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;自媒体图文数据统计表&#x27;;-- ------------------------------ Records of wm_news_statistics-- ------------------------------ ------------------------------ Table structure for wm_user-- ----------------------------DROP TABLE IF EXISTS `wm_user`;CREATE TABLE `wm_user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `ap_user_id` int(11) DEFAULT NULL, `ap_author_id` int(11) DEFAULT NULL, `name` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;登录用户名&#x27;, `password` varchar(36) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;登录密码&#x27;, `salt` varchar(36) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;盐&#x27;, `nickname` varchar(2) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;昵称&#x27;, `image` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;头像&#x27;, `location` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;归属地&#x27;, `phone` varchar(36) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;手机号&#x27;, `status` tinyint(11) unsigned DEFAULT NULL COMMENT &#x27;状态\\r 0 暂时不可用\\r 1 永久不可用\\r 9 正常可用&#x27;, `email` varchar(20) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `type` tinyint(1) unsigned DEFAULT NULL COMMENT &#x27;账号类型\\r 0 个人 \\r 1 企业\\r 2 子账号&#x27;, `score` tinyint(3) unsigned DEFAULT NULL COMMENT &#x27;运营评分&#x27;, `login_time` datetime DEFAULT NULL COMMENT &#x27;最后一次登录时间&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1120 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT=&#x27;自媒体用户信息表&#x27;;-- ------------------------------ Records of wm_user-- ----------------------------INSERT INTO `wm_user` VALUES (&#x27;1100&#x27;, null, null, &#x27;zhangsan&#x27;, &#x27;ab8c7c1e66a164ab6891b927550ea39a&#x27;, &#x27;abc&#x27;, &#x27;小张&#x27;, null, null, &#x27;13588996789&#x27;, &#x27;1&#x27;, null, null, null, &#x27;2020-02-17 23:51:15&#x27;, &#x27;2020-02-17 23:51:18&#x27;);INSERT INTO `wm_user` VALUES (&#x27;1101&#x27;, null, null, &#x27;lisi&#x27;, &#x27;a6ecab0c246bbc87926e0fba442cc014&#x27;, &#x27;def&#x27;, &#x27;小李&#x27;, null, null, &#x27;13234567656&#x27;, &#x27;1&#x27;, null, null, null, null, null);INSERT INTO `wm_user` VALUES (&#x27;1102&#x27;, null, null, &#x27;admin&#x27;, &#x27;a66abb5684c45962d887564f08346e8d&#x27;, &#x27;123456&#x27;, &#x27;管理&#x27;, null, null, &#x27;13234567657&#x27;, &#x27;1&#x27;, null, null, null, null, &#x27;2020-03-14 09:35:13&#x27;);INSERT INTO `wm_user` VALUES (&#x27;1118&#x27;, null, null, &#x27;lisi1&#x27;, &#x27;123&#x27;, &#x27;123&#x27;, null, null, null, null, null, null, null, null, null, null);INSERT INTO `wm_user` VALUES (&#x27;1119&#x27;, null, null, &#x27;shaseng&#x27;, &#x27;1234&#x27;, null, null, null, null, null, null, null, null, null, null, null); 自媒体后端搭建创建模块在leadnews-service中创建子模块leadnews-wemedia，子模块中创建包com.swx.wemedia 创建启动类 @SpringBootApplication@EnableDiscoveryClient@MapperScan(&quot;com.swx.wemedia.mapper&quot;)public class WemediaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WemediaApplication.class, args); &#125;&#125; 配置文件 bootstrap.yamlserver: port: 51803spring: application: name: leadnews-wemedia cloud: nacos: discovery: server-addr: xxx.xxx.xxx.xxx:8848 config: server-addr: xxx.xxx.xxx.xxx:8848 file-extension: yml 在Nacos配置中心添加如下配置：http://ip:8848/nacos spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/leadnews_wemedia?serverTimezone=GMT%2B8&amp;useSSL=false&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: xxxxxxxxmybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.model.wemedia.pojo 代码生成在test中创建代码生成工具类，生成基本代码： public class CodeGenerate &#123; public static void OnMac() &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setAuthor(&quot;sw-code&quot;); gc.setOpen(false); // 是否打开文件资源管理器 gc.setFileOverride(true); // 是否覆盖 gc.setServiceName(&quot;%sService&quot;); // 去Service的I前缀 gc.setSwagger2(false); // 实体属性 Swagger2 注解 gc.setIdType(IdType.AUTO); // 主键策略 gc.setDateType(DateType.ONLY_DATE); // 定义生成的实体类中日期类型 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql:///leadnews_wemedia?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;nullCatalogMeansCurrent=true&quot;); // dsc.setSchemaName(&quot;public&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;xxxxxx&quot;); mpg.setDataSource(dsc); /* * 包配置 * 简单来讲 就是写绝对路径 */ PackageConfig pc = new PackageConfig(); // pc.setModuleName(&quot;code&quot;); pc.setParent(&quot;com.swx&quot;); //指定生成文件的绝对路径 Map&lt;String, String&gt; pathInfo = new HashMap&lt;&gt;(); String packageName = &quot;wemedia&quot;; String parentPath = &quot;/src/main/java/com/swx&quot;; String otherPath =&quot;/leadnews-service/leadnews-wemedia/src/main/java/com/swx/&quot; + packageName; String entityPackageName = &quot;wemedia&quot;; pc.setEntity(&quot;model.&quot; + entityPackageName + &quot;.pojo&quot;); pc.setMapper(packageName + &quot;.mapper&quot;); pc.setService(packageName + &quot;.service&quot;); pc.setServiceImpl(packageName + &quot;.service.impl&quot;); pc.setController(packageName + &quot;.controller.v1&quot;); String entityPath = projectPath.concat(&quot;/leadnews-model&quot;).concat(parentPath).concat(&quot;/model/&quot; + entityPackageName + &quot;/pojo&quot;); String mapper_path = projectPath.concat(otherPath).concat(&quot;/mapper&quot;); String mapper_xml_path = projectPath.concat(&quot;/leadnews-service/leadnews-wemedia&quot;).concat(&quot;/src/main/resources/mapper&quot;); String service_path = projectPath.concat(otherPath).concat(&quot;/service&quot;); String service_impl_path = projectPath.concat(otherPath).concat(&quot;/service/impl&quot;); String controller_path = projectPath.concat(otherPath).concat(&quot;/controller/v1&quot;); pathInfo.put(&quot;entity_path&quot;,entityPath); pathInfo.put(&quot;mapper_path&quot;,mapper_path); pathInfo.put(&quot;xml_path&quot;,mapper_xml_path); pathInfo.put(&quot;service_path&quot;,service_path); pathInfo.put(&quot;service_impl_path&quot;,service_impl_path); pathInfo.put(&quot;controller_path&quot;,controller_path); pc.setPathInfo(pathInfo); mpg.setPackageInfo(pc); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;wm_user&quot;); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 字段注解 strategy.setEntityTableFieldAnnotationEnable(true); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); mpg.execute(); &#125; public static void main(String[] args) &#123; OnMac(); &#125;&#125; 编写登陆接口接受参数实体类 wemedia.dto.WmLoginDTO@Datapublic class WmLoginDTO &#123; private String name; private String password;&#125; 定义Service接口 WmUserServicepublic interface WmUserService extends IService&lt;WmUser&gt; &#123; /** * 自媒体端登录 * @param dto 参数：用户名和密码 * @return 用户信息 */ public Map&lt;String,Object&gt; login(WmLoginDTO dto);&#125; 实现Service接口 public class WmUserServiceImpl extends ServiceImpl&lt;WmUserMapper, WmUser&gt; implements WmUserService &#123; @Override public Map&lt;String,Object&gt; login(WmLoginDTO dto) &#123; //1.检查参数 if(StringUtils.isBlank(dto.getName()) || StringUtils.isBlank(dto.getPassword()))&#123; throw new BizException(ResultCodeEnum.PARAM_INVALID.code(), &quot;用户名或密码为空&quot;); &#125; //2.查询用户 WmUser wmUser = getOne(Wrappers.&lt;WmUser&gt;lambdaQuery().eq(WmUser::getName, dto.getName())); if(wmUser == null)&#123; throw new BizException(ResultCodeEnum.DATA_NOT_EXIST); &#125; //3.比对密码 String salt = wmUser.getSalt(); String pswd = dto.getPassword(); pswd = DigestUtils.md5DigestAsHex((pswd + salt).getBytes()); if(pswd.equals(wmUser.getPassword()))&#123; //4.返回数据 jwt Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;, AppJwtUtil.getToken(wmUser.getId().longValue())); wmUser.setSalt(&quot;&quot;); wmUser.setPassword(&quot;&quot;); map.put(&quot;user&quot;,wmUser); return map; &#125;else &#123; throw new BizException(ResultCodeEnum.LOGIN_PWD_ERROR); &#125; &#125;&#125; 编写Controller LoginController/** * &lt;p&gt; * 自媒体用户信息表 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-06 */@RestController@ResponseResult@RequestMapping(&quot;/login&quot;)public class LoginController &#123; private final WmUserService wmUserService; public LoginController(WmUserService wmUserService) &#123; this.wmUserService = wmUserService; &#125; @PostMapping(&quot;/in&quot;) public Map&lt;String, Object&gt; login(@RequestBody WmLoginDTO dto) &#123; return wmUserService.login(dto); &#125;&#125; 自媒体前端搭建下载前端项目，下载完成后，解压到Nginx的html目录 下载地址：https://wwab.lanzoue.com/ibO7U14n48ta 编辑配置文件 Mac的Nginx配置文件路径：/usr/local/etc/nginx/ 在leadnews.conf文件下创建新的配置文件leadnews-wemedia.conf，内容如下： upstream leadnews-wemedia-gateway &#123; server localhost:51602;&#125;server &#123; listen 8802; location / &#123; root html/wemedia-web/; index index.html; &#125; location ~/wemedia/MEDIA/(.*) &#123; proxy_pass http://leadnews-wemedia-gateway/$1; proxy_set_header HOST $host; # 不改变源请求头的值 proxy_pass_request_body on; # 开启获取请求体 proxy_pass_request_headers on; # 开启获取请求头 proxy_set_header X-Real-IP $remote_addr; # 记录真实发出请求的客户端IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 记录代理信息 &#125;&#125; 重启Nginx，浏览器访问：http://localhost:8802 自媒体素材管理展示素材信息，可以进行图片上传 对应sql表为wm_material，表结构如下： CREATE TABLE `wm_material` ( `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_id` int unsigned DEFAULT NULL COMMENT &#x27;自媒体用户ID&#x27;, `url` varchar(255) CHARACTER DEFAULT NULL COMMENT &#x27;图片地址&#x27;, `type` tinyint unsigned DEFAULT NULL COMMENT &#x27;素材类型 0图片 1视频&#x27;, `is_collection` tinyint(1) DEFAULT NULL COMMENT &#x27;是否收藏&#x27;, `created_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB COMMENT=&#x27;自媒体图文素材信息表&#x27;; 实现思路 修改网关的过滤器，在放行前添加如下代码 // 获取用户信息Object userId = claimsBody.get(&quot;id&quot;);ServerHttpRequest serverHttpRequest = request.mutate().headers(httpHeaders -&gt; &#123; httpHeaders.add(&quot;userId&quot;, userId + &quot;&quot;);&#125;).build();// 重置请求exchange.mutate().request(serverHttpRequest); 完善自媒体微服务首先使用代码生成工具生成对应的基础文件 创建拦截器 WmTokenInterceptorpublic class WmTokenInterceptor implements HandlerInterceptor &#123; /** * 获取header中的用户信息，并且存入到当前线程中 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String userId = request.getHeader(&quot;userId&quot;); if (userId != null) &#123; // 存入到当前线程中 IdThreadUtil.setId(Long.valueOf(userId)); &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; IdThreadUtil.clear(); &#125;&#125; 其中线程工具可在leadnews-utils模块中创建 thread.IdThreadUtilpackage com.swx.utils.thread;public class IdThreadUtil &#123; private final static ThreadLocal&lt;Long&gt; USER_ID_THREAD_LOCAL = new ThreadLocal&lt;&gt;(); public static void setId(Long userId) &#123; USER_ID_THREAD_LOCAL.set(userId); &#125; // 从线程中获取 public static Long getId() &#123; return USER_ID_THREAD_LOCAL.get(); &#125; // 清理 public static void clear() &#123; USER_ID_THREAD_LOCAL.remove(); &#125;&#125; 注册拦截器 创建配置文件：WebMvcConfig，内容如下： @Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new WmTokenInterceptor()) .addPathPatterns(&quot;/**&quot;); &#125;&#125; 图片上传接口定义 说明 接口路径 &#x2F;api&#x2F;v1&#x2F;material&#x2F;upload_picture 请求方式 POST 参数 MultipartFile 响应结果 R 添加MinIO 首先在leadnews-wemedia的pom文件中添加依赖信息 pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;leadnews-file-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在Nacos中找到leadnews-wemedia配置，添加MinIO配置信息 minio: accessKey: minio secretKey: minio123 bucket: leadnews endpoint: http://ip:9000 readPath: http://ip:9000 注意修改IP 定义Service接口 WmMaterialServicepublic interface WmMaterialService extends IService&lt;WmMaterial&gt; &#123; /** * 图片上传 * * @param multipartFile 文件信息 * @return */ public WmMaterial uploadPicture(MultipartFile multipartFile);&#125; 实现Service接口 WmMaterialServiceImpl@Slf4j@Servicepublic class WmMaterialServiceImpl extends ServiceImpl&lt;WmMaterialMapper, WmMaterial&gt; implements WmMaterialService &#123; private final FileStorageService fileStorageService; public WmMaterialServiceImpl(FileStorageService fileStorageService) &#123; this.fileStorageService = fileStorageService; &#125; /** * 图片上传 * * @param multipartFile 文件信息 * @return */ @Override public WmMaterial uploadPicture(MultipartFile multipartFile) &#123; // 参数校验 if (multipartFile == null || multipartFile.getSize() == 0) &#123; throw new BizException(ResultCodeEnum.PARAM_INVALID); &#125; // 上传图片到minIO中 String filename = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); String originalFilename = multipartFile.getOriginalFilename(); String prefix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)); String fileId = null; try &#123; fileId = fileStorageService.uploadImgFile(&quot;&quot;, filename + prefix, multipartFile.getInputStream()); log.info(&quot;上传图片到MinIO中，fileId: &#123;&#125;&quot;, fileId); &#125; catch (IOException e) &#123; e.printStackTrace(); log.info(&quot;WmMaterialServiceImpl-上传文件失败&quot;); &#125; // 保持到数据库中 WmMaterial wmMaterial = new WmMaterial(); // 获取userId wmMaterial.setUserId(IdThreadUtil.getId().intValue()); wmMaterial.setUrl(fileId); wmMaterial.setIsCollection((short)0); wmMaterial.setType(0); wmMaterial.setCreatedTime(new Date()); save(wmMaterial); return wmMaterial; &#125;&#125; 完善图片上传服务接口Controller WmMaterialController@RestController@ResponseResult@RequestMapping(&quot;/api/v1/material&quot;)public class WmMaterialController &#123; private final WmMaterialService wmMaterialService; public WmMaterialController(WmMaterialService wmMaterialService) &#123; this.wmMaterialService = wmMaterialService; &#125; @PostMapping(&quot;/upload_picture&quot;) public WmMaterial uploadPicture(MultipartFile multipartFile) &#123; return wmMaterialService.uploadPicture(multipartFile); &#125;&#125; 素材列表接口定义 说明 接口路径 &#x2F;api&#x2F;v1&#x2F;material&#x2F;list 请求方式 POST 参数 WmMaterialDTO 响应结果 PageR 定义Service方法 WmMaterialService/** * 素材列表查询 * * @param dto 参数 */public PageR findList(WmMaterialDTO dto); 实现Service方法 /** * 素材列表查询 * * @param dto 参数 */@Overridepublic PageR findList(WmMaterialDTO dto) &#123; // 检查参数 dto.checkParam(); // 分页查询 IPage&lt;WmMaterial&gt; page = new Page&lt;&gt;(dto.getPage(), dto.getSize()); LambdaQueryWrapper&lt;WmMaterial&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); if (dto.getIsCollection() != null &amp;&amp; dto.getIsCollection() == 1) &#123; wrapper.eq(WmMaterial::getIsCollection, dto.getIsCollection()); &#125; // 安装用户查询 wrapper.eq(WmMaterial::getUserId, IdThreadUtil.getId()).orderByDesc(WmMaterial::getCreatedTime); page = page(page, wrapper); PageR pageR = new PageR(dto.getPage(), dto.getSize(), (int) page.getTotal()); pageR.setData(page.getRecords()); return pageR;&#125; 完善列表服务接口Controller @PostMapping(&quot;/list&quot;)public PageR findList(@RequestBody WmMaterialDTO dto) &#123; return wmMaterialService.findList(dto);&#125; 频道列表接口定义 说明 接口路径 &#x2F;api&#x2F;v1&#x2F;channel&#x2F;channels 请求方式 GET 响应结果 R 使用代码生成器生成wm_channel表的基础代码 完善Controller，提供查询所有频道服务 WmChannelController@RestController@ResponseResult@RequestMapping(&quot;/api/v1/channel&quot;)public class WmChannelController &#123; private final WmChannelService wmChannelService; public WmChannelController(WmChannelService wmChannelService) &#123; this.wmChannelService = wmChannelService; &#125; @GetMapping(&quot;/channels&quot;) public List&lt;WmChannel&gt; findAll() &#123; return wmChannelService.list(); &#125;&#125; 文章列表接口定义 说明 接口路径 &#x2F;api&#x2F;v1&#x2F;news&#x2F;list 请求方式 POST 参数 WmNewsDTO 响应结果 PageR 使用代码生成器生成wm_news表的基础代码 实体类中添加枚举 @Alias(&quot;WmNewsStatus&quot;)public enum Status &#123; NORMAL((short) 0, &quot;草稿&quot;), SUBMIT((short) 1, &quot;提交（待审核）&quot;), FAIL((short) 2, &quot;审核失败&quot;), ADMIN_AUTH((short) 3, &quot;人工审核&quot;), ADMIN_SUCCESS((short) 4, &quot;人工审核通过&quot;), SUCCESS((short) 8, &quot;审核通过（待发布）&quot;), PUBLISHED((short) 9, &quot;已发布&quot;); short code; String desc; Status(short code, String desc) &#123; this.code = code; &#125; public short getCode() &#123; return this.code; &#125;&#125; 创建参数DTO WmNewsPageReqDTO@Data@EqualsAndHashCode(callSuper = true)public class WmNewsPageReqDTO extends PageDTO &#123; /** * 状态 */ private Short status; /** * 开始时间 */ private Date beginPubData; /** * 结束时间 */ private Date endPubData; /** * 所属频道 */ private Integer channelId; /** * 关键字 */ private String keyword;&#125; Service接口方法 WmNewsService/** * 条件查询文章列表 * @param dto 查询条件 * @return 分页信息 */public PageR findList(WmNewsPageReqDTO dto); 实现Service方法 WmNewsServiceImpl/** * 条件查询文章列表 * * @param dto 查询条件 * @return 分页信息 */@Overridepublic PageR findList(WmNewsPageReqDTO dto) &#123; // 检查参数 dto.checkParam(); IPage&lt;WmNews&gt; page = new Page&lt;&gt;(dto.getPage(), dto.getSize()); LambdaQueryWrapper&lt;WmNews&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper // 状态精确查询 .eq(dto.getStatus() != null, WmNews::getStatus, dto.getStatus()) // 频道精确查询 .eq(dto.getChannelId() != null, WmNews::getChannelId, dto.getChannelId()) // 时间范围查询 .between(dto.getBeginPubData() != null &amp;&amp; dto.getEndPubData() != null, WmNews::getPublishTime, dto.getBeginPubData(), dto.getEndPubData()) // 关键字的模糊查询 .like(StringUtils.hasText(dto.getKeyword()), WmNews::getTitle, dto.getKeyword()) // 按照发布时间倒叙查询 .eq(WmNews::getUserId, IdThreadUtil.getId()) .orderByDesc(WmNews::getCreatedTime); page = page(page, wrapper); PageR pageR = new PageR(dto.getPage(), dto.getSize(), (int)page.getTotal()); pageR.setData(page.getRecords()); return pageR;&#125; 提供条件查询文章列表的服务 WmNewsController@RestController@ResponseResult@RequestMapping(&quot;/api/v1/news&quot;)public class WmNewsController &#123; private final WmNewsService wmNewsService; public WmNewsController(WmNewsService wmNewsService) &#123; this.wmNewsService = wmNewsService; &#125; @PostMapping(&quot;/list&quot;) public PageR findAll(@RequestBody WmNewsPageReqDTO dto) &#123; return wmNewsService.findList(dto); &#125;&#125; 文章发布、修改、保存草稿该功能为保存、修改（是否有id）、保存草稿的共有方法 接口定义 说明 接口路径 &#x2F;api&#x2F;v1&#x2F;news&#x2F;submit 请求方式 POST 参数 WmNewsDto 响应结果 R 接受参数 WmNewsDTO@Datapublic class WmNewsDTO &#123; private Integer id; /** * 标题 */ private String title; /** * 频道ID */ private Integer channelId; /** * 文章标签 */ private String labels; /** * 发布时间 */ private Data publishTime; /** * 文章内容 */ private String content; /** * 文章封面类型，0 无图 1 单图 3 多图 -1 自动 */ private Short type; // 封面图片列表，多张图以逗号分隔开 private List&lt;String&gt; images;&#125; 定义Service接口 WmNewsSubmitService/** * 处理文章提交的逻辑，解决循环依赖问题 */public interface WmNewsSubmitService &#123; /** * 保存、修改文章或保存为草稿 * @param dto 文章信息 */ public void submitNews(WmNewsDTO dto);&#125; 实现该方法 WmNewsSubmitServiceImpl@Slf4j@Servicepublic class WmNewsSubmitServiceImpl implements WmNewsSubmitService &#123; private final WmNewsMaterialMapper wmNewsMaterialMapper; private final WmMaterialMapper wmMaterialMapper; private final WmNewsTaskService wmNewsTaskService; private final WmNewsService wmNewsService; public WmNewsSubmitServiceImpl(WmNewsMaterialMapper wmNewsMaterialMapper, WmMaterialMapper wmMaterialMapper, WmNewsTaskService wmNewsTaskService, WmNewsService wmNewsService) &#123; this.wmNewsMaterialMapper = wmNewsMaterialMapper; this.wmMaterialMapper = wmMaterialMapper; this.wmNewsTaskService = wmNewsTaskService; this.wmNewsService = wmNewsService; &#125; /** * 保存、修改文章或保存为草稿 * * @param dto 文章信息 */ @Override @Transactional(rollbackFor = Exception.class) public void submitNews(WmNewsDTO dto) &#123; if (dto == null || dto.getContent() == null) &#123; throw new BizException(ResultCodeEnum.PARAM_INVALID); &#125; WmNews wmNews = new WmNews(); BeanUtils.copyProperties(dto, wmNews); if (dto.getImages() != null &amp;&amp; !dto.getImages().isEmpty()) &#123; String imgStr = StringUtils.join(dto.getImages(), &quot;,&quot;); wmNews.setImages(imgStr); &#125; if (dto.getType().equals(WmNewsTypeEnum.AUTO.getType())) &#123; wmNews.setType(null); &#125; saveOrUpdateWmNews(wmNews); // 草稿 if (dto.getStatus().equals(WmNews.Status.NORMAL.code())) &#123; return; &#125; // 不是草稿，保存文章内容图片与素材的关系 List&lt;String&gt; materials = extractUrlInfo(dto.getContent()); saveRelativeInfoForContent(materials, wmNews.getId()); // 不是草稿，保存文章封面与素材的关系，布局自动，需要从内容中提起封面 saveRelativeInfoForCover(dto, wmNews, materials); &#125; /** * 保存或修改文章 * * @param wmNews 文章 */ public void saveOrUpdateWmNews(WmNews wmNews) &#123; wmNews.setUserId(IdThreadUtil.getId().intValue()); wmNews.setCreatedTime(new Date()); wmNews.setSubmitedTime(new Date()); wmNews.setEnable((short) 1); if (wmNews.getId() == null) &#123; // 保存 wmNewsService.save(wmNews); &#125; else &#123; // 修改 // 删除文章图片与素材的关系 wmNewsMaterialMapper.delete(Wrappers.&lt;WmNewsMaterial&gt;lambdaQuery().eq(WmNewsMaterial::getNewsId, wmNews.getId())); wmNewsService.updateById(wmNews); &#125; &#125; /** * 提取文章内容中图片信息 * * @param content 文章内容 * @return 图片URL列表 */ private List&lt;String&gt; extractUrlInfo(String content) &#123; List&lt;String&gt; materials = new ArrayList&lt;&gt;(); List&lt;Map&gt; maps = JSON.parseArray(content, Map.class); for (Map map : maps) &#123; if (map.get(&quot;type&quot;).equals(&quot;image&quot;)) &#123; String imgUrl = (String) map.get(&quot;value&quot;); materials.add(imgUrl); &#125; &#125; return materials; &#125; /** * 1.封面类型为自动，则从内容中提取封面信息 * 提取规则 * - 内容素材大于等于1，小于3 单图 type=1 * - 内容素材大于等于3 多图 type=3 * - 如果内容没有素材 无图 type=0 * 2.保存封面图片和素材的关系 * * @param dto 封面类型 * @param wmNews 文章 * @param materials 内容中的素材 */ private void saveRelativeInfoForCover(WmNewsDTO dto, WmNews wmNews, List&lt;String&gt; materials) &#123; List&lt;String&gt; covers = dto.getImages(); if (dto.getType().equals(WmNewsTypeEnum.AUTO.getType())) &#123; // 多图 if (materials.size() &gt;= 3) &#123; wmNews.setType(WmNewsTypeEnum.MULTI_IMAGE.getType()); covers = materials.stream().limit(3).collect(Collectors.toList()); &#125; else if (!materials.isEmpty()) &#123; // 单图 wmNews.setType(WmNewsTypeEnum.SINGLE_IMAGE.getType()); covers = materials.stream().limit(1).collect(Collectors.toList()); &#125; else &#123; // 无图 wmNews.setType(WmNewsTypeEnum.NONE_IMAGE.getType()); &#125; // 修改文章 if (covers != null &amp;&amp; !covers.isEmpty()) &#123; wmNews.setImages(StringUtils.join(covers, &quot;,&quot;)); &#125; wmNewsService.updateById(wmNews); &#125; saveRelativeInfo(covers, wmNews.getId(), WmNewsMaterialReferenceEnum.COVER_REFERENCE.getRef()); &#125; /** * 保存内容中素材和文章的关系 * * @param materials 素材url * @param newsId 文章ID */ public void saveRelativeInfoForContent(List&lt;String&gt; materials, Integer newsId) &#123; saveRelativeInfo(materials, newsId, WmNewsMaterialReferenceEnum.CONTENT_REFERENCE.getRef()); &#125; /** * 保存文章与素材的关系 * * @param materials 素材 * @param newsId 文章ID * @param ref 哪种关系 */ private void saveRelativeInfo(List&lt;String&gt; materials, Integer newsId, Short ref) &#123; if (materials == null || materials.isEmpty()) &#123; return; &#125; List&lt;WmMaterial&gt; dbMaterials = wmMaterialMapper.selectList(Wrappers.&lt;WmMaterial&gt;lambdaQuery().in(WmMaterial::getUrl, materials)); // 判断素材是否有效 if (dbMaterials == null || dbMaterials.isEmpty()) &#123; throw new BizException(ResultCodeEnum.MATERIAL_REFERENCE_FAIL); &#125; if (materials.size() != dbMaterials.size()) &#123; throw new BizException(ResultCodeEnum.MATERIAL_REFERENCE_FAIL); &#125; List&lt;Integer&gt; idList = dbMaterials.stream().map(WmMaterial::getId).collect(Collectors.toList()); wmNewsMaterialMapper.saveRelations(idList, newsId, WmNewsMaterialReferenceEnum.CONTENT_REFERENCE.getRef()); &#125;&#125; 文章与素材关联表的操作Mapper WmNewsMaterialMapper@Mapperpublic interface WmNewsMaterialMapper extends BaseMapper&lt;WmNewsMaterial&gt; &#123; void saveRelations(@Param(&quot;materialIds&quot;)List&lt;Integer&gt; materialIds, @Param(&quot;newsId&quot;) Integer newsId, @Param(&quot;type&quot;) Short type);&#125; 实现该Mapper的XML &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.wemedia.mapper.WmNewsMaterialMapper&quot;&gt; &lt;insert id=&quot;saveRelations&quot;&gt; INSERT INTO wm_news_material (material_id, news_id, type, ord) VALUES &lt;foreach collection=&quot;materialIds&quot; index=&quot;ord&quot; item=&quot;mid&quot; separator=&quot;,&quot;&gt; (#&#123;mid&#125;, #&#123;newsId&#125;, #&#123;type&#125;, #&#123;ord&#125;) &lt;/foreach&gt; &lt;/insert&gt;&lt;/mapper&gt; Service中使用的枚举类 文章布局类型 WmNewsTypeEnumpublic enum WmNewsTypeEnum &#123; NONE_IMAGE((short) 0, &quot;无图&quot;), SINGLE_IMAGE((short) 1, &quot;单图&quot;), MULTI_IMAGE((short) 2, &quot;多图&quot;), AUTO((short) -1, &quot;自动&quot;); private final Short type; private final String desc; WmNewsMaterialTypeEnum(Short type, String desc) &#123; this.type = type; this.desc = desc; &#125; public Short getType() &#123; return type; &#125; public String getDesc() &#123; return desc; &#125;&#125; 文章素材引用关系 WmNewsMaterialReferenceEnumpublic enum WmNewsMaterialReferenceEnum &#123; CONTENT_REFERENCE((short) 0, &quot;内容引用&quot;), COVER_REFERENCE((short) 1, &quot;封面引用&quot;); private final Short ref; private final String desc; WmNewsMaterialReferenceEnum(Short ref, String desc) &#123; this.ref = ref; this.desc = desc; &#125; public Short getRef() &#123; return ref; &#125; public String getDesc() &#123; return desc; &#125;&#125; 提供文章发布、修改、保存草稿的服务 WmNewsController@PostMapping(&quot;/submit&quot;)public void submitNews(@RequestBody WmNewsDTO dto) &#123; wmNewsService.submitNews(dto);&#125; 文章审核自媒体保存的文章，用户查询到需要经历审核步骤：包括文本审核和图片审核。 审核设计的关键技术 第三方内容安全审核接口 分布式主键 异步调用 feign远程接口 熔断降级 自动审核：文章发布之后，系统自动审核，主要是通过第三方接口对文章内容进行审核（成功、失败、不确定）。 人工审核：待自动审核返回不确定信息时，转到人工审核，由平台管理员进行审核。 自动审核的流程 阿里云的内容审核需要企业认证，这里直接跳过 APP端文章保存随着业务的增长，文章表可能要占用很大的物理存储空间，为了解决该问题，后期使用数据库分片技术。将一个数据库进行拆分，通过数据库中间件连接。如果数据库中该表选用ID自增策略，则可能产生重复的ID，此时应该使用分布式ID生成策略来生成ID。 分布式ID-技术选型 方案 优势 劣势 redis （INCR）生成一个全局连续递增 的数字类型主键 增加了一个外部组件的依赖，Redis不可用，则整个数据库将无法在插入 UUID 全局唯一，Mysql也有UUID实现 36个字符组成，占用空间大 snowflake算法 全局唯一 ，数字类型，存储成本低 机器规模大于1024台无法支持 项目中使用雪花(snowflake)算法解决分布式ID 将ApArticle、ApArticleConfig、ApArticleContent实体类的主键策略更改为ASSIGN_ID @TableId(value = &quot;id&quot;, type = IdType.ASSIGN_ID)private Long id; 在配置中心中配置数据中心ID和机器ID mybatis-plus: global-config: datacenter-id: 1 workerId: 1 接口定义 说明 接口路径 &#x2F;api&#x2F;v1&#x2F;article&#x2F;save 请求方式 POST 参数 ArticleDto 响应结果 R 定义Service方法 ApArticleService/** * 保存APP端相关文章 * * @param dto 文章信息 */public Long saveArticle(ArticleDTO dto); 实现Service方法 /** * 保存APP端相关文章 * * @param dto 文章信息 */@Transactional(rollbackFor = RuntimeException.class)@Overridepublic Long saveArticle(ArticleDTO dto) &#123; if (dto == null) &#123; throw new BizException(ResultCodeEnum.PARAM_INVALID); &#125; ApArticle apArticle = new ApArticle(); BeanUtils.copyProperties(dto, apArticle); if (dto.getId() == null) &#123; // 不存在ID，保存 save(apArticle); // 保存文章配置 ApArticleConfig apArticleConfig = new ApArticleConfig(apArticle.getId()); apArticleConfigMapper.insert(apArticleConfig); // 保存文章内容 ApArticleContent apArticleContent = new ApArticleContent(); apArticleContent.setArticleId(apArticle.getId()); apArticleContent.setContent(dto.getContent()); apArticleContentMapper.insert(apArticleContent); &#125; else &#123; // 存在ID，修改 updateById(apArticle); // 修改文章内容 ApArticleContent apArticleContent = apArticleContentMapper.selectOne( Wrappers.&lt;ApArticleContent&gt;lambdaQuery().eq(ApArticleContent::getArticleId, apArticle.getId())); apArticleContent.setContent(dto.getContent()); apArticleContentMapper.updateById(apArticleContent); &#125; return apArticle.getId();&#125; Feign接口定义在leadnews-feign-api模块中创建包com.swx.apis.article 在该包下创建IArticleClient接口，内容如下： IArticleClient@FeignClient(&quot;leadnews-article&quot;)public interface IArticleClient &#123; @PostMapping(&quot;/api/v1/article/save&quot;) public R saveArticle(ArticleDTO dto);&#125; 在leadnews-article模块中实现该方法 feign.ArticleClient@RestControllerpublic class ArticleClient implements IArticleClient &#123; private final ApArticleService apArticleService; public ArticleClient(ApArticleService apArticleService) &#123; this.apArticleService = apArticleService; &#125; @PostMapping(&quot;/api/v1/article/save&quot;) @Override public R saveArticle(@RequestBody ArticleDTO dto) &#123; Long articleId = apArticleService.saveArticle(dto); return R.success(articleId); &#125;&#125; 百度云自动审核 文本审核接口地址：https://aip.baidubce.com/rest/2.0/solution/v1/text_censor/v2/user_defined请求方式：POST接口名称：内容审核平台-文本响应结果： &#123;\t&quot;log_id&quot;: 15556561295920002,\t&quot;conclusion&quot;: &quot;合规&quot;,\t&quot;conclusionType&quot;: 1&#125; 图像审核接口地址：https://aip.baidubce.com/rest/2.0/solution/v1/img_censor/v2/user_defined请求方式：POST接口名称：内容审核平台-图像响应结果： &#123;\t&quot;log_id&quot;: 15556561295920003,\t&quot;conclusion&quot;: &quot;合规&quot;,\t&quot;conclusionType&quot;: 1&#125; 申请百度云资源 内容审核需要申请到百度云的权限 百度云资源免费领取：领取地址 获取AccessToken 在leadnews-common模块中添加com.swx.common.baiduyun包，包下创建AithUtil类 public class AuthUtil &#123; private static Calendar expireDate; private static boolean flag = false; private static String accessToken; static final OkHttpClient HTTP_CLIENT = new OkHttpClient().newBuilder().build(); private static Boolean needAuth() &#123; Calendar c = Calendar.getInstance(); c.add(5, 1); return Boolean.valueOf(!flag || c.after(expireDate)); &#125; /** * 获取权限token * @return access_token */ public static String getAccessToken(String clientId, String clientSecret) throws Exception &#123; if (needAuth()) &#123; flag = true; accessToken = getAuth(clientId, clientSecret); &#125; return accessToken; &#125; /** * 从用户的AK，SK生成鉴权签名（Access Token） * * @return 鉴权签名（Access Token） * @throws IOException IO异常 */ private static String getAuth(String clientId, String clientSecret) throws Exception &#123; MediaType mediaType = MediaType.parse(&quot;application/json&quot;); RequestBody body = RequestBody.create(mediaType, &quot;&quot;); Request request = new Request.Builder() .url(String.format(URLConstants.BAIDU_AUTH_TOKEN, clientId, clientSecret)) .method(&quot;POST&quot;, body) .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .addHeader(&quot;Accept&quot;, &quot;application/json&quot;) .build(); Response response = HTTP_CLIENT.newCall(request).execute(); if (response.code() != HttpStatus.OK.value()) &#123; throw new RuntimeException(&quot;百度云AccessToken获取失败&quot;); &#125; JSONObject result = JSONObject.parseObject(response.body().string()); String accessToken = result.getString(&quot;access_token&quot;); return accessToken; &#125;&#125; 需要添加okHttp3依赖： &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt;&lt;/dependency&gt; 创建自动配置类，内容审核服务 将所需接口地址定义为常量，可以放到leadnews-common模块中的com.swx.common.constants包下 URLConstantspublic class URLConstants &#123; public static final String BAIDU_AUTH_TOKEN = &quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s&quot;; public static final String BAIDU_TEXT_CENSOR = &quot;https://aip.baidubce.com/rest/2.0/solution/v1/text_censor/v2/user_defined?access_token=%s&quot;; public static final String BAIDU_IMG_CENSOR = &quot;https://aip.baidubce.com/rest/2.0/solution/v1/img_censor/v2/user_defined?access_token=%s&quot;;&#125; 将百度审核结果类型定义为枚举，可以放到leadnews-common模块中的com.swx.common.enums包下 public enum TextCensorResultEnum &#123; COMPLIANCE((short) 1, &quot;合规&quot;), NON_COMPLIANCE((short) 2, &quot;不合规&quot;), SUSPECTED((short) 3, &quot;疑似&quot;), AUDIT_FAILED((short) 4, &quot;审核失败&quot;); private final Short type; private final String desc; TextCensorResultEnum(Short type, String desc) &#123; this.type = type; this.desc = desc; &#125; public Short type() &#123; return type; &#125; public String desc() &#123; return desc; &#125;&#125; 内容审核服务 @Getter@Setter@Slf4j@Component@ConfigurationProperties(prefix = &quot;baiduyun&quot;)public class ContentCensor &#123; private String clientId; private String clientSecret; /** * 文本审核 * * @param text 待审核文本 * @return 审核结果 &#123; log_id, conclusion, conclusionType &#125; * @throws Exception 审核异常 */ public Map&lt;String, Object&gt; textCensor(String text) throws Exception &#123; String accessToken = AuthUtil.getAccessToken(clientId, clientSecret); FormBody formBody = new FormBody.Builder().add(&quot;text&quot;, text).build(); Request request = new Request.Builder() .url(String.format(URLConstants.BAIDU_TEXT_CENSOR, accessToken)) .method(&quot;POST&quot;, formBody) .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) .addHeader(&quot;Accept&quot;, &quot;application/json&quot;) .build(); Response response = AuthUtil.HTTP_CLIENT.newCall(request).execute(); String strBody = response.body().string(); if (response.code() != HttpStatus.OK.value()) &#123; JSONObject errObj = JSONObject.parseObject(strBody); log.error(&quot;百度文本审核接口调用失败：error_code: &#123;&#125;, error_msg: &#123;&#125;&quot;, errObj.getString(&quot;error_code&quot;), errObj.getString(&quot;error_msg&quot;)); throw new RuntimeException(&quot;百度文本审核接口调用失败&quot;); &#125; JSONObject resultObj = JSONObject.parseObject(strBody); Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put(&quot;log_id&quot;, resultObj.getString(&quot;log_id&quot;)); result.put(&quot;conclusion&quot;, resultObj.getString(&quot;conclusion&quot;)); result.put(&quot;conclusionType&quot;, resultObj.getShortValue(&quot;conclusionType&quot;)); return result; &#125; /** * 图像审核 * * @param imgParams 待审核图像列表 * @return 审核结果 &#123; log_id, conclusion, conclusionType &#125; * @throws Exception 审核异常 */ public Map&lt;String, Object&gt; imgCensor(List&lt;String&gt; imgParams) throws Exception &#123; String accessToken = AuthUtil.getAccessToken(clientId, clientSecret); Request.Builder builder = new Request.Builder() .url(String.format(URLConstants.BAIDU_IMG_CENSOR, accessToken)) .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) .addHeader(&quot;Accept&quot;, &quot;application/json&quot;); Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); for (String imgParam : imgParams) &#123; FormBody formBody = new FormBody.Builder().add(&quot;image&quot;, imgParam).build(); Request request = builder.method(&quot;POST&quot;, formBody).build(); Response response = AuthUtil.HTTP_CLIENT.newCall(request).execute(); String strBody = response.body().string(); if (response.code() != HttpStatus.OK.value()) &#123; JSONObject errObj = JSONObject.parseObject(strBody); log.error(&quot;百度图像审核接口调用失败：error_code: &#123;&#125;, error_msg: &#123;&#125;&quot;, errObj.getString(&quot;error_code&quot;), errObj.getString(&quot;error_msg&quot;)); throw new RuntimeException(&quot;百度文本审核接口调用失败&quot;); &#125; JSONObject resultObj = JSONObject.parseObject(strBody); Short conclusionType = resultObj.getShort(&quot;conclusionType&quot;); // 审核不是通过 if (!Objects.equals(conclusionType, TextCensorResultEnum.COMPLIANCE.type())) &#123; result.put(&quot;log_id&quot;, resultObj.getString(&quot;log_id&quot;)); result.put(&quot;conclusion&quot;, resultObj.getString(&quot;conclusion&quot;)); result.put(&quot;conclusionType&quot;, resultObj.getShortValue(&quot;conclusionType&quot;)); return result; &#125; &#125; result.put(&quot;conclusionType&quot;, TextCensorResultEnum.COMPLIANCE.type()); return result; &#125;&#125; 文章自动审核为了方便使用，定义一下几个枚举类 文章内容类型： WmNewsContentTypeEnumpublic enum WmNewsContentTypeEnum &#123; TEXT(&quot;text&quot;, &quot;文本&quot;), IMAGE(&quot;image&quot;, &quot;图片&quot;); private String type; private String desc; WmNewsContentTypeEnum(String type, String desc) &#123; this.type = type; this.desc = desc; &#125; public String getType() &#123; return type; &#125; public String getDesc() &#123; return desc; &#125;&#125; 定义文章自动审核Service WmNewsAutoScanServicepublic interface WmNewsAutoScanService &#123; /** * 自媒体文章审核 * * @param id 自媒体文章ID */ public void autoScanWmNews(Integer id);&#125; 实现该接口 @Servicepublic class WmNewsAutoScanServiceImpl implements WmNewsAutoScanService &#123; private final WmNewsService wmNewsService; private final ContentCensor contentCensor; private final FileStorageService fileStorageService; private final IArticleClient articleClient; private final WmChannelService wmChannelService; private final WmUserService wmUserService; public WmNewsAutoScanServiceImpl(WmNewsService wmNewsService, ContentCensor contentCensor, FileStorageService fileStorageService, IArticleClient articleClient, WmChannelService wmChannelService, WmUserService wmUserService) &#123; this.wmNewsService = wmNewsService; this.contentCensor = contentCensor; this.fileStorageService = fileStorageService; this.articleClient = articleClient; this.wmChannelService = wmChannelService; this.wmUserService = wmUserService; &#125; /** * 自媒体文章审核 * * @param id 自媒体文章ID */ @Override @Transactional(rollbackFor = RuntimeException.class) public void autoScanWmNews(Integer id) &#123; // 查询文章 WmNews wmNews = wmNewsService.getById(id); if (wmNews == null) &#123; throw new RuntimeException(&quot;WmNewsAutoScanServiceImpl-文章不存在&quot;); &#125; if (!wmNews.getStatus().equals(WmNews.Status.SUBMIT.code())) &#123; return; &#125; // 从内容中提取文本和图片 Map&lt;String, Object&gt; textAndImages = handleTextAndImages(wmNews); // 审核文本内容 boolean isTextScan = handleTextScan((String) textAndImages.get(&quot;text&quot;), wmNews); if (!isTextScan) return; // 审核图片 boolean isImageScan = handleImageScan((List&lt;String&gt;) textAndImages.get(&quot;image&quot;), wmNews); if (!isImageScan) return; // 审核成功，保存APP端的相关文章数据 R r = saveAppArticle(wmNews); if (!r.getCode().equals(ResultCodeEnum.SUCCESS.code())) &#123; throw new RuntimeException(&quot;WmNewsAutoScanServiceImpl-文章审核失败， 保存app端相关文章数据失败&quot;); &#125; // 回填article_id wmNews.setArticleId((Long) r.getData()); updateWmNews(wmNews, WmNews.Status.PUBLISHED.code(), &quot;审核成功&quot;); &#125; /** * 保存APP端的相关文章数据 * @param wmNews 文章数据 */ private R saveAppArticle(WmNews wmNews) &#123; ArticleDTO articleDTO = new ArticleDTO(); BeanUtils.copyProperties(wmNews, articleDTO); articleDTO.setLayout(wmNews.getType()); WmChannel wmChannel = wmChannelService.getById(wmNews.getChannelId()); if (wmChannel != null) &#123; articleDTO.setChannelName(wmChannel.getName()); &#125; articleDTO.setAuthorId(wmNews.getUserId()); WmUser wmUser = wmUserService.getById(wmNews.getUserId()); if (wmUser != null) &#123; articleDTO.setAuthorName(wmUser.getName()); &#125; if (wmNews.getArticleId() != null) &#123; articleDTO.setId(wmNews.getArticleId()); &#125; articleDTO.setCreatedTime(new Date()); return articleClient.saveArticle(articleDTO); &#125; /** * 审核图片内容 * * @param images 图片列表 * @param wmNews 文章信息 * @return 是否审核通过 */ private boolean handleImageScan(List&lt;String&gt; images, WmNews wmNews) &#123; if (images == null || images.isEmpty()) return true; List&lt;String&gt; imgParams = new ArrayList&lt;&gt;(); // 下载MinIO // 图片去重 images = images.stream().distinct().collect(Collectors.toList()); for (String image : images) &#123; byte[] imgData = fileStorageService.downLoadFile(image); String imgStr = Base64Util.encode(imgData); String imgParam = URLEncoder.encode(imgStr, StandardCharsets.UTF_8); imgParams.add(imgParam); &#125; try &#123; Map&lt;String, Object&gt; map = contentCensor.imgCensor(imgParams); Short conclusionType = (Short) map.get(&quot;conclusionType&quot;); // 存在违规内容 if (conclusionType.equals(TextCensorResultEnum.NON_COMPLIANCE.type())) &#123; updateWmNews(wmNews, WmNews.Status.FAIL.code(), &quot;当前素材中存在违规内容&quot;); &#125; // 文章疑似有违规内容 if (conclusionType.equals(TextCensorResultEnum.SUSPECTED.type())) &#123; updateWmNews(wmNews, WmNews.Status.ADMIN_AUTH.code(), &quot;当前素材中存在不确定性内容&quot;); &#125; // 自动审核失败，转人工审核 if (conclusionType.equals(TextCensorResultEnum.AUDIT_FAILED.type())) &#123; updateWmNews(wmNews, WmNews.Status.ADMIN_AUTH.code(), &quot;自动审核失败&quot;); &#125; return conclusionType.equals(TextCensorResultEnum.COMPLIANCE.type()); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 审核文本内容 * * @param text 文本内容 * @param wmNews 文章信息 * @return 是否审核通过 */ private boolean handleTextScan(String text, WmNews wmNews) &#123; if ((wmNews.getTitle() + text).isEmpty()) return true; try &#123; Map&lt;String, Object&gt; map = contentCensor.textCensor(wmNews.getTitle() + &quot;-&quot; + text); Short conclusionType = (Short) map.get(&quot;conclusionType&quot;); // 存在违规内容 if (conclusionType.equals(TextCensorResultEnum.NON_COMPLIANCE.type())) &#123; updateWmNews(wmNews, WmNews.Status.FAIL.code(), &quot;当前文章中存在违规内容&quot;); &#125; // 文章疑似有违规内容 if (conclusionType.equals(TextCensorResultEnum.SUSPECTED.type())) &#123; updateWmNews(wmNews, WmNews.Status.ADMIN_AUTH.code(), &quot;当前文章中存在不确定性内容&quot;); &#125; // 自动审核失败，转人工审核 if (conclusionType.equals(TextCensorResultEnum.AUDIT_FAILED.type())) &#123; updateWmNews(wmNews, WmNews.Status.ADMIN_AUTH.code(), &quot;自动审核失败&quot;); &#125; return conclusionType.equals(TextCensorResultEnum.COMPLIANCE.type()); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 修改文章内容 * * @param wmNews 文章 * @param status 待修改文章状态 * @param reason 待修改文章审核原因 */ private void updateWmNews(WmNews wmNews, short status, String reason) &#123; wmNews.setStatus(status); wmNews.setReason(reason); wmNewsService.updateById(wmNews); &#125; /** * 从内容和封面中提取文本和图片 * * @param wnNews 内容 * @return 文本和图片 */ private Map&lt;String, Object&gt; handleTextAndImages(WmNews wnNews) &#123; if (!StringUtils.hasText(wnNews.getContent())) &#123; return null; &#125; // 存储纯文本内容 StringBuilder texts = new StringBuilder(); ArrayList&lt;String&gt; images = new ArrayList&lt;&gt;(); List&lt;Map&gt; maps = JSON.parseArray(wnNews.getContent(), Map.class); for (Map map : maps) &#123; if (map.get(&quot;type&quot;).equals(WmNewsContentTypeEnum.TEXT.getType())) &#123; texts.append(map.get(&quot;value&quot;)); &#125; if (map.get(&quot;type&quot;).equals(WmNewsContentTypeEnum.IMAGE.getType())) &#123; images.add((String) map.get(&quot;value&quot;)); &#125; &#125; // 提取封面 if (StringUtils.hasText(wnNews.getImages())) &#123; String[] split = wnNews.getImages().split(&quot;,&quot;); images.addAll(Arrays.asList(split)); &#125; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put(&quot;text&quot;, texts.toString()); result.put(&quot;images&quot;, images); return result; &#125;&#125; Base64工具类 Base64Util/** * Base64 工具类 */public class Base64Util &#123; private static final char last2byte = (char) Integer.parseInt(&quot;00000011&quot;, 2); private static final char last4byte = (char) Integer.parseInt(&quot;00001111&quot;, 2); private static final char last6byte = (char) Integer.parseInt(&quot;00111111&quot;, 2); private static final char lead6byte = (char) Integer.parseInt(&quot;11111100&quot;, 2); private static final char lead4byte = (char) Integer.parseInt(&quot;11110000&quot;, 2); private static final char lead2byte = (char) Integer.parseInt(&quot;11000000&quot;, 2); private static final char[] encodeTable = new char[]&#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;+&#x27;, &#x27;/&#x27;&#125;; public Base64Util() &#123; &#125; public static String encode(byte[] from) &#123; StringBuilder to = new StringBuilder((int) ((double) from.length * 1.34D) + 3); int num = 0; char currentByte = 0; int i; for (i = 0; i &lt; from.length; ++i) &#123; for (num %= 8; num &lt; 8; num += 6) &#123; switch (num) &#123; case 0: currentByte = (char) (from[i] &amp; lead6byte); currentByte = (char) (currentByte &gt;&gt;&gt; 2); case 1: case 3: case 5: default: break; case 2: currentByte = (char) (from[i] &amp; last6byte); break; case 4: currentByte = (char) (from[i] &amp; last4byte); currentByte = (char) (currentByte &lt;&lt; 2); if (i + 1 &lt; from.length) &#123; currentByte = (char) (currentByte | (from[i + 1] &amp; lead2byte) &gt;&gt;&gt; 6); &#125; break; case 6: currentByte = (char) (from[i] &amp; last2byte); currentByte = (char) (currentByte &lt;&lt; 4); if (i + 1 &lt; from.length) &#123; currentByte = (char) (currentByte | (from[i + 1] &amp; lead4byte) &gt;&gt;&gt; 4); &#125; &#125; to.append(encodeTable[currentByte]); &#125; &#125; if (to.length() % 4 != 0) &#123; for (i = 4 - to.length() % 4; i &gt; 0; --i) &#123; to.append(&quot;=&quot;); &#125; &#125; return to.toString(); &#125;&#125; 服务降级服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃 服务降级虽然会导致请求失败，但是不会导致阻塞。 在leadnews-feign-api模块中的com.swx.apis.article下新建包fallback 实现IArticleClient @Componentpublic class IArticleClientFallback implements IArticleClient &#123; @Override public R saveArticle(ArticleDTO dto) &#123; return R.fail(ResultCodeEnum.SERVER_ERROR.code(), &quot;获取数据失败&quot;); &#125;&#125; 指定实现的Fallback @FeignClient(value = &quot;leadnews-article&quot;, fallback = IArticleClientFallback.class)public interface IArticleClient &#123; @PostMapping(&quot;/api/v1/article/save&quot;) public R saveArticle(ArticleDTO dto);&#125; 在leadnews-wemedia模块中增加配置，扫描发现Fallback实现类 config.InitConfig@Configuration@ComponentScan(&quot;com.swx.apis.article.fallback&quot;)public class InitConfig &#123;&#125; 在leadnews-wemedia的Nacos配置中增加如下配置： feign: hystrix: enabled: true client: config: default: connect-timeout: 2000 read-timeout: 2000 异步调用 使用异步线程的方式实现异步调用 首先在启动类中添加开启异步的注解 @EnableAsyncpublic class WemediaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WemediaApplication.class, args); &#125;&#125; 在方法上添加异步注解 @Override@Async@Transactional(rollbackFor = RuntimeException.class)public void autoScanWmNews(Integer id) &#123;\t....&#125; 在处理保存文章的方法中添加异步调用文章审核的逻辑 WmNewsSubmitServiceImpl/** * 保存、修改文章或保存为草稿 * * @param dto 文章信息 */@Override@Transactional(rollbackFor = Exception.class)public void submitNews(WmNewsDTO dto) &#123; ....; // 异步调用自动审核 wmNewsAutoScanService.autoScanWmNews(wmNews.getId());&#125; 自管理敏感词过滤文字敏感词过滤维护一个敏感词表 CREATE TABLE `wm_sensitive` ( `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `sensitive` varchar(10) DEFAULT NULL COMMENT &#x27;敏感词&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2; 匹配工具方法 SensitiveWordUtilpublic class SensitiveWordUtil &#123; public static Map&lt;String, Object&gt; dictionaryMap = new HashMap&lt;&gt;(); /** * 生成关键词字典库 * @param words * @return */ public static void initMap(Collection&lt;String&gt; words) &#123; if (words == null) &#123; System.out.println(&quot;敏感词列表不能为空&quot;); return ; &#125; // map初始长度words.size()，整个字典库的入口字数(小于words.size()，因为不同的词可能会有相同的首字) Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(words.size()); // 遍历过程中当前层次的数据 Map&lt;String, Object&gt; curMap = null; Iterator&lt;String&gt; iterator = words.iterator(); while (iterator.hasNext()) &#123; String word = iterator.next(); curMap = map; int len = word.length(); for (int i =0; i &lt; len; i++) &#123; // 遍历每个词的字 String key = String.valueOf(word.charAt(i)); // 当前字在当前层是否存在, 不存在则新建, 当前层数据指向下一个节点, 继续判断是否存在数据 Map&lt;String, Object&gt; wordMap = (Map&lt;String, Object&gt;) curMap.get(key); if (wordMap == null) &#123; // 每个节点存在两个数据: 下一个节点和isEnd(是否结束标志) wordMap = new HashMap&lt;&gt;(2); wordMap.put(&quot;isEnd&quot;, &quot;0&quot;); curMap.put(key, wordMap); &#125; curMap = wordMap; // 如果当前字是词的最后一个字，则将isEnd标志置1 if (i == len -1) &#123; curMap.put(&quot;isEnd&quot;, &quot;1&quot;); &#125; &#125; &#125; dictionaryMap = map; &#125; /** * 搜索文本中某个文字是否匹配关键词 * @param text * @param beginIndex * @return */ private static int checkWord(String text, int beginIndex) &#123; if (dictionaryMap == null) &#123; throw new RuntimeException(&quot;字典不能为空&quot;); &#125; boolean isEnd = false; int wordLength = 0; Map&lt;String, Object&gt; curMap = dictionaryMap; int len = text.length(); // 从文本的第beginIndex开始匹配 for (int i = beginIndex; i &lt; len; i++) &#123; String key = String.valueOf(text.charAt(i)); // 获取当前key的下一个节点 curMap = (Map&lt;String, Object&gt;) curMap.get(key); if (curMap == null) &#123; break; &#125; else &#123; wordLength ++; if (&quot;1&quot;.equals(curMap.get(&quot;isEnd&quot;))) &#123; isEnd = true; &#125; &#125; &#125; if (!isEnd) &#123; wordLength = 0; &#125; return wordLength; &#125; /** * 获取匹配的关键词和命中次数 * @param text * @return */ public static Map&lt;String, Integer&gt; matchWords(String text) &#123; Map&lt;String, Integer&gt; wordMap = new HashMap&lt;&gt;(); int len = text.length(); for (int i = 0; i &lt; len; i++) &#123; int wordLength = checkWord(text, i); if (wordLength &gt; 0) &#123; String word = text.substring(i, i + wordLength); // 添加关键词匹配次数 if (wordMap.containsKey(word)) &#123; wordMap.put(word, wordMap.get(word) + 1); &#125; else &#123; wordMap.put(word, 1); &#125; i += wordLength - 1; &#125; &#125; return wordMap; &#125; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;法轮&quot;); list.add(&quot;法轮功&quot;); list.add(&quot;冰毒&quot;); initMap(list); String content=&quot;我是一个好人，并不会卖冰毒，也不操练法轮功,我真的不卖冰毒&quot;; Map&lt;String, Integer&gt; map = matchWords(content); System.out.println(map); &#125;&#125; 使用该方法 WmNewsAutoScanServiceImpl/** * 自管理的敏感词审核 * * @param text 文本 * @param wmNews 文章信息 * @return 是否审核通过 */private boolean handleSensitiveScan(String text, WmNews wmNews) &#123; // 获取所有敏感词 List&lt;WmSensitive&gt; wmSensitives = wmSensitiveMapper.selectList(Wrappers.&lt;WmSensitive&gt;lambdaQuery().select(WmSensitive::getSensitive)); List&lt;String&gt; sensitives = wmSensitives.stream().map(WmSensitive::getSensitive).collect(Collectors.toList()); // 初始化敏感词库 SensitiveWordUtil.initMap(sensitives); // 查看文章中是否存在敏感词库 Map&lt;String, Integer&gt; map = SensitiveWordUtil.matchWords(text); if (!map.isEmpty()) &#123; updateWmNews(wmNews, WmNews.Status.FAIL.code(), &quot;当前文章存在违规内容&quot; + map); return false; &#125; return true;&#125; 图片敏感词过滤图片识别 引入tess4j的依赖 pom.xml&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt; &lt;artifactId&gt;tess4j&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt;&lt;/dependency&gt; 封装一下： Tess4jClient@Getter@Setter@Component@ConfigurationProperties(prefix = &quot;tess4j&quot;)public class Tess4jClient &#123; private String dataPath; private String language; public String doOCR(BufferedImage image) throws TesseractException &#123; ITesseract tesseract = new Tesseract(); tesseract.setDatapath(dataPath); tesseract.setLanguage(language); String result = tesseract.doOCR(image); result = result.replaceAll(&quot;\\\\r|\\ &quot;, &quot;-&quot;).replaceAll(&quot; &quot;, &quot;&quot;); return result; &#125;&#125; 自动装配 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.swx.common.tees4j.Tess4jClient 使用，首先配置信息 bootstrap.yamltess4j: data-path: classpath:tessdata/ language: chi_sim 修改图片审核的逻辑 handleImageScan/** * 审核图片内容 * * @param images 图片列表 * @param wmNews 文章信息 * @return 是否审核通过 */private boolean handleImageScan(List&lt;String&gt; images, WmNews wmNews) &#123; if (images == null || images.isEmpty()) return true; List&lt;String&gt; imgParams = new ArrayList&lt;&gt;(); try &#123; // 图片去重 images = images.stream().distinct().collect(Collectors.toList()); for (String image : images) &#123; // 下载MinIO byte[] imgData = fileStorageService.downLoadFile(image); ByteArrayInputStream in = new ByteArrayInputStream(imgData); BufferedImage bufferedImage = ImageIO.read(in); // 图片识别 String result = tess4jClient.doOCR(bufferedImage); // 过滤文字 boolean isSensitive = handleSensitiveScan(result, wmNews); if (!isSensitive) &#123; return false; &#125; // 转Base64 String imgStr = Base64Util.encode(imgData); String imgParam = URLEncoder.encode(imgStr, StandardCharsets.UTF_8); imgParams.add(imgParam); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; Map&lt;String, Object&gt; map = contentCensor.imgCensor(imgParams); Short conclusionType = (Short) map.get(&quot;conclusionType&quot;); // 存在违规内容 if (conclusionType.equals(TextCensorResultEnum.NON_COMPLIANCE.type())) &#123; updateWmNews(wmNews, WmNews.Status.FAIL.code(), &quot;当前素材中存在违规内容&quot;); &#125; // 图片疑似有违规内容 if (conclusionType.equals(TextCensorResultEnum.SUSPECTED.type())) &#123; updateWmNews(wmNews, WmNews.Status.ADMIN_AUTH.code(), &quot;当前素材中存在不确定性内容&quot;); &#125; // 自动审核失败，转人工审核 if (conclusionType.equals(TextCensorResultEnum.AUDIT_FAILED.type())) &#123; updateWmNews(wmNews, WmNews.Status.ADMIN_AUTH.code(), &quot;自动审核失败&quot;); &#125; return conclusionType.equals(TextCensorResultEnum.COMPLIANCE.type()); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125;&#125; APP端静态模版文章保存之后，应该调用生成静态模版并上传至MinIO的逻辑，可以使用异步调用，不干扰文章的保存进度。 为了防止循环依赖，这里将保存APP端文章的逻辑提取到ApArticleSaveService中 创建ApArticleSaveService，代码从原ApArticleService中拷贝即可： public interface ApArticleSaveService &#123; /** * 保存APP端相关文章 * * @param dto 文章信息 */ public Long saveArticle(ArticleDTO dto);&#125; 实现该接口 @Servicepublic class ApArticleSaveServiceImpl implements ApArticleSaveService &#123; private final ApArticleConfigMapper apArticleConfigMapper; private final ApArticleContentMapper apArticleContentMapper; private final ArticleFreemarkerService articleFreemarkerService; private final ApArticleService apArticleService; public ApArticleSaveServiceImpl(ApArticleConfigMapper apArticleConfigMapper, ApArticleContentMapper apArticleContentMapper, ArticleFreemarkerService articleFreemarkerService, ApArticleService apArticleService) &#123; this.apArticleConfigMapper = apArticleConfigMapper; this.apArticleContentMapper = apArticleContentMapper; this.articleFreemarkerService = articleFreemarkerService; this.apArticleService = apArticleService; &#125; /** * 保存APP端相关文章 * * @param dto 文章信息 */ @Transactional(rollbackFor = RuntimeException.class) @Override public Long saveArticle(ArticleDTO dto) &#123; if (dto == null) &#123; throw new BizException(ResultCodeEnum.PARAM_INVALID); &#125; ApArticle apArticle = new ApArticle(); BeanUtils.copyProperties(dto, apArticle); if (dto.getId() == null) &#123; // 不存在ID，保存 apArticleService.save(apArticle); // 保存文章配置 ApArticleConfig apArticleConfig = new ApArticleConfig(apArticle.getId()); apArticleConfigMapper.insert(apArticleConfig); // 保存文章内容 ApArticleContent apArticleContent = new ApArticleContent(); apArticleContent.setArticleId(apArticle.getId()); apArticleContent.setContent(dto.getContent()); apArticleContentMapper.insert(apArticleContent); &#125; else &#123; // 存在ID，修改 apArticleService.updateById(apArticle); // 修改文章内容 ApArticleContent apArticleContent = apArticleContentMapper.selectOne( Wrappers.&lt;ApArticleContent&gt;lambdaQuery().eq(ApArticleContent::getArticleId, apArticle.getId())); apArticleContent.setContent(dto.getContent()); apArticleContentMapper.updateById(apArticleContent); &#125; // 异步调用，生成静态文件上传到MinIOn中 articleFreemarkerService.buildArticleToMinIO(apArticle, dto.getContent()); return apArticle.getId(); &#125;&#125; 修改Feign远程调用的Client ArticleClient@RestControllerpublic class ArticleClient implements IArticleClient &#123; private final ApArticleSaveService apArticleSaveService; public ArticleClient(ApArticleSaveService apArticleSaveService) &#123; this.apArticleSaveService = apArticleSaveService; &#125; @PostMapping(&quot;/api/v1/article/save&quot;) @Override public R saveArticle(@RequestBody ArticleDTO dto) &#123; Long articleId = apArticleSaveService.saveArticle(dto); return R.success(articleId); &#125;&#125; 下面，实现生成模版并上传到MinIO的逻辑，回填MinIO返回的URL到数据库中 ArticleFreemarkerServicepublic interface ArticleFreemarkerService &#123; /** * 生成静态文件上传到MinIO中 * * @param apArticle 文章 * @param content 内容 */ public void buildArticleToMinIO(ApArticle apArticle, String content);&#125; 实现该接口 ArticleFreemarkerServiceImpl@Servicepublic class ArticleFreemarkerServiceImpl implements ArticleFreemarkerService &#123; private final Configuration configuration; private final FileStorageService fileStorageService; private final ApArticleService apArticleService; public ArticleFreemarkerServiceImpl(Configuration configuration, FileStorageService fileStorageService, ApArticleService apArticleService) &#123; this.configuration = configuration; this.fileStorageService = fileStorageService; this.apArticleService = apArticleService; &#125; /** * 生成静态文件上传到MinIO中 * * @param apArticle 文章 * @param content 内容 */ @Async @Override public void buildArticleToMinIO(ApArticle apArticle, String content) &#123; if (!StringUtils.hasText(content)) &#123; return; &#125; // 文章内容通过freemarker生成html文件 Template template = null; try &#123; template = configuration.getTemplate(&quot;article.ftl&quot;); StringWriter out = new StringWriter(); // 数据模型 HashMap&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;content&quot;, JSONArray.parseArray(content)); // 合成 template.process(params, out); // 把html文件上传到minio中 InputStream is = new ByteArrayInputStream(out.toString().getBytes()); String url = fileStorageService.uploadHtmlFile(&quot;&quot;, apArticle.getId() + &quot;.html&quot;, is); // 保存URL到数据库 apArticleService.update(Wrappers.&lt;ApArticle&gt;lambdaUpdate() .eq(ApArticle::getId, apArticle.getId()) .set(ApArticle::getStaticUrl, url)); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 分布式事务自媒体微服务异步调用文章微服务，如果文章微服务出现了问题，自媒体微服务并不知道，一致性无法保证，这时候就需要使用分布式事务。 文章下架这部分使用消息队列实现微服务间的异步远程调用，使用消息队列可以解耦 消息中间件中间件技术对比 特性 ActiveMQ RabbitMQ RocketMQ Kafka 开发语言 java erlang java scala 单机吞吐量 万级 万级 10万级 100万级 时效性 ms us ms ms级以内 可用性 高（主从） 高（主从） 非常高（分布式） 非常高（分布式） 功能特性 成熟的产品、较全的文档、各种协议支持好 并发能力强、性能好、延迟低 MQ功能比较完善，扩展性佳 只支持主要的MQ功能，主要应用于大数据领域 选择建议 消息中间件 建议 Kafka 追求高吞吐量，适合产生大量数据的互联网服务的数据收集业务 RocketMQ 可靠性要求很高的金融互联网领域,稳定性高，经历了多次阿里双11考验 RabbitMQ 性能较好，社区活跃度高，数据量没有那么大，优先选择功能比较完备的RabbitMQ Kafka producer：发布消息的对象称之为主题生产者（Kafka topic producer） topic：Kafka将消息分门别类，每一类的消息称之为一个主题（Topic） consumer：订阅消息并处理发布的消息的对象称之为主题消费者（consumers） broker：已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理（Broker）。 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。 安装ZookeeperKafka对于zookeeper是强依赖，保存kafka相关的节点数据，所以安装Kafka之前必须先安装zookeeper 下载镜像 docker pull zookeeper:3.6 创建容器 docker run -d --name zookeeper -p 2181:2181 zookeeper:3.6 安装Kafka下载镜像 docker pull wurstmeister/kafka:2.12-2.5.0 创建容器，替换IP地址 docker run -d --name kafka \\--env KAFKA_ADVERTISED_HOST_NAME=xxx.xxx.xxx.xxx \\--env KAFKA_ZOOKEEPER_CONNECT=xxx.xxx.xxx.xxx:2181 \\--env KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://xxx.xxx.xxx.xxx:9092 \\--env KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \\--env KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms256M&quot; \\--net=host wurstmeister/kafka:2.12-2.5.0"},{"title":"创建后端项目","path":"/wiki/learning-online/03-project-init/create-server.html","content":"创建Git仓库项目基本信息从Git中拉取，首先在gitee或者github中创建仓库，命名为learning-online 初始化Git到本地使用IDEA创建项目，选择Get from VCS，填写仓库的URL 创建.gitignore文件，填入如下内容： logs/HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**/target/!**/src/test/**/target/### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/!**/src/main/**/build/!**/src/test/**/build/### VS Code ###.vscode/### Mac OS ###.DS_Store 使用IDEA创建分支dev01，并切换到该分支 项目工程结构提供服务的模块learning-online-contet的依赖继承关系如下，其他所有提供服务的模块都将按照如下关系创建 创建父工程右键learning-online选择New下面的Module；填入learning-online-parent，注意其真实目录地址在learning-online目录下。 父工程只负责Maven版本控制，只保留pom.xml文件，内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;groupId&gt;com.swx&lt;/groupId&gt;\t&lt;artifactId&gt;learning-online-parent&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;packaging&gt;pom&lt;/packaging&gt;\t&lt;name&gt;learning-online-parent&lt;/name&gt;\t&lt;description&gt;learning-online-parent&lt;/description&gt;\t&lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;spring.cloud.version&gt;Hoxton.SR10&lt;/spring.cloud.version&gt; &lt;spring.boot.version&gt;2.3.9.RELEASE&lt;/spring.boot.version&gt; &lt;mybatis-plus.version&gt;3.4.1&lt;/mybatis-plus.version&gt; &lt;lombok.version&gt;1.18.18&lt;/lombok.version&gt; &lt;mysql.connector.version&gt;8.0.23&lt;/mysql.connector.version&gt; &lt;knife4j.version&gt;3.0.3&lt;/knife4j.version&gt;\t&lt;/properties&gt;\t&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.connector.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- knife4j接口文档 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;knife4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;\t&lt;/dependencyManagement&gt;\t&lt;build&gt; &lt;finalName&gt;$&#123;project.name&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt; 创建基础模块创建新模块learning-online-base，其Parent为learning-online-parent但其目录位置在learning-online下，创建完成后其pom.xml的内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../learning-online-parent&lt;/relativePath&gt;\t&lt;/parent&gt;\t&lt;artifactId&gt;learning-online-base&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;name&gt;learning-online-base&lt;/name&gt;\t&lt;description&gt;learning-online-base&lt;/description&gt;\t&lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt;\t&lt;/properties&gt;\t&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt; relativePath：指示其父工程的目录 创建内容管理模块创建新模块**learning-online-content**，其Parent为learning-online-parent但其目录位置在learning-online下，目录结构如下： learning-online├── learning-online-base├── learning-online-content└── learning-online-parent 创建内容管理接口工程创建步骤同上，创创建新模块learning-online-content-api，其Parent为learning-online-content 创建内容管理服务工程创建步骤同上，创创建新模块learning-online-content-service，其Parent为learning-online-content 创建内容管理模块工程创建步骤同上，创创建新模块learning-online-content-model，其Parent为learning-online-content 最终的目录结构工程都是空的，只是初始化项目结构 learning-online├── learning-online-base├── learning-online-content│ ├── learning-online-content-api│ ├── learning-online-content-service│ └── learning-online-content-model └── learning-online-parent"},{"title":"导入前端项目","path":"/wiki/learning-online/03-project-init/deploy-web.html","content":"前端项目分为两部分： 管理网站 门户网站 管理网站前端项目基于Vue使用Typescript开发，需要在系统中配置如下环境： nodeJs 下载项目前端项目下载地址： https://wwab.lanzoue.com/iQMur16otgqd 初始化项目使用VS-Code打开项目，在终端中执行命令： npm install 运行项目nodeJS版本在16以上需要在package.json的scripts中添加： # Mac/Linuxexport NODE_OPTIONS=--openssl-legacy-provider# WindowsSET NODE_OPTIONS=--openssl-legacy-provider 修改完成如下： &quot;scripts&quot;: &#123;&quot;serve&quot;: &quot;export NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve&quot;,&quot;serve-prod&quot;: &quot;export NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve --mode prod&quot;,&quot;build&quot;: &quot;export NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service build&quot;,&quot;build-prod&quot;: &quot;export NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service build --mode prod&quot;,&quot;lint&quot;: &quot;vue-cli-service lint&quot;&#125;, 使用下面命令启动项目： npm run serve 此时项目启动后会报错，因为后端服务还没有创建。 修改项目为了使前端能够适配后端统一返回的结果类型： &#123; code: 200, message: &#x27;成功&#x27;, data: null,&#125; 需要对axios的拦截器做修改，找到utils/request.ts，修改响应拦截如下： // Response interceptorsserviceInstance.interceptors.response.use( // response =&gt; response, response =&gt; &#123; const res = response.data if (res.code !== 200) &#123; Message(&#123; message: res.message || &#x27;Error&#x27;, type: &#x27;error&#x27;, duration: 5 * 1000, &#125;); return Promise.reject(new Error(res.message || &#x27;Error&#x27;)); &#125; else &#123; const &#123; code, data, message &#125; = response.data if (code != 200) &#123; Message(&#123; message: message || &#x27;Error&#x27;, type: &#x27;warning&#x27;, duration: 5 * 1000, &#125;); return Promise.reject(new Error(message || &#x27;Error&#x27;)); &#125; return response.data; &#125; &#125;, error =&gt; &#123; Message(&#123; message: error.response.data.message || error.message, type: &#x27;error&#x27;, duration: 5 * 1000 &#125;) if(error.response.status==&quot;401&quot; &amp;&amp; error.response.data.errMessage==&#x27;没有认证&#x27;)&#123; window.location.href=&#x27;http://www.51xuecheng.cn/sign.html&#x27; &#125; return Promise.reject(error) &#125;) 门户网站门户网站是提供给用户浏览的网站 下载项目下载地址： https://www.lanzouw.com/iG91I1w8ffbi Host配置因为没有备案域名，所以这里通过修改本机host的方式实现域名访问： 修改Mac的host文件命令 sudo vim /etc/hosts 修改内容如下： 127.0.0.1 www.51xuecheng.cn 51xuecheng.cn ucenter.51xuecheng.cn teacher.51xuecheng.cn file.51xuecheng.cn localhost Nginx配置修改nginx.conf文件，为如下内容，让其加载 leadnews.conf目录下的所有配置文件 worker_processes 1; events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 引入自定义配置文件 # include leadnews.conf/*.conf; include learning.conf/*.conf;&#125; 创建 leadnews.conf目录，并在其中创建如下的配置文件 文件服务：fileserver.conf，使用Nginx代理访问MinIO： # 文件服务upstream fileserver &#123; server 124.221.23.47:9000 weight=10;&#125;server &#123; listen 80; ssi on; ssi_silent_errors on; server_name file.51xuecheng.cn; location /video &#123; proxy_pass http://fileserver; &#125; location /mediafiles &#123; proxy_pass http://fileserver; &#125;&#125; 项目资源和文件服务的Nginx配置learning.conf upstream learning-online-gateway &#123; server 127.0.0.1:63010 weight=10;&#125;server &#123; listen 80; ssi on; server_name www.51xuecheng.cn localhost; location / &#123; root html/lo-ui-pc-static-portal/; index index.html; &#125; # 静态资源 location /static/img/ &#123; alias html/lo-ui-pc-static-portal/img/; &#125; location /static/css/ &#123; alias html/lo-ui-pc-static-portal/css/; &#125; location /static/js/ &#123; alias html/lo-ui-pc-static-portal/js/; &#125; location /static/plugins/ &#123; alias html/lo-ui-pc-static-portal/plugins/; add_header Access-Control-Allow-Origin http://www.51xuecheng.cn; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Methods GET; &#125; location /plugins/ &#123; alias html/lo-ui-pc-static-portal/plugins/; &#125; location /course/preview/learning.html &#123; alias html/lo-ui-pc-static-portal/course/learning.html; &#125; location /course/search.html &#123; root html/lo-ui-pc-static-portal; &#125; location /course/learning.html &#123; root html/lo-ui-pc-static-portal; &#125; # openapi location /open/content/ &#123; proxy_pass http://learning-online-gateway/content/open/; &#125; location /open/media/ &#123; proxy_pass http://learning-online-gateway/media/open/; &#125; location ~/api/(.*) &#123; proxy_pass http://learning-online-gateway/$1?$args; proxy_set_header HOST $host; # 不改变源请求头的值 proxy_pass_request_body\ton; # 开启获取请求体 proxy_pass_request_headers\ton;\t# 开启获取请求头 proxy_set_header X-Real-IP $remote_addr; # 记录真实发出请求的客户端IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 记录代理信息 &#125;&#125; 关于root和alias的区别 root的处理结果是：root路径＋location路径alias的处理结果是：使用alias路径替换location路径alias的结尾必须加上 / 管理项目服务：teacher.conf # 前端开发服务upstream uidevserver &#123; server 127.0.0.1:8601 weight=10;&#125;server &#123; listen 80; ssi on; ssi_silent_errors on; server_name teacher.51xuecheng.cn; location / &#123; proxy_pass http://uidevserver; &#125; location /api/ &#123; proxy_pass http://gatewayserver/; &#125;&#125; 微信授权登录配置：wxauth.conf upstream gatewayserver &#123; server 127.0.0.1:63010 weight=10;&#125;server &#123; listen 8160; server_name www.51xuecheng.cn localhost; location /api &#123; proxy_pass http://gatewayserver; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 这里需要添加一个rewrite规则，把请求中的/api去掉 rewrite ^/api(.*)$ $1 break; &#125;&#125; 我的学习页面配置：ucenter.conf ucenter.confserver &#123; listen 80; ssi on; ssi_silent_errors on; server_name ucenter.51xuecheng.cn; location / &#123; root html/lo-ui-pc-static-portal/ucenter/;\tindex index.html; &#125; location /include &#123; alias html/lo-ui-pc-static-portal/include/; &#125; location /img/ &#123; proxy_pass http://127.0.0.1/static/img/; &#125; location ~/api/(.*) &#123; proxy_pass http://learning-online-gateway/$1?$args; proxy_set_header HOST $host; # 不改变源请求头的值 proxy_pass_request_body\ton; # 开启获取请求体 proxy_pass_request_headers\ton;\t# 开启获取请求头 proxy_set_header X-Real-IP $remote_addr; # 记录真实发出请求的客户端IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 记录代理信息 &#125;&#125; 预览项目门户首页： 课程预览页面："},{"title":"完善Base工程","path":"/wiki/learning-online/04-project-tools/base.html","content":"Base工程是用来放公共组件的 依赖信息引入如下依赖： pom.xml&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt;&lt;/dependency&gt; 实体类在learning-online-base工程下创建包com.swx.base.model，并在该包下创建两个实体类 分页查询参数 PageParam/** * 分页查询参数 */@Data@ApiModel(&quot;分页查询参数&quot;)public class PageParam &#123; // 当前页 @ApiModelProperty(&quot;当前页码&quot;) private Long pageNo = 1L; // 每页记录数 @ApiModelProperty(&quot;每页记录数&quot;) private Long pageSize = 10L; public PageParam() &#123; &#125; public PageParam(Long pageNo, Long pageSize) &#123; this.pageNo = pageNo; this.pageSize = pageSize; &#125;&#125; 分页查询结果 PageResult/** * 分页查询结果模型类 * * @param &lt;T&gt; 范型 */@Datapublic class PageResult&lt;T&gt; implements Serializable &#123; // 数据列表 private List&lt;T&gt; items; // 总记录数 private long counts; // 当前页数 private long page; // 每页记录数 private long pageSize; public PageResult() &#123; &#125; public PageResult(List&lt;T&gt; items, long counts, long page, long pageSize) &#123; this.items = items; this.counts = counts; this.page = page; this.pageSize = pageSize; &#125; public PageResult(List&lt;T&gt; items, long counts, PageParam pageParam) &#123; this.items = items; this.counts = counts; this.page = pageParam.getPageNo(); this.pageSize = pageParam.getPageSize(); &#125;&#125; JSON格式化在com.swx.base.config创建配置类JSONConvertConfig JSONConvertConfig@Configurationpublic class JSONConvertConfig &#123; /** * 序列化内容 */ @Bean public LocalDateTimeSerializer localDateTimeSerializer() &#123; return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)); &#125; @Bean public LocalDateTimeDeserializer localDateTimeDeserializer() &#123; return new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)); &#125; @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() &#123; return builder -&gt; &#123; builder.serializerByType(LocalDateTime.class, localDateTimeSerializer()); builder.deserializerByType(LocalDateTime.class, localDateTimeDeserializer()); &#125;; &#125; // Long 转 String @Bean public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) &#123; ObjectMapper objectMapper = builder.createXmlMapper(false).build(); // 忽略value为null时key的输出 objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); SimpleModule module = new SimpleModule(); module.addSerializer(Long.class, ToStringSerializer.instance); module.addSerializer(Long.TYPE, ToStringSerializer.instance); objectMapper.registerModule(module); return objectMapper; &#125;&#125; Knife4j配置类在com.swx.base.config创建配置类Knife4jConfiguration Knife4jConfiguration@Configuration@EnableSwagger2@EnableKnife4j@Import(BeanValidatorPluginsConfiguration.class)public class Knife4jConfiguration &#123; @Bean(value = &quot;defaultApi2&quot;) public Docket defaultApi2() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .groupName(&quot;1.0&quot;) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.swx&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;学成在线API文档&quot;) .description(&quot;学成在线API文档&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; 统一返回结果为了让前端接受到统一的返回结果，需要使用拦截器自动包装Controller返回结果，同时全局拦截异常处理，并一起包装返回统一结果。 &#123; code: 200, message: &#x27;成功&#x27;, data: null,&#125; 返回结果在learning-online-base工程的com.swx.base.model包下创建如下几个实体类 返回结果 R/** * 返回结果实体类 */@Datapublic class R implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 返回码 */ private Integer code; /** * 返回消息 */ private String message; /** * 返回数据 */ private Object data; public R() &#123; &#125; public R(ResultCodeEnum resultCode, Object data) &#123; this.code = resultCode.code(); this.message = resultCode.message(); this.data = data; &#125; private void setResultCode(ResultCodeEnum resultCode) &#123; this.code = resultCode.code(); this.message = resultCode.message(); &#125; // 返回成功 public static R success() &#123; R result = new R(); result.setResultCode(ResultCodeEnum.SUCCESS); return result; &#125; // 返回成功 public static R success(Object data) &#123; R result = new R(); result.setResultCode(ResultCodeEnum.SUCCESS); result.setData(data); return result; &#125; // 返回失败 public static R fail(Integer code, String message) &#123; R result = new R(); result.setCode(code); result.setMessage(message); return result; &#125; // 返回失败 public static R fail(ResultCodeEnum resultCode) &#123; R result = new R(); result.setResultCode(resultCode); return result; &#125;&#125; 异常结果 ErrorResult/** * 异常结果包装类 * @author sw-code * */public class ErrorResult &#123; private Integer code; private String message; private String exception; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public String getException() &#123; return exception; &#125; public void setException(String exception) &#123; this.exception = exception; &#125; public static ErrorResult fail(ResultCodeEnum resultCode, Throwable e, String message) &#123; ErrorResult errorResult = ErrorResult.fail(resultCode, e); errorResult.setMessage(message); return errorResult; &#125; public static ErrorResult fail(ResultCodeEnum resultCode, Throwable e) &#123; ErrorResult errorResult = new ErrorResult(); errorResult.setCode(resultCode.code()); errorResult.setMessage(resultCode.message()); errorResult.setException(e.getClass().getName()); return errorResult; &#125; public static ErrorResult fail(Integer code, String message) &#123; ErrorResult errorResult = new ErrorResult(); errorResult.setCode(code); errorResult.setMessage(message); return errorResult; &#125;&#125; 异常枚举类 ResultCodeEnumpublic enum ResultCodeEnum &#123; /* 成功状态码 */ SUCCESS(200, &quot;成功&quot;), /* Token 50~100 */ TOKEN_INVALID(50, &quot;无效TOKEN&quot;), TOKEN_EXPIRE(51, &quot;TOKEN已过期&quot;), TOKEN_REQUIRE(50, &quot;TOKEN是必须的&quot;), /* 参数错误 500~1000 */ SERVER_ERROR(500, &quot;服务器内部错误&quot;), PARAM_REQUIRE(501, &quot;缺少参数&quot;), PARAM_INVALID(502, &quot;无效参数&quot;), PARAM_TIMAGE_FORMAT_ERROR(503, &quot;图片格式有误&quot;), /* 数据错误 1000~2000 */ DATA_EXIST(1000, &quot;数据已经存在&quot;), AP_USER_DATA_NOT_EXIST(1001, &quot;ApUser数据不存在&quot;), DATA_NOT_EXIST(1002, &quot;数据不存在&quot;), /* 数据错误 300~3500 */ NO_OPERATOR_AUTH(3000, &quot;无权操作&quot;), NEED_ADMIN(3001, &quot;需要管理员权限&quot;); private Integer code; private String message; private ResultCodeEnum(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer code() &#123; return this.code; &#125; public String message() &#123; return this.message; &#125;&#125; 自定义异常在learning-online-base工程的com.swx.base.excpetion包下创建自定义异常 BizExceptionpublic class BizException extends RuntimeException &#123; /** * 错误码 */ private Integer code; /** * 错误信息 */ private String message; public BizException() &#123; super(); &#125; public BizException(ResultCodeEnum resultCode) &#123; super(resultCode.message()); this.code = resultCode.code(); this.message = resultCode.message(); &#125; public BizException(ResultCodeEnum resultCode, Throwable cause) &#123; super(resultCode.message(), cause); this.code = resultCode.code(); this.message = resultCode.message(); &#125; public BizException(String message) &#123; super(message); this.code = -1; this.message = message; &#125; public BizException(Integer code, String message) &#123; super(message); this.code = code; this.message = message; &#125; public BizException(Integer code, String message, Throwable cause) &#123; super(message, cause); this.code = code; this.message = message; &#125; @Override public synchronized Throwable fillInStackTrace() &#123; return this; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 自定义注解添加了该注解的Controller的方法的返回结果将被我们统一包装 ResponseResult@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.TYPE, ElementType.METHOD&#125;)@Documentedpublic @interface ResponseResult &#123;&#125; 注解拦截器创建自定义的拦截器，判断方法是否使用了@ResponseResult @Componentpublic class ResponseResultInterceptor implements HandlerInterceptor &#123; //标记名称 public static final String RESPONSE_RESULT_ANN = &quot;RESPONSE-RESULT-ANN&quot;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO Auto-generated method stub if (handler instanceof HandlerMethod) &#123; final HandlerMethod handlerMethod = (HandlerMethod) handler; final Class&lt;?&gt; clazz = handlerMethod.getBeanType(); final Method method = handlerMethod.getMethod(); // 判断是否在类对象上添加了注解 if (clazz.isAnnotationPresent(ResponseResult.class)) &#123; // 设置此请求返回体，需要包装，往下传递，在ResponseBodyAdvice接口进行判断 request.setAttribute(RESPONSE_RESULT_ANN, clazz.getAnnotation(ResponseResult.class)); &#125; else if (method.isAnnotationPresent(ResponseResult.class)) &#123; request.setAttribute(RESPONSE_RESULT_ANN, method.getAnnotation(ResponseResult.class)); &#125; &#125; return true; &#125;&#125; 返回结果处理使用@ControllerAdvice可以拦截Controller方法返回参数，自动包装成为统一返回结果： ResponseResultHandler/** * 使用 @ControllerAdvice &amp; ResponseBodyAdvice * 拦截Controller方法默认返回参数，统一处理返回值/响应体 */@ControllerAdvicepublic class ResponseResultHandler implements ResponseBodyAdvice&lt;Object&gt; &#123; // 标记名称 public static final String RESPONSE_RESULT_ANN = &quot;RESPONSE-RESULT-ANN&quot;; // 判断是否要执行 beforeBodyWrite 方法，true为执行，false不执行，有注解标记的时候处理返回值 @Override public boolean supports(MethodParameter arg0, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; arg1) &#123; ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = sra.getRequest(); // 判断请求是否有包装标记 ResponseResult responseResultAnn = (ResponseResult) request.getAttribute(RESPONSE_RESULT_ANN); return responseResultAnn == null ? false : true; &#125; // 对返回值做包装处理，如果属于异常结果，则需要再包装 @Override public Object beforeBodyWrite(Object body, MethodParameter arg1, MediaType arg2, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; arg3, ServerHttpRequest arg4, ServerHttpResponse arg5) &#123; if (body instanceof ErrorResult) &#123; ErrorResult error = (ErrorResult) body; return R.fail(error.getCode(), error.getMessage()); &#125; else if (body instanceof R) &#123; return (R) body; &#125; else if (body instanceof String) &#123; return body; &#125; return R.success(body); &#125;&#125; 全局异常处理正常返回的结果R被自动包装，那么异常结果也应该被自动包装，因此使用@RestControllerAdvice注解做全局的异常处理，返回错误结果ErrorResult GlobalExceptionHandler/** * 全局异常处理类 * @RestControllerAdvice(@ControllerAdvice)，拦截异常并统一处理 * @author sw-code * */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(&quot;GlobalExceptionHandler.class&quot;); /** * 处理自定义的业务异常 * @param e\t异常对象 * @param request\trequest * @return\t错误结果 */ @ExceptionHandler(BizException.class) public ErrorResult bizExceptionHandler(BizException e, HttpServletRequest request) &#123; logger.error(&quot;发生业务异常！原因是: &#123;&#125;&quot;, e.getMessage()); return ErrorResult.fail(e.getCode(), e.getMessage()); &#125; // 拦截抛出的异常，@ResponseStatus：用来改变响应状态码 @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Throwable.class) public ErrorResult handlerThrowable(Throwable e, HttpServletRequest request) &#123; logger.error(&quot;发生未知异常！原因是: &quot;, e); // 使用这种方式，而不是拦截AccessDeniedException异常，可引入Spring Security防止污染工程 if (e.getMessage().equals(&quot;不允许访问&quot;)) &#123; return ErrorResult.fail(ResultCodeEnum.NO_OPERATOR_AUTH, e); &#125; return ErrorResult.fail(ResultCodeEnum.SERVER_ERROR, e); &#125; // 参数校验异常 @ExceptionHandler(BindException.class) public ErrorResult handleBindExcpetion(BindException e, HttpServletRequest request) &#123; logger.error(&quot;发生参数校验异常！原因是：&quot;,e); ErrorResult error = ErrorResult.fail(ResultCodeEnum.PARAM_INVALID, e, e.getAllErrors().get(0).getDefaultMessage()); return error; &#125; @ExceptionHandler(MethodArgumentNotValidException.class) public ErrorResult handleMethodArgumentNotValidException(MethodArgumentNotValidException e, HttpServletRequest request) &#123; logger.error(&quot;发生参数校验异常！原因是：&quot;,e); ErrorResult error = ErrorResult.fail(ResultCodeEnum.PARAM_INVALID,e,e.getBindingResult().getAllErrors().get(0).getDefaultMessage()); return error; &#125;&#125; 系统如何处理异常？ 使用控制器增强注解@RestControllerAdvice捕获处理不同的异常，可以返回一个自定义的异常结果。同时还可以使用增强注解@ControllerAdvice拦截Controller方法的返回，并在beforeBodyWrite方法包装对象和异常结果为统一结果。 自动装配为了让引入base模块的项目能够自动装配配置类，需要在resources下创建目录META-INF并在目录下创建文件spring.factories，内容如下： org.springframework.boot.autoconfigure.EnableAutoConfiguration = \\ com.swx.base.config.LocalDateTimeConfig, \\ com.swx.base.config.Knife4jConfiguration, \\ com.swx.base.config.WebAppConfig, \\ com.swx.base.exception.GlobalExceptionHandler, \\ com.swx.base.exception.ResponseResultHandler 所有的配置类都要在这里声明一下。 JSR303校验 请求参数的合法校验如何做？ 使用基于JSR303的校验框架实现，Spring Boot提供了JSR-303的支持，它就是spring-boot-starter-validation，它包括了很多校验规则，只需要在模型类中通过注解指定校验规则，在Controller方法上开启校验。 实现统一校验引入依赖信息 pom.xml&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 在实体类中加入校验信息，如下： @Data@ApiModel(value = &quot;AddCourseDTO&quot;, description = &quot;新增课程基本信息&quot;)public class AddCourseDTO &#123; @NotEmpty(message = &quot;课程名称不能为空&quot;) @ApiModelProperty(value = &quot;课程名称&quot;, required = true) private String name; @NotEmpty(message = &quot;适用人群不能为空&quot;) @Size(message = &quot;适用人群内容过少&quot;, min = 10) @ApiModelProperty(value = &quot;适用人群&quot;, required = true) private String users;&#125; 分组校验修改和新增的校验规则不同，此时可以使用分组来解决。 在base模块的com.swx.base.exception包下创建分组类： ValidationGroup/** * 用于分组校验 */public class ValidationGroup &#123; public interface Insert&#123;&#125;; public interface Update&#123;&#125;; public interface Delete&#123;&#125;;&#125; 修改校验规则 @NotEmpty(message = &quot;新增课程名称不能为空&quot;, groups = &#123;ValidationGroup.Insert.class&#125;)@NotEmpty(message = &quot;修改课程名称不能为空&quot;, groups = &#123;ValidationGroup.Update.class&#125;)@ApiModelProperty(value = &quot;课程名称&quot;, required = true)private String name; 增加分组信息 @ApiOperation(&quot;新增课程&quot;)@PostMapping(&quot;&quot;)public CourseBaseInfoVO createCourseBase(@RequestBody @Validated(ValidationGroup.Insert.class) AddCourseDTO dto) &#123; Long companyId = 1232141425L; return courseBaseService.createCourseBase(companyId, dto);&#125;"},{"title":"代码生成工具","path":"/wiki/learning-online/04-project-tools/code-generator.html","content":"可以创建一个模块命名为learning-online-generator，父工程设置为learning-online-parent但其目录位置在learning-online下，目录结构如下： learning-online├── learning-online-base├── learning-online-content├── learning-online-generator└── learning-online-parent 所需依赖如下： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; CodeGenerator在test目录创建代码生成工具，配置好路径和表信息。 CodeGeneratorpublic class CodeGenerator &#123; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/learning-online-generator/src/main/java&quot;); gc.setAuthor(&quot;sw-code&quot;); gc.setOpen(false); // 是否打开文件资源管理器 gc.setFileOverride(false); // 是否覆盖 gc.setServiceName(&quot;%sService&quot;); // 去Service的I前缀 gc.setIdType(IdType.NONE); // 主键策略 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql:///lo_content?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;nullCatalogMeansCurrent=true&quot;); // dsc.setSchemaName(&quot;public&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;xxxxxx&quot;); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setParent(&quot;com.swx.content&quot;); pc.setEntity(&quot;model.po&quot;); pc.setMapper(&quot;mapper&quot;); pc.setService(&quot;service&quot;); pc.setController(&quot;controller&quot;); mpg.setPackageInfo(pc); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;course_base&quot;, &quot;course_market&quot;, &quot;course_teacher&quot;, &quot;course_category&quot;, &quot;teachplan&quot;, &quot;teachplan_media&quot;, &quot;course_publish&quot;, &quot;course_publish_pre&quot;); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 字段注解 strategy.setEntityTableFieldAnnotationEnable(true); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); mpg.execute(); &#125;&#125;"},{"title":"增加网关工程","path":"/wiki/learning-online/04-project-tools/gateway.html","content":"前端需要记录每个微服务的地址，不利于项目上线更换地址。增加网关后，前端只需要请求网关，由网关帮忙路由到各个微服务。 但是网关如何知道每个微服务的地址呢？这个时候就要借助注册中心。每个微服务都将自己注册到注册中心，网关也将自己注册到注册中心；注册中心会记录下每个微服务的地址，网关从注册中心读取服务列表，路由到具体的微服务。 创建网关工程创建learning-online-gateway模块，其Parent为learning-online-parent，但其父目录为learning-online。 其pom依赖如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../learning-online-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;learning-online-gateway&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 在com.swx.gateway包下创建启动类GatewayApplication，内容如下： @SpringBootApplicationpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 配置文件bootstrap.yml放在资源目录resources下，内容如下： bootstrap.ymlspring: application: name: gateway cloud: nacos: discovery: server-addr: 127.0.0.1:8848 namespace: learning-online-dev group: learning-online-project config: server-addr: 127.0.0.1:8848 namespace: learning-online-dev group: learning-online-project file-extension: yaml refresh-enabled: true shared-configs: - data-id: logging-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true profiles: active: dev 日志文件 log4j2-dev.xml同其他微服务。 Nacos配置打开Nacos管理界面，添加新的配置文件：http://ip:8848/nacos 命名空间选择learning-online-dev 创建系统管理工程配置：gateway-dev.yaml ID：gateway-dev.yaml Group：learning-online-project 描述：网关微服务配置 配置内容： gateway-dev.yamlserver: port: 63010spring: cloud: gateway: routes: - id: content-api uri: lb://content-api predicates: - Path=/content/** - id: system-api uri: lb://system-api predicates: - Path=/system/** - id: media-api uri: lb://media-api predicates: - Path=/media/** - id: search uri: lb://search predicates: - Path=/search/** - id: auth-service uri: lb://auth-service predicates: - Path=/auth/** - id: checkcode uri: lb://checkcode predicates: - Path=/checkcode/** - id: learning uri: lb://learning-api predicates: - Path=/learning/** - id: orders uri: lb://orders-api predicates: - Path=/orders/**"},{"title":"注册配置中心","path":"/wiki/learning-online/04-project-tools/nacos.html","content":"所有的微服务应该将自己注册到注册中心，然后相互之间通过远程调用。使用注册中心统一管理微服务的访问地址，也便于其他服务，例如网关服务，无须记录每个微服务地址。 注意本地配置信息优先级最低，包括-Dserver.port 搭建Nacos本项目使用阿里巴巴推出的Nacos作为注册中心和配置中心 使用Docker安装Nacos docker pull nacos/nacos-server:1.2.0 创建容器 docker run --env MODE=standalone --name nacos --restart=always -d -p 8848:8848 nacos/nacos-server:1.2.0 MODE&#x3D;standalone 单机版 –restart&#x3D;always 开机启动 -p 8848:8848 映射端口 -d 创建一个守护式容器在后台运行 访问地址：http://ip:8848/nacos 创建命名空间进入到Nacos控制后台界面，分别创建下面两个命名空间： 命名空间名称:开发环境——学成在线命名空间ID:learning-online-dev描述:学成在线开发环境 命名空间名称:生产环境——学成在线命名空间ID:learning-online-prod描述:学成在线生产环境 创建配置信息进入到Nacos控制后台界面，在右侧找到配置管理，点击配置列表，选择开发环境。 创建公共配置：logging-dev.yaml ID：logging-dev.yaml Group：learning-online-common 描述：日志配置 配置内容： logging-dev.yaml# 日志文件位置logging: config: classpath:log4j2-dev.xml 创建公共配置：logging-dev.yaml ID：feign-dev.yaml Group：learning-online-common 描述：远程调用Feign配置 配置内容： feign-dev.yamlfeign: httpclient: enabled: true hystrix: enabled: true circuitbreaker: enabled: truehystrix: command: default: execution: isolation: #strategy: SEMAPHORE thread: timeoutInMilliseconds: 1000 ribbon: ConnectTimeout: 60000 # 连接超时时间 ReadTimeout: 60000 MaxAutoRetries: 0 MaxAutoRetriesNextServer: 1 创建消息队列配置：rabbitmq-dev.yaml ID：rabbitmq-dev.yaml Group：learning-online-common 配置内容： rabbitmq-dev.yamlspring: rabbitmq: host: 124.221.23.47 port: 5672 username: swcode password: 123321 virtual-host: / publisher-confirm-type: correlated #correlated 异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback publisher-returns: true #开启publish-return功能，同样是基于callback机制，需要定义ReturnCallback template: mandatory: true #定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息 listener: simple: prefetch: 1 #每次只能获取一条消息，处理完成才能获取下一个消息 acknowledge-mode: auto #auto:出现异常时返回unack，消息回滚到mq；没有异常，返回ack ,manual:手动控制,none:丢弃消息，不回滚到mq retry: enabled: false #开启消费者失败重试 initial-interval: 5000ms #初识的失败等待时长为1秒 multiplier: 1 #失败的等待时长倍数，下次等待时长 = multiplier * last-interval max-attempts: 3 #最大重试次数 stateless: true #true无状态；false有状态。如果业务中包含事务，这里改为false 修改微服务工程找到learning-online-parent父工程，添加版本信息： pom.xml&lt;properties&gt; &lt;spring-cloud-alibaba.version&gt;2.2.5.RELEASE&lt;/spring-cloud-alibaba.version&gt;&lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 重新启动微服务重新启动后即可以在Nacos中看到服务列表："},{"title":"初始化工程","path":"/wiki/learning-online/05-system/init.html","content":"创建learning-online-system模块，其Parent为learning-online-parent，但其父目录为learning-online。 创建learning-online-system-api模块，其Parent为learning-online-system，在pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-system-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类，在com.swx.system包下创建启动类SystemApplication SystemApplication@SpringBootApplication@MapperScan(&quot;com.swx.system.mapper&quot;)public class SystemApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SystemApplication.class, args); &#125;&#125; 配置文件 bootstrap.ymlspring: application: name: system-api cloud: nacos: discovery: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project config: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project file-extension: yaml refresh-enabled: true extension-configs: - data-id: system-service-$&#123;spring.profiles.active&#125;.yaml group: learning-online-project refresh: true shared-configs: - data-id: logging-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true profiles: active: dev 日志配置，在learning-online-content-api工程的resources下创建log4j2-dev.xml log4j2-dev.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration monitorInterval=&quot;180&quot; packages=&quot;&quot;&gt; &lt;properties&gt; &lt;property name=&quot;logdir&quot;&gt;logs&lt;/property&gt; &lt;property name=&quot;PATTERN&quot;&gt;%date&#123;YYYY-MM-dd HH:mm:ss,SSS&#125; %level [%thread][%file:%line] - %msg%n%throwable&lt;/property&gt; &lt;/properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;ErrorAppender&quot; fileName=&quot;$&#123;logdir&#125;/error.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/error.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;DebugAppender&quot; fileName=&quot;$&#123;logdir&#125;/info.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/info.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;!--异步appender--&gt; &lt;Async name=&quot;AsyncAppender&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;ErrorAppender&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Async&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的debug信息 &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt;--&gt; &lt;logger name=&quot;cn.itcast.wanxinp2p.consumer.mapper&quot; level=&quot;DEBUG&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;springfox&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;com.netflix.discovery&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqCommon&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqRemoting&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqClient&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.lottery&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.bonuspoint&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;!--OFF 0--&gt; &lt;!--FATAL 100--&gt; &lt;!--ERROR 200--&gt; &lt;!--WARN 300--&gt; &lt;!--INFO 400--&gt; &lt;!--DEBUG 500--&gt; &lt;!--TRACE 600--&gt; &lt;!--ALL Integer.MAX_VALUE--&gt; &lt;Root level=&quot;DEBUG&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;AsyncAppender&quot;/&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 创建learning-online-system-model模块，其Parent为learning-online-system，在pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建learning-online-system-service模块，其Parent为&#96;learning-online-system，在pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-system-model&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;"},{"title":"Nacos配置","path":"/wiki/learning-online/05-system/nacos.html","content":"找到Nacos配置列表，选择开发环境learning-online-dev 创建系统管理工程配置：system-api-dev.yaml ID：system-api-dev.yaml Group：learning-online-project 描述：学成在线系统管理微服务开发环境配置 配置内容： system-api-dev.yamlserver: port: 63110 servlet: context-path: /systemspring: cloud: config: # 本地优先 override-none: true 创建系统管理工程配置：system-service-dev.yaml ID：system-service-dev.yaml Group：learning-online-project 配置内容： system-service-dev.yamlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///lo_system?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: 123456mybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.system.model.po"},{"title":"课程类别服务","path":"/wiki/learning-online/06-content/category.html","content":"在learning-online-content-api工程的com.swx.content.api包下创建控制类 api.CourseCategoryController/** * &lt;p&gt; * 课程分类信息 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */@Api(value = &quot;课程分类信息管理接口&quot;)@RestController@RequestMapping(&quot;/course-category&quot;)public class CourseCategoryController &#123;&#125; 查询所有类别课程类别是树形表结构，在查询到时候用到了MySQL8的递归查询，在代码中处理查询结果将二级类别添加到父类别的childrenTreeNodes列表中。 接口信息如下 值 路径地址 http://localhost:63040/content/course-category/tree-nodes 请求方式 GET 请求参数 返回结果 List 返回结果VOCourseCategoryTreeVO@Data@EqualsAndHashCode(callSuper = true)public class CourseCategoryTreeVO extends CourseCategory implements Serializable &#123; private static final long serialVersionUID = 1L; List&lt;CourseCategoryTreeVO&gt; childrenTreeNodes;&#125; 定义Mapper找到CourseCategoryMapper，定义递归查询方法 /** * &lt;p&gt; * 课程分类 Mapper 接口 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */public interface CourseCategoryMapper extends BaseMapper&lt;CourseCategory&gt; &#123; public List&lt;CourseCategory&gt; selectTreeNodes(@Param(&quot;id&quot;) String id);&#125; 在resources/mapper/CourseCategoryMapper.xml中实现该方法： CourseCategoryMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.content.mapper.CourseCategoryMapper&quot;&gt; &lt;select id=&quot;selectTreeNodes&quot; parameterType=&quot;string&quot; resultType=&quot;com.swx.content.model.po.CourseCategory&quot;&gt; WITH RECURSIVE t1 as ( SELECT c1.* FROM course_category c1 WHERE id = #&#123;id&#125; UNION ALL SELECT c2.* FROM course_category c2 INNER JOIN t1 ON t1.id = c2.parentid ) SELECT * FROM t1 order by t1.id &lt;/select&gt;&lt;/mapper&gt; 树型表的标记字段是什么？如何查询MySQL树型表？ 树型表的标记字段是parentid即父节点id；查询方法一般有两种：1）当层级固定时可以用表的自连接进行查询2）如果灵活查询每个层级可以使用mysql递归方法，使用WITH RECURSIVE t1 AS() 实现 resultType和resultMap的区别 resultType需要实体类和查询的字段名对应，会自动映射resultMap为自定义映射规则，当查询字段名和实体类不匹配（别名）时可通过resultMap实现一对一映射；此外resultMap还可以进行一对多映射（集合）。 #{}和${}有什么区别？ #{}是标记一个占位符，可防治sql注入${} 用于动态sql中拼接字符串，可能导致sql注入 定义ServiceService就是将递归查询的结果进行组装，形成二级树形结构。 如果参数id是’1’，则代表查询所有类别，此时和不使用递归查询没区别但是当id是’1-1’这种二级目录时，查询的是以当前二级目录为根目录的递归结果。 找到CourseCategoryService接口，定义课程查询接口 CourseCategoryService/** * &lt;p&gt; * 课程分类 服务类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */public interface CourseCategoryService extends IService&lt;CourseCategory&gt; &#123; /** * 查询课程分类信息 * * @return 树形结构的分类信息 */ List&lt;CourseCategoryTreeVO&gt; treeNodes(String id);&#125; 实现该方法，找到其实现类CourseCategoryServiceImpl CourseCategoryServiceImpl/** * &lt;p&gt; * 课程分类 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */@Servicepublic class CourseCategoryServiceImpl extends ServiceImpl&lt;CourseCategoryMapper, CourseCategory&gt; implements CourseCategoryService &#123; /** * 查询课程分类信息 * * @return 树形结构的分类信息 */ @Override public List&lt;CourseCategoryTreeVO&gt; treeNodes(String id) &#123; // 查询数据 List&lt;CourseCategory&gt; courseCategories = baseMapper.selectTreeNodes(id); // 将数据转换为VO形式 List&lt;CourseCategoryTreeVO&gt; courseCategoryVos = courseCategories.stream().map(item -&gt; &#123; CourseCategoryTreeVO vo = new CourseCategoryTreeVO(); BeanUtils.copyProperties(item, vo); return vo; &#125;).collect(Collectors.toList()); // 转为Map&lt;id, vo&gt;的形式 Map&lt;String, CourseCategoryTreeVO&gt; map = courseCategoryVos.stream() .filter(item -&gt; !id.equals(item.getId())) .collect(Collectors.toMap(CourseCategory::getId, value -&gt; value, (key1, key2) -&gt; key1)); // 组装树形结构 ArrayList&lt;CourseCategoryTreeVO&gt; results = new ArrayList&lt;&gt;(); courseCategoryVos.stream() .filter(item -&gt; !id.equals(item.getId())) .forEach(item -&gt; &#123; if (item.getParentid().equals(id)) &#123; // 根节点 results.add(item); &#125; // item的父节点 CourseCategoryTreeVO categoryTreeVO = map.get(item.getParentid()); if (categoryTreeVO != null) &#123; if (categoryTreeVO.getChildrenTreeNodes() == null) &#123; categoryTreeVO.setChildrenTreeNodes(new ArrayList&lt;&gt;()); &#125; // 添加到其父节点 categoryTreeVO.getChildrenTreeNodes().add(item); &#125; &#125;); return results; &#125;&#125; 定义ControllerCourseBaseInfoController/** * &lt;p&gt; * 课程分类信息 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */@Api(value = &quot;课程分类信息管理接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/course-category&quot;)public class CourseCategoryController &#123; private final CourseCategoryService courseCategoryService; public CourseCategoryController(CourseCategoryService courseCategoryService) &#123; this.courseCategoryService = courseCategoryService; &#125; @ApiOperation(&quot;课程查询接口&quot;) @GetMapping(&quot;/tree-nodes&quot;) public List&lt;CourseCategoryTreeVO&gt; treeNodes() &#123; return courseCategoryService.treeNodes(&quot;1&quot;); &#125;&#125; Push到Gitcommit &quot;完成课程类别查询功能&quot;"},{"title":"查询系统字典","path":"/wiki/learning-online/05-system/select.html","content":"定义实体类在learning-online-system-model工程的com.swx.system.model.po包下创建Dictionary Dictionary/** * 字典实体类 */@Data@TableName(&quot;dictionary&quot;)public class Dictionary &#123; private static final long serialVersionUID = 1L; /** * 主键 */ @TableId(value = &quot;id&quot;, type = IdType.AUTO) public Long id; /** * 数据字典名称 */ @TableField(&quot;name&quot;) public String name; /** * 数据字典代码 */ @TableField(&quot;code&quot;) public String code; /** * 数据字典项--json格式 */ @TableField(&quot;item_values&quot;) public String itemValues;&#125; 定义Mapper在learning-online-system-service工程下的com.swx.system.mapper包下创建DictionaryMapper DictionaryMapperpublic interface DictionaryMapper extends BaseMapper&lt;Dictionary&gt; &#123;&#125; 在learning-online-system-service工程下的com.swx.system.service包下创建DictionaryService DictionaryMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.system.mapper.DictionaryMapper&quot;&gt;&lt;/mapper&gt; 定义Service在learning-online-system-service工程下的com.swx.system.service包下创建DictionaryService DictionaryServicepublic interface DictionaryService extends IService&lt;Dictionary&gt; &#123; /** * 根据code获取字典 * * @param code 字典code * @return 指定字典 */ Dictionary getByCode(String code);&#125; 实现该接口，在impl下创建DictionaryServiceImpl impl.DictionaryServiceImpl@Servicepublic class DictionaryServiceImpl extends ServiceImpl&lt;DictionaryMapper, Dictionary&gt; implements DictionaryService &#123; /** * 根据code获取字典 * * @param code 字典code * @return 指定字典 */ @Override public Dictionary getByCode(String code) &#123; return getOne(Wrappers.&lt;Dictionary&gt;lambdaQuery().eq(Dictionary::getCode, code)); &#125;&#125; 定义Controlller配置跨域浏览器访问导致跨域，这里暂时在后端使用拦截器做跨域处理 GlobalCorsConfig@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; CorsConfiguration config = new CorsConfiguration(); config.addAllowedOrigin(&quot;*&quot;); // 允许跨域发送cookie config.setAllowCredentials(true); // 放行全部原始头信息 config.addAllowedHeader(&quot;*&quot;); // 允许所有方法跨域调用 config.addAllowedMethod(&quot;*&quot;); UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource(); corsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, config); return new CorsFilter(corsConfigurationSource); &#125;&#125; 定义ControllerDictionaryController/** * 系统字典接口类 */@Api(&quot;系统字典接口类&quot;)@RestController@ResponseResult@RequestMapping(&quot;/dictionary&quot;)public class DictionaryController &#123; private final DictionaryService dictionaryService; public DictionaryController(DictionaryService dictionaryService) &#123; this.dictionaryService = dictionaryService; &#125; @ApiOperation(&quot;查询所有字典&quot;) @GetMapping(&quot;/all&quot;) public List&lt;Dictionary&gt; queryAll() &#123; return dictionaryService.list(); &#125; @GetMapping(&quot;/code/&#123;code&#125;&quot;) public Dictionary getByCode(@PathVariable(&quot;code&quot;) String code) &#123; return dictionaryService.getByCode(code); &#125;&#125; 系统字典服务已经提供，此时可以打开前端项目验证代码是否正确。"},{"title":"课程信息服务","path":"/wiki/learning-online/06-content/course.html","content":"查询所有课程接口信息如下 值 路径地址 http://localhost:63040/content/course/list 请求方式 POST 请求参数 PageParam、QueryCourseParamsDTO 返回结果 PageResult 查询DTOQueryCourseParamsDTO/** * 课程查询条件模型类 */@Datapublic class QueryCourseParamsDTO implements Serializable &#123; private static final long serialVersionUID = 1L; // 审核状态 private String auditStatus; // 课程名称 private String courseName; // 发布状态 private String publishStatus;&#125; 定义Service找到CourseBaseService接口，定义课程查询接口 CourseBaseService/** * &lt;p&gt; * 课程基本信息 服务类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */public interface CourseBaseService extends IService&lt;CourseBase&gt; &#123; /** * 课程分页查询 * * @param pageParam 分页参数 * @param dto 查询参数 */ public PageResult&lt;CourseBase&gt; queryCourseBaseList(PageParam pageParam, QueryCourseParamsDTO dto);&#125; 实现该方法，找到其实现类CourseBaseServiceImp CourseBaseServiceImpl/** * &lt;p&gt; * 课程基本信息 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */@Servicepublic class CourseBaseServiceImpl extends ServiceImpl&lt;CourseBaseMapper, CourseBase&gt; implements CourseBaseService &#123; /** * 课程分页查询 * * @param pageParam 分页参数 * @param dto 查询参数 */ @Override public PageResult&lt;CourseBase&gt; queryCourseBaseList(PageParam pageParam, QueryCourseParamsDTO dto) &#123; LambdaQueryWrapper&lt;CourseBase&gt; wrapper = Wrappers.&lt;CourseBase&gt;lambdaQuery() .like(StringUtils.hasText(dto.getCourseName()), CourseBase::getName, dto.getCourseName()) .eq(StringUtils.hasText(dto.getAuditStatus()), CourseBase::getAuditStatus, dto.getAuditStatus()) .eq(StringUtils.hasText(dto.getPublishStatus()), CourseBase::getStatus, dto.getPublishStatus()); Page&lt;CourseBase&gt; page = new Page&lt;&gt;(pageParam.getPageNo(), pageParam.getPageSize()); Page&lt;CourseBase&gt; pageResult = page(page, wrapper); return new PageResult&lt;&gt;(pageResult.getRecords(), pageResult.getTotal(), pageParam); &#125;&#125; 配置分页插件在learning-online-content-service工程下的com.swx.content.config包下创建分页配置类，其内容如下： MybatisPlusConfig@Configuration@MapperScan(&quot;com.swx.content.mapper&quot;)public class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; Mybatis分页插件的原理 首先分页参数放到ThreadLocal中，拦截执行的sql，根据数据库类型添加对应的分页语句重写sql，例如：(select * from table where a)转换为(select count(*) from table where a)和(select * from table where a limit ,)，计算出total总条数，pageNum当前第几页，pageSize每页大小和当前页数据，是否为首页，是否为尾页，总页数等。 定义ControllerCourseBaseInfoController@Api(value = &quot;课程基本信息管理接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/course&quot;)public class CourseBaseInfoController &#123; private final CourseBaseService courseBaseService; public CourseBaseInfoController(CourseBaseService courseBaseService) &#123; this.courseBaseService = courseBaseService; &#125; @ApiOperation(&quot;课程查询接口&quot;) @PostMapping(&quot;/list&quot;) public PageResult&lt;CourseBase&gt; list(PageParam pageParam, @RequestBody(required = false) QueryCourseParamsDTO dto) &#123; return courseBaseService.queryCourseBaseList(pageParam, dto); &#125;&#125; 课程查询信息服务以提供，打开前端项目查看是否成功 Push到Gitcommit &quot;完成课程查询功能&quot; 新增课程信息接口信息如下 值 路径地址 http://localhost:63040/content/course 请求方式 POST 请求参数 AddCourseDTO 返回结果 CourseBaseInfoVO 新增DTOQueryCourseParamsDTO@Data@ApiModel(value = &quot;AddCourseDTO&quot;, description = &quot;新增课程基本信息&quot;)public class AddCourseDTO &#123; @NotEmpty(message = &quot;课程名称不能为空&quot;) @ApiModelProperty(value = &quot;课程名称&quot;, required = true) private String name; @NotEmpty(message = &quot;适用人群不能为空&quot;) @Size(message = &quot;适用人群内容过少&quot;, min = 10) @ApiModelProperty(value = &quot;适用人群&quot;, required = true) private String users; @ApiModelProperty(value = &quot;课程标签&quot;) private String tags; @NotEmpty(message = &quot;课程分类不能为空&quot;) @ApiModelProperty(value = &quot;课程大分类&quot;, required = true) private String mt; @NotEmpty(message = &quot;课程分类不能为空&quot;) @ApiModelProperty(value = &quot;课程小分类&quot;, required = true) private String st; @NotEmpty(message = &quot;课程等级不能为空&quot;) @ApiModelProperty(value = &quot;课程等级&quot;, required = true) private String grade; @NotEmpty(message = &quot;课程等级不能为空&quot;) @ApiModelProperty(value = &quot;教学模式（普通，录播，直播等）&quot;, required = true) private String teachmode; @ApiModelProperty(value = &quot;课程介绍&quot;) private String description; @ApiModelProperty(value = &quot;课程图片&quot;) private String pic; @NotEmpty(message = &quot;收费规则不能为空&quot;) @ApiModelProperty(value = &quot;收费规则，对应数据字典&quot;, required = true) private String charge; @ApiModelProperty(value = &quot;价格&quot;) private Float price; @ApiModelProperty(value = &quot;原价&quot;) private Float originPrice; @ApiModelProperty(value = &quot;QQ&quot;) private String qq; @ApiModelProperty(value = &quot;微信&quot;) private String wechat; @ApiModelProperty(value = &quot;电话&quot;) private String phone; @ApiModelProperty(value = &quot;有效期&quot;) private Integer validDays;&#125; 视图VOCourseBaseInfoVO@Data@EqualsAndHashCode(callSuper = true)public class CourseBaseInfoVO extends CourseBase &#123; private String users; private String tags; private String mt; private String st; private String mtName; private String stName; private String grade; private String teachmode; private String description; private String pic; private String charge; private Float price; private Float originPrice; private String qq; private String wechat; private String phone; private String validDays;&#125; 定义Service找到CourseBaseService接口，定义课程新增接口 CourseBaseService/** * 新增课程 * * @param companyId 机构ID * @param dto 课程信息 */public CourseBaseInfoVO createCourseBase(Long companyId, AddCourseDTO dto); 实现该方法，找到其实现类CourseBaseServiceImp，添加如下代码： CourseBaseServiceImplprivate final CourseMarketService courseMarketService;private final CourseCategoryService courseCategoryService;public CourseBaseServiceImpl(CourseMarketService courseMarketService, CourseCategoryService courseCategoryService) &#123; this.courseMarketService = courseMarketService; this.courseCategoryService = courseCategoryService;&#125;/** * 新增课程 * * @param companyId 机构ID * @param dto 课程信息 */@Override@Transactional(rollbackFor = Exception.class)public CourseBaseInfoVO createCourseBase(Long companyId, AddCourseDTO dto) &#123; // 新增course_base数据 CourseBase courseBase = new CourseBase(); BeanUtils.copyProperties(dto, courseBase); courseBase.setCompanyId(companyId); courseBase.setCreateDate(LocalDateTime.now()); // TODO 添加创建人信息 courseBase.setStatus(&quot;203001&quot;); courseBase.setAuditStatus(&quot;202002&quot;); boolean save = save(courseBase); if (!save) &#123; throw new BizException(&quot;添加课程失败&quot;); &#125; // 新增course_market数据 CourseMarket courseMarket = new CourseMarket(); BeanUtils.copyProperties(dto, courseMarket); courseMarket.setId(courseBase.getId()); courseMarketService.saveOrUpdateCourseMarket(courseMarket); // 查询详细信息 return getCourseBaseInfo(courseMarket.getId());&#125;/** * 查询课程信息 * * @param courseId 课程ID * @return 课程信息 */public CourseBaseInfoVO getCourseBaseInfo(long courseId) &#123; // 查询基本信息 CourseBase courseBase = getById(courseId); if (courseBase == null) &#123; return null; &#125; // 查询营销信息 CourseMarket courseMarket = courseMarketService.getById(courseId); CourseBaseInfoVO courseBaseInfoVO = new CourseBaseInfoVO(); BeanUtils.copyProperties(courseBase, courseBaseInfoVO); BeanUtils.copyProperties(courseMarket, courseBaseInfoVO); // 查询分类信息 CourseCategory mtCategory = courseCategoryService.getById(courseBase.getMt()); CourseCategory stCategory = courseCategoryService.getById(courseBase.getSt()); courseBaseInfoVO.setMtName(mtCategory == null ? &quot;&quot; : mtCategory.getName()); courseBaseInfoVO.setStName(stCategory == null ? &quot;&quot; : stCategory.getName()); return courseBaseInfoVO;&#125; 定义Controller找到CourseBaseInfoController，添加新增课程服务 CourseBaseInfoController@ApiOperation(&quot;新增课程&quot;)@PostMapping(&quot;&quot;)public CourseBaseInfoVO createCourseBase(@RequestBody @Validated(ValidationGroup.Insert.class) AddCourseDTO dto) &#123; // TODO 暂时使用固定值 Long companyId = 1232141425L; return courseBaseService.createCourseBase(companyId, dto);&#125; 新增课程信息服务以提供，打开前端项目查看是否成功 Push到Gitcommit &quot;完成新增课程功能&quot; 修改课程信息接口信息如下 值 路径地址 http://localhost:63040/content/course 请求方式 PUT 请求参数 AddCourseDTO 返回结果 CourseBaseInfoVO 定义Service找到CourseBaseService接口，定义课程新增接口 CourseBaseService/** * 更新课程信息 * * @param companyId 公司ID * @param dto 修改信息 * @return 更新后的课程详细信息 */CourseBaseInfoVO updateCourseBase(Long companyId, EditCourseDTO dto); 实现该方法，找到其实现类CourseBaseServiceImp，添加如下代码： CourseBaseServiceImpl/** * 更新课程信息 * * @param companyId 公司ID * @param dto 修改信息 * @return 更新后的课程详细信息 */@Override@Transactional(rollbackFor = Exception.class)public CourseBaseInfoVO updateCourseBase(Long companyId, EditCourseDTO dto) &#123; CourseBase dbCourseBase = getById(dto.getId()); if (dbCourseBase == null) &#123; throw new BizException(ResultCodeEnum.DATA_NOT_EXIST); &#125; if (!companyId.equals(dbCourseBase.getCompanyId())) &#123; throw new BizException(&quot;本机构只能修改本机构的课程&quot;); &#125; BeanUtils.copyProperties(dto, dbCourseBase); dbCourseBase.setCreateDate(LocalDateTime.now()); // TODO 添加修改人信息 // 更新课程信息 boolean updateBase = updateById(dbCourseBase); // 更新营销信息 CourseMarket courseMarket = new CourseMarket(); BeanUtils.copyProperties(dto, courseMarket); boolean updateMarket = courseMarketService.saveOrUpdateCourseMarket(courseMarket); if (!updateBase || !updateMarket) &#123; throw new BizException(&quot;修改课程失败&quot;); &#125; return getCourseBaseInfo(dbCourseBase.getId());&#125; 定义Controller找到CourseBaseInfoController，添加新增课程服务 CourseBaseInfoController@ApiOperation(&quot;修改课程&quot;)@PutMapping(&quot;&quot;)public CourseBaseInfoVO updateCourseBase(@RequestBody @Validated EditCourseDTO dto) &#123; // TODO 暂时使用固定值 Long companyId = 1232141425L; return courseBaseService.updateCourseBase(companyId, dto);&#125; 新增课程信息服务以提供，打开前端项目查看是否成功 Push到Gitcommit &quot;完成新增课程功能&quot; 查询具体课程接口信息如下 值 路径地址 http://localhost:63040/content/course/{courseId} 请求方式 GET 请求参数 Long 返回结果 CourseBaseInfoVO 定义Service找到CourseBaseService接口，定义课程新增接口 CourseBaseService/** * 根据ID获取课程信息 * * @param courseId 课程ID */public CourseBaseInfoVO getCourseBaseInfo(Long courseId); 实现该方法，找到其实现类CourseBaseServiceImp，修改代码如下： CourseBaseServiceImpl/** * 查询课程信息 * * @param courseId 课程ID * @return 课程信息 */@Overridepublic CourseBaseInfoVO getCourseBaseInfo(Long courseId) &#123; // 查询基本信息 CourseBase courseBase = getById(courseId); if (courseBase == null) &#123; return null; &#125; // 查询营销信息 CourseMarket courseMarket = Optional.ofNullable(courseMarketService.getById(courseId)).orElse(new CourseMarket()); CourseBaseInfoVO courseBaseInfoVO = new CourseBaseInfoVO(); BeanUtils.copyProperties(courseMarket, courseBaseInfoVO); BeanUtils.copyProperties(courseBase, courseBaseInfoVO); // 查询分类信息 CourseCategory mtCategory = courseCategoryService.getById(courseBase.getMt()); CourseCategory stCategory = courseCategoryService.getById(courseBase.getSt()); courseBaseInfoVO.setMtName(mtCategory == null ? &quot;&quot; : mtCategory.getName()); courseBaseInfoVO.setStName(stCategory == null ? &quot;&quot; : stCategory.getName()); return courseBaseInfoVO;&#125; 定义Controller接口信息找到CourseBaseInfoController，添加新增课程服务 CourseBaseInfoController@ApiOperation(&quot;根据课程id查询接口&quot;)@GetMapping(&quot;/&#123;courseId&#125;&quot;)public CourseBaseInfoVO list(@PathVariable(&quot;courseId&quot;) Long courseId) &#123; return courseBaseService.getCourseBaseInfo(courseId);&#125; 更新课程信息接口信息如下 值 路径地址 http://localhost:63040/content/course 请求方式 PUT 请求参数 EditCourseDTO 返回结果 CourseBaseInfoVO 定义Service找到CourseBaseService接口，定义课程新增接口 CourseBaseService/** * 更新课程信息 * * @param companyId 公司ID * @param dto 修改信息 * @return 更新后的课程详细信息 */CourseBaseInfoVO updateCourseBase(Long companyId, EditCourseDTO dto); 实现该方法，找到其实现类CourseBaseServiceImp，添加如下代码： CourseBaseServiceImpl/** * 更新课程信息 * * @param companyId 公司ID * @param dto 修改信息 * @return 更新后的课程详细信息 */@Override@Transactional(rollbackFor = Exception.class)public CourseBaseInfoVO updateCourseBase(Long companyId, EditCourseDTO dto) &#123; CourseBase dbCourseBase = getById(dto.getId()); if (dbCourseBase == null) &#123; throw new BizException(ResultCodeEnum.DATA_NOT_EXIST); &#125; if (!companyId.equals(dbCourseBase.getCompanyId())) &#123; throw new BizException(&quot;本机构只能修改本机构的课程&quot;); &#125; BeanUtils.copyProperties(dto, dbCourseBase); dbCourseBase.setChangeDate(LocalDateTime.now()); // TODO 添加修改人信息 // 更新课程信息 boolean updateBase = updateById(dbCourseBase); // 更新营销信息 CourseMarket courseMarket = new CourseMarket(); BeanUtils.copyProperties(dto, courseMarket); boolean updateMarket = courseMarketService.saveOrUpdateCourseMarket(courseMarket); if (!updateBase || !updateMarket) &#123; throw new BizException(&quot;修改课程失败&quot;); &#125; return getCourseBaseInfo(dbCourseBase.getId());&#125; 定义Controller找到CourseBaseInfoController，添加新增课程服务 CourseBaseInfoController@ApiOperation(&quot;修改课程&quot;)@PutMapping(&quot;&quot;)public CourseBaseInfoVO updateCourseBase(@RequestBody @Validated EditCourseDTO dto) &#123; // TODO 暂时使用固定值 Long companyId = 1232141425L; return courseBaseService.updateCourseBase(companyId, dto);&#125; Push到Gitcommit &quot;完成课程查询修改功能&quot;"},{"title":"Nacos配置","path":"/wiki/learning-online/06-content/nacos.html","content":"找到Nacos配置列表，选择开发环境learning-online-dev 创建内容管理工程配置：content-api-dev.yaml ID：content-api-dev.yaml Group：learning-online-project 描述：学成在线内容管理微服务开发环境配置 配置内容： content-api-dev.yamlserver: port: 63040 servlet: context-path: /contentspring: cloud: config: # 本地优先 override-none: true 创建内容管理工程配置：content-service-dev.yaml ID：content-service-dev.yaml Group：learning-online-project 配置内容： content-service-dev.yamlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///lo_content?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: rootmybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.content.model.po# xxl-job配置xxl: job: admin: # 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册； addresses: http://127.0.0.1:8080/xxl-job-admin executor: # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。 address: # 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册 appname: coursepublish-executor # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;； ip: # 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口； port: 8999 # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径； logpath: /Users/swcode/data/applogs/xxl-job/jobhandler # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能； logretentiondays: 30 # 执行器通讯TOKEN [选填]：非空时启用； accessToken:"},{"title":"课程营销服务","path":"/wiki/learning-online/06-content/market.html","content":"保存营销信息定义Service找到CourseMarketService，新增保存课程营销信息方法： CourseMarketService/** * &lt;p&gt; * 课程营销信息 服务类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */public interface CourseMarketService extends IService&lt;CourseMarket&gt; &#123; /** * 保存课程营销信息 * * @param courseMarket 课程营销信息 * @return 是否保存成功 */ public boolean saveOrUpdateCourseMarket(CourseMarket courseMarket);&#125; 找到CourseMarketServiceImpl，实现该方法： CourseMarketServiceImpl/** * &lt;p&gt; * 课程营销信息 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */@Servicepublic class CourseMarketServiceImpl extends ServiceImpl&lt;CourseMarketMapper, CourseMarket&gt; implements CourseMarketService &#123; /** * 保存课程营销信息 * * @param courseMarket 课程营销信息 * @return 是否保存成功 */ @Override @Transactional(rollbackFor = Exception.class) public boolean saveOrUpdateCourseMarket(CourseMarket courseMarket) &#123; String charge = courseMarket.getCharge(); if (StringUtils.isEmpty(charge)) &#123; throw new BizException(&quot;收费规则为空&quot;); &#125; if (charge.equals(&quot;201001&quot;)) &#123; if (courseMarket.getPrice() == null || courseMarket.getPrice() &lt;= 0) &#123; throw new BizException(&quot;课程的价格不能为空且必须大于0&quot;); &#125; &#125; CourseMarket dbMarket = getById(courseMarket.getId()); if (dbMarket == null) &#123; return save(courseMarket); &#125; else &#123; BeanUtils.copyProperties(courseMarket, dbMarket); dbMarket.setId(courseMarket.getId()); return updateById(dbMarket); &#125; &#125;&#125; Push到Gitcommit &quot;完成课程类别查询功能&quot;"},{"title":"初始化工程","path":"/wiki/learning-online/06-content/init.html","content":"创建媒资管理工程，分为三个子模块 learning-online-content├── learning-online-content-api├── learning-online-content-model└── learning-online-content-service 创建工程结构在learning-online-content-model模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在learning-online-content-service模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-content-model&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-message-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Freemarker 模版技术 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Feign远程调用 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Feign支持文件传输 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt; &lt;artifactId&gt;feign-form&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt; &lt;artifactId&gt;feign-form-spring&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在learning-online-content-api模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-content-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类，在learning-online-content-api工程的com.swx.content包下创建启动类ContentApplication，内容如下： ContentApplication@SpringBootApplication@EnableTransactionManagement@EnableFeignClients(basePackages = &#123;&quot;com.swx.content.client&quot;&#125;)public class ContentApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ContentApplication.class, args); &#125;&#125; 项目配置信息，在learning-online-content-api工程的resources下创建bootstrap.yml bootstrap.ymlspring: application: name: content-api cloud: nacos: discovery: server-addr: xxx.xxx.xxx.xxx:8848 namespace: learning-online-dev group: learning-online-project config: server-addr: xxx.xxx.xxx.xxx:8848 namespace: learning-online-dev group: learning-online-project file-extension: yaml refresh-enabled: true extension-configs: - data-id: content-service-$&#123;spring.profiles.active&#125;.yaml group: learning-online-project refresh: true shared-configs: - data-id: logging-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true - data-id: freemarker-config-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true - data-id: feign-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true - data-id: redis-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true profiles: active: dev 日志配置，在learning-online-content-api工程的resources下创建log4j2-dev.xml log4j2-dev.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration monitorInterval=&quot;180&quot; packages=&quot;&quot;&gt; &lt;properties&gt; &lt;property name=&quot;logdir&quot;&gt;logs&lt;/property&gt; &lt;property name=&quot;PATTERN&quot;&gt;%date&#123;YYYY-MM-dd HH:mm:ss,SSS&#125; %level [%thread][%file:%line] - %msg%n%throwable&lt;/property&gt; &lt;/properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;ErrorAppender&quot; fileName=&quot;$&#123;logdir&#125;/error.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/error.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;DebugAppender&quot; fileName=&quot;$&#123;logdir&#125;/info.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/info.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;!--异步appender--&gt; &lt;Async name=&quot;AsyncAppender&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;ErrorAppender&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Async&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的debug信息 &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt;--&gt; &lt;logger name=&quot;cn.itcast.wanxinp2p.consumer.mapper&quot; level=&quot;DEBUG&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;springfox&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;com.netflix.discovery&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqCommon&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqRemoting&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqClient&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.lottery&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.bonuspoint&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;!--OFF 0--&gt; &lt;!--FATAL 100--&gt; &lt;!--ERROR 200--&gt; &lt;!--WARN 300--&gt; &lt;!--INFO 400--&gt; &lt;!--DEBUG 500--&gt; &lt;!--TRACE 600--&gt; &lt;!--ALL Integer.MAX_VALUE--&gt; &lt;Root level=&quot;DEBUG&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;AsyncAppender&quot;/&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 基础代码实体类使用代码生成工具生成lo_content表的实体类，将其拷贝到learning-online-content-model工程的com.swx.content.model.po包下，暂时所需实体类如下： CourseBase.java CourseCategory.java CourseMarket.java CoursePublish.java CoursePublishPre.java CourseTeacher.java Teachplan.java TeachplanMedia.java Mapper层将代码生成的所有Mapper.java文件拷贝到learning-online-content-service工程下的com.swx.content.mapper包下。 将代码生成的所有Mapper.xml文件拷贝到learning-online-content-service工程下的resources/mapper目录下。 Service层将代码生成的所有Service和ServiceImpl文件拷贝到learning-online-content-service工程下的com.swx.content.service包下。"},{"title":"课程计划服务","path":"/wiki/learning-online/06-content/plan.html","content":"查询所有计划树型表使用自连接查询，使用Mybatis的一对多映射形成二级目录结构 接口信息如下 值 路径地址 http://localhost:63040/content/teachplan/1/tree-nodes 请求方式 GET 请求参数 路径参数Long 返回结果 List 定义TeachPlanVO其中teachPlanMedia是关联媒体文件，只有根节点才有该属性。 /** * 课程计划信息模型类 */@Data@EqualsAndHashCode(callSuper = true)public class TeachPlanVO extends TeachPlan &#123; private TeachPlanMedia teachplanMedia; private List&lt;TeachPlanVO&gt; teachPlanTreeNodes;&#125; 定义Mapper找到TeachPlanMapper接口，定义计划查询接口： TeachPlanMapper/** * &lt;p&gt; * 课程计划 Mapper 接口 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */public interface TeachPlanMapper extends BaseMapper&lt;TeachPlan&gt; &#123; /** * 查询课程计划 * * @param courseId 课程Id * @return 课程计划 */ public List&lt;TeachPlanVO&gt; getTreeNodes(@Param(&quot;courseId&quot;) Long courseId);&#125; 找到TeachPlanMapper.xml文件，编写查询接口。 课程计划是固定二级结构，所以使用自连接查询，然后使用Mybatis的一对多映射和一对一映射实现二级目录查询。 TeachPlanMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.content.mapper.TeachPlanMapper&quot;&gt; &lt;resultMap id=&quot;treeNodeResultMap&quot; type=&quot;com.swx.content.model.vo.TeachPlanVO&quot;&gt; &lt;id column=&quot;one_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;one_pname&quot; property=&quot;pname&quot; /&gt; &lt;result column=&quot;one_grade&quot; property=&quot;grade&quot; /&gt; &lt;result column=&quot;one_mediaType&quot; property=&quot;mediaType&quot; /&gt; &lt;result column=&quot;one_startTime&quot; property=&quot;startTime&quot; /&gt; &lt;result column=&quot;one_endTime&quot; property=&quot;endTime&quot; /&gt; &lt;result column=&quot;one_orderby&quot; property=&quot;orderby&quot; /&gt; &lt;result column=&quot;one_courseId&quot; property=&quot;courseId&quot; /&gt; &lt;result column=&quot;one_coursePubId&quot; property=&quot;coursePubId&quot; /&gt; &lt;!-- 映射子节点，一对多映射 --&gt; &lt;collection property=&quot;teachPlanTreeNodes&quot; ofType=&quot;com.swx.content.model.vo.TeachPlanVO&quot;&gt; &lt;id column=&quot;two_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;two_id&quot; property=&quot;pname&quot; /&gt; &lt;result column=&quot;two_grade&quot; property=&quot;grade&quot; /&gt; &lt;result column=&quot;two_mediaType&quot; property=&quot;mediaType&quot; /&gt; &lt;result column=&quot;two_startTime&quot; property=&quot;startTime&quot; /&gt; &lt;result column=&quot;two_endTime&quot; property=&quot;endTime&quot; /&gt; &lt;result column=&quot;two_orderby&quot; property=&quot;orderby&quot; /&gt; &lt;result column=&quot;two_courseId&quot; property=&quot;courseId&quot; /&gt; &lt;result column=&quot;two_coursePubId&quot; property=&quot;coursePubId&quot; /&gt; &lt;!-- 映射子节点，一对一映射 --&gt; &lt;association property=&quot;teachplanMedia&quot; javaType=&quot;com.swx.content.model.po.TeachPlanMedia&quot;&gt; &lt;id column=&quot;teachPlanMediaId&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;mediaFilename&quot; property=&quot;mediaFilename&quot; /&gt; &lt;result column=&quot;mediaId&quot; property=&quot;mediaId&quot; /&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getTreeNodes&quot; parameterType=&quot;long&quot; resultMap=&quot;treeNodeResultMap&quot;&gt; SELECT one.id one_id, one.pname one_pname, one.grade one_grade, one.media_type one_mediaType, one.start_time one_startTime, one.end_time one_endTime, one.orderby one_orderby, one.course_id one_courseId, one.course_pub_id one_coursePubId, two.id two_id, two.pname two_pname, two.grade two_grade, two.media_type two_mediaType, two.start_time two_startTime, two.end_time two_endTime, two.orderby two_orderby, two.course_id two_courseId, two.course_pub_id two_coursePubId, tm.media_fileName mediaFilename, tm.id teachPlanMediaId, tm.media_id mediaId FROM teachplan one LEFT JOIN teachplan two ON one.id = two.parentid LEFT JOIN teachplan_media tm on two.id = tm.teachplan_id WHERE one.parentid = 0 AND one.course_id = #&#123;courseId&#125; &lt;/select&gt;&lt;/mapper&gt; 定义Service找到TeachPlanService接口，定义计划查询接口 TeachPlanService/** * &lt;p&gt; * 课程计划 服务类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */public interface TeachPlanService extends IService&lt;TeachPlan&gt; &#123; /** * 查询课程计划树形结构 * * @param courseId 课程Id * @return 课程计划树形结构 */ public List&lt;TeachPlanVO&gt; getTreeNodes(Long courseId);&#125; 实现该方法，找到其实现类TeachPlanServiceImpl TeachPlanServiceImpl/** * &lt;p&gt; * 课程计划 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */@Servicepublic class TeachPlanServiceImpl extends ServiceImpl&lt;TeachPlanMapper, TeachPlan&gt; implements TeachPlanService &#123; /** * 查询课程计划树形结构 * * @param courseId 课程Id * @return 课程计划树形结构 */ @Override public List&lt;TeachPlanVO&gt; getTreeNodes(Long courseId) &#123; return baseMapper.getTreeNodes(courseId); &#125;&#125; 定义ControllerTeachPlanController/** * &lt;p&gt; * 课程计划信息 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-20 */@Api(value = &quot;课程计划信息编辑接口&quot;, tags = &quot;课程计划信息编辑接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/teachplan&quot;)public class TeachPlanController &#123; private final TeachPlanService teachPlanService; public TeachPlanController(TeachPlanService teachPlanService) &#123; this.teachPlanService = teachPlanService; &#125; @ApiOperation(&quot;查询课程计划树形结构&quot;) @GetMapping(&quot;/&#123;courseId&#125;/tree-nodes&quot;) public List&lt;TeachPlanVO&gt; getTreeNodes(@PathVariable(&quot;courseId&quot;) Long courseId) &#123; return teachPlanService.getTreeNodes(courseId); &#125;&#125; 课程查询信息服务以提供，打开前端项目查看是否成功 Push到Gitcommit &quot;完成课程计划查询功能&quot; 更新课程计划接口信息如下 值 路径地址 http://localhost:63040/content/teachplan/1/tree-nodes 请求方式 POST 请求参数 SaveTeachPlan 返回结果 List 定义TeachPlanVO其中teachPlanMedia是关联媒体文件，只有根节点才有该属性。 /** * 课程计划信息模型类 */@Data@EqualsAndHashCode(callSuper = true)public class TeachPlanVO extends TeachPlan &#123; private TeachPlanMedia teachPlanMedia; private List&lt;TeachPlanVO&gt; teachPlanTreeNodes;&#125; 定义Mapper找到TeachPlanMapper接口，定义计划查询接口： TeachPlanMapper/** * &lt;p&gt; * 课程计划 Mapper 接口 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */public interface TeachPlanMapper extends BaseMapper&lt;TeachPlan&gt; &#123; /** * 查询课程计划 * * @param courseId 课程Id * @return 课程计划 */ public List&lt;TeachPlanVO&gt; getTreeNodes(@Param(&quot;courseId&quot;) Long courseId);&#125; 找到TeachPlanMapper.xml文件，编写查询接口。 课程计划是固定二级结构，所以使用自连接查询，然后使用Mybatis的一对多映射和一对一映射实现二级目录查询。 TeachPlanMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.content.mapper.TeachPlanMapper&quot;&gt; &lt;resultMap id=&quot;treeNodeResultMap&quot; type=&quot;com.swx.content.model.vo.TeachPlanVO&quot;&gt; &lt;id column=&quot;one_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;one_pname&quot; property=&quot;pname&quot; /&gt; &lt;result column=&quot;one_grade&quot; property=&quot;grade&quot; /&gt; &lt;result column=&quot;one_mediaType&quot; property=&quot;mediaType&quot; /&gt; &lt;result column=&quot;one_startTime&quot; property=&quot;startTime&quot; /&gt; &lt;result column=&quot;one_endTime&quot; property=&quot;endTime&quot; /&gt; &lt;result column=&quot;one_orderby&quot; property=&quot;orderby&quot; /&gt; &lt;result column=&quot;one_courseId&quot; property=&quot;courseId&quot; /&gt; &lt;result column=&quot;one_coursePubId&quot; property=&quot;coursePubId&quot; /&gt; &lt;!-- 映射子节点，一对多映射 --&gt; &lt;collection property=&quot;teachPlanTreeNodes&quot; ofType=&quot;com.swx.content.model.vo.TeachPlanVO&quot;&gt; &lt;id column=&quot;two_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;two_id&quot; property=&quot;pname&quot; /&gt; &lt;result column=&quot;two_grade&quot; property=&quot;grade&quot; /&gt; &lt;result column=&quot;two_mediaType&quot; property=&quot;mediaType&quot; /&gt; &lt;result column=&quot;two_startTime&quot; property=&quot;startTime&quot; /&gt; &lt;result column=&quot;two_endTime&quot; property=&quot;endTime&quot; /&gt; &lt;result column=&quot;two_orderby&quot; property=&quot;orderby&quot; /&gt; &lt;result column=&quot;two_courseId&quot; property=&quot;courseId&quot; /&gt; &lt;result column=&quot;two_coursePubId&quot; property=&quot;coursePubId&quot; /&gt; &lt;!-- 映射子节点，一对一映射 --&gt; &lt;association property=&quot;teachPlanMedia&quot; javaType=&quot;com.swx.content.model.po.TeachPlanMedia&quot;&gt; &lt;id column=&quot;teachPlanMediaId&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;mediaFilename&quot; property=&quot;mediaFilename&quot; /&gt; &lt;result column=&quot;mediaId&quot; property=&quot;mediaId&quot; /&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getTreeNodes&quot; parameterType=&quot;long&quot; resultMap=&quot;treeNodeResultMap&quot;&gt; SELECT one.id one_id, one.pname one_pname, one.grade one_grade, one.media_type one_mediaType, one.start_time one_startTime, one.end_time one_endTime, one.orderby one_orderby, one.course_id one_courseId, one.course_pub_id one_coursePubId, two.id two_id, two.pname two_pname, two.grade two_grade, two.media_type two_mediaType, two.start_time two_startTime, two.end_time two_endTime, two.orderby two_orderby, two.course_id two_courseId, two.course_pub_id two_coursePubId, tm.media_fileName mediaFilename, tm.id teachPlanMediaId, tm.media_id mediaId FROM teachplan one INNER JOIN teachplan two ON one.id = two.parentid LEFT JOIN teachplan_media tm on two.id = tm.teachplan_id WHERE one.parentid = 0 AND one.course_id = #&#123;courseId&#125; &lt;/select&gt;&lt;/mapper&gt; 定义Service找到TeachPlanService接口，定义计划查询接口 TeachPlanService/** * &lt;p&gt; * 课程计划 服务类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */public interface TeachPlanService extends IService&lt;TeachPlan&gt; &#123; /** * 查询课程计划树形结构 * * @param courseId 课程Id * @return 课程计划树形结构 */ public List&lt;TeachPlanVO&gt; getTreeNodes(Long courseId);&#125; 实现该方法，找到其实现类TeachPlanServiceImpl TeachPlanServiceImpl/** * &lt;p&gt; * 课程计划 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */@Servicepublic class TeachPlanServiceImpl extends ServiceImpl&lt;TeachPlanMapper, TeachPlan&gt; implements TeachPlanService &#123; /** * 查询课程计划树形结构 * * @param courseId 课程Id * @return 课程计划树形结构 */ @Override public List&lt;TeachPlanVO&gt; getTreeNodes(Long courseId) &#123; return baseMapper.getTreeNodes(courseId); &#125;&#125; 定义ControllerTeachPlanController/** * &lt;p&gt; * 课程计划信息 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-20 */@Api(value = &quot;课程计划信息编辑接口&quot;, tags = &quot;课程计划信息编辑接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/teachplan&quot;)public class TeachPlanController &#123; private final TeachPlanService teachPlanService; public TeachPlanController(TeachPlanService teachPlanService) &#123; this.teachPlanService = teachPlanService; &#125; @ApiOperation(&quot;查询课程计划树形结构&quot;) @GetMapping(&quot;/&#123;courseId&#125;/tree-nodes&quot;) public List&lt;TeachPlanVO&gt; getTreeNodes(@PathVariable(&quot;courseId&quot;) Long courseId) &#123; return teachPlanService.getTreeNodes(courseId); &#125;&#125; 课程查询信息服务以提供，打开前端项目查看是否成功 Push到Gitcommit &quot;完成课程计划查询功能&quot; 绑定媒资文件 该部分需要实现媒资管理服务，请先转到媒资管理工程，完成该部分开发。 接口信息如下 值 路径地址 http://localhost:63040/content/teachplan/association/media 请求方式 POST 请求参数 BindTeachPlanMediaDTO 返回结果 TeachPlanMedia 定义TeachPlanDTO其中teachPlanMedia是关联媒体文件，只有根节点才有该属性。 BindTeachPlanMediaDTO@Datapublic class BindTeachPlanMediaDTO implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 媒资文件ID */ @NotBlank(message = &quot;媒资文件不能为空&quot;) private String mediaId; /** * 媒资文件名称 */ private String fileName; /** * 课程计划标识 */ @NotNull(message = &quot;课程计划信息不能为空&quot;) private Long teachplanId;&#125; 定义Service找到TeachPlanService接口，定义计划查询接口 TeachPlanService/** * 课程计划和媒资信息绑定 * * @param dto 绑定信息 */public TeachPlanMedia associationMedia(BindTeachPlanMediaDTO dto); 实现该方法，找到其实现类TeachPlanServiceImpl TeachPlanServiceImpl/** * 课程计划和媒资信息绑定 * * @param dto 绑定信息 */@Override@Transactional(rollbackFor = Exception.class)public TeachPlanMedia associationMedia(BindTeachPlanMediaDTO dto) &#123; TeachPlan dbTeachPlan = Optional.ofNullable(getById(dto.getTeachplanId())).orElseThrow(() -&gt; new BizException(ResultCodeEnum.DATA_NOT_EXIST)); if (dbTeachPlan.getGrade() != 2) &#123; throw new BizException(&quot;只允许第二级教学计划绑定媒资文件&quot;); &#125; // 删除原有记录，根据课程计划ID删除其绑定的媒资 teachPlanMediaService.remove(Wrappers.&lt;TeachPlanMedia&gt;lambdaQuery().eq(TeachPlanMedia::getTeachplanId, dto.getTeachplanId())); // 新增记录 TeachPlanMedia teachPlanMedia = new TeachPlanMedia(); teachPlanMedia.setMediaId(dto.getMediaId()); teachPlanMedia.setMediaFilename(dto.getFileName()); teachPlanMedia.setTeachplanId(dto.getTeachplanId()); teachPlanMedia.setCreateDate(LocalDateTime.now()); teachPlanMedia.setCourseId(dbTeachPlan.getCourseId()); teachPlanMediaService.save(teachPlanMedia); return teachPlanMedia;&#125; 定义ControllerTeachPlanController@ApiOperation(&quot;课程计划和媒资信息绑定&quot;)@PostMapping(&quot;/association/media&quot;)public TeachPlanMedia associateMedia(@RequestBody @Validated BindTeachPlanMediaDTO dto) &#123; return teachPlanService.associationMedia(dto);&#125; 课程计划绑定媒资信息服务以提供，打开前端项目查看是否成功 Push到Gitcommit &quot;完成媒资信息绑定服务&quot;"},{"title":"课程索引服务","path":"/wiki/learning-online/07-search/index.html","content":"从ElasticSearch中查询课程信息。 添加课程索引接口信息如下 值 路径地址 http://localhost:63040/search/index/course 请求方式 POST 请求参数 CourseIndex 返回结果 Boolean 课程文档参数CourseIndex@Datapublic class CourseIndex implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 主键 */ @NotNull(message = &quot;课程id为空&quot;) private Long id; /** * 机构ID */ private Long companyId; /** * 公司名称 */ private String companyName; /** * 课程名称 */ private String name; /** * 适用人群 */ private String users; /** * 标签 */ private String tags; /** * 大分类 */ private String mt; /** * 大分类名称 */ private String mtName; /** * 小分类 */ private String st; /** * 小分类名称 */ private String stName; /** * 课程等级 */ private String grade; /** * 教育模式 */ private String teachmode; /** * 课程图片 */ private String pic; /** * 课程介绍 */ private String description; /** * 发布时间 */ @JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;) @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private LocalDateTime createDate; /** * 状态 */ private String status; /** * 备注 */ private String remark; /** * 收费规则，对应数据字典--203 */ private String charge; /** * 现价 */ private Float price; /** * 原价 */ private Float originalPrice; /** * 课程有效期天数 */ private Integer validDays;&#125; 定义Service新建CourseSearchService接口，定义课程搜索接口 IndexService/** * 课程索引service */public interface IndexService &#123; /** * 添加索引 * * @param indexName 索引名称 * @param id 主键 * @param object 索引对象 * @return Boolean true表示成功,false失败 */ public Boolean addCourseIndex(String indexName, String id, Object object); /** * 更新索引 * * @param indexName 索引名称 * @param id 主键 * @param object 索引对象 * @return Boolean true表示成功,false失败 */ public Boolean updateCourseIndex(String indexName, String id, Object object); /** * 删除索引 * * @param indexName 索引名称 * @param id 主键 * @return java.lang.Boolean */ public Boolean deleteCourseIndex(String indexName, String id);&#125; 实现该方法，创建其实现类IndexServiceImpl IndexServiceImpl@Slf4j@Servicepublic class IndexServiceImpl implements IndexService &#123; private final RestHighLevelClient restHighLevelClient; public IndexServiceImpl(RestHighLevelClient restHighLevelClient) &#123; this.restHighLevelClient = restHighLevelClient; &#125; /** * 添加索引 * * @param indexName 索引名称 * @param id 主键 * @param object 索引对象 * @return Boolean true表示成功,false失败 */ @Override public Boolean addCourseIndex(String indexName, String id, Object object) &#123; String jsonString = JSON.toJSONString(object); IndexRequest indexRequest = new IndexRequest(indexName).id(id); // 指定索引文档内容 indexRequest.source(jsonString, XContentType.JSON); IndexResponse indexResponse = null; try &#123; indexResponse = restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; log.error(&quot;添加索引出错: &quot;, e); throw new BizException(&quot;添加索引出错&quot;); &#125; String name = indexResponse.getResult().name(); return name.equalsIgnoreCase(&quot;created&quot;) || name.equalsIgnoreCase(&quot;updated&quot;); &#125; /** * 更新索引 * * @param indexName 索引名称 * @param id 主键 * @param object 索引对象 * @return Boolean true表示成功,false失败 */ @Override public Boolean updateCourseIndex(String indexName, String id, Object object) &#123; String jsonString = JSON.toJSONString(object); UpdateRequest updateRequest = new UpdateRequest(indexName, id); updateRequest.doc(jsonString, XContentType.JSON); UpdateResponse updateResponse = null; try &#123; updateResponse = restHighLevelClient.update(updateRequest, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; log.error(&quot;更新索引出错: &quot;,e); throw new BizException(&quot;更新索引出错&quot;); &#125; DocWriteResponse.Result result = updateResponse.getResult(); return result.name().equalsIgnoreCase(&quot;updated&quot;); &#125; /** * 删除索引 * * @param indexName 索引名称 * @param id 主键 * @return java.lang.Boolean */ @Override public Boolean deleteCourseIndex(String indexName, String id) &#123; //删除索引请求对象 DeleteRequest deleteRequest = new DeleteRequest(indexName,id); //响应对象 DeleteResponse deleteResponse = null; try &#123; deleteResponse = restHighLevelClient.delete(deleteRequest, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; log.error(&quot;删除索引出错: &quot;,e); throw new BizException(&quot;删除索引出错&quot;); &#125; //获取响应结果 DocWriteResponse.Result result = deleteResponse.getResult(); return result.name().equalsIgnoreCase(&quot;deleted&quot;); &#125;&#125; 定义ControllerCourseIndexController@Api(value = &quot;课程信息索引接口&quot;, tags = &quot;课程信息索引接口&quot;)@RestController@RequestMapping(&quot;/index&quot;)@RefreshScopepublic class CourseIndexController &#123; @Value(&quot;$&#123;elasticsearch.course.index&#125;&quot;) private String courseIndexStore; private final IndexService indexService; public CourseIndexController(IndexService indexService) &#123; this.indexService = indexService; &#125; @ApiOperation(&quot;添加课程索引&quot;) @PostMapping(&quot;course&quot;) public Boolean add(@RequestBody @Validated CourseIndex courseIndex) &#123; Long id = courseIndex.getId(); Boolean result = indexService.addCourseIndex(courseIndexStore, String.valueOf(id), courseIndex); if (!result) &#123; throw new BizException(&quot;添加课程索引失败&quot;); &#125; return true; &#125;&#125;"},{"title":"课程发布服务","path":"/wiki/learning-online/06-content/publish.html","content":"课程信息编辑完毕即可发布课程，发布课程相当于—个确认操作，课程发布后学习者在网站可以搜索到课程，然后查看课程的详细信息，进一步选课、支付、在线学习。 下边是课程编辑与发布的整体流程： 为了课程内容没有违规信息、课程内容安排合理，在课程发布之前运营方会进行课程审核，审核通过后课程方可发布。 作为课程制作方即教学机构，在课程发布前通过课程预览功能可以看到课程发布后的效果，哪里的课程信息存在问题方便查看，及时修改。 Freemarker课程预览页面使用Freemarker技术，后端填充数据返回给前端 在Nacos中添加Freemarker配置，创建内容管理工程配置：content-api-dev.yaml ID：freemarker-config-dev.yaml Group：learning-online-common 描述：静态模版引擎Freemarker 配置内容： freemarker-config-dev.yamlspring: freemarker: enabled: true cache: false # 关闭模版缓存，方便测试 settings: template_update_delay: 0 suffix: .ftl charset: UTF-8 template-loader-path: classpath:/templates/ resources: add-mappings: false # 关闭项目中的静态资源映射 在内容管理工程的learning-online-content-api模块的pom文件中添加依赖： pom.xml&lt;!-- 静态模版引擎Freemarker --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 修改learning-online-content-api模块的配置文件，引入freemarker配置 bootstrap.ymlshared-configs: - data-id: freemarker-config-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true 课程预览服务 在resources目录下创建templates目录，并在目录下放入course_template.ftl模版文件，该文件下载地址： 接口信息如下 值 路径地址 http://localhost:63040/content/coursepreview/267 请求方式 GET 请求参数 Long 返回结果 ModelAndView 定义CoursePreviewVOCoursePreviewVO/** * 课程预览 */@Datapublic class CoursePreviewVO &#123; // 课程基本信息, 营销信息 private CourseBaseInfoVO courseBase; // 课程计划信息 private List&lt;TeachPlanVO&gt; teachplans;&#125; 定义Service找到CoursePublishService接口，定义计划查询接口 CoursePublishService/** * &lt;p&gt; * 课程发布 服务类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */public interface CoursePublishService extends IService&lt;CoursePublish&gt; &#123; /** * 获取课程预览信息 * * @param courseId 课程ID * @return CoursePreviewVO 预览信息 */ public CoursePreviewVO getCoursePreviewInfo(Long courseId);&#125; 实现该方法，找到其实现类CoursePublishServiceImpl CoursePublishServiceImpl/** * &lt;p&gt; * 课程发布 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-18 */@Slf4j@Servicepublic class CoursePublishServiceImpl extends ServiceImpl&lt;CoursePublishMapper, CoursePublish&gt; implements CoursePublishService &#123; private final CourseBaseService courseBaseService; private final TeachPlanService teachPlanService; public CoursePublishServiceImpl(CourseBaseService courseBaseService, TeachPlanService teachPlanService) &#123; this.courseBaseService = courseBaseService; this.teachPlanService = teachPlanService; &#125; /** * 获取课程预览信息 * * @param courseId 课程ID * @return CoursePreviewVO 预览信息 */ @Override public CoursePreviewVO getCoursePreviewInfo(Long courseId) &#123; // 课程基本信息, 营销信息 CourseBaseInfoVO courseBaseInfo = courseBaseService.getCourseBaseInfo(courseId); // 课程计划信息 List&lt;TeachPlanVO&gt; teachPlans = teachPlanService.getTreeNodes(courseId); // 封装VO CoursePreviewVO previewVO = new CoursePreviewVO(); previewVO.setCourseBase(courseBaseInfo); previewVO.setTeachplans(teachPlans); return previewVO; &#125;&#125; 定义Controller注意返回的是ModelView模版数据，不能使用@RestController TeachPlanController@Controllerpublic class CoursePublishController &#123; private final CoursePublishService coursePublishService; public CoursePublishController(CoursePublishService coursePublishService) &#123; this.coursePublishService = coursePublishService; &#125; @GetMapping(&quot;/coursepreview/&#123;courseId&#125;&quot;) public ModelAndView preview(@PathVariable(&quot;courseId&quot;) @NotNull(message = &quot;课程ID不能为空&quot;) Long courseId) &#123; ModelAndView data = new ModelAndView(); CoursePreviewVO previewInfo = coursePublishService.getCoursePreviewInfo(courseId); data.addObject(&quot;model&quot;, previewInfo); data.setViewName(&quot;course_template&quot;); return data; &#125;&#125; 课程预览服务以提供，打开前端项目查看是否成功 Push到Gitcommit &quot;完成课程预览功能&quot; 视频预览服务接口信息如下查询课程信息，无需登陆操作 值 路径地址 http://localhost:63040/content/open/course/whole/2 请求方式 GET 请求参数 Long 返回结果 CoursePreviewVO 查询视频URL 值 路径地址 http://localhost:63040/content/open/preview/mediaId 请求方式 GET 请求参数 String 返回结果 R 定义Controller找到learning-online-content-api模块，创建如下Controller CourseOpenController@RestController@RequestMapping(&quot;/open&quot;)public class CourseOpenController &#123; private final CoursePublishService coursePublishService; public CourseOpenController(CoursePublishService coursePublishService) &#123; this.coursePublishService = coursePublishService; &#125; @GetMapping(&quot;/course/whole/&#123;courseId&#125;&quot;) public CoursePreviewVO preview(@PathVariable(&quot;courseId&quot;) @NotNull(message = &quot;课程ID不能为空&quot;) Long courseId) &#123; return coursePublishService.getCoursePreviewInfo(courseId); &#125;&#125; 找到learning-online-media-api模块，创建如下Controller MediaOpenController/** * 视频播放页面，openapi */@RestController@ResponseResult@RequestMapping(&quot;/open&quot;)public class MediaOpenController &#123; private final MediaFilesService mediaFilesService; public MediaOpenController(MediaFilesService mediaFilesService) &#123; this.mediaFilesService = mediaFilesService; &#125; @GetMapping(&quot;/preview/&#123;mediaId&#125;&quot;) public R getPlayUrlByMediaId(@PathVariable(&quot;mediaId&quot;) String mediaId) &#123; MediaFiles mediaFiles = mediaFilesService.getById(mediaId); if (mediaFiles == null || StringUtils.isEmpty(mediaFiles.getUrl())) &#123; throw new BizException(&quot;视频还没有转码处理&quot;); &#125; return R.success(mediaFiles.getUrl()); &#125;&#125; 课程预览服务以提供，打开前端项目查看是否成功 Push到Gitcommit &quot;完成视频预览功能&quot; 课程审核服务 在课程基本表course_base表设置课程审核状态字段，包括：未提交、已提交(未审核)、审核通过、审核不通过。 下边是课程状态的转化关系： 说明如下： 1、一门课程新增后它的审核状为”未提交“，发布状态为”未发布“。 2、课程信息编辑完成，教学机构人员执行”提交审核“操作。此时课程的审核状态为”已提交“。 3、当课程状态为已提交时运营平台人员对课程进行审核。 4、运营平台人员审核课程，结果有两个：审核通过、审核不通过。 5、课程审核过后不管状态是通过还是不通过，教学机构可以再次修改课程并提交审核，此时课程状态为”已提交“。此时运营平台人员再次审核课程。 6、课程审核通过，教学机构人员可以发布课程，发布成功后课程的发布状态为”已发布“。 7、课程发布后通过”下架“操作可以更改课程发布状态为”下架“ 8、课程下架后通过”上架“操作可以再次发布课程，上架后课程发布状态为“发布”。 审核过程中，用户的修改操作是被允许的，如果审核和用户共同查询课程信息表，会造成冲突。为了避免冲突，在用户点击审核时，将课程信息拷贝到预审表。审核通过后修改预发布表和基本信息表的审核状态为审核通过，发布时课程信息数据则从预发布表中获取， 流程如下： 关于审核部分本项目不予实现，这里只实现将审核信息放入预审表 定义Service找到CoursePublishService接口，定义提交审核接口 CoursePublishService/** * 提交审核 * 将课程基本信息、课程计划信息和营销信息保存到预发布表 * * @param companyId 机构ID * @param courseId 课程ID */public void commitAudit(Long companyId, Long courseId); 实现该方法，找到其实现类CoursePublishServiceImpl CoursePublishServiceImpl/** * 提交审核 * 将课程基本信息、课程计划信息和营销信息保存到预发布表 * * @param companyId 机构ID * @param courseId 课程ID */@Override@Transactional(rollbackFor = Exception.class)public void commitAudit(Long companyId, Long courseId) &#123; // 查询课程基本信息 CourseBase courseBase = Optional.ofNullable(courseBaseService.getById(courseId)).orElseThrow(() -&gt; new BizException(&quot;课程信息不存在&quot;)); // 如果课程的审核状态为已提交则不允许提交 if (&quot;202003&quot;.equals(courseBase.getAuditStatus())) &#123; throw new BizException(&quot;当前为等待审核状态，审核完成可以再次提交&quot;); &#125; if (!courseBase.getCompanyId().equals(companyId)) &#123; throw new BizException(&quot;不允许提交其它机构的课程&quot;); &#125; // 课程的图片 if (StringUtils.isEmpty(courseBase.getPic())) &#123; throw new BizException(&quot;提交失败，请上传课程图片&quot;); &#125; // 查询课程计划信息 List&lt;TeachPlanVO&gt; teachPlans = teachPlanService.getTreeNodes(courseId); // 计划信息没有填写也不允许提交 if (teachPlans.isEmpty()) &#123; throw new BizException(&quot;提交失败，还没有添加课程计划&quot;); &#125; // 查询营销信息 CourseMarket courseMarket = Optional.ofNullable(courseMarketService.getById(courseId)).orElseThrow(() -&gt; new BizException(&quot;请完善课程营销信息&quot;)); // 查询分类信息 List&lt;String&gt; list = Arrays.asList(courseBase.getSt(), courseBase.getMt()); String join = StringUtils.join(list, &quot;,&quot;); List&lt;CourseCategory&gt; categories = courseCategoryService.list(Wrappers.&lt;CourseCategory&gt;lambdaQuery() .in(CourseCategory::getId, list).last(&quot;ORDER BY FIELD(id, &#x27;&quot; + list.get(0) + &quot;&#x27;, &#x27;&quot; + list.get(1) + &quot;&#x27;)&quot;)); // 查询课程基本信息、营销信息、计划等信息插入到课程预发布表 CoursePublishPre coursePublishPre = new CoursePublishPre(); // 设置分类名 coursePublishPre.setStName(categories.get(0) == null ? &quot;&quot; : categories.get(0).getName()); coursePublishPre.setMtName(categories.get(1) == null ? &quot;&quot; : categories.get(1).getName()); BeanUtils.copyProperties(courseMarket, coursePublishPre); // 设置基本信息 BeanUtils.copyProperties(courseBase, coursePublishPre); // 设置营销信息 coursePublishPre.setMarket(JSON.toJSONString(courseMarket)); // 设置课程计划 coursePublishPre.setTeachplan(JSON.toJSONString(teachPlans)); //设置预发布记录状态,已提交 coursePublishPre.setStatus(&quot;202003&quot;); //教学机构id coursePublishPre.setCompanyId(companyId); //提交时间 coursePublishPre.setCreateDate(LocalDateTime.now()); // 保存预发布信息 CoursePublishPre coursePublishPreUpdate = coursePublishPreService.getById(courseId); if (coursePublishPreUpdate == null) &#123; //添加课程预发布记录 coursePublishPreService.save(coursePublishPre); &#125; else &#123; coursePublishPreService.updateById(coursePublishPre); &#125; //更新课程基本表的审核状态 courseBase.setAuditStatus(&quot;202003&quot;); courseBaseService.updateById(courseBase);&#125; 定义Controller注意返回的是ModelView模版数据，不能使用@RestController CoursePublishController@Api(value = &quot;课程发布审核接口&quot;, tags = &quot;课程发布审核接口&quot;)@ResponseResult@RestControllerpublic class CoursePublishController &#123; private final CoursePublishService coursePublishService; public CoursePublishController(CoursePublishService coursePublishService) &#123; this.coursePublishService = coursePublishService; &#125; @ApiOperation(&quot;提交审核&quot;) @PostMapping(&quot;/courseaudit/commit/&#123;courseId&#125;&quot;) public void commitAudit(@PathVariable(&quot;courseId&quot;) Long courseId) &#123; Long companyId = 1232141425L; coursePublishService.commitAudit(companyId, courseId); &#125;&#125; 课程发布服务 该部分需要实现媒资管理服务的文件上传，请先转到媒资管理工程，完成该部分开发。 课程发布时，会将数据缓存至Redis、将添加Elasticsearch索引信息（便于检索）、生成静态化文件并存储到MinIO中。因此为了保证事务一致，项目采用AP模式，即保证高可用。AP模式的实现方式为，使用任务调度的方案，启动任务调度将课程信息由数据库同步到elasticsearch、MinlO、redis中。重试机制保证消息最终一致。 分布式事务分布式事务控制有哪些常用的技术方案？ 实现CP就是要实现强一致性： 使用Seata框架基于AT模式实现 使用Seata框架基于TCC模式实现 实现AP则要保证最终数据一致性： 使用消息队列通知的方式去实现，通知失败自动重试，达到最大失败次数需要人工处理； 使用任务调度的方案，启动任务调度将课程信息由数据库同步到elasticsearch、MinlO、redis中。 本项目使用AP方式，最终的流程如下： 1、在内容管理服务的数据库中添加一个消息表，消息表和课程发布表在同一个数据库。 2、点击课程发布通过本地事务向课程发布表写入课程发布信息，同时向消息表写课程发布的消息。通过数据库进行控制，只要课程发布表插入成功消息表也插入成功，消息表的数据就记录了某门课程发布的任务。 3、启动任务调度系统定时调度内容管理服务去定时扫描消息表的记录。 4、当扫描到课程发布的消息时即开始完成向redis、elasticsearch、MinIO同步数据的操作。 5、同步数据的任务完成后删除消息表记录。 时序图如下： 发布课程用户点击课程发布时，需要将预发布表中的数据转移到发布表中，同时向消息表中添加记录 为更方便使用任务调度，引入learning-online-message-sdk，封装好的调度SDK。其会对lo_content数据库的mq_message和mq_message_history两张消息记录表进行增删改查操作。 定义Service定义接口方法 CoursePublishService/** * 发布课程 * * @param companyId 机构ID * @param courseId 课程ID */public void publish(Long companyId, Long courseId); 使用该方法： CoursePublishServiceImplprivate final CoursePublishPreService coursePublishPreService;private final CourseBaseService courseBaseService;private final MqMessageService mqMessageService;/** * 发布课程 * * @param companyId 机构ID * @param courseId 课程ID */@Override@Transactional(rollbackFor = Exception.class)public void publish(Long companyId, Long courseId) &#123; // 查询预发布表 CoursePublishPre coursePublishPre = Optional.ofNullable(coursePublishPreService.getById(courseId)) .orElseThrow(() -&gt; new BizException(&quot;未提交审核，不允许发布&quot;)); if (!coursePublishPre.getCompanyId().equals(companyId)) &#123; throw new BizException(&quot;不允许发布其它机构的课程&quot;); &#125; if (!coursePublishPre.getStatus().equals(&quot;202004&quot;)) &#123; // 未通过审核 throw new BizException(&quot;未通过审核，不允许发布&quot;); &#125; // 向课程发布表写数据 CoursePublish coursePublish = new CoursePublish(); BeanUtils.copyProperties(coursePublishPre, coursePublish); // 查询是否有发布记录 CoursePublish dbCoursePublish = getById(courseId); if (dbCoursePublish == null) &#123; // 没有则新增 save(coursePublish); &#125; else &#123; // 有则更新 updateById(coursePublish); &#125; // 更改文章状态为已经发布 courseBaseService.update(Wrappers.&lt;CourseBase&gt;lambdaUpdate().eq(CourseBase::getId, courseId).set(CourseBase::getStatus, &quot;203002&quot;)); // 向消息表写入数据 saveCoursePublishMessage(courseId); // 删除预发布表数据 coursePublishPreService.removeById(coursePublishPre);&#125;/** * 保存消息记录 * * @param courseId 课程id */public void saveCoursePublishMessage(Long courseId) &#123; // 使用消息SDK插入课程发布消息 Optional.ofNullable(mqMessageService.addMessage(&quot;course_publish&quot;, String.valueOf(courseId), null, null)) .orElseThrow(() -&gt; new BizException(&quot;保存消息记录失败&quot;));&#125; 定义ControllerCoursePublishController@ApiOperation(&quot;课程发布&quot;)@PostMapping(&quot;/coursepublish/&#123;courseId&#125;&quot;)public void coursePublish(@PathVariable(&quot;courseId&quot;) Long courseId) &#123; Long companyId = 1232141425L; coursePublishService.publish(companyId, courseId);&#125; 任务调度引入依赖为了使用任务调度，需要在learning-online-content-service模块中添加如下依赖： pom.xml&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;&lt;/dependency&gt; 配置信息按照XXL-JOB的使用方式，还需要进行配置： 首先添加Nacos的配置： content-service-dev.yaml# xxl-job配置xxl: job: admin: # 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册； addresses: http://127.0.0.1:8080/xxl-job-admin executor: # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。 address: # 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册 appname: coursepublish-executor # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;； ip: # 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口； port: 8999 # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径； logpath: /Users/swcode/data/applogs/xxl-job/jobhandler # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能； logretentiondays: 30 # 执行器通讯TOKEN [选填]：非空时启用； accessToken: 在项目中创建配置类： XxlJonConfig@Slf4j@Configurationpublic class XxlJonConfig &#123; @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;) private String address; @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;) private String ip; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;) private String accessToken; @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;) private String logPath; @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; log.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(address); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; &#125;&#125; 创建执行器： 创建调度任务： 任务处理类下一步就是定义任务的处理类，这里我们使用了SDK，继承MessageProcessAbstract抽象类，该抽象类实现了XXL-JOB分片广播调度的分片操作、任务拉取、根据系统核心数开启线程（多线程）、线程计数器等基础操作；我们需要重写其中的execute方法，实现具体的业务处理逻辑，注意幂等。 创建包com.swx.content.service.jobhandler，在该包下创建如下类： @Slf4j@Servicepublic class CoursePublishTask extends MessageProcessAbstract &#123; private final CoursePublishService coursePublishService; public CoursePublishTask(CoursePublishService coursePublishService) &#123; this.coursePublishService = coursePublishService; &#125; @XxlJob(&quot;CoursePublishJobHandler&quot;) public void coursePublishJobHandler() &#123; // 分片参数 int shardIndex = XxlJobHelper.getShardIndex(); int shardTotal = XxlJobHelper.getShardTotal(); // 执行任务 this.process(shardIndex, shardTotal, &quot;course_publish&quot;, 30, 60); &#125; /** * 任务处理 * * @param mqMessage 执行任务内容 * @return boolean true:处理成功，false处理失败 */ @Override public boolean execute(MqMessage mqMessage) &#123; if (StringUtils.isEmpty(mqMessage.getBusinessKey1())) &#123; log.debug(&quot;消息参数错误，无业务ID: &#123;&#125;&quot;, mqMessage); return false; &#125; long courseId = Long.parseLong(mqMessage.getBusinessKey1()); // 生成并上传静态页面 generateCourseHtml(mqMessage, courseId); // 创建索引 saveCourseIndex(mqMessage, courseId); // 缓存至Redis save2Redis(mqMessage, courseId); return true; &#125; /** * 生成静态化页面上传至文件系统 * * @param mqMessage 消息 * @param courseId 课程ID */ private void generateCourseHtml(MqMessage mqMessage, long courseId) &#123; Long taskId = mqMessage.getId(); MqMessageService mqMessageService = this.getMqMessageService(); // 任务幂等性处理 int stageOne = mqMessageService.getStageOne(taskId); if (stageOne &gt; 0) &#123; log.debug(&quot;静态化页面已生成，无需处理&quot;); return; &#125; // 生成静态页面 // 上传静态页面 // 置状态为已完成 mqMessageService.completedStageOne(taskId); &#125; /** * 保存课程索引到Elasticsearch * * @param mqMessage 消息 * @param courseId 课程ID */ private void saveCourseIndex(MqMessage mqMessage, long courseId) &#123; Long taskId = mqMessage.getId(); MqMessageService mqMessageService = this.getMqMessageService(); // 任务幂等性处理 int stageTwo = mqMessageService.getStageTwo(taskId); if (stageTwo &gt; 0) &#123; log.debug(&quot;课程索引已缓存，无需处理&quot;); return; &#125; // 创建索引 // 置状态为已完成 mqMessageService.completedStageTwo(taskId); &#125; /** * 缓存到Redis * * @param mqMessage 消息 * @param courseId 课程ID */ private void save2Redis(MqMessage mqMessage, long courseId) &#123; Long taskId = mqMessage.getId(); MqMessageService mqMessageService = this.getMqMessageService(); // 任务幂等性处理 int stageThree = mqMessageService.getStageThree(taskId); if (stageThree &gt; 0) &#123; log.debug(&quot;课程已缓存，无需处理&quot;); return; &#125; // 保存到Redis // 置状态为已完成 mqMessageService.completedStageThree(taskId); &#125;&#125; 静态化页面使用Freemarker技术生成静态化页面，并使用Feign远程调用媒资上传服务，上传至MinIO中。 配置Feign为了使用Feign调用媒资服务上传文件，需要在learning-online-content-service引入如下依赖： pom.xml&lt;!-- Feign远程调用 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Feign熔断降级 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Feign支持文件传输 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt; &lt;artifactId&gt;feign-form&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt; &lt;artifactId&gt;feign-form-spring&lt;/artifactId&gt;&lt;/dependency&gt; 在config包下添加文件传输支持配置类： MultipartSupportConfig/** * 传输文件支持 */@Configurationpublic class MultipartSupportConfig &#123; private final ObjectFactory&lt;HttpMessageConverters&gt; messageConverters; public MultipartSupportConfig(ObjectFactory&lt;HttpMessageConverters&gt; messageConverters) &#123; this.messageConverters = messageConverters; &#125; @Bean @Primary//注入相同类型的bean时优先使用 @Scope(&quot;prototype&quot;) public Encoder feignEncoder() &#123; return new SpringFormEncoder(new SpringEncoder(messageConverters)); &#125; /** * 将file转为Multipart * * @param file 文件 * @return MultipartFile */ public static MultipartFile getMultipartFile(File file) &#123; FileItem item = new DiskFileItemFactory().createItem(&quot;file&quot;, MediaType.MULTIPART_FORM_DATA_VALUE, true, file.getName()); try (FileInputStream inputStream = new FileInputStream(file); OutputStream outputStream = item.getOutputStream();) &#123; IOUtils.copy(inputStream, outputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new CommonsMultipartFile(item); &#125; /** * 将 输入流 转为Multipart * * @param inputStream 输入流 * @param filename 文件名 * @return MultipartFile */ public static MultipartFile getMultipartFile(InputStream inputStream, String filename) &#123; FileItem item = new DiskFileItemFactory().createItem(&quot;file&quot;, MediaType.MULTIPART_FORM_DATA_VALUE, true, filename); try (OutputStream outputStream = item.getOutputStream()) &#123; IOUtils.copy(inputStream, outputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return new CommonsMultipartFile(item); &#125;&#125; 在Nacos中新建Feign的配置文件 创建内容管理工程配置：feign-dev.yaml ID：feign-dev.yaml Group：learning-online-common 配置内容： feign-dev.yamlfeign: httpclient: enabled: true hystrix: enabled: true circuitbreaker: enabled: truehystrix: command: default: execution: isolation: #strategy: SEMAPHORE thread: timeoutInMilliseconds: 1000 ribbon: ConnectTimeout: 60000 # 连接超时时间 ReadTimeout: 60000 MaxAutoRetries: 0 MaxAutoRetriesNextServer: 1 在content-api的bootstrap.yaml中添加Feign的配置： - data-id: feign-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true 修改媒资服务修改媒资服务的文件上传服务，增加一个objectName参数 MediaFilesUploadController@ApiOperation(&quot;上传文件&quot;)@PostMapping(value = &quot;/coursefile&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)public UploadFileResultVO upload(@RequestPart(&quot;filedata&quot;) MultipartFile filedata, @RequestParam(value = &quot;objectName&quot;, required = false) String objectName) &#123; Long companyId = 1232141425L; UploadFileParamDTO dto = new UploadFileParamDTO(); dto.setFilename(filedata.getOriginalFilename()); dto.setFileSize(filedata.getSize()); return mediaFilesService.uploadFile(companyId, dto, filedata, objectName);&#125; MediaFilesService/** * 上传文件 * * @param companyId 机构ID * @param dto 文件信息 * @param multipartFile 文件信息 * @param objectName 文件路径 * @return UploadFileResultVO */public UploadFileResultVO uploadFile(Long companyId, UploadFileParamDTO dto, MultipartFile multipartFile, String objectName); MediaFilesServiceImpl/** * 上传文件 * * @param companyId 机构ID * @param dto 文件信息 * @param multipartFile 文件信息 * @param objectName 文件路径 * @return UploadFileResultVO */@Overridepublic UploadFileResultVO uploadFile(Long companyId, UploadFileParamDTO dto, MultipartFile multipartFile, String objectName) &#123; ....; try &#123; ...; // 已存在数据库，直接返回 ....; // 获取文章类型 String mineType = getMineType(suffix); if (mineType.contains(&quot;image&quot;)) &#123; dto.setFileType(&quot;001001&quot;); &#125; else &#123; dto.setFileType(&quot;001003&quot;); &#125; // 上传到MinIO Map&lt;String, String&gt; result = null; if (StringUtils.hasText(objectName)) &#123; result = fileStorageService.uploadMediaFile(objectName, mineType, multipartFile.getInputStream()); &#125; else &#123; result = fileStorageService.uploadMediaFile(&quot;&quot;, prefix + suffix, mineType, multipartFile.getInputStream()); &#125; ....; // 保存到数据库，使用编程式事务 ....; // 返回数据 ....; &#125; catch (IOException e) &#123; ....; &#125;&#125; 修改MinIO上传方法的逻辑 MinIOFileStorageService/** * @param dirPath * @param filename yyyy/mm/dd/file.jpg * @return */public String builderFilePath(String dirPath, String filename) &#123; StringBuilder stringBuilder = new StringBuilder(50); if (!StringUtils.isEmpty(dirPath)) &#123; stringBuilder.append(dirPath).append(separator); &#125; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;); String todayStr = sdf.format(new Date()); stringBuilder.append(todayStr).append(separator); stringBuilder.append(filename); return stringBuilder.toString();&#125;/** * 上传文件 * * @param prefix 文件前缀 * @param filename 文件名 * @param inputStream 文件流 * @return 文件全路径 */@Overridepublic Map&lt;String, String&gt; uploadMediaFile(String prefix, String filename, String mineType, InputStream inputStream) &#123; String filepath = builderFilePath(prefix, filename); String bucket = upload2Files(filepath, mineType, inputStream); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;path&quot;, filepath); map.put(&quot;bucket&quot;, bucket); return map;&#125;/** * 上传文件 * * @param objectName 文件路径 * @param inputStream 文件流 * @return 桶和文件全路径 */@Overridepublic Map&lt;String, String&gt; uploadMediaFile(String objectName, String mineType, InputStream inputStream) &#123; String bucket = upload2Files(objectName, mineType, inputStream); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;path&quot;, objectName); map.put(&quot;bucket&quot;, bucket); return map;&#125; 媒资Client在learning-online-content-service下创建包com.swx.content.client，并创建Feign的接口 /** * 远程调用媒资服务 */@FeignClient(value = &quot;media-api&quot;, configuration = MultipartSupportConfig.class, fallbackFactory = MediaServiceClientFallbackFactory.class)public interface MediaServiceClient &#123; /** * 文件传输 * * @param filedata 文件 * @param objectName MinIO路径 * @return String */ @PostMapping(value = &quot;/media/upload/coursefile&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE) public String upload(@RequestPart(&quot;filedata&quot;) MultipartFile filedata, @RequestParam(value = &quot;objectName&quot;, required = false) String objectName);&#125; 同一包下创建熔断降级处理类： MediaServiceClientFallbackFactory// 注意别导错包import org.springframework.cloud.openfeign.FallbackFactory;/** * 降级方法，可以拿到异常信息 */@Slf4j@Componentpublic class MediaServiceClientFallbackFactory implements FallbackFactory&lt;MediaServiceClient&gt; &#123; @Override public MediaServiceClient create(Throwable throwable) &#123; return new MediaServiceClient() &#123; @Override public String upload(MultipartFile filedata, String objectName) &#123; log.debug(&quot;远程调用媒资上传文件的接口发生熔断: &quot;, throwable); return null; &#125; &#125;; &#125;&#125; 定义Service找到CoursePublishService，分别定义生成和上传课程静态化页面的方法。 /** * 生成课程静态化页面 * * @param courseId 课程ID * @return InputStream */public InputStream generateCourseHtml(Long courseId);/** * 上传课程静态化页面 * * @param courseId 课程ID * @param inputStream 文件流 */public void uploadCourseHtml(Long courseId, InputStream inputStream);/** * 查询已发布课程的信息 * * @param courseId 课程ID * @return com.swx.content.model.po.CoursePublish 课程发布信息 */public CoursePreviewVO getCoursePublish(Long courseId); 在CoursePublishServiceImpl中实现方法： CoursePublishServiceImplprivate final static String COURSE_TEMPLATE = &quot;course_template&quot;;private final static String HTML_PATH = &quot;course/&quot;;/** * 生成课程静态化页面 * * @param courseId 课程ID * @return File */@Overridepublic InputStream generateCourseHtml(Long courseId) &#123; try &#123; Template template = configuration.getTemplate(COURSE_TEMPLATE + &quot;.ftl&quot;); StringWriter out = new StringWriter(); // 数据模型 HashMap&lt;String, Object&gt; params = new HashMap&lt;&gt;(); // 获取发布课程的信息，作为静态页面的参数 params.put(&quot;model&quot;, getCoursePublish(courseId)); // 文章内容通过freemarker生成html文件 template.process(params, out); // 返回文件流 return new ByteArrayInputStream(out.toString().getBytes()); &#125; catch (Exception e) &#123; log.error(&quot;页面静态化出现问题&quot;, e); &#125; return null;&#125;/** * 上传课程静态化页面 * * @param courseId 课程ID * @param inputStream 文件流 */@Overridepublic void uploadCourseHtml(Long courseId, InputStream inputStream) &#123; // 把html文件上传到minio中 MultipartFile multipartFile = MultipartSupportConfig.getMultipartFile(inputStream, courseId + COURSE_TEMPLATE + &quot;.html&quot;); // Feign调用接口 String upload = mediaServiceClient.upload(multipartFile, HTML_PATH + courseId + &quot;.html&quot;); if (upload == null) &#123; log.debug(&quot;上传结果为null, 课程ID: &#123;&#125;&quot;, courseId); &#125;&#125;/** * 查询已发布课程的信息 * * @param courseId 课程ID * @return com.swx.content.model.po.CoursePublish 课程发布信息 */public CoursePreviewVO getCoursePublish(Long courseId) &#123; CoursePublish coursePublish = getById(courseId); if (coursePublish == null) &#123; throw new BizException(&quot;课程未发布&quot;); &#125; CoursePreviewVO coursePreviewVO = new CoursePreviewVO(); // 解析课程基本信息和营销信息 CourseBaseInfoVO courseBaseInfoVO = new CourseBaseInfoVO(); BeanUtils.copyProperties(coursePublish, courseBaseInfoVO); coursePreviewVO.setCourseBase(courseBaseInfoVO); // 解析课程计划信息 List&lt;TeachPlanVO&gt; teachPlans = JSON.parseArray(coursePublish.getTeachplan(), TeachPlanVO.class); coursePreviewVO.setTeachplans(teachPlans); return coursePreviewVO;&#125; 完善调度任务逻辑找到文章发布任务调度类CoursePublishTask，修改生成静态化页面上传至文件系统逻辑 CoursePublishTask/** * 生成静态化页面上传至文件系统 * * @param mqMessage 消息 * @param courseId 课程ID */private void generateCourseHtml(MqMessage mqMessage, long courseId) &#123; Long taskId = mqMessage.getId(); MqMessageService mqMessageService = this.getMqMessageService(); // 任务幂等性处理 int stageOne = mqMessageService.getStageOne(taskId); if (stageOne &gt; 0) &#123; log.debug(&quot;静态化页面已生成，无需处理&quot;); return; &#125; // 生成静态页面 InputStream inputStream = coursePublishService.generateCourseHtml(courseId); if (inputStream == null) &#123; return; &#125; // 上传静态页面 coursePublishService.uploadCourseHtml(courseId, inputStream); // 置状态为已完成 mqMessageService.completedStageOne(taskId);&#125; 修改Nginx配置新增如下配置信息，将其代理到文件服务的course目录下 learning.conflocation /course/ &#123; proxy_pass http://fileserver/mediafiles/course/;&#125; 测试生成的静态文件将存储在MinIO中的mediafiles/course/courseId.html下 浏览器访问：http://www.51xuecheng.cn/course/2.html 创建内容索引ElasticSearch MySQL Elasticsearch 说明 Table Index 索引(index)，就是文档的集合，类似数据库的表(table) Row Document 文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式 Column Field 字段（Field），就是JSON文档中的字段，类似数据库中的列（Column） Schema Mapping Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema） SQL DSL DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD 拉取ElasticSearch镜像 docker pull elasticsearch:7.4.0 创建ElasticSearch容器 docker run -id --name elasticsearch \\-p 9200:9200 -p 9300:9300 \\-v /usr/share/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\-e &quot;discovery.type=single-node&quot; elasticsearch:7.4.0 配置中文分词器 ik 下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases 上传到服务器的/usr/share/elasticsearch/plugins，解压到新建目录analysis-ik 创建索引mapping是对索引库中文档的约束，常见的mapping属性包括： type：字段数据类型，常见的简单类型有： 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家等） 数值：long、integer、short、byte、double、float、 布尔：boolean 日期：date 对象：object index：是否创建索引，默认为true analyzer：使用哪种分词器 properties：该字段的子字段 创建索引course_publish，如下： &#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 1, &quot;number_of_replicas&quot;: 0 &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;companyId&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;companyName&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;users&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;index&quot;: false &#125;, &quot;tags&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;mt&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;mtName&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;st&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;stName&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;grade&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;teachmode&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;pic&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;index&quot;: false &#125;, &quot;description&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;createDate&quot;: &#123; &quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot; &#125;, &quot;status&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;remark&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;index&quot;: false &#125;, &quot;charge&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;price&quot;: &#123; &quot;type&quot;: &quot;scaled_float&quot;, &quot;scaling_factor&quot;: 100.0 &#125;, &quot;originalPrice&quot;: &#123; &quot;type&quot;: &quot;scaled_float&quot;, &quot;scaling_factor&quot;: 100.0 &#125;, &quot;validDays&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125; &#125; &#125;&#125; 使用接口测试工具插入数据：http://124.221.23.47:9200/course_publish/_doc/2 &#123; &quot;id&quot;: 2, &quot;companyId&quot;: 1232141425, &quot;companyName&quot;: &quot;Test1&quot;, &quot;name&quot;: &quot;测试课程01&quot;, &quot;users&quot;: &quot;IT爱好者IT爱好者IT爱好者IT爱好者IT爱好者IT爱好者IT爱好者IT爱好者&quot;, &quot;tags&quot;: &quot;课程标签&quot;, &quot;mt&quot;: &quot;1-1&quot;, &quot;st&quot;: &quot;1-1-1&quot;, &quot;grade&quot;: &quot;204001&quot;, &quot;teachmode&quot;: &quot;200002&quot;, &quot;description&quot;: &quot;测试课程测试课程测试课程测试课程测试课程测试课程测试课程测试课程测试课程测试课程测试课程测试课程测试课程测试课程测试课程测试课程&quot;, &quot;pic&quot;: &quot;/mediafiles/2023/08/23/d13fc2687d9335eddd4dc23ccd8c8b8e.jpg&quot;, &quot;createDate&quot;: &quot;2019-09-04 08:49:26&quot;, &quot;status&quot;: &quot;203001&quot;, &quot;remark&quot;: &quot;没有备注&quot;, &quot;mtName&quot;: &quot;前端开发&quot;, &quot;stName&quot;: &quot;HTML/CSS&quot;, &quot;charge&quot;: &quot;201001&quot;, &quot;price&quot;: 1.0, &quot;originPrice&quot;: null, &quot;validDays&quot;: null&#125; 数据同步Elasticsearch和MySQL之间需要数据同步，一般有以下几种方式： 同步调用，即写入本地数据库的同时，（异步）调用更新ELK的同步接口，完成同步。 异步通知，即使用消息中间件，写入数据库的同时发送同步消息，监听同步消息完成数据推送。 监听binlog，使用Cannal等组件，可以监听数据库的binlog，完成数据同步。 任务调度，即将任务写入数据库，调度时从数据库查询同步任务，将数据同步到ELK。 本项目使用任务调度方式，适合实时性要求不高的场景！ 搜索Client在包com.swx.content.client下新建Feign的接口 SearchServiceClient/** * 远程调用搜索服务 * 新增索引 */@FeignClient(value = &quot;search&quot;, fallbackFactory = SearchServiceClientFallbackFactory.class)public interface SearchServiceClient &#123; @PostMapping(&quot;/search/index/course&quot;) public Boolean add(@RequestBody CourseIndex courseIndex);&#125; 同一包下创建熔断降级处理类： SearchServiceClientFallbackFactory@Slf4j@Componentpublic class SearchServiceClientFallbackFactory implements FallbackFactory&lt;SearchServiceClient&gt; &#123; @Override public SearchServiceClient create(Throwable throwable) &#123; return courseIndex -&gt; &#123; log.debug(&quot;远程调用搜索服务创建课程索引接口发生熔断: &quot;, throwable); return false; &#125;; &#125;&#125; 完善调度任务逻辑找到文章发布任务调度类saveCourseIndex，修改生成静态化页面上传至文件系统逻辑 saveCourseIndexprivate final SearchServiceClient searchServiceClient;/** * 保存课程索引到Elasticsearch * * @param mqMessage 消息 * @param courseId 课程ID */private void saveCourseIndex(MqMessage mqMessage, long courseId) &#123; Long taskId = mqMessage.getId(); MqMessageService mqMessageService = this.getMqMessageService(); // 任务幂等性处理 int stageTwo = mqMessageService.getStageTwo(taskId); if (stageTwo &gt; 0) &#123; log.debug(&quot;课程索引已缓存，无需处理&quot;); return; &#125; // 查询课程 CoursePublish coursePublish = coursePublishService.getById(courseId); CourseIndex courseIndex = new CourseIndex(); BeanUtils.copyProperties(coursePublish, courseIndex); // 远程调用 Boolean add = searchServiceClient.add(courseIndex); if (!add) &#123; throw new BizException(&quot;添加课程索引失败&quot;); &#125; // 置状态为已完成 mqMessageService.completedStageTwo(taskId);&#125; 缓存至Redis测试测试流程说明 启动前端的管理项目； 将一门课程提交审核，打开数据库管理工具，找到course_base和course_publish_pre两张表，修改其中的status字段为202004，即审核通过； 再次来到管理项目，将审核通过的课程发布； 开启任务调度，置状态为RUNNING，等待调度完成； 打开门户网站，进入课程搜索页面，看到刚发布的课程，表示测试通过。 获取课程获取已发布课程的详细信息 接口信息如下 值 路径地址 http://localhost:63040/content/course/whole/2 请求方式 GET 请求参数 Long 返回结果 CoursePreviewVO 查询Service在com.swx.content.service包下的 CoursePublishService 类中定义查询方法 CoursePublishService/** * 查询已发布课程的信息 * * @param courseId 课程ID * @return com.swx.content.model.po.CoursePublish 课程发布信息 */public CoursePreviewVO getCoursePublish(Long courseId); 实现该方法 CoursePublishServiceImpl/** * 查询已发布课程的信息 * * @param courseId 课程ID * @return com.swx.content.model.po.CoursePublish 课程发布信息 */@Overridepublic CoursePreviewVO getCoursePublish(Long courseId) &#123; CoursePublish coursePublish = getById(courseId); if (coursePublish == null) &#123; throw new BizException(&quot;课程未发布&quot;); &#125; CoursePreviewVO coursePreviewVO = new CoursePreviewVO(); // 解析课程基本信息和营销信息 CourseBaseInfoVO courseBaseInfoVO = new CourseBaseInfoVO(); BeanUtils.copyProperties(coursePublish, courseBaseInfoVO); coursePreviewVO.setCourseBase(courseBaseInfoVO); // 解析课程计划信息 List&lt;TeachPlanVO&gt; teachPlans = JSON.parseArray(coursePublish.getTeachplan(), TeachPlanVO.class); coursePreviewVO.setTeachplans(teachPlans); return coursePreviewVO;&#125; 查询ControllerCoursePublishController@ApiOperation(&quot;获取课程发布信息&quot;)@GetMapping(&quot;/course/whole/&#123;courseId&#125;&quot;)public CoursePreviewVO getCOursePublish(@PathVariable(&quot;courseId&quot;) @NotNull(message = &quot;课程ID不能为空&quot;) Long courseId) &#123; return coursePublishService.getCoursePublish(courseId);&#125;"},{"title":"初始化工程","path":"/wiki/learning-online/07-search/init.html","content":"基础代码创建learning-online-search模块，其Parent为learning-online-parent，但其父目录为learning-online。 在pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 排除 Spring Boot 依赖的日志包冲突 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot 集成 log4j2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类，在com.swx.system包下创建启动类SearchApplication SearchApplication@SpringBootApplicationpublic class SearchApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SearchApplication.class, args); &#125;&#125; 配置文件 bootstrap.ymlspring: application: name: search cloud: nacos: discovery: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project config: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project file-extension: yaml refresh-enabled: true shared-configs: - data-id: logging-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true profiles: active: dev 日志配置，在learning-online-search工程的resources下创建log4j2-dev.xml log4j2-dev.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration monitorInterval=&quot;180&quot; packages=&quot;&quot;&gt; &lt;properties&gt; &lt;property name=&quot;logdir&quot;&gt;logs&lt;/property&gt; &lt;property name=&quot;PATTERN&quot;&gt;%date&#123;YYYY-MM-dd HH:mm:ss,SSS&#125; %level [%thread][%file:%line] - %msg%n%throwable&lt;/property&gt; &lt;/properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;ErrorAppender&quot; fileName=&quot;$&#123;logdir&#125;/error.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/error.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;DebugAppender&quot; fileName=&quot;$&#123;logdir&#125;/info.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/info.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;!--异步appender--&gt; &lt;Async name=&quot;AsyncAppender&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;ErrorAppender&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Async&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的debug信息 &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt;--&gt; &lt;logger name=&quot;cn.itcast.wanxinp2p.consumer.mapper&quot; level=&quot;DEBUG&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;springfox&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;com.netflix.discovery&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqCommon&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqRemoting&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqClient&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.lottery&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.bonuspoint&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;!--OFF 0--&gt; &lt;!--FATAL 100--&gt; &lt;!--ERROR 200--&gt; &lt;!--WARN 300--&gt; &lt;!--INFO 400--&gt; &lt;!--DEBUG 500--&gt; &lt;!--TRACE 600--&gt; &lt;!--ALL Integer.MAX_VALUE--&gt; &lt;Root level=&quot;DEBUG&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;AsyncAppender&quot;/&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 配置ElastciSearch创建ElasticSearch的配置文件，其内容如下： ElasticsearchConfig@Data@Component@RefreshScope@ConfigurationProperties(prefix = &quot;elasticsearch&quot;)public class ElasticsearchConfig &#123; private String hostList; @Bean public RestHighLevelClient restHighLevelClient() &#123; //解析hostList配置信息 String[] split = hostList.split(&quot;,&quot;); HttpHost[] httpHosts = new HttpHost[split.length]; for (int i = 0; i &lt; split.length; i++) &#123; String item = split[i]; httpHosts[i] = new HttpHost(item.split(&quot;:&quot;)[0], Integer.parseInt(item.split(&quot;:&quot;)[1]), &quot;http&quot;); &#125; // 创建RestHighLevelClient客户端 return new RestHighLevelClient(RestClient.builder(httpHosts)); &#125;&#125;"},{"title":"Nacos配置","path":"/wiki/learning-online/07-search/nacos.html","content":"找到Nacos配置列表，选择开发环境learning-online-search 创建内容管理工程配置：search-dev.yaml ID：search-dev.yaml Group：learning-online-project 描述：学成在线课程搜索微服务开发环境配置 配置内容： content-api-dev.yamlserver: servlet: context-path: /search port: 63080elasticsearch: host-list: 124.221.23.47:9200 # 多个节点逗号隔开 course: index: course_publish source-fields: id,name,grade,mt,st,charge,pic,price,originalPrice,teachmod,validDays,createDate"},{"title":"课程搜索服务","path":"/wiki/learning-online/07-search/search.html","content":"从ElasticSearch中查询课程信息。 接口信息如下 值 路径地址 http://localhost:63040/search/course/list 请求方式 GET 请求参数 PageParam、SearchCourseParamDTO 返回结果 SearchPageResultVO 查询DTOSearchCourseParamDTO/** * 搜索课程参数dto */ @Data @ToStringpublic class SearchCourseParamDTO &#123; //关键字 private String keywords; //大分类 private String mt; //小分类 private String st; //难度等级 private String grade;&#125; 视图VOSearchPageResultVO@Data@ToStringpublic class SearchPageResultVO&lt;T&gt; extends PageResult &#123; //大分类列表 List&lt;String&gt; mtList; //小分类列表 List&lt;String&gt; stList; public SearchPageResultVO(List&lt;T&gt; items, long counts, long page, long pageSize) &#123; super(items, counts, page, pageSize); &#125;&#125; 定义Service新建CourseSearchService接口，定义课程搜索接口 CourseSearchService/** * 课程搜索service */public interface CourseSearchService &#123; /** * 搜索课程列表 * * @param pageParam 分页参数 * @param dto 搜索条件 * @return com.xuecheng.base.model.PageResult&lt;com.swx.search.po.CourseIndex&gt; 课程列表 */ SearchPageResultVO&lt;CourseIndex&gt; queryCoursePubIndex(PageParam pageParam, SearchCourseParamDTO dto);&#125; 实现该方法，创建其实现类CourseSearchServiceImpl CourseSearchServiceImpl@Slf4j@Service@RefreshScopepublic class CourseSearchServiceImpl implements CourseSearchService &#123; @Value(&quot;$&#123;elasticsearch.course.index&#125;&quot;) private String courseIndexStore; @Value(&quot;$&#123;elasticsearch.course.source-fields&#125;&quot;) private String sourceFields; private final RestHighLevelClient restHighLevelClient; public CourseSearchServiceImpl(RestHighLevelClient restHighLevelClient) &#123; this.restHighLevelClient = restHighLevelClient; &#125; /** * 搜索课程列表 * * @param pageParam 分页参数 * @param dto 搜索条件 * @return com.swx.base.model.PageResult&lt;com.swx.search.po.CourseIndex&gt; 课程列表 */ @Override public SearchPageResultVO&lt;CourseIndex&gt; queryCoursePubIndex(PageParam pageParam, SearchCourseParamDTO dto) &#123; // 设置索引 SearchRequest request = new SearchRequest(courseIndexStore); SearchSourceBuilder builder = new SearchSourceBuilder(); BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // source源字段过滤 String[] sourceFieldsArray = sourceFields.split(&quot;,&quot;); builder.fetchSource(sourceFieldsArray, new String[]&#123;&#125;); if (dto == null) &#123; dto = new SearchCourseParamDTO(); &#125; // 关键字 if (StringUtils.hasText(dto.getKeywords())) &#123; // 匹配关键字 MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(dto.getKeywords(), &quot;name&quot;, &quot;description&quot;); //设置匹配占比 multiMatchQueryBuilder.minimumShouldMatch(&quot;70%&quot;); //提升另个字段的Boost值 multiMatchQueryBuilder.field(&quot;name&quot;, 10); boolQuery.must(multiMatchQueryBuilder); &#125; //过滤 if (StringUtils.hasText(dto.getMt())) &#123; boolQuery.filter(QueryBuilders.termQuery(&quot;mtName&quot;, dto.getMt())); &#125; if (StringUtils.hasText(dto.getSt())) &#123; boolQuery.filter(QueryBuilders.termQuery(&quot;stName&quot;, dto.getSt())); &#125; if (StringUtils.hasText(dto.getGrade())) &#123; boolQuery.filter(QueryBuilders.termQuery(&quot;grade&quot;, dto.getGrade())); &#125; //分页 Long pageNo = pageParam.getPageNo(); Long pageSize = pageParam.getPageSize(); int start = (int) ((pageNo - 1) * pageSize); builder.from(start).size(Math.toIntExact(pageSize)); //布尔查询 builder.query(boolQuery); // 高亮 title builder.highlighter(new HighlightBuilder() .field(&quot;name&quot;) .preTags(&quot;&lt;font style=&#x27;color:red;font-size:inherit;&#x27;&gt;&quot;) .postTags(&quot;&lt;/font&gt;&quot;)); // 请求搜索 request.source(builder); //聚合设置 buildAggregation(request); SearchResponse searchResponse = null; try &#123; searchResponse = restHighLevelClient.search(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; log.error(&quot;课程搜索异常：&quot;, e); return new SearchPageResultVO&lt;CourseIndex&gt;(new ArrayList&lt;CourseIndex&gt;(), 0, 0, 0); &#125; //结果集处理 SearchHits hits = searchResponse.getHits(); SearchHit[] searchHits = hits.getHits(); //记录总数 TotalHits totalHits = hits.getTotalHits(); //数据列表 List&lt;CourseIndex&gt; list = new ArrayList&lt;&gt;(); for (SearchHit hit : searchHits) &#123; String sourceAsString = hit.getSourceAsString(); CourseIndex courseIndex = JSON.parseObject(sourceAsString, CourseIndex.class); //课程id Long id = courseIndex.getId(); //取出名称 String name = courseIndex.getName(); //取出高亮字段内容 Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields(); if (highlightFields != null) &#123; HighlightField nameField = highlightFields.get(&quot;name&quot;); if (nameField != null) &#123; Text[] names = nameField.getFragments(); StringBuilder stringBuffer = new StringBuilder(); for (Text str : names) &#123; stringBuffer.append(str.string()); &#125; name = stringBuffer.toString(); &#125; &#125; courseIndex.setId(id); courseIndex.setName(name); list.add(courseIndex); &#125; SearchPageResultVO&lt;CourseIndex&gt; pageResult = new SearchPageResultVO&lt;&gt;(list, totalHits.value, pageNo, pageSize); //获取聚合结果 List&lt;String&gt; mtList= getAggregation(searchResponse.getAggregations(), &quot;mtAgg&quot;); List&lt;String&gt; stList = getAggregation(searchResponse.getAggregations(), &quot;stAgg&quot;); pageResult.setMtList(mtList); pageResult.setStList(stList); return pageResult; &#125; private void buildAggregation(SearchRequest request) &#123; request.source().aggregation(AggregationBuilders .terms(&quot;mtAgg&quot;) .field(&quot;mtName&quot;) .size(100) ); request.source().aggregation(AggregationBuilders .terms(&quot;stAgg&quot;) .field(&quot;stName&quot;) .size(100) ); &#125; private List&lt;String&gt; getAggregation(Aggregations aggregations, String aggName) &#123; // 4.1.根据聚合名称获取聚合结果 Terms brandTerms = aggregations.get(aggName); // 4.2.获取buckets List&lt;? extends Terms.Bucket&gt; buckets = brandTerms.getBuckets(); // 4.3.遍历 List&lt;String&gt; brandList = new ArrayList&lt;&gt;(); for (Terms.Bucket bucket : buckets) &#123; // 4.4.获取key String key = bucket.getKeyAsString(); brandList.add(key); &#125; return brandList; &#125;&#125; 定义ControllerCourseSearchController/** * 课程搜索接口 */@Api(value = &quot;课程搜索接口&quot;, tags = &quot;课程搜索接口&quot;)@RestController@RequestMapping(&quot;/course&quot;)public class CourseSearchController &#123; private final CourseSearchService courseSearchService; public CourseSearchController(CourseSearchService courseSearchService) &#123; this.courseSearchService = courseSearchService; &#125; @ApiOperation(&quot;课程搜索列表&quot;) @GetMapping(&quot;/list&quot;) public SearchPageResultVO&lt;CourseIndex&gt; list(PageParam pageParam, SearchCourseParamDTO searchCourseParamDTO) &#123; return courseSearchService.queryCoursePubIndex(pageParam, searchCourseParamDTO); &#125;&#125;"},{"title":"媒资信息服务","path":"/wiki/learning-online/08-media/file.html","content":"在learning-online-media-api工程的com.swx.media.api包下创建控制类 api.MediaFilesController/** * &lt;p&gt; * 媒资信息 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-21 */@Api(value = &quot;媒资文件管理接口&quot;, tags = &quot;媒资文件管理接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/files&quot;)public class MediaFilesController &#123;&#125; 查询所有媒资接口信息如下 值 路径地址 http://localhost:63040/meida/files 请求方式 POST 请求参数 PageParam、QueryMediaParamsDTO 返回结果 PageResult 查询DTOQueryCourseParamsDTO@Datapublic class QueryMediaParamsDTO implements Serializable &#123; private static final long serialVersionUID = 1L; private String filename; private String fileType; private String auditStatus;&#125; 定义Service找到MediaFilesService接口，定义课程查询接口 MediaFilesService/** * &lt;p&gt; * 媒资信息 服务类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-21 */public interface MediaFilesService extends IService&lt;MediaFiles&gt; &#123; /** * 查询所有符合条件的媒资信息 * * @param companyId 机构ID * @param pageParam 分页参数 * @param dto 查询参数 * @return PageResult&lt;MediaFiles&gt; */ PageResult&lt;MediaFiles&gt; queryMediaFiles(Long companyId, PageParam pageParam, QueryMediaParamsDTO dto);&#125; 实现该方法，找到其实现类MediaFilesServiceImpl MediaFilesServiceImpl/** * &lt;p&gt; * 媒资信息 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-21 */@Slf4j@Servicepublic class MediaFilesServiceImpl extends ServiceImpl&lt;MediaFilesMapper, MediaFiles&gt; implements MediaFilesService &#123; /** * 查询所有符合条件的媒资信息 * * @param companyId 机构ID * @param pageParam 分页参数 * @param dto 查询参数 * @return PageResult&lt;MediaFiles&gt; */ @Override public PageResult&lt;MediaFiles&gt; queryMediaFiles(Long companyId, PageParam pageParam, QueryMediaParamsDTO dto) &#123; IPage&lt;MediaFiles&gt; page = new Page&lt;&gt;(pageParam.getPageNo(), pageParam.getPageSize()); LambdaQueryWrapper&lt;MediaFiles&gt; wrapper = Wrappers.&lt;MediaFiles&gt;lambdaQuery() .like(StringUtils.hasText(dto.getFilename()), MediaFiles::getFilename, dto.getFilename()) .eq(StringUtils.hasText(dto.getFileType()), MediaFiles::getFileType, dto.getFileType()); IPage&lt;MediaFiles&gt; pageResult = page(page, wrapper); return new PageResult&lt;&gt;(pageResult.getRecords(), pageResult.getTotal(), pageParam); &#125;&#125; 配置分页插件在learning-online-media-service工程下的com.swx.media.config包下创建分页配置类，其内容如下： MybatisPlusConfig@Configuration@MapperScan(&quot;com.swx.media.mapper&quot;)public class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 定义ControllerMediaFilesController/** * &lt;p&gt; * 媒资信息 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-21 */@Api(value = &quot;媒资文件管理接口&quot;, tags = &quot;媒资文件管理接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/files&quot;)public class MediaFilesController &#123; private final MediaFilesService mediaFilesService; public MediaFilesController(MediaFilesService mediaFilesService) &#123; this.mediaFilesService = mediaFilesService; &#125; @ApiOperation(&quot;媒资列表查询接口&quot;) @PostMapping public PageResult&lt;MediaFiles&gt; list(PageParam pageParam, @RequestBody QueryMediaParamsDTO dto) &#123; Long companyId = 1232141425L; return mediaFilesService.queryMediaFiles(companyId, pageParam, dto); &#125;&#125; 媒资查询信息服务以提供，打开前端项目查看是否成功 Push到Gitcommit &quot;完成媒资查询功能&quot;"},{"title":"初始化工程","path":"/wiki/learning-online/08-media/init.html","content":"创建媒资管理工程，依然是分为三个子模块 learning-online-media├── learning-online-media-api├── learning-online-media-model└── learning-online-media-service 创建工程结构在learning-online-media-model模块的pom文件中添加如下依赖： pom.xml&lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 在learning-online-media-service模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-media-model&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 根据扩展名获取mineType --&gt; &lt;dependency&gt; &lt;groupId&gt;com.j256.simplemagic&lt;/groupId&gt; &lt;artifactId&gt;simplemagic&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 分布式任务调度 xxJob --&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- FFmpeg --&gt; &lt;dependency&gt; &lt;groupId&gt;ws.schild&lt;/groupId&gt; &lt;artifactId&gt;jave-all-deps&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在learning-online-media-api模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-media-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类，在learning-online-media-api工程的com.swx.media包下创建启动类MediaApplication，内容如下： ContentApplication@SpringBootApplication@EnableTransactionManagementpublic class MediaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MediaApplication.class, args); &#125;&#125; 项目配置信息，在learning-online-media-api工程的resources下创建bootstrap.yml bootstrap.ymlspring: application: name: media-api cloud: nacos: discovery: server-addr: xxx.xxx.xxx.xxx:8848 namespace: learning-online-dev group: learning-online-project config: server-addr: xxx.xxx.xxx.xxx:8848 namespace: learning-online-dev group: learning-online-project file-extension: yaml refresh-enabled: true extension-configs: - data-id: media-service-$&#123;spring.profiles.active&#125;.yaml group: learning-online-project refresh: true shared-configs: - data-id: logging-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true profiles: active: dev 日志配置，在learning-online-media-api工程的resources下创建log4j2-dev.xml log4j2-dev.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration monitorInterval=&quot;180&quot; packages=&quot;&quot;&gt; &lt;properties&gt; &lt;property name=&quot;logdir&quot;&gt;logs&lt;/property&gt; &lt;property name=&quot;PATTERN&quot;&gt;%date&#123;YYYY-MM-dd HH:mm:ss,SSS&#125; %level [%thread][%file:%line] - %msg%n%throwable&lt;/property&gt; &lt;/properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;ErrorAppender&quot; fileName=&quot;$&#123;logdir&#125;/error.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/error.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;DebugAppender&quot; fileName=&quot;$&#123;logdir&#125;/info.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/info.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;!--异步appender--&gt; &lt;Async name=&quot;AsyncAppender&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;ErrorAppender&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Async&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的debug信息 &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt;--&gt; &lt;logger name=&quot;cn.itcast.wanxinp2p.consumer.mapper&quot; level=&quot;DEBUG&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;springfox&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;com.netflix.discovery&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqCommon&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqRemoting&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqClient&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.lottery&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.bonuspoint&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;!--OFF 0--&gt; &lt;!--FATAL 100--&gt; &lt;!--ERROR 200--&gt; &lt;!--WARN 300--&gt; &lt;!--INFO 400--&gt; &lt;!--DEBUG 500--&gt; &lt;!--TRACE 600--&gt; &lt;!--ALL Integer.MAX_VALUE--&gt; &lt;Root level=&quot;DEBUG&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;AsyncAppender&quot;/&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 添加基础代码实体类使用代码生成工具生成lo_media表的实体类，将其拷贝到learning-online-media-model工程的com.swx.media.model.po包下，暂时所需实体类如下： MediaFiles.java MediaProcess.java MediaProcessHistory.java Mapper层将代码生成的所有Mapper.java文件拷贝到learning-online-media-service工程下的com.swx.media.mapper包下。 将代码生成的所有Mapper.xml文件拷贝到learning-online-media-service工程下的resources/mapper目录下。 Service层将代码生成的所有Service和ServiceImpl文件拷贝到learning-online-media-service工程下的com.swx.media.service包下。 Controller层将代码生成的Controller文件拷贝到learning-online-media-api工程下的com.swx.media.api包下，并修改添加注解如下： MediaFilesController/** * &lt;p&gt; * 媒资信息 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-21 */@Api(value = &quot;媒资文件管理接口&quot;, tags = &quot;媒资文件管理接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/files&quot;)public class MediaFilesController &#123;&#125;"},{"title":"分布式文件系统","path":"/wiki/learning-online/08-media/minio.html","content":"分布式文件系統 (Distributed File System, DFS) 是指文件系統管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点(可简单的理解为一台计算机）相连；或是若干不同的逻辑磁盘分区或卷标组合在一起而形成的完整的有层次的文件系统。DFS为分布在网络上任意位置的资源提供一个逻镇上的树形文件系统结构，从而使用户访问分布在网络上的共享文件更加简便。单独的DFS共享文件夹的作用是相对于通过网络上的其他共享文件夹的访问点 。 通过概念可以简单理解为：一个计算机无法存储海量的文件，通过网络将若干计算机組织起来共同去存储海量的文件，去接收海量用户的请求，这些组织起来的计算机通过网络进行通信，如下图： 相关产品1、NFS NFS一般指网络文件系统。 网络文件系统，英文Network File System(NFS)，是由SUN公司研制的UNIX表示层协议(presentation layer protocol)，能使使用者访问网络上别处的文件就像在使用自己的计算机一样。 特点： 1）在客户端映射NFS服务器的驱动器。 2）客户端通过网络访问NFS服务器的硬盘完全透明。 2、GFS GFS是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，并提供容错功能。它可以给大量的用户提供总体性能较高的服务 1）GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver组成。2）master存储了数据文件的元数据，一个文件被分成了若干块存储在多个chunkserver中。3）用户从master中获取数据元信息，向chunkserver存储数据。 3、HDFS HDFS，Hadoop Distribute File System（Hadoop分布式文件系统）的简称，它是Hadoop核心组件之一，是大数据生态圈最底层的分布式存储服务。将计算靠近数据，而不是将数据移动到离计算更近的地方，使得应用的计算更有效率。 HDFS遵循主从架构（master&#x2F;slave）。通常包括一个主节点和多个从节点。主节点为NameNode，从节点为DataNode。 4、云计算厂家 阿里云对象存储服务（Object Storage Service，简称OSS） 百度云对象存储服务（Baidu Object Storage，简称BOS） MinIOMinIO基于Apache License v2.0开源协议的对象存储服务，可以做为云存储的解决方案用来保存海量的图片，视频，文档。 uGolang语言实现，配置简单，单行命令可以运行起来。 uMinIO兼容亚马逊S3云存储服务接口，适合于存储大容量非结构化的数据，一个对象文件可以是任意大小，从几kb到最大5T不等。 官网文档：http://docs.minio.org.cn/docs/ 安装MinIO①：拉取镜像 docker pull minio/minio ②：创建容器 docker run -p 9000:9000 -p 9001:9001 \\\t--name minio \\\t-d --restart=always \\\t-e &quot;MINIO_ACCESS_KEY=minio&quot; \\\t-e &quot;MINIO_SECRET_KEY=minio123&quot; \\\t-v /home/data:/data \\\t-v /home/config:/root/.minio \\\tminio/minio server /data \\\t--console-address &quot;:9001&quot; ③：访问minio系统 http://ip:9001 配置MinIO找到learning-online-media-service工程，添加MinIO的配置类 创建配置属性MinIOConfigProperties类，内容如下： MinIOConfigProperties@Data@ConfigurationProperties(prefix = &quot;minio&quot;) // 文件上传 配置前缀file.osspublic class MinIOConfigProperties implements Serializable &#123; private String accessKey; private String secretKey; private String endpoint; private Map&lt;String, String&gt; bucket;&#125; 在Nacos中配置这些属性： media-service-dev.yamlminio: endpoint: http://124.221.23.47:9000 accessKey: minio secretKey: minio123 bucket: files: mediafiles video: video 创建MinIO客户端配置类 MinIOConfig@Configuration@EnableConfigurationProperties(&#123;MinIOConfigProperties.class&#125;)//当引入FileStorageService接口时@ConditionalOnClass(FileStorageService.class)public class MinIOConfig &#123; @Autowired private MinIOConfigProperties minIOConfigProperties; @Bean public MinioClient buildMinioClient() &#123; return MinioClient .builder() .credentials(minIOConfigProperties.getAccessKey(), minIOConfigProperties.getSecretKey()) .endpoint(minIOConfigProperties.getEndpoint()) .build(); &#125;&#125; MinIO Service找到learning-online-media-service工程，在包com.swx.media.service下创建接口类MinIOFileStorageService MinIOFileStorageServicepublic interface FileStorageService &#123;&#125; 在包com.swx.media.service.impl下实现该接口 MinIOFileStorageService@Slf4j@EnableConfigurationProperties(MinIOConfigProperties.class)@Import(MinIOConfig.class)@Servicepublic class MinIOFileStorageService implements FileStorageService &#123; private final static String separator = &quot;/&quot;; /** * @param dirPath * @param filename yyyy/mm/dd/file.jpg * @return */ public String builderFilePath(String dirPath, String filename) &#123; StringBuilder stringBuilder = new StringBuilder(50); if (!StringUtils.isEmpty(dirPath)) &#123; stringBuilder.append(dirPath).append(separator); &#125; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;); String todayStr = sdf.format(new Date()); stringBuilder.append(todayStr).append(separator); stringBuilder.append(filename); return stringBuilder.toString(); &#125;&#125;"},{"title":"Nacos配置","path":"/wiki/learning-online/08-media/nacos.html","content":"打开Nacos管理界面，添加新的配置文件：http://ip:8848/nacos 命名空间选择learning-online-dev 创建系统管理工程配置：media-api-dev.yaml ID：media-api-dev.yaml Group：learning-online-project 描述：媒资管理微服务API配置 配置内容： server: port: 63050 servlet: context-path: /mediaspring: cloud: config: # 本地优先 override-none: true 创建系统管理工程配置：media-service-dev.yaml ID：media-service-dev.yaml Group：learning-online-project 配置内容： media-service-dev.yamlspring: servlet: multipart: max-file-size: 10MB max-request-size: 20MB datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///lo_media?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: swx852345mybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.media.model.pominio: endpoint: http://xxx.xxx.xxx.xxx:9000 accessKey: minio secretKey: minio123 bucket: files: mediafiles video: video# xxl-job配置xxl: job: admin: # 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册； addresses: http://127.0.0.1:8080/xxl-job-admin executor: # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。 address: # 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册 appname: media-process-executor # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;； ip: # 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口； port: 9999 # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径； logpath: /Users/swcode/data/applogs/xxl-job/jobhandler # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能； logretentiondays: 30 # 执行器通讯TOKEN [选填]：非空时启用； accessToken:"},{"title":"文件上传服务","path":"/wiki/learning-online/08-media/picture.html","content":"图片上传服务业务流程 接口信息如下 值 路径地址 http://localhost:63040/media/upload/coursefile 请求方式 POST 请求参数 MultipartFile 返回结果 UploadFileResultVO 返回结果VOCourseCategoryTreeVO@Data@EqualsAndHashCode(callSuper = true)public class UploadFileResultVO extends MediaFiles &#123;&#125; 参数DTOUploadFileParamDTO@Datapublic class UploadFileParamDTO implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 文件名称 */ private String filename; /** * 文件类型（图片、文档，视频） */ private String fileType; /** * 文件大小 */ private Long fileSize; /** * 标签 */ private String tags; /** * 上传人 */ private String username; /** * 备注 */ private String remark;&#125; 定义Service文件存储操作定义上传媒体文件的方法，找到com.swx.media.service包下的FileStorageService接口，定义如下方法： FileStorageService/** * 上传文件 * * @param prefix 文件前缀 * @param filename 文件名 * @param inputStream 文件流 * @return 桶和文件全路径 */public Map&lt;String, String&gt; uploadMediaFile(String prefix, String filename, String mineType, InputStream inputStream); 实现该方法 MinIOFileStorageServiceprivate final MinioClient minioClient;private final MinIOConfigProperties minIOConfigProperties;public MinIOFileStorageService(MinioClient minioClient, MinIOConfigProperties minIOConfigProperties) &#123; this.minioClient = minioClient; this.minIOConfigProperties = minIOConfigProperties;&#125;/** * 上传图片文件 * * @param prefix 文件前缀 * @param filename 文件名 * @param inputStream 文件流 * @return 文件全路径 */@Overridepublic Map&lt;String, String&gt; uploadMediaFile(String prefix, String filename, String mineType, InputStream inputStream) &#123; String filepath = builderFilePath(prefix, filename); String bucket = minIOConfigProperties.getBucket().get(&quot;files&quot;); try &#123; PutObjectArgs putObjectArgs = PutObjectArgs.builder() .object(filepath) .contentType(mineType) .bucket(bucket) .stream(inputStream, inputStream.available(), -1) .build(); minioClient.putObject(putObjectArgs); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;path&quot;, filepath); map.put(&quot;bucket&quot;, bucket); return map; &#125; catch (Exception ex) &#123; log.error(&quot;minio put file error.&quot;, ex); throw new RuntimeException(&quot;上传文件失败&quot;); &#125;&#125; 文件上传方法定义上传文件的方法，找到com.swx.media.service包下的MediaFilesService接口，定义如下方法： MediaFilesServicepublic interface MediaFilesService extends IService&lt;MediaFiles&gt; &#123; /** * 上传文件 * * @param companyId 机构ID * @param dto 文件信息 * @param multipartFile 文件信息 * @return UploadFileResultVO */ public UploadFileResultVO uploadFile(Long companyId, UploadFileParamDTO dto, MultipartFile multipartFile); /** * 从dto保存到数据库 * * @param dto 文件信息 * @return 保是否保存成功 */ /** * 上传到MinIO之后保存到数据库 * * @param dto 文件信息 * @param companyId 机构ID * @param prefix 前缀 * @param bucket 桶 * @param path 文件路径 * @return 保是否保存成功 */ public MediaFiles saveAfterStore(UploadFileParamDTO dto, Long companyId, String prefix, String bucket, String path);&#125; 实现该方法： /** * &lt;p&gt; * 媒资信息 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-08-21 */@Slf4j@Servicepublic class MediaFilesServiceImpl extends ServiceImpl&lt;MediaFilesMapper, MediaFiles&gt; implements MediaFilesService &#123; private final FileStorageService fileStorageService; private final TransactionTemplate transactionTemplate; public MediaFilesServiceImpl(FileStorageService fileStorageService, TransactionTemplate transactionTemplate) &#123; this.fileStorageService = fileStorageService; this.transactionTemplate = transactionTemplate; &#125; /** * 上传文件 * * @param companyId 机构ID * @param dto 文件信息 * @param multipartFile 文件信息 * @return UploadFileResultVO */ @Override public UploadFileResultVO uploadFile(Long companyId, UploadFileParamDTO dto, MultipartFile multipartFile) &#123; String filename = dto.getFilename(); String suffix = filename.substring(filename.lastIndexOf(&quot;.&quot;)); try &#123; String prefix = getFileMd5(multipartFile.getInputStream()); // 已存在数据库，直接返回 MediaFiles dbMediaFile = getById(prefix); if (dbMediaFile != null) &#123; UploadFileResultVO resultVO = new UploadFileResultVO(); BeanUtils.copyProperties(dbMediaFile, resultVO); return resultVO; &#125; // 上传到MinIO String mineType = getMineType(suffix); Map&lt;String, String&gt; result = fileStorageService.uploadMediaFile(&quot;&quot;, prefix + suffix, mineType, multipartFile.getInputStream()); String bucket = result.get(&quot;bucket&quot;); String path = result.get(&quot;path&quot;); // 保存到数据库，使用编程式事务 MediaFiles mediaFiles = transactionTemplate.execute(transactionStatus -&gt; &#123; try &#123; return saveAfterStore(dto, companyId, prefix, bucket, path); &#125; catch (Exception e) &#123; log.error(&quot;文件入库失败: &quot;, e); transactionStatus.setRollbackOnly(); &#125; return null; &#125;); // 返回数据 UploadFileResultVO resultVO = new UploadFileResultVO(); if (mediaFiles == null) return resultVO; BeanUtils.copyProperties(mediaFiles, resultVO); return resultVO; &#125; catch (IOException e) &#123; log.info(&quot;MediaFilesServiceImpl-上传文件失败&quot;, e); throw new BizException(&quot;文件上传失败&quot;); &#125; &#125; /** * 从dto保存到数据库 * * @param dto 文件信息 * @return 保是否保存成功 */ @Override public MediaFiles saveAfterStore(UploadFileParamDTO dto, Long companyId, String fileMd5, String bucket, String path) &#123; // 构造参数 MediaFiles mediaFiles = new MediaFiles(); BeanUtils.copyProperties(dto, mediaFiles); mediaFiles.setId(fileMd5); mediaFiles.setCompanyId(companyId); mediaFiles.setBucket(bucket); mediaFiles.setFilePath(path); mediaFiles.setFileId(fileMd5); mediaFiles.setUrl(&quot;/&quot; + bucket + &quot;/&quot; + path); mediaFiles.setCreateDate(LocalDateTime.now()); mediaFiles.setStatus(MediaFileStatusEnum.NORMAL.status()); mediaFiles.setAuditStatus(&quot;002003&quot;); boolean save = save(mediaFiles); if (!save) &#123; log.error(&quot;想数据库保存文件失败，bucket: &#123;&#125;，文件名: &#123;&#125;&quot;, bucket, path); return null; &#125; return mediaFiles; &#125; private String getMineType(String suffix) &#123; if (suffix == null) suffix = &quot;&quot;; ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(suffix); String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE; if (extensionMatch != null) &#123; mimeType = extensionMatch.getMimeType(); &#125; return mimeType; &#125; /** * 获得文件Md5值 * * @param inputStream 文件 * @return Md5值 */ private String getFileMd5(InputStream inputStream) &#123; try &#123; return DigestUtils.md5DigestAsHex(inputStream); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 什么情况Spring事务会失效？ 在方法中捕获异常没有抛出 非事务方法调用事务方法 @Transactional标记的方法不是public 抛出的异常与rollbackFor指定的异常不匹配，默认rollbackFor指定的异常为RuntimeException 数据库不支持事务，比如MySQL的MyISAM Spring的传播行为导致事务失效，比如：PROPAGATION_NEVER、PROPAGATION_NOT_SUPPORTED PROPAGATION_REQUIRED -- 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。PROPAGATION_SUPPORT -- 支持当前事务，如果当前没有事务，就以非事务方式执行。PROPAGATION_MANDATORY -- 支持当前事务，如果当前没有事务，就抛出异常。PROPAGATION_REQUIRES_NEW -- 新建事务，如果当前存在事务，把当前事务挂起。PROPAGATION_NOT_SUPPORTED -- 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。PROPAGATION_NEVER -- 以非事务方式执行，如果当前存在事务，则抛出异常。PROPAGATION_NESTED -- 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则与PROPAGATION_REQUIRED类似的操作。 分块文件清理问题？上传一个文件进行分块上传，上传一半不传了，之前上传到minio的分块文件要清理吗？ 怎么做的？ 1、在数据库中有一张文件表记录minio中存储的文件信息。2、文件开始上传时会亏入文件表，状志为上传中，上传完成会更新状态为上传成。3、当一个文件传了一半不再上传了说明该文件没有上传完成，会有定时任务去查询文件表中的记录，如果文件末上传完成则删除minio中没有上传成功的文件目录。 定义ControllerMediaFilesUploadController/** * &lt;p&gt; * 媒资上传 前端控制器 * &lt;/p&gt; * * @author sw-code * @since 2023-08-21 */@Api(value = &quot;媒资文件上传管理接口&quot;, tags = &quot;媒资文件上传管理接口&quot;)@RestController@ResponseResult@RequestMapping(&quot;/upload&quot;)public class MediaFilesUploadController &#123; private final MediaFilesService mediaFilesService; public MediaFilesUploadController(MediaFilesService mediaFilesService) &#123; this.mediaFilesService = mediaFilesService; &#125; @ApiOperation(&quot;上传文件&quot;) @PostMapping(value = &quot;/coursefile&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE) public UploadFileResultVO uploadImage(@RequestPart(&quot;filedata&quot;) MultipartFile filedata) &#123; Long companyId = 1232141425L; UploadFileParamDTO dto = new UploadFileParamDTO(); dto.setFilename(filedata.getOriginalFilename()); dto.setFileSize(filedata.getSize()); dto.setFileType(&quot;001001&quot;); return mediaFilesService.uploadFile(companyId, dto, filedata); &#125;&#125; Push到Gitcommit &quot;完成图片上传功能&quot;"},{"title":"视频转码服务","path":"/wiki/learning-online/08-media/video-transcoding.html","content":"AVI 是一种比较老的视频格式，现代浏览器通常不直接支持 AVI 格式，因此在网页上播放 AVI 视频时，您需要将视频转换为一种更常见的格式（如 MP4），或使用一些第三方的 JavaScript 播放器库。 下面是整个转码服务的运行过程 FFmpeg处理视频使用FFmpeg进行视频转码操作 分布式任务调度XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 如何保证任务不重复执行？ 1）调度中心按分片广播的方式去下发任务2）执行器收到作北分片广播的参数：分片总教和分片序号，计管任务id除以分片总数得到一个余数．如果余数等于分片序号这时就去执行这个任务，这里保证了不同的执行器执行不同的任务。3）配置调度过期策路为〝忽略”，避免同一个执行器多次重复执行同—个任务4）配置任务阻塞处理策略为〝丢弃后续调度〞，注意：丢弃也没事下一次调度就又可以执行了5）另外还要保证任务处理的幂等性，执行过的任务可以打一个状态标记已完成，下次再调度执行该任务判断该任务已完成就不再执行。 任务幂等性如何保证？ 它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果。 幂等性是为了解決重复提交问题，比如：恶意刷单，重复支付等。 解决幂等性常用的方案： 1）数据库约束，比如：唯一素引，主键。同一个主键不可能两次都插入成功。2） 乐观锁，常用于数据库，更新数据时根据乐观锁状态去更新。3）唯一序列号，请求前生成唯一的序列号，携带序列号去请求，执行时在redis记录该序列号表示以该序列号的请求执行过了，如果相同的序列号再次来执行说明是重复执行。 这里我们在数据库视频处理表中添加处理状态字段，视频处理完成更新状态为完成，执行视频处理前判断 安装XXL-JOB使用Docker部署，使用下面命令安装： docker pull xuxueli/xxl-job-admin:2.3.0 使用如下命令启动： docker run -e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://ip:3306/xxl_job?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true \\ --spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver \\ --spring.datasource.username=root \\ --spring.datasource.password=root&quot; \\ -p 8080:8080 \\ -v /tmp:/data/applogs \\ --name xxl-job-admin \\ -d xuxueli/xxl-job-admin:2.3.0 注意修改数据源，其中url中的IP设置为服务器IP地址，如果是本机，请使用本机地址不要使用localhost或者127.0.0.1，同时记得开启mysql的远程访问 use mysql;update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;flush privilegesgrant all privileges on *.* TO &#x27;root&#x27;@&#x27;%&#x27; with grant option; 访问http://localhost:8080/xxl-job-admin/ 创建执行器进入后台管理，点击右侧执行器管理，新建一个执行器 注册执行器进入Nacos后台，找到media-service-dev.yaml，添加xxl-Job的配置： media-service-dev.yaml# xxl-job配置xxl: job: admin: # 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册； addresses: http://127.0.0.1:8080/xxl-job-admin executor: # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。 address: # 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册 appname: media-process-executor # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;； ip: # 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口； port: 9999 # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径； logpath: /Users/swcode/data/applogs/xxl-job/jobhandler # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能； logretentiondays: 30 # 执行器通讯TOKEN [选填]：非空时启用； accessToken: 找到learning-online-media-service模块，在config包下创建XxlJonConfig配置类 XxlJonConfig@Slf4j@Configurationpublic class XxlJonConfig &#123; @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;) private String address; @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;) private String ip; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;) private String accessToken; @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;) private String logPath; @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; log.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(address); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; &#125;&#125; 启动learning-online-media服务，在执行器管理页面可以看到自动注册了一个服务。 添加任务管理进入后台管理，点击右侧任务管理，新建一个任务 分布式锁买现分布式锁的方案有很多，常用的如下：1、基于数据库实现分布锁利用数据库主键唯一性的特点，或利用数据库唯一索号l、行级锁的特点，比如：多个线程同时向数据库插入主键相同的同一条记录，谁插入成功谁就获取锁，多个线程同时去更新相同的记录，谁更新成功谁就抢到锁。 2、基于redis实现锁redis提供了分布式锁的实现方案，比如：SETNX、set nx、redisson等。拿SETNX举例说明，SETNX命令的工作过程是去set一个不存在的key，多个线程去设置同一个key只会有一个线程设置成功，设置成功的的线程拿到锁。 3、使用zookeeper实现zookeeper是一个分布式协调服务，主要解决分布式程序之间的同步的问题。zookeeper的结构类似的文件目录，多线程向zookeeper创建一个子目录(节点)只会有一个创建成功，利用此特点可以实现分布式锁，谁创建该结点成功谁就获得锁。 本次我们使用数据库实现分布锁，后边的模块会使用其它方法到时再洋细介绍， 使用乐观锁机制实现 当某次调用者执行成功时，status被置为4，其他执行都会失败；这个执行成功的就拿到了”锁”。 MediaProcessMapperpublic interface MediaProcessMapper extends BaseMapper&lt;MediaProcess&gt; &#123; /** * 开启一个任务 * @param id 任务id * @return int 更新成功条数 */ @Update(&quot;update media_process set status = &#x27;4&#x27; where (status=&#x27;1&#x27; or status=&#x27;3&#x27;) and fail_count&lt;3 and id=#&#123;id&#125;&quot;) int startTask(@Param(&quot;id&quot;) Long id);&#125; Service包一层 MediaProcessServicepublic interface MediaProcessService extends IService&lt;MediaProcess&gt; &#123; /** * 开启一个任务 * @param id 任务id * @return true 开启任务成功，false开启任务失败 */ public boolean startTask(long id);&#125; 实现该方法 MediaProcessServiceImpl@Servicepublic class MediaProcessServiceImpl extends ServiceImpl&lt;MediaProcessMapper, MediaProcess&gt; implements MediaProcessService &#123; /** * 开启一个任务 * * @param id 任务id * @return true 开启任务成功，false开启任务失败 */ @Override public boolean startTask(long id) &#123; return baseMapper.startTask(id) &gt; 0; &#125;&#125; 实现添加任务在文件合并完成之后，将数据保存到media_files同时，判断视频文件是否为.avi，如果是需要进行转码操作，将其添加到任务表media_process。 找到MediaFilesServiceImpl，修改saveAfterStore方法 MediaFilesServiceImpl@Overridepublic MediaFiles saveAfterStore(UploadFileParamDTO dto, Long companyId, String fileMd5, String bucket, String path) &#123; // 构造参数 MediaFiles mediaFiles = new MediaFiles(); BeanUtils.copyProperties(dto, mediaFiles); mediaFiles.setId(fileMd5); mediaFiles.setCompanyId(companyId); mediaFiles.setBucket(bucket); mediaFiles.setFilePath(path); mediaFiles.setFileId(fileMd5); mediaFiles.setUrl(&quot;/&quot; + bucket + &quot;/&quot; + path); mediaFiles.setCreateDate(LocalDateTime.now()); mediaFiles.setStatus(MediaFileStatusEnum.NORMAL.status()); mediaFiles.setAuditStatus(&quot;002003&quot;); // 保存到媒资文件表 boolean save = save(mediaFiles); if (!save) &#123; log.error(&quot;想数据库保存文件失败，bucket: &#123;&#125;，文件名: &#123;&#125;&quot;, bucket, path); return null; &#125; // 记录待处理任务 addWaitingTask(mediaFiles); return mediaFiles;&#125;/** * 添加文件转码待处理任务 * @param mediaFiles 文件信息 */private void addWaitingTask(MediaFiles mediaFiles) &#123; // 获取文件的mimeType, 如果是avi视频，写入待处理任务 String filename = mediaFiles.getFilename(); String suffix = filename.substring(filename.lastIndexOf(&quot;.&quot;)); String mineType = getMineType(suffix); if (!mineType.equals(&quot;video/x-msvideo&quot;)) &#123; return; &#125; MediaProcess mediaProcess = new MediaProcess(); BeanUtils.copyProperties(mediaProcess, mediaFiles); mediaProcess.setStatus(&quot;1&quot;); mediaProcess.setCreateDate(LocalDateTime.now()); mediaProcess.setFailCount(0); mediaProcess.setUrl(null); mediaProcessService.save(mediaProcess);&#125; 更新任务状态任务处理完成需要更新任务处理结果，任务执行成功更新视频的URL、及任务处理结果，将待处理任务记录删除，同时向历史任务表添加记录。 创建MediaProcessSaveService接口添加方法 MediaProcessSaveService.javapublic interface MediaProcessSaveService &#123; /** * 保存任务结果 * * @param taskId 任务ID * @param status 任务状态 * @param fileId 文件id * @param url 转码路径 * @param errorMsg 错误信息 */ public void saveProcessFinishStatus(Long taskId, String status, String fileId, String url, String errorMsg);&#125; 创建实现类MediaProcessSaveServiceImpl实现保存方法： MediaProcessSaveServiceImpl@Servicepublic class MediaProcessSaveServiceImpl implements MediaProcessSaveService &#123; private final MediaFilesService mediaFilesService; private final MediaProcessService mediaProcessService; private final MediaProcessHistoryService mediaProcessHistoryService; public MediaProcessSaveServiceImpl(MediaFilesService mediaFilesService, MediaProcessService mediaProcessService, MediaProcessHistoryService mediaProcessHistoryService) &#123; this.mediaFilesService = mediaFilesService; this.mediaProcessService = mediaProcessService; this.mediaProcessHistoryService = mediaProcessHistoryService; &#125; /** * 保存任务结果 * * @param taskId 任务ID * @param status 任务状态 * @param fileId 文件id * @param url 转码路径 * @param errorMsg 错误信息 */ @Override @Transactional(rollbackFor = Exception.class) public void saveProcessFinishStatus(Long taskId, String status, String fileId, String url, String errorMsg) &#123; MediaProcess dbProcess = mediaProcessService.getById(taskId); if (dbProcess == null) &#123; return; &#125; // 任务执行失败 if (status.equals(ProcessStatus.PROCESS_FAIL.status())) &#123; // 更新失败次数 mediaProcessService.update(Wrappers.&lt;MediaProcess&gt;lambdaUpdate() .eq(MediaProcess::getId, taskId) .set(MediaProcess::getStatus, status) .set(MediaProcess::getFailCount, dbProcess.getFailCount() + 1) .set(MediaProcess::getErrormsg, errorMsg)); return; &#125; // 任务执行成功 MediaFiles mediaFiles = mediaFilesService.getById(fileId); if (mediaFiles == null) &#123; return; &#125; // 更新media_file中的url mediaFilesService.update(Wrappers.&lt;MediaFiles&gt;lambdaUpdate().eq(MediaFiles::getId, fileId).set(MediaFiles::getUrl, url)); // 将MediaProcess记录插入到MediaProcessHistory中 dbProcess.setStatus(status); dbProcess.setFinishDate(LocalDateTime.now()); dbProcess.setUrl(url); MediaProcessHistory processHistory = new MediaProcessHistory(); BeanUtils.copyProperties(dbProcess, processHistory); mediaProcessHistoryService.save(processHistory); // 删除MediaProcess记录 mediaFilesService.removeById(taskId); &#125;&#125; 实现获取任务从数据库中获取任务，根据分片数量和当前分片序号确定当前分片要处理的任务。 找到MediaProcessMapper，添加查询任务方法： MediaProcessMapper/** * 查询当前分片的任务 * * @param shardTotal 分片总数 * @param shardIndex 当前分片序号 * @param count 任务数量 * @return List&lt;MediaProcess&gt; */@Select(&quot;select * from media_process t where t.id % #&#123;shardTotal&#125; = #&#123;shardIndex&#125; and t.status &lt;&gt; 2 and t.fail_count &lt; 3 limit #&#123;count&#125;&quot;)List&lt;MediaProcess&gt; selectListByShardIndex(@Param(&quot;shardTotal&quot;) int shardTotal, @Param(&quot;shardIndex&quot;) int shardIndex, @Param(&quot;count&quot;) int count); 包一层MediaProcessService MediaProcessService/** * 获取待处理任务 * * @param shardTotal 分片总数 * @param shardIndex 当前分片序号 * @param count 任务数量 * @return List&lt;MediaProcess&gt; */List&lt;MediaProcess&gt; getMediaProcessList(int shardTotal, int shardIndex, int count); 实现该方法，MediaProcessServiceImpl MediaProcessServiceImpl/** * 获取待处理任务 * * @param shardTotal 分片总数 * @param shardIndex 当前分片序号 * @param count 任务数量 * @return List&lt;MediaProcess&gt; */@Overridepublic List&lt;MediaProcess&gt; getMediaProcessList(int shardTotal, int shardIndex, int count) &#123; return baseMapper.selectListByShardIndex(shardTotal, shardIndex, count);&#125; 实现调度任务创建包com.swx.media.service.jobhandle，并创建视频编码任务VideoTask 根据系统CPU核心数，确定从数据库查询多少任务，如果任务为0则直接返回； 根据获取的任务数，开启对应数量的线程数； 使用计数器，确保所有任务执行完成后再结束方法； 循环所有任务，指定线程取执行如下步骤： 获取任务锁，实现幂等性，防止重复执行，失败，写入数据库，返回； 从MinIO下载要转码的视频，下载失败，写入数据库，返回； 使用FFmpeg进行视频转码，保存到临时文件；转码失败，写入数据库，返回； 将转码之后的文件上传到MinIO中，上传失败，写入数据库，返回； 上传成功，写入数据库。 使用try finally包裹线程方法，在finally中将计数器减1； 使用计数器阻塞进程，并设置最大等待时间，无论线程中计数器是否减1，最大时间过后释放线程。 VideoTask/** * 视频转码任务处理类 */@Slf4j@Componentpublic class VideoTask &#123; private final MediaProcessService mediaProcessService; private final FileStorageService fileStorageService; private final MediaProcessSaveService mediaProcessSaveService; public VideoTask(MediaProcessService mediaProcessService, FileStorageService fileStorageService, MediaProcessSaveService mediaProcessSaveService) &#123; this.mediaProcessService = mediaProcessService; this.fileStorageService = fileStorageService; this.mediaProcessSaveService = mediaProcessSaveService; &#125; /** * 视频处理任务 */ @XxlJob(&quot;videoJobHandler&quot;) public void videoJobHandler() throws Exception &#123; // 分片参数 int shardIndex = XxlJobHelper.getShardIndex(); int shardTotal = XxlJobHelper.getShardTotal(); // 确定CPU核心数 int processors = Runtime.getRuntime().availableProcessors(); // 拉取任务 List&lt;MediaProcess&gt; mediaProcessList = mediaProcessService.getMediaProcessList(shardIndex, shardTotal, processors); int size = mediaProcessList.size(); if (size == 0) &#123; log.debug(&quot;取到的视频处理任务数：&#123;&#125;&quot;, size); return; &#125; // 创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(size); // 使用计数器，等待所有线程执行完再结束方法 CountDownLatch countDownLatch = new CountDownLatch(size); for (MediaProcess mediaProcess : mediaProcessList) &#123; // 将任务加入线程池 executorService.execute(() -&gt; &#123; try &#123; // 获取任务锁，幂等性操作，避免重复执行 Long taskId = mediaProcess.getId(); boolean lock = mediaProcessService.startTask(taskId); String fileId = mediaProcess.getFileId(); if (!lock) &#123; log.debug(&quot;抢占任务失败，任务id: &#123;&#125;&quot;, taskId); return; &#125; // 下载MinIO视频 String bucket = mediaProcess.getBucket(); String objectName = mediaProcess.getFilePath(); File file = fileStorageService.downloadFile(bucket, objectName); if (file == null) &#123; log.error(&quot;下载视频出错，任务id: &#123;&#125;, bucket: &#123;&#125;, objectName: &#123;&#125;&quot;, taskId, bucket, objectName); // 保存任务处理失败结果 mediaProcessSaveService.saveProcessFinishStatus(taskId, ProcessStatus.PROCESS_FAIL.status(), fileId, null, &quot;下载视频到本地失败&quot;); return; &#125; // 视频转码 // 源avi视频的路径 File sourcePath = file.getAbsoluteFile(); File targetFile = null; try &#123; targetFile = File.createTempFile(&quot;minio&quot;, &quot;.mp4&quot;); &#125; catch (IOException e) &#123; log.error(&quot;创建临时文件异常, &quot;, e); // 保存任务处理失败结果 mediaProcessSaveService.saveProcessFinishStatus(taskId, ProcessStatus.PROCESS_FAIL.status(), fileId, null, &quot;创建临时文件异常&quot;); return; &#125; String targetPath = targetFile.getAbsolutePath(); // 开始转换 String result = &quot;success&quot;; if (!result.equals(&quot;success&quot;)) &#123; log.error(&quot;视频转码失败, bucket: &#123;&#125;, objectName: &#123;&#125;, 原因: &#123;&#125;&quot;, taskId, bucket, result); // 保存任务处理失败结果 mediaProcessSaveService.saveProcessFinishStatus(taskId, ProcessStatus.PROCESS_FAIL.status(), fileId, null, result); return; &#125; // 上传到MinIO FileInputStream fileInputStream = null; try &#123; fileInputStream = new FileInputStream(targetPath); &#125; catch (FileNotFoundException e) &#123; log.error(&quot;转码后的文件不存在, 文件路径: &#123;&#125;&quot;, targetPath); // 保存任务处理失败结果 mediaProcessSaveService.saveProcessFinishStatus(taskId, ProcessStatus.PROCESS_FAIL.status(), fileId, null, &quot;转码后的文件不存在&quot;); return; &#125; // 开始上传 boolean isUploadMinIO = fileStorageService.uploadVideoFile(objectName, &quot;video/mp4&quot;, fileInputStream); if (!isUploadMinIO) &#123; log.error(&quot;上传mp4到MinIO失败, taskId: &#123;&#125;&quot;, taskId); // 保存任务处理失败结果 mediaProcessSaveService.saveProcessFinishStatus(taskId, ProcessStatus.PROCESS_FAIL.status(), fileId, null, &quot;上传mp4到MinIO失败&quot;); return; &#125; // 保存任务成功结果，mp4文件的url String url = getFilePathByMd5(fileId, &quot;.mp4&quot;); mediaProcessSaveService.saveProcessFinishStatus(taskId, ProcessStatus.PROCESS_SUCCESS.status(), fileId, url, null); &#125; finally &#123; // 线程任务完成，计算器-1 countDownLatch.countDown(); &#125; &#125;); &#125; // 阻塞，最多等待30分钟 countDownLatch.await(30, TimeUnit.MINUTES); &#125; /** * 得到MinIO文件的路径 * * @param fileMd5 源文件Md5 * @param suffix 文件后缀 * @return 分块存储路径 */ private String getFilePathByMd5(String fileMd5, String suffix) &#123; return fileMd5.charAt(0) + &quot;/&quot; + fileMd5.charAt(1) + &quot;/&quot; + fileMd5 + &quot;/&quot; + fileMd5 + suffix; &#125;&#125;"},{"title":"视频上传服务","path":"/wiki/learning-online/08-media/video-upload.html","content":"断点续传通常视频文件都比较大，所以对于媒资系统上传文件的需求要满足大文件的上传要求。http协议本身对上传文件大小没有限制，但是客户的网络环境质量、电脑硬件环境等参差不齐，如果一个大文件快上传完了网断了没有上传完成，需要客户重新上传，用户体验非常差，所以对于大文件上传的要求最基本的是断点续传。 什么是断点续传： 引用百度百科：断点续传指的是在下载或上传时，将下载或上传任务（一个文件或一个压縮包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载末完成的部分，而没有必要从头开始年传下载，断点续传可以提高节省操作时间，提高用户体验性。 业务流程1、前端会发起checkFile请求，后端检查文件是否在数据库和MinIO中，如果不在直接返回false，在数据库中但不在MinIO中也返回false。ID为文件MD5。 2、文件不存在，前端将文件分块；分块上传前会再次检查分片是否在MinIO中，如果不存在返回false。 3、分块不存在，前端发起分块上传请求，后端将文件转存至MinIO中；分块存在，前端继续重复2-3步骤，直至所有分块上传完成。 4、分块上传完成后，前端发起合并文件请求，后端向MinIO发起合并请求；合并完成后，将数据保存到数据库中。 5、后端向MinIO中发起删除分块请求。 接口信息文件上传前的检查文件 值 路径地址 http://localhost:63040/media/upload/checkfile 请求方式 POST 请求参数 fileMd5 返回结果 Boolean 分块文件上传前的检查文件 值 路径地址 http://localhost:63040/media/upload/checkchunk 请求方式 POST 请求参数 fileMd5、chunk 返回结果 Boolean 上传分块文件 值 路径地址 http://localhost:63040/media/upload/uploadchunk 请求方式 POST 请求参数 MultipartFile、fileMd5、chunk 返回结果 Boolean 合并分块文件 值 路径地址 http://localhost:63040/media/upload/uploadchunk 请求方式 POST 请求参数 fileName、fileMd5、chunkTotal 返回结果 R 定义Service文件存储操作定义上传媒体文件的方法，找到com.swx.media.service包下的FileStorageService接口，定义如下方法： FileStorageService/** * 上传视频分块文件 * * @param path 文件路径 * @param inputStream 文件流 * @return 文件全路径 */public String uploadChunkFile(String path, String mimeType, InputStream inputStream);/** * 合并文件 * * @param folder 分片目录路径 * @param filepath 合并文件路径 * @param chunkSize 分片数量 */public void mergeFile(String folder, String filepath, int chunkSize) throws Exception;/** * 获取文件信息 * * @param bucket 桶 * @param filepath 文件路径 * @return 文件信息 */public ObjectStat getObjectStat(String bucket, String filepath);/** * 清理分块文件 * * @param chunkFolder 分块目录 * @param chunkTotal 分块数量 */void clearChunkFiles(String chunkFolder, int chunkTotal); 实现该方法 MinIOFileStorageServiceprivate final MinioClient minioClient;private final MinIOConfigProperties minIOConfigProperties;private final static String separator = &quot;/&quot;;public MinIOFileStorageService(MinioClient minioClient, MinIOConfigProperties minIOConfigProperties) &#123; this.minioClient = minioClient; this.minIOConfigProperties = minIOConfigProperties;&#125;/** * 上传视频分块文件 * * @param path 文件名 * @param inputStream 文件流 * @return 文件全路径 */@Overridepublic String uploadChunkFile(String path, String mimeType, InputStream inputStream) &#123; try &#123; PutObjectArgs putObjectArgs = PutObjectArgs.builder() .object(path) .bucket(minIOConfigProperties.getBucket().get(&quot;video&quot;)) .stream(inputStream, inputStream.available(), -1) .contentType(mimeType) .build(); minioClient.putObject(putObjectArgs); return path; &#125; catch (Exception ex) &#123; log.error(&quot;minio put file error.&quot;, ex); throw new RuntimeException(&quot;上传文件失败&quot;); &#125;&#125;/** * 合并文件 * * @param folder 分片目录路径 * @param filepath 合并文件路径 * @param chunkSize 分片数量 * @return bucket */@Overridepublic void mergeFile(String folder, String filepath, int chunkSize) throws Exception &#123; try &#123; String bucket = minIOConfigProperties.getBucket().get(&quot;video&quot;); // 源文件 List&lt;ComposeSource&gt; sources = Stream.iterate(0, i -&gt; ++i).limit(chunkSize) .map(i -&gt; ComposeSource.builder().bucket(bucket).object(folder + i).build()).collect(Collectors.toList()); // 合并 ComposeObjectArgs composeObjectArgs = ComposeObjectArgs.builder() .object(filepath) .bucket(bucket) .sources(sources) .build(); minioClient.composeObject(composeObjectArgs); &#125; catch (Exception ex) &#123; log.error(&quot;minio compose file error.&quot;, ex); throw new Exception(&quot;合并文件失败&quot;); &#125;&#125;/** * 获取文件信息 * * @param bucket 桶 * @param filepath 文件路径 * @return 文件信息 */@Overridepublic ObjectStat getObjectStat(String bucket, String filepath) &#123; try &#123; return minioClient.statObject( StatObjectArgs.builder().bucket(&quot;video&quot;).object(filepath).build()); &#125; catch (Exception e) &#123; log.error(&quot;文件信息获取失败, 桶: &#123;&#125;, 文件路径: &#123;&#125;&quot;, bucket, filepath, e); return null; &#125;&#125;/** * 清理分块文件 * * @param chunkFolder 分块目录 * @param chunkTotal 分块数量 */@Override@Asyncpublic void clearChunkFiles(String chunkFolder, int chunkTotal) &#123; // 构建清理item List&lt;DeleteObject&gt; objects = Stream.iterate(0, i -&gt; ++i).limit(chunkTotal) .map(i -&gt; new DeleteObject(chunkFolder.concat(Integer.toString(i)))).collect(Collectors.toList()); RemoveObjectsArgs removeObjectsArgs = RemoveObjectsArgs.builder() .bucket(minIOConfigProperties.getBucket().get(&quot;video&quot;)) .objects(objects) .build(); // 清理文件 Iterable&lt;Result&lt;DeleteError&gt;&gt; results = minioClient.removeObjects(removeObjectsArgs); // 需要迭代返回的可迭代来执行删除。 for (Result&lt;DeleteError&gt; result : results) &#123; DeleteError error = null; try &#123; error = result.get(); log.info(&quot;Error in deleting object &#123;&#125;; &#123;&#125;&quot;, error.objectName(), error.message()); &#125; catch (Exception e) &#123; log.error(&quot;清理文件出错&quot;, e); &#125; &#125;&#125; 文件上传方法定义上述方法，找到com.swx.media.service包下的MediaFilesService接口，定义如下方法： MediaFilesService/** * 检查文件是否存在 * * @param fileMd5 文件md5值 * @return false不存在，true存在 */Boolean checkFile(String fileMd5);/** * 检查文件分块是否存在 * * @param fileMd5 文件md5 * @param chunk 分块序号 * @return false不存在，true存在 */Boolean checkChunk(String fileMd5, int chunk);/** * 上传分块 * * @param file 文件信息 * @param fileMd5 文件md5 * @param chunk 分块序号 */Boolean uploadChunk(MultipartFile file, String fileMd5, int chunk);/** * 合并分块 * * @param companyId 机构ID * @param fileMd5 文件md5 * @param chunkTotal 分块数量 * @param dto 文件信息 */R mergeChunks(Long companyId, String fileMd5, int chunkTotal, UploadFileParamDTO dto); 实现该方法 MediaFilesServiceImplprivate final FileStorageService fileStorageService;private final TransactionTemplate transactionTemplate;private final MinIOConfigProperties minIOConfigProperties;public MediaFilesServiceImpl(FileStorageService fileStorageService, TransactionTemplate transactionTemplate, MinIOConfigProperties minIOConfigProperties) &#123; this.fileStorageService = fileStorageService; this.transactionTemplate = transactionTemplate; this.minIOConfigProperties = minIOConfigProperties;&#125;/** * 检查文件是否存在 * * @param fileMd5 文件md5值 * @return false不存在，true存在 */@Overridepublic Boolean checkFile(String fileMd5) &#123; MediaFiles dbMediaFile = getById(fileMd5); if (dbMediaFile != null) &#123; // 文件存在数据库，查询MinIO ObjectStat objectStat = fileStorageService.getObjectStat(dbMediaFile.getBucket(), dbMediaFile.getFilePath()); return objectStat != null; &#125; return false;&#125;/** * 检查文件分块是否存在 * * @param fileMd5 文件md5 * @param chunk 分块序号 * @return false不存在，true存在 */@Overridepublic Boolean checkChunk(String fileMd5, int chunk) &#123; // 分块存储路径：md5前两位为两个目录，chunk存储分块文件 String path = getChunkFileFolderPath(fileMd5) + chunk; String bucket = minIOConfigProperties.getBucket().get(&quot;video&quot;); ObjectStat objectStat = fileStorageService.getObjectStat(bucket, path); return objectStat != null;&#125;/** * 上传分块 * * @param file 文件信息 * @param fileMd5 文件md5 * @param chunk 分块序号 */@Overridepublic Boolean uploadChunk(MultipartFile file, String fileMd5, int chunk) &#123; try &#123; String mineType = getMineType(null); String chunkFilePath = getChunkFileFolderPath(fileMd5) + chunk; fileStorageService.uploadChunkFile(chunkFilePath, mineType, file.getInputStream()); return true; &#125; catch (IOException e) &#123; log.error(&quot;分块文件上传失败，文件ID：&#123;&#125;，分块序号: &#123;&#125;&quot;, fileMd5, chunk, e); return false; &#125;&#125;/** * 合并分块 * * @param companyId 机构ID * @param fileMd5 文件md5 * @param chunkTotal 分块数量 * @param dto 文件信息 */@Overridepublic R mergeChunks(Long companyId, String fileMd5, int chunkTotal, UploadFileParamDTO dto) &#123; // 找到分块文件调用minio的sdk进行文件合并 String chunkFileFolderPath = getChunkFileFolderPath(fileMd5); String suffix = dto.getFilename().substring(dto.getFilename().lastIndexOf(&quot;.&quot;)); String filepath = getFilePathByMd5(fileMd5, suffix); String bucket = minIOConfigProperties.getBucket().get(&quot;video&quot;); try &#123; // 请求合并操作 fileStorageService.mergeFile(chunkFileFolderPath, filepath, chunkTotal); &#125; catch (Exception e) &#123; log.error(&quot;文件合并失败，文件名: &#123;&#125;&quot;, filepath, e); return R.fail(false, &quot;文件合并失败&quot;); &#125; // 获取分片文件 ObjectStat objectStat = fileStorageService.getObjectStat(bucket, filepath); if (objectStat == null) &#123; return R.fail(false, &quot;合并文件获取失败&quot;); &#125; // 设置文件大小 dto.setFileSize(objectStat.length()); // 将文件信息入库 // 保存到数据库，使用编程式事务 MediaFiles mediaFiles = transactionTemplate.execute(transactionStatus -&gt; &#123; return saveAfterStore(dto, companyId, fileMd5, bucket, filepath); &#125;); if (mediaFiles == null) &#123; return R.fail(false, &quot;文件保存失败&quot;); &#125; // 删除分块文件 fileStorageService.clearChunkFiles(chunkFileFolderPath, chunkTotal); return R.success(true);&#125;private String getMineType(String suffix) &#123; if (suffix == null) suffix = &quot;&quot;; ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(suffix); String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE; if (extensionMatch != null) &#123; mimeType = extensionMatch.getMimeType(); &#125; return mimeType;&#125;/** * 获得文件Md5值 * * @param inputStream 文件 * @return Md5值 */private String getFileMd5(InputStream inputStream) &#123; try &#123; return DigestUtils.md5DigestAsHex(inputStream); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125;/** * 得到合并后文件的路径 * * @param fileMd5 源文件Md5 * @param suffix 文件后缀 * @return 分块存储路径 */private String getFilePathByMd5(String fileMd5, String suffix) &#123; return fileMd5.charAt(0) + &quot;/&quot; + fileMd5.charAt(1) + &quot;/&quot; + fileMd5 + &quot;/&quot; + fileMd5 + suffix;&#125;/** * 分块存储路径：md5前两位为两个目录，chunk存储分块文件 * * @param fileMd5 源文件Md5 * @return 分块存储路径 */private String getChunkFileFolderPath(String fileMd5) &#123; return fileMd5.charAt(0) + &quot;/&quot; + fileMd5.charAt(1) + &quot;/&quot; + fileMd5 + &quot;/chunk/&quot;;&#125; 定义ControllerMediaFilesUploadControllerprivate final MediaFilesService mediaFilesService;public MediaFilesUploadController(MediaFilesService mediaFilesService) &#123; this.mediaFilesService = mediaFilesService;&#125;@ApiOperation(&quot;文件上传前的检查文件&quot;)@PostMapping(&quot;/checkfile&quot;)public Boolean checkFile(@RequestParam(&quot;fileMd5&quot;) String fileMd5) &#123; return mediaFilesService.checkFile(fileMd5);&#125;@ApiOperation(&quot;分块文件上传前的检查文件&quot;)@PostMapping(&quot;/checkchunk&quot;)public Boolean checkChunk(@RequestParam(&quot;fileMd5&quot;) String fileMd5, @RequestParam(&quot;chunk&quot;) int chunk) &#123; return mediaFilesService.checkChunk(fileMd5, chunk);&#125;@ApiOperation(&quot;上传分块文件&quot;)@PostMapping(&quot;/uploadchunk&quot;)public Boolean uploadChunk(@RequestParam(&quot;file&quot;) MultipartFile file, @RequestParam(&quot;fileMd5&quot;) String fileMd5, @RequestParam(&quot;chunk&quot;) int chunk) &#123; return mediaFilesService.uploadChunk(file, fileMd5, chunk);&#125;@ApiOperation(&quot;合并文件&quot;)@PostMapping(&quot;/mergechunks&quot;)public R mergeChunks(@RequestParam(&quot;fileName&quot;) String fileName, @RequestParam(&quot;fileMd5&quot;) String fileMd5, @RequestParam(&quot;chunkTotal&quot;) int chunkTotal) &#123; Long companyId = 1232141425L; UploadFileParamDTO dto = new UploadFileParamDTO(); dto.setFilename(fileName); dto.setFileType(&quot;001002&quot;); dto.setTags(&quot;视频文件&quot;); return mediaFilesService.mergeChunks(companyId, fileMd5, chunkTotal, dto);&#125; Push到Gitcommit &quot;完成视频上传功能&quot;"},{"title":"初始化工程","path":"/wiki/learning-online/09-checkcode/init.html","content":"创建learning-online-checkcode工程，目录结构如下 learning-online-media├── src/main/java│ ├── com.swx.checkcode│ │ ├── config│ │ ├── controller│ │ ├── model│ │ ├── service│ │ └── CheckCodeApplication.java│ └──resource└── pom.xml 在pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Boot 的 Spring Web MVC 集成 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 排除 Spring Boot 依赖的日志包冲突 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Boot 集成 log4j2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类，在com.swx.checkcode包下创建启动类CheckCodeApplication，内容如下： CheckCodeApplication@SpringBootApplicationpublic class CheckCodeApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CheckCodeApplication.class, args); &#125;&#125; 项目配置信息，在resources下创建bootstrap.yml bootstrap.ymlspring: application: name: checkcode cloud: nacos: discovery: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project config: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project file-extension: yaml refresh-enabled: true shared-configs: - data-id: logging-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true - data-id: redis-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true profiles: active: dev 日志配置，在resources下创建log4j2-dev.xml log4j2-dev.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration monitorInterval=&quot;180&quot; packages=&quot;&quot;&gt; &lt;properties&gt; &lt;property name=&quot;logdir&quot;&gt;logs&lt;/property&gt; &lt;property name=&quot;PATTERN&quot;&gt;%date&#123;YYYY-MM-dd HH:mm:ss,SSS&#125; %level [%thread][%file:%line] - %msg%n%throwable&lt;/property&gt; &lt;/properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;ErrorAppender&quot; fileName=&quot;$&#123;logdir&#125;/error.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/error.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;DebugAppender&quot; fileName=&quot;$&#123;logdir&#125;/info.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/info.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;!--异步appender--&gt; &lt;Async name=&quot;AsyncAppender&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;ErrorAppender&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Async&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的debug信息 &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt;--&gt; &lt;logger name=&quot;cn.itcast.wanxinp2p.consumer.mapper&quot; level=&quot;DEBUG&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;springfox&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;com.netflix.discovery&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqCommon&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqRemoting&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqClient&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.lottery&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.bonuspoint&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;!--OFF 0--&gt; &lt;!--FATAL 100--&gt; &lt;!--ERROR 200--&gt; &lt;!--WARN 300--&gt; &lt;!--INFO 400--&gt; &lt;!--DEBUG 500--&gt; &lt;!--TRACE 600--&gt; &lt;!--ALL Integer.MAX_VALUE--&gt; &lt;Root level=&quot;DEBUG&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;AsyncAppender&quot;/&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt;"},{"title":"Nacos配置","path":"/wiki/learning-online/09-checkcode/nacos.html","content":"打开Nacos管理界面，添加新的配置文件：http://ip:8848/nacos 命名空间选择learning-online-dev 创建验证码工程配置：checkcode-dev.yaml ID：checkcode-dev.yaml Group：learning-online-project 描述：验证码微服务 配置内容： server: servlet: context-path: /checkcode port: 63075 创建系统管理工程配置：redis-dev.yaml ID：redis-dev.yaml Group：learning-online-common 描述：验证码微服务 配置内容： spring: redis: host: 124.221.23.47 password: redis port: 6379 database: 0 lettuce: pool: max-active: 20 max-idle: 10 min-idle: 0 timeout: 10000"},{"title":"工程代码","path":"/wiki/learning-online/09-checkcode/project.html","content":"接口信息生成验证码图片 值 路径地址 http://localhost:63075/checkcode/pic 请求方式 POST 请求参数 CheckCodeParamsDTO 返回结果 CheckCodeResultVO 校验验证码图片 值 路径地址 http://localhost:63075/checkcode/verify 请求方式 POST 请求参数 String key, String code 返回结果 Boolean 配置图片生成使用开源的图片生成工具 Kaptcha，并进行自定义的配置 /** * 图片验证码配置类 **/@Configurationpublic class KaptchaConfig &#123; //图片验证码生成器，使用开源的kaptcha @Bean public DefaultKaptcha producer() &#123; Properties properties = new Properties(); properties.put(&quot;kaptcha.border&quot;, &quot;no&quot;); properties.put(&quot;kaptcha.textproducer.font.color&quot;, &quot;black&quot;); properties.put(&quot;kaptcha.textproducer.char.space&quot;, &quot;10&quot;); properties.put(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;); properties.put(&quot;kaptcha.image.height&quot;, &quot;34&quot;); properties.put(&quot;kaptcha.image.width&quot;, &quot;138&quot;); properties.put(&quot;kaptcha.textproducer.font.size&quot;, &quot;25&quot;); properties.put(&quot;kaptcha.noise.impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;); Config config = new Config(properties); DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); defaultKaptcha.setConfig(config); return defaultKaptcha; &#125;&#125; Model实体类在com.swx.checkcode.model包下创建下面两个实体类： 验证码参数类 CheckCodeParamsDTO/** * 验证码生成参数类 */@Datapublic class CheckCodeParamsDTO &#123; /** * 验证码类型:pic、sms、email等 */ private String checkCodeType; /** * 业务携带参数 */ private String param1; private String param2; private String param3;&#125; 验证码结果类 CheckCodeResultVO/** * 验证码结果类 */@Datapublic class CheckCodeResultVO &#123; /** * key用于验证 */ private String key; /** * 混淆后的内容 * 举例： * 1.图片验证码为:图片base64编码 * 2.短信验证码为:null * 3.邮件验证码为: null * 4.邮件链接点击验证为：null * ... */ private String aliasing;&#125; Service方法接口定义在com.swx.checkcode.service包下创建下面接口： /** * 验证码接口 */public interface CheckCodeService &#123; /** * 生成验证码 * * @param dto 生成验证码参数 * @return com.swx.checkcode.model.CheckCodeResultDTO 验证码结果 */ CheckCodeResultVO generate(CheckCodeParamsDTO dto); /** * 校验验证码 * * @param key key * @param code 验证码 * @return boolean 验证结果 */ public boolean verify(String key, String code); /** * 验证码生成器 */ public interface CheckCodeGenerator &#123; /** * 验证码生成 * * @param length 验证码长度 * @return String 验证码 */ String generate(int length); &#125; /** * Key生成器 */ public interface KeyGenerator &#123; /** * key生成 * * @param prefix key前缀 * @return String key */ String generate(String prefix); &#125; /** * 验证码存储 */ public interface CheckCodeStore &#123; /** * 向缓存设置key * * @param key key * @param value value * @param expire 过期时间,单位秒 */ void set(String key, String value, Integer expire); String get(String key); void remove(String key); &#125;&#125; 使用抽象类实现该接口，提供基础功能 AbstractCheckCodeService/** * 验证码接口 */@Slf4jpublic abstract class AbstractCheckCodeService implements CheckCodeService &#123; protected CheckCodeGenerator checkCodeGenerator; protected KeyGenerator keyGenerator; protected CheckCodeStore checkCodeStore; public abstract void setCheckCodeGenerator(CheckCodeGenerator checkCodeGenerator); public abstract void setKeyGenerator(KeyGenerator keyGenerator); public abstract void setCheckCodeStore(CheckCodeStore CheckCodeStore); /** * 生成验证公用方法 * * @param dto 生成验证码参数 * @param codeLength 验证码长度 * @param keyPrefix key的前缀 * @param expire 过期时间 * @return com.swx.checkcode.service.AbstractCheckCodeService.GenerateResult 生成结果 */ public GenerateResult generate(CheckCodeParamsDTO dto, Integer codeLength, String keyPrefix, Integer expire) &#123; // 生成四位验证码 String code = checkCodeGenerator.generate(codeLength); // 生成一个key String key = keyGenerator.generate(keyPrefix); // 存储验证码 checkCodeStore.set(key, code, expire); // 返回验证码生成结果 return new GenerateResult(key, code); &#125; /** * 验证方法 * * @param key key * @param code 验证码 * @return boolean 验证结果 */ public boolean verify(String key, String code) &#123; if (StringUtils.isBlank(key) || StringUtils.isBlank(code)) &#123; return false; &#125; String code_l = checkCodeStore.get(key); if (code_l == null) &#123; return false; &#125; boolean result = code_l.equalsIgnoreCase(code); if (result) &#123; //删除验证码 checkCodeStore.remove(key); &#125; return result; &#125; @Data protected static class GenerateResult &#123; String key; String code; GenerateResult() &#123; &#125; GenerateResult(String key, String code) &#123; this.key = key; this.code = code; &#125; &#125; public abstract CheckCodeResultVO generate(CheckCodeParamsDTO checkCodeParamsDto);&#125; 实现缓存接口使用策略模式，实现不同的缓存方案。 内存缓存将验证码数据存放在内存中 MemoryCheckCodeStore@Component(&quot;MemoryCheckCodeStore&quot;)public class MemoryCheckCodeStore implements CheckCodeService.CheckCodeStore &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); /** * 向缓存设置key * * @param key key * @param value value * @param expire 过期时间,单位秒 */ @Override public void set(String key, String value, Integer expire) &#123; map.put(key, value); &#125; /** * @param key 值 * @return 键 */ @Override public String get(String key) &#123; return map.get(key); &#125; /** * @param key 值 */ @Override public void remove(String key) &#123; map.remove(key); &#125;&#125; Redis缓存使用redis存储验证码，可以设置过期时间 RedisCheckCodeStore/** * 使用redis存储验证码 */@Component(&quot;RedisCheckCodeStore&quot;)public class RedisCheckCodeStore implements CheckCodeService.CheckCodeStore &#123; private final StringRedisTemplate redisTemplate; public RedisCheckCodeStore(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * 向缓存设置key * * @param key key * @param value value * @param expire 过期时间,单位秒 */ @Override public void set(String key, String value, Integer expire) &#123; redisTemplate.opsForValue().set(key, value, expire, TimeUnit.SECONDS); &#125; /** * @param key 键 * @return 值 */ @Override public String get(String key) &#123; return redisTemplate.opsForValue().get(key); &#125; /** * @param key 键 */ @Override public void remove(String key) &#123; redisTemplate.delete(key); &#125;&#125; 实现生成验证码实现 CheckCodeService.CheckCodeGenerator 接口 NumberLetterCheckCodeGenerator/** * 数字字母生成器 */@Component(&quot;NumberLetterCheckCodeGenerator&quot;)public class NumberLetterCheckCodeGenerator implements CheckCodeService.CheckCodeGenerator &#123; @Override public String generate(int length) &#123; String str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; Random random = new Random(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; length; i++) &#123; int number = random.nextInt(36); sb.append(str.charAt(number)); &#125; return sb.toString(); &#125;&#125; 实现生成Key接口实现 CheckCodeService.KeyGenerator 接口 UUIDKeyGenerator/** * uuid生成器 */@Component(&quot;UUIDKeyGenerator&quot;)public class UUIDKeyGenerator implements CheckCodeService.KeyGenerator &#123; @Override public String generate(String prefix) &#123; String uuid = UUID.randomUUID().toString(); return prefix + uuid.replaceAll(&quot;-&quot;, &quot;&quot;); &#125;&#125; 实现图片验证码继承 AbstractCheckCodeService 抽象类，实现 CheckCodeService 接口。注入指定的实现类，实现生成图片验证码的同时，将生成的key和code缓存至Redis。 PicCheckCodeServiceImpl/** * 图片验证码生成器 */@Slf4j@Service(&quot;PicCheckCodeService&quot;)public class PicCheckCodeServiceImpl extends AbstractCheckCodeService implements CheckCodeService &#123; private final DefaultKaptcha kaptcha; public PicCheckCodeServiceImpl(DefaultKaptcha kaptcha) &#123; this.kaptcha = kaptcha; &#125; @Resource(name=&quot;NumberLetterCheckCodeGenerator&quot;) @Override public void setCheckCodeGenerator(CheckCodeGenerator checkCodeGenerator) &#123; this.checkCodeGenerator = checkCodeGenerator; &#125; @Resource(name=&quot;UUIDKeyGenerator&quot;) @Override public void setKeyGenerator(KeyGenerator keyGenerator) &#123; this.keyGenerator = keyGenerator; &#125; @Resource(name=&quot;RedisCheckCodeStore&quot;) @Override public void setCheckCodeStore(CheckCodeStore checkCodeStore) &#123; this.checkCodeStore = checkCodeStore; &#125; /** * 生成验证码 * * @param dto 生成验证码参数 * @return com.swx.checkcode.model.CheckCodeResultDTO 验证码结果 */ @Override public CheckCodeResultVO generate(CheckCodeParamsDTO dto) &#123; GenerateResult generate = generate(dto, 4, &quot;checkcode:&quot;, 60); String key = generate.getKey(); String code = generate.getCode(); String pic = createPic(code); CheckCodeResultVO resultDTO = new CheckCodeResultVO(); resultDTO.setAliasing(pic); resultDTO.setKey(key); return resultDTO; &#125; private String createPic(String code) &#123; // 生成图片验证码 ByteArrayOutputStream outputStream = null; BufferedImage image = kaptcha.createImage(code); outputStream = new ByteArrayOutputStream(); String imgBase64Encoder = null; try &#123; // 对字节数组Base64编码 ImageIO.write(image, &quot;png&quot;, outputStream); imgBase64Encoder = &quot;data:image/png;base64,&quot; + Base64Utils.encodeToString(outputStream.toByteArray()); &#125; catch (IOException e) &#123; log.error(&quot;图片验证码生成错误&quot;, e); &#125; finally &#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; log.error(&quot;流关闭失败&quot;, e); &#125; &#125; return imgBase64Encoder; &#125;&#125; Controller服务主要提供验证码获取和验证功能，其中验证功能将由认证授权微服务远程调用，进行登陆时验证码的验证。 CheckCodeController@Api(value = &quot;验证码服务接口&quot;, tags = &quot;验证码服务接口&quot;)@RestControllerpublic class CheckCodeController &#123; private final CheckCodeService picCheckCodeService; public CheckCodeController(CheckCodeService picCheckCodeService) &#123; this.picCheckCodeService = picCheckCodeService; &#125; @ApiOperation(value=&quot;生成验证信息&quot;, notes=&quot;生成验证信息&quot;) @PostMapping(value = &quot;/pic&quot;) public CheckCodeResultVO generatePicCheckCode(CheckCodeParamsDTO dto)&#123; return picCheckCodeService.generate(dto); &#125; @ApiOperation(value=&quot;校验&quot;, notes=&quot;校验&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;name&quot;, value = &quot;业务名称&quot;, required = true, dataType = &quot;String&quot;, paramType=&quot;query&quot;), @ApiImplicitParam(name = &quot;key&quot;, value = &quot;验证key&quot;, required = true, dataType = &quot;String&quot;, paramType=&quot;query&quot;), @ApiImplicitParam(name = &quot;code&quot;, value = &quot;验证码&quot;, required = true, dataType = &quot;String&quot;, paramType=&quot;query&quot;) &#125;) @PostMapping(value = &quot;/verify&quot;) public Boolean verify(String key, String code)&#123; return picCheckCodeService.verify(key, code); &#125;&#125;"},{"title":"微服务授权","path":"/wiki/learning-online/10-auth/authorize.html","content":"身份的认证服务我们在网关中配置了，授权应该放在各个微服务，为此我们需要在微服务中添加依赖并配置Spring Security。 如何实现授权？业界通常基于RBAC实现授权。 什么是RBACRBAC分为两种方式： 基于角色的访问控制（Role-Based Access Control） 基于资源的访问控制（Resource-Based Access Control） 其中基于角色控制访问的逻辑如下： if (主体.hasRole(&quot;总经理角色&quot;)) &#123; 查询工资&#125; 如果能够查询工资的角色变为总经理和部门经理，此时需要修改逻辑为如下： if (主体.hasRole(&quot;总经理角色&quot;) || 主体.hasRole(&quot;部门经理角色&quot;)) &#123; 查询工资&#125; 当需求变动时，代码也需要修改，扩展性较差。 其中基于资源控制访问的逻辑如下： if (主体.hasPermission(&quot;查询工资权限&quot;)) &#123; 查询工资&#125; 我们只需要将该权限赋值给需要的角色即可，业务变动时，只需要授予角色相应权限即可。 数据模型设计查询权限信息使用下面SQL语句可以查询登陆用户的权限信息： SELECT code FROM xc_menu WHERE id IN( SELECT menu_id FROM xc_permission WHERE role_id IN( SELECT role_id FROM xc_user_role WHERE user_id = &#x27;52&#x27; )) 找到 XcMenuMapper，定义查询权限列表的方法： public interface XcMenuMapper extends BaseMapper&lt;XcMenu&gt; &#123; @Select(&quot;SELECT code FROM xc_menu WHERE id IN(SELECT menu_id FROM xc_permission WHERE role_id IN(SELECT role_id FROM xc_user_role WHERE user_id = #&#123;userId&#125;))&quot;) List&lt;String&gt; selectPermissionCodeByUserId(@Param(&quot;userId&quot;) String userId);&#125; 同样在 XcMenuService 中定义查询方法 public interface XcMenuService extends IService&lt;XcMenu&gt; &#123; /** * 根据用户ID查询用户权限列表 * * @param userId 用户ID * @return List&lt;com.swx.ucenter.model.po.XcMenu&gt; 权限列表 */ List&lt;String&gt; selectPermissionCodeByUserId(String userId);&#125; 在 XcMenuServiceImpl 中实现查询方法 XcMenuServiceImpl@Servicepublic class XcMenuServiceImpl extends ServiceImpl&lt;XcMenuMapper, XcMenu&gt; implements XcMenuService &#123; /** * 根据用户ID查询用户权限列表 * * @param userId 用户ID * @return List&lt;com.swx.ucenter.model.po.XcMenu&gt; 权限列表 */ @Override public List&lt;String&gt; selectPermissionCodeByUserId(String userId) &#123; return baseMapper.selectPermissionCodeByUserId(userId); &#125;&#125; 修改 UserDetailsServiceImpl，增加查询列表的方法 XcMenuServiceImpl/** * 查询用户信息 * @param xcUserExt 用户信息 * @return UserDetails */private UserDetails getUserPrincipal(XcUserExt xcUserExt) &#123; String password = xcUserExt.getPassword(); // 根据用户ID查询权限信息 String[] authorities = &#123;&#125;; List&lt;String&gt; permissions = xcMenuService.selectPermissionCodeByUserId(xcUserExt.getId()); if (!CollectionUtils.isEmpty(permissions)) &#123; // 转数组 authorities = permissions.toArray(new String[0]); &#125; // 转JSON xcUserExt.setPassword(null); String userJson = JSON.toJSONString(xcUserExt); // 封装 UserDetails 对象 return User.withUsername(userJson) .password(password) .authorities(authorities).build();&#125; 集成Spring Security首先添加Spring Security的依赖信息 pom.xml&lt;!-- Spring Security --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt; 接着在config包下创建两个配置文件： 令牌配置，这里需要和learning-onlie-auth认证工程的令牌配置保持一致： TokenConfig@Configurationpublic class TokenConfig &#123; private final static String SIGNING_KEY = &quot;sw-code&quot;; @Bean public TokenStore tokenStore() &#123; return new JwtTokenStore(accessTokenConverter()); &#125; @Bean public JwtAccessTokenConverter accessTokenConverter() &#123; JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(SIGNING_KEY); return converter; &#125; // 令牌管理服务 @Bean(name = &quot;authorizationServerTokenServicesCustom&quot;) public AuthorizationServerTokenServices tokenServices() &#123; DefaultTokenServices services = new DefaultTokenServices(); services.setSupportRefreshToken(true); // 支持刷新令牌 services.setTokenStore(tokenStore()); // 令牌存储策略 TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); tokenEnhancerChain.setTokenEnhancers(Collections.singletonList(accessTokenConverter())); services.setTokenEnhancer(tokenEnhancerChain); services.setAccessTokenValiditySeconds(7200); //令牌默认有效期2小时 services.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期2天 return services; &#125;&#125; 资源过滤配置 认证已经在网关配置，这里直接放行所有接口，即不用进行认证。 ResourceServerConfig@Configuration@EnableResourceServer@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)public class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; // 资源服务标识 public static final String RESOURCE_ID = &quot;learning-online&quot;; private final TokenStore tokenStore; public ResourceServerConfig(TokenStore tokenStore) &#123; this.tokenStore = tokenStore; &#125; @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123; resources.resourceId(RESOURCE_ID) .tokenStore(tokenStore) .stateless(true); &#125; @Override public void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable() .authorizeRequests() .anyRequest().permitAll(); &#125;&#125; 资源服务授权在 learning-online-content-api工程中集成Spring Security后，只需要在Controller的接口上添加如下注解，即可实现权限验证： @ApiOperation(&quot;课程查询接口&quot;)@PreAuthorize(&quot;hasAuthority(&#x27;xc_teachmanager_course_list&#x27;)&quot;) // 指定权限标识符@PostMapping(&quot;/list&quot;)public PageResult&lt;CourseBase&gt; list(PageParam pageParam, @RequestBody(required = false) QueryCourseParamsDTO dto) &#123; return courseBaseService.queryCourseBaseList(pageParam, dto);&#125; 细粒度控制在查询所有课程时，我们希望当前机构的用户只能查看本机构的课程数据，这个时候需要自己来控制细粒度的过滤，在查询时从 SecurityContextHolder 上下文中拿到用户信息中的机构信息查询即可。 为了方便从 SecurityContextHolder 上下文中拿到用户信息，定义工具类 SecurityUtil/** * 获取当前用户身份工具类 */@Slf4jpublic class SecurityUtil &#123; public static XcUser getUser() &#123; try &#123; Object principalObj = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); if (principalObj instanceof String) &#123; // 取出用户身份信息 String principal = principalObj.toString(); return JSON.parseObject(principal, XcUser.class); &#125; throw new RuntimeException(); &#125; catch (Exception e) &#123; log.error(&quot;获取当前登陆用户身份出错&quot;, e); throw new BizException(&quot;获取当前登陆用户身份出错&quot;); &#125; &#125; @Data public static class XcUser implements Serializable &#123; private static final long serialVersionUID = 1L; private String id; private String username; private String salt; private String wxUnionid; private String nickname; private String name; private String userpic; private String companyId; private String utype; private LocalDateTime birthday; private String sex; private String email; private String cellphone; private String qq; private String status; private LocalDateTime createTime; private LocalDateTime updateTime; &#125;&#125; 改造查询接口 @ApiOperation(&quot;课程查询接口&quot;)@PreAuthorize(&quot;hasAuthority(&#x27;xc_teachmanager_course_list&#x27;)&quot;) // 指定权限标识符@PostMapping(&quot;/list&quot;)public PageResult&lt;CourseBase&gt; list(PageParam pageParam, @RequestBody(required = false) QueryCourseParamsDTO dto) &#123; SecurityUtil.XcUser user = SecurityUtil.getUser(); Long companyId = null; if (StringUtils.hasText(user.getCompanyId())) &#123; companyId = Long.parseLong(user.getCompanyId()); &#125; return courseBaseService.queryCourseBaseList(companyId, pageParam, dto);&#125; 相应的，在查询时增加机构条件 /** * 课程分页查询 * * @param companyId 培训结构ID * @param pageParam 分页参数 * @param dto 查询参数 */@Overridepublic PageResult&lt;CourseBase&gt; queryCourseBaseList(Long companyId, PageParam pageParam, QueryCourseParamsDTO dto) &#123; LambdaQueryWrapper&lt;CourseBase&gt; wrapper = Wrappers.&lt;CourseBase&gt;lambdaQuery() .like(StringUtils.hasText(dto.getCourseName()), CourseBase::getName, dto.getCourseName()) .eq(StringUtils.hasText(dto.getAuditStatus()), CourseBase::getAuditStatus, dto.getAuditStatus()) .eq(StringUtils.hasText(dto.getPublishStatus()), CourseBase::getStatus, dto.getPublishStatus()) .eq(companyId != null, CourseBase::getCompanyId, companyId); Page&lt;CourseBase&gt; page = new Page&lt;&gt;(pageParam.getPageNo(), pageParam.getPageSize()); Page&lt;CourseBase&gt; pageResult = page(page, wrapper); return new PageResult&lt;&gt;(pageResult.getRecords(), pageResult.getTotal(), pageParam);&#125;"},{"title":"业务流程","path":"/wiki/learning-online/10-auth/bizpro.html","content":"统一认证项目包括学生、学习机构的老师、平台运营人员三类用户，三类用户将使用统一的认证入口，只需要认证一次，即可访问所有的服务。流程如下图： 单点登录本项目基于微服务架构构建，微服务包括：内容管理服务、媒资管理服务、学习中心服务、系统管理服务等，为了提高用户体验性，用户只需要认证一次便可以在多个拥有访问权限的系统中访问，这个功能叫做单点登录 引用百度百科：单点登录(SingleSignOn），简称为SSO，是目前比较流行的企业业务整合的解決方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 第三方认证为了提高用户体验，很多网站有扫码登录的功能，如：微信扫码登录、QQ扫码登录等。扫码登录的好处是用户不 用输入账号和密码，操作简便，另外一个好处就是有利于用户信息的共享，互联网的优势就是资源共享，用户也是 一种资源，对于一个新网站如果让用户去注册是很困难的，如果提供了微信扫码登录将省去用户注册的成本，是一种非常有效的推广手段。 微信扫码登录其中的原理正是使用了第三方认证，如下图："},{"title":"网关认证","path":"/wiki/learning-online/10-auth/gatewayauth.html","content":"所有访问微服务的请求都要经过网关，在网关进行用户身份的认证可以将很多非法的请求拦截到微服务以外，这叫做网关认证。 下边需要明确网关的职责：1、网站白名单维护，针对不用认证的URL全部放行。2、校验JWT的合法性。 除了白名单剩下的就是需要认证的请求，网关需要验证JWT的合法性，JWT合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问。 网关负责授权吗？网关不负责授权，对请求的授权操作在各个微服务进行，因为微服务最清楚用户有哪些权限访问哪些接口。 新增依赖将 Spring Security 所需依赖添加到learning-online-gateway工程下的pom文件中 pom.xml&lt;!-- Spring Security --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt; &lt;artifactId&gt;fastjson2&lt;/artifactId&gt;&lt;/dependency&gt; 白名单在resource目录下新建白名单文件 security-whitelist.properties，内容如下 /auth/**=认证接口/content/open/**=内容管理服务公开访问接口/media/open/**=媒资管理服务公开访问接口/checkcode/**=验证码服务/learning/open/**=学习中心服务公开访问接口 配置文件Token的签发规则应该同认证服务保持一致，在config包下创建 TokenConfig TokenConfig@Configurationpublic class TokenConfig &#123; private final static String SIGNING_KEY = &quot;sw-code&quot;; @Bean public TokenStore tokenStore() &#123; return new JwtTokenStore(accessTokenConverter()); &#125; @Bean public JwtAccessTokenConverter accessTokenConverter() &#123; JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(SIGNING_KEY); return converter; &#125; // 令牌管理服务 @Bean(name = &quot;authorizationServerTokenServicesCustom&quot;) public AuthorizationServerTokenServices tokenServices() &#123; DefaultTokenServices services = new DefaultTokenServices(); services.setSupportRefreshToken(true); // 支持刷新令牌 services.setTokenStore(tokenStore()); // 令牌存储策略 TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); tokenEnhancerChain.setTokenEnhancers(Collections.singletonList(accessTokenConverter())); services.setTokenEnhancer(tokenEnhancerChain); services.setAccessTokenValiditySeconds(7200); //令牌默认有效期2小时 services.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期2天 return services; &#125;&#125; 安全配置类配置URL拦截规则 SecurityConfig/** * 安全配置类 */@EnableWebFluxSecurity@Configurationpublic class SecurityConfig &#123; @Bean public SecurityWebFilterChain webFluxSecurityFilterChain(ServerHttpSecurity http) &#123; return http.authorizeExchange() .pathMatchers(&quot;/**&quot;).permitAll() .anyExchange().authenticated() .and().csrf().disable().build(); &#125;&#125; 认证过滤器自定义网关认证过滤器，需要实现两个接口类：GlobalFilter、Ordered 错误实体类，返回给前端 ErrorResult/** * 返回结果实体类 */@Datapublic class ErrorResult implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer code; private String message; private Object data; public ErrorResult() &#123;&#125; // 返回失败 public static ErrorResult fail(Integer code, String message) &#123; ErrorResult result = new ErrorResult(); result.setCode(code); result.setMessage(message); return result; &#125;&#125; 在过滤器中，操作步骤如下： 使用配置的白名单过滤需要认证的URL； 取出Token，检查其有效性 有效，将携带JWT路由到各个微服务；无效则返回错误结果。 GatewayAuthFilter/** * 网关认证过滤器 */@Slf4j@Componentpublic class GatewayAuthFilter implements GlobalFilter, Ordered &#123; private static List&lt;String&gt; whitelist = null; private final TokenStore tokenStore; static &#123; // 加载白名单 try ( InputStream resourceAsStream = GatewayAuthFilter.class.getResourceAsStream(&quot;/security-whitelist.properties&quot;); ) &#123; Properties properties = new Properties(); properties.load(resourceAsStream); Set&lt;String&gt; strings = properties.stringPropertyNames(); whitelist = new ArrayList&lt;&gt;(strings); &#125; catch (Exception e) &#123; log.error(&quot;加载/security-whitelist.properties出错&quot;, e); &#125; &#125; public GatewayAuthFilter(TokenStore tokenStore) &#123; this.tokenStore = tokenStore; &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; String requestUrl = exchange.getRequest().getPath().value(); AntPathMatcher pathMatcher = new AntPathMatcher(); // 白名单放行 for (String url : whitelist) &#123; if (pathMatcher.match(url, requestUrl)) &#123; return chain.filter(exchange); &#125; &#125; // 检查Token是否存在 String token = getToken(exchange); if (StringUtils.isEmpty(token)) &#123; return buildReturnMono(&quot;没有认证&quot;, exchange); &#125; // 校验Token有效性 OAuth2AccessToken oAuth2AccessToken; try &#123; oAuth2AccessToken = tokenStore.readAccessToken(token); boolean expired = oAuth2AccessToken.isExpired(); if (expired) &#123; return buildReturnMono(&quot;认证令牌已过期&quot;, exchange); &#125; return chain.filter(exchange); &#125; catch (InvalidTokenException e) &#123; log.info(&quot;认证令牌无效: &#123;&#125;&quot;, token); return buildReturnMono(&quot;认证令牌无效&quot;, exchange); &#125; &#125; /** * 获取Token */ private String getToken(ServerWebExchange exchange) &#123; String tokenStr = exchange.getRequest().getHeaders().getFirst(&quot;Authorization&quot;); if (StringUtils.isEmpty(tokenStr)) &#123; return null; &#125; String token = tokenStr.split(&quot; &quot;)[1]; if (StringUtils.isEmpty(token)) &#123; return null; &#125; return token; &#125; /** * 构建错误返回结果 */ private Mono&lt;Void&gt; buildReturnMono(String error, ServerWebExchange exchange) &#123; ServerHttpResponse response = exchange.getResponse(); String jsonString = JSON.toJSONString(ErrorResult.fail(HttpStatus.UNAUTHORIZED.value(), error)); byte[] bytes = jsonString.getBytes(StandardCharsets.UTF_8); DataBuffer buffer = response.bufferFactory().wrap(bytes); response.setStatusCode(HttpStatus.UNAUTHORIZED); response.getHeaders().add(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); return response.writeWith(Mono.just(buffer)); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125;"},{"title":"初始化工程","path":"/wiki/learning-online/10-auth/init.html","content":"创建learning-online-auth工程，目录结构如下 learning-online-media├── src/main/java│ ├── com.swx│ │ ├── auth│ │ │ ├── config│ │ │ └── controller│ │ ├── ucenter│ │ │ ├── client│ │ │ ├── mapper│ │ │ ├── model│ │ │ └── service│ │ └── AuthApplication.java│ └──resource└── pom.xml 创建工程结构在pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Feign远程调用 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类，在com.swx包下创建启动类AuthApplication，内容如下： AuthApplication@SpringBootApplication@EnableTransactionManagement@EnableFeignClients(basePackages = &quot;com.swx.ucenter.client&quot;)public class AuthApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AuthApplication.class, args); &#125;&#125; 项目配置信息，在resources下创建bootstrap.yml bootstrap.ymlspring: application: name: auth-service cloud: nacos: discovery: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project config: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project file-extension: yaml refresh-enabled: true shared-configs: - data-id: logging-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true - data-id: feign-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true profiles: active: dev 日志配置，在resources下创建log4j2-dev.xml log4j2-dev.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration monitorInterval=&quot;180&quot; packages=&quot;&quot;&gt; &lt;properties&gt; &lt;property name=&quot;logdir&quot;&gt;logs&lt;/property&gt; &lt;property name=&quot;PATTERN&quot;&gt;%date&#123;YYYY-MM-dd HH:mm:ss,SSS&#125; %level [%thread][%file:%line] - %msg%n%throwable&lt;/property&gt; &lt;/properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;ErrorAppender&quot; fileName=&quot;$&#123;logdir&#125;/error.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/error.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;DebugAppender&quot; fileName=&quot;$&#123;logdir&#125;/info.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/info.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;!--异步appender--&gt; &lt;Async name=&quot;AsyncAppender&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;ErrorAppender&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Async&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的debug信息 &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt;--&gt; &lt;logger name=&quot;cn.itcast.wanxinp2p.consumer.mapper&quot; level=&quot;DEBUG&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;springfox&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;com.netflix.discovery&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqCommon&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqRemoting&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqClient&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.lottery&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.bonuspoint&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;!--OFF 0--&gt; &lt;!--FATAL 100--&gt; &lt;!--ERROR 200--&gt; &lt;!--WARN 300--&gt; &lt;!--INFO 400--&gt; &lt;!--DEBUG 500--&gt; &lt;!--TRACE 600--&gt; &lt;!--ALL Integer.MAX_VALUE--&gt; &lt;Root level=&quot;DEBUG&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;AsyncAppender&quot;/&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 添加基础代码实体类使用代码生成工具生成lo_user表的实体类，将其拷贝到learning-online-auth工程的com.swx.ucenter.model.po包下，暂时所需实体类如下： XcCompany.java XcCompanyUser.java XcMenu.java XcPermission.java XcRole.java XcTeacher.java XcUser.java XcUserRole.java Mapper层将代码生成的所有Mapper.java文件拷贝到learning-online-auth工程下的com.swx.ucenter.mapper包下。 将代码生成的所有Mapper.xml文件拷贝到learning-online-auth工程下的resources/mapper目录下。 Service层将代码生成的所有Service和ServiceImpl文件拷贝到learning-online-auth工程下的com.swx.ucenter.service包下。 Controller层在com.swx.auth.controller包下，新建登陆Controller，添加如下的基础代码 /** * 统一登陆认证接口 */@Api(value = &quot;统一登陆认证接口&quot;, tags = &quot;统一登陆认证接口&quot;)@RestControllerpublic class LoginController &#123; private final XcUserService xcUserService; public LoginController(XcUserService xcUserService) &#123; this.xcUserService = xcUserService; &#125; @RequestMapping(&quot;/login-success&quot;) public String loginSuccess() &#123; return &quot;登陆成功&quot;; &#125; @RequestMapping(&quot;/user/&#123;id&#125;&quot;) public XcUser getUser(@PathVariable(&quot;id&quot;) String id) &#123; XcUser xcUser = xcUserService.getById(id); return xcUser; &#125; @RequestMapping(&quot;/r/r1&quot;) public String r1() &#123; return &quot;访问r1资源&quot;; &#125; @RequestMapping(&quot;/r/r2&quot;) public String r2() &#123; return &quot;访问r2资源&quot;; &#125;&#125; 配置Mybatis分页在com.swx.auth.config包下创建 MybatisPlusConfig MybatisPlusConfig@Configuration@MapperScan(&quot;com.swx.ucenter.mapper&quot;)public class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125;"},{"title":"Nacos配置","path":"/wiki/learning-online/10-auth/nacos.html","content":"打开Nacos管理界面，添加新的配置文件：http://ip:8848/nacos 命名空间选择learning-online-dev 创建认证授权工程配置：media-api-dev.yaml ID：auth-service-dev.yaml Group：learning-online-project 描述：统一认证中心服务配置 配置内容： server: servlet: context-path: /auth port: 63070 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///lo_user?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: xxxxxxmybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.ucenter.model.powechat: appid: wxed9954c01bb89b47 secret: a7482517235173ddb4083788de60b90e"},{"title":"Spring Security","path":"/wiki/learning-online/10-auth/springsecurity.html","content":"统一认证支持的认证方式有： 账号和密码认证 手机号加验证码认证 微信扫码认证 认证的流程如下图： 要点解析： AuthenticationManager 会委托 DaoAuthenticationProvider 进行认证，该类中的方法会校验从 loadUserByUsername() 返回的用户信息中的密码。我们项目中只有一种需要进行密码校验，所以我们需要自定义 DaoAuthenticationProvider，自己进行密码校验工作。 DaoAuthenticationProvider 会调用 UserDetailsService 的 loadUserByUsername方法，去获取 UserDetails 对象。我们的用户信息都存放在数据库，所以这里需要自定义 UserDetailsService 此外，因为username为单一对象，所以我们在传入username时，使用JSON数据，在后端使用JSON工具将其转为对象，从对象中获取登陆信息进行校验。 注意到第 6 步会返回一个 UserDetails，其中的username属性，会被放到JWT的数据部分，为了能让JWT携带更多的用户信息，在设置username属性时，可以设置为用户的JSON字符串。 前端请求 使用密码获取Token时，前端请求链接如需下： http://127.0.0.1:63010/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=&#123;&quot;username&quot;:&quot;t1&quot;, &quot;password&quot;:&quot;111111&quot;,&quot;authType&quot;:&quot;password&quot;,&quot;checkcode&quot;: &quot;4WHU&quot;,&quot;checkcodekey&quot;: &quot;checkcode:f2f2a238515e4c1a937fce77ab46bde3&quot;&#125; 参数解释：其中的username即为JSON字符串，包含了登录所需信息 client_id:XcWebAppclient_secret:XcWebAppgrant_type:passwordusername:&#123;&quot;username&quot;:&quot;t1&quot;, &quot;password&quot;:&quot;111111&quot;,&quot;authType&quot;:&quot;password&quot;,&quot;checkcode&quot;: &quot;4WHU&quot;,&quot;checkcodekey&quot;: &quot;checkcode:f2f2a238515e4c1a937fce77ab46bde3&quot;&#125; 项目中有两个前端项目，他们都会从本地cookie中获取登录时保存的JWT信息，这时要注意两个项目的域名。门户网站的域名为: www.51xuecheng.cn，管理网站的域名为: teacher.51xuecheng.cn，如果想让两个网站共享cookie，在保存cookie时域要设置到二级域名：.51xuecheng.cn。就先下面这样： 实体类接受登陆参数的AuthParamDTO AuthParamDTO@Datapublic class AuthParamDTO &#123; /** * 用户名 */ private String username; /** * 密码 */ private String password; /** * 手机号 */ private String cellphone; /** * 验证码 */ private String checkcode; /** * 验证码key */ private String checkcodekey; /** * 认证的类型 password 或 sms:短信模式 */ private String authType; /** * 附加数据 */ private Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();&#125; 保存到UserDetails中的信息 这里继承了XcUser，而不是直接使用。如果以后想添加别的内容可以直接在XcUserExt中添加。 @Data@EqualsAndHashCode(callSuper = true)public class XcUserExt extends XcUser &#123;&#125; 自定义DaoAuthenticationProvider我们项目中只有一种需要进行密码校验，所以我们需要自定义 DaoAuthenticationProvider，自己进行校验工作。 在auth.config包下创建 DaoAuthenticationProviderCustom 类，继承 DaoAuthenticationProvider，重写其中的密码校验方法，置空即可。 注意UserDetailsService引入我们自己定义的 DaoAuthenticationProviderCustomimport com.swx.ucenter.service.UserDetailsService;/** * 重写DaoAuthenticationProvider校验密码方式 * 有些校验方式不需要密码 */@Componentpublic class DaoAuthenticationProviderCustom extends DaoAuthenticationProvider &#123; @Autowired public void setUserDetailsService(UserDetailsService userDetailsService) &#123; super.setUserDetailsService(userDetailsService); &#125; @Override protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; &#125;&#125; 统一认证校验Service针对不同方式的校验（账户+密码、手机+验证码、微信扫码），使用策略模式，定义统一认证校验Service接口，并给予不同的实现类。 校验接口定义在ucenter.service包下定义统一认证的接口 /** * 统一认证接口 */public interface AuthService &#123; /** * 认证方法 * @param dto 认证参数 * @return XcUserExt */ public XcUserExt execute(AuthParamDTO dto);&#125; 账户密码实现类给该Bean的名称为 password_authService，其中password为认证方式，由前端传入，后面为固定字符串_authService，通过拼接方式可以拿到指定的BeanName 这里通过Feign远程调用了验证码微服务提供的校验方法，完成验证码校验。 CheckCodeClient/** * 远程调用校验验证码 */@FeignClient(value = &quot;checkcode&quot;, fallbackFactory = CheckCodeClientFallbackFactory.class)public interface CheckCodeClient &#123; @PostMapping(&quot;/checkcode/verify&quot;) public Boolean verify(@RequestParam(&quot;key&quot;) String key, @RequestParam(&quot;code&quot;) String code);&#125; CheckCodeClientFallbackFactory@Slf4j@Componentpublic class CheckCodeClientFallbackFactory implements FallbackFactory&lt;CheckCodeClient&gt; &#123; /** * @param throwable * @return */ @Override public CheckCodeClient create(Throwable throwable) &#123; return (key, code) -&gt; &#123; log.error(&quot;远程调用校验验证码服务失败，熔断降级, key: &#123;&#125;, code: &#123;&#125;&quot;, key, code); return false; &#125;; &#125;&#125; PasswordAuthServiceImpl/** * 密码认证方式实现类 */@Slf4j@Service(&quot;password_authService&quot;)public class PasswordAuthServiceImpl implements AuthService &#123; private final XcUserService xcUserService; private final PasswordEncoder passwordEncoder; private final CheckCodeClient checkCodeClient; public PasswordAuthServiceImpl(XcUserService xcUserService, PasswordEncoder passwordEncoder, CheckCodeClient checkCodeClient) &#123; this.xcUserService = xcUserService; this.passwordEncoder = passwordEncoder; this.checkCodeClient = checkCodeClient; &#125; /** * 认证方法 * * @param dto 认证参数 * @return XcUserExt */ @Override public XcUserExt execute(AuthParamDTO dto) &#123; String username = dto.getUsername(); // 校验验证码 String key = dto.getCheckcodekey(); String code = dto.getCheckcode(); if (StringUtils.isEmpty(key) || StringUtils.isEmpty(code)) &#123; log.debug(&quot;认证失败: 验证码参数不完整&quot;); throw new BadCredentialsException(&quot;验证码参数不完整&quot;); &#125; // 远程调用校验验证码服务，检验 Boolean verify = checkCodeClient.verify(key, code); if (!verify) &#123; log.debug(&quot;认证失败: 验证码不合法&quot;); throw new BadCredentialsException(&quot;验证码不合法&quot;); &#125; // 查询数据库 XcUser dbXcUser = Optional.ofNullable(xcUserService.getOne(Wrappers.&lt;XcUser&gt;lambdaQuery().eq(XcUser::getUsername, username))) .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;账号不存在&quot;)); //dbXcUser.getStatus() // 检验密码 String password = dbXcUser.getPassword(); if (!passwordEncoder.matches(dto.getPassword(), password)) &#123; log.debug(&quot;认证失败: 密码错误&quot;); throw new BadCredentialsException(&quot;密码错误&quot;); &#125; XcUserExt xcUserExt = new XcUserExt(); BeanUtils.copyProperties(dbXcUser, xcUserExt); return xcUserExt; &#125;&#125; 微信登录实现类/** * 微信扫码认证方式 */@Slf4j@RefreshScope@Service(&quot;wx_authService&quot;)public class WxAuthServiceImpl implements AuthService &#123; private final XcUserService xcUserService; public WxAuthServiceImpl(XcUserService xcUserService) &#123; this.xcUserService = xcUserService; &#125; /** * 认证方法 * * @param dto 认证参数 * @return XcUserExt */ @Override public XcUserExt execute(AuthParamDTO dto) &#123; String username = dto.getUsername(); if (StringUtils.isEmpty(username)) &#123; throw new BizException(ResultCodeEnum.PARAM_INVALID); &#125; // 查询数据库 XcUser xcUser = xcUserService.getOne(Wrappers.&lt;XcUser&gt;lambdaQuery().eq(XcUser::getUsername, username)); if (xcUser == null) &#123; throw new BizException(ResultCodeEnum.DATA_NOT_EXIST); &#125; XcUserExt xcUserExt = new XcUserExt(); BeanUtils.copyProperties(xcUser, xcUserExt); return xcUserExt; &#125;&#125; 自定义UserDetailsService定义 UserDetailsService，继承Spring Security的 UserDetailsService，实现 loadUserByUsername 方法 UserDetailsServicepublic interface UserDetailsService extends org.springframework.security.core.userdetails.UserDetailsService &#123; /** * 根据账号获取用户对象，获取不到直接抛异常 * * @param account 账号 * @return 用户完整信息 */ @Override UserDetails loadUserByUsername(String account) throws UsernameNotFoundException;&#125; 在impl包下实现该接口，传入的account参数，是从前端来的JSON字符对象，使用JSON工具将其转为 AuthParamDTO 对象： 以认证方式(AuthType)拼接beanName的方式获取指定的检验实现类，通过ApplicationContext获取到实现类对象，调用其中的 execute 方法完成校验。 将返回的用户信息转为JSON字符串，将其放到 UserDetails 中的 username 中，方便放到JWT的数据部分。 /** * 实现自定义UserDetailsService */@Slf4j@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; private final ApplicationContext applicationContext; public UserDetailsServiceImpl(ApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; &#125; /** * 根据账号获取用户对象，获取不到直接抛异常 * * @param account 账号 * @return 用户完整信息 */ @Override public UserDetails loadUserByUsername(String account) throws UsernameNotFoundException &#123; AuthParamDTO authParamDTO = null; try &#123; authParamDTO = JSON.parseObject(account, AuthParamDTO.class); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;认证请求参数不符合要求&quot;); &#125; String authType = authParamDTO.getAuthType(); if (StringUtils.isEmpty(authType)) &#123; throw new RuntimeException(&quot;未指定认证方式&quot;); &#125; String beanName = authType + &quot;_authService&quot;; // 根据认证类型从spring容器中取出指定Bean AuthService authService = applicationContext.getBean(beanName, AuthService.class); // 调用统一execute方法完成认证 XcUserExt xcUserExt = authService.execute(authParamDTO); return getUserPrincipal(xcUserExt); &#125; /** * 查询用户信息 * @param xcUserExt 用户信息 * @return UserDetails */ private UserDetails getUserPrincipal(XcUserExt xcUserExt) &#123; String password = xcUserExt.getPassword(); // 权限 String[] authorities = &#123;&quot;test&quot;&#125;; // 转JSON xcUserExt.setPassword(null); String userJson = JSON.toJSONString(xcUserExt); // 封装 UserDetails 对象 return User.withUsername(userJson) .password(password) .authorities(authorities).build(); &#125;&#125; 接口测试获取Token用户名+密码方式获取Token http://127.0.0.1:63010/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=&#123;&quot;username&quot;:&quot;t1&quot;, &quot;password&quot;:&quot;111111&quot;,&quot;authType&quot;:&quot;password&quot;&#125; 参数： &#123;\t&quot;client_id&quot;: &quot;XcWebApp&quot;,\t&quot;client_secret&quot;: &quot;XcWebApp&quot;,\t&quot;grant_type&quot;: &quot;password&quot;,\t&quot;username&quot;: &quot;&#123;\\&quot;username\\&quot;:\\&quot;t1\\&quot;, \\&quot;password\\&quot;:\\&quot;111111\\&quot;,\\&quot;authType\\&quot;:\\&quot;password\\&quot;&#125;&quot;&#125; client_id: 客户端密钥 client_secret: 客户端密匙 grant_type: 认证方式 username: 登陆参数 集成微信扫码登录网站应用微信登录开发获取access_token流程如下： 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数； 通过code参数加上AppID和AppSecret等，通过API换取access_token； 通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。 请求code的参数如下： self_redirect:true,id:&quot;login_container&quot;, appid: &quot;wxed9954c01bb89b47&quot;, scope: &quot;snsapi_login&quot;, redirect_uri: &quot;http://localhost:8160/api/auth/wxLogin&quot;,state: token,style: &quot;&quot;,href: &quot;&quot; 微信扫码回调接口在auth.controller包下创建 WxLoginController WxLoginController@Slf4j@Controllerpublic class WxLoginController &#123; private final String REDIRECT_URL = &quot;redirect:http://www.51xuecheng.cn/sign.html?username=%s&amp;authType=wx&quot;; private final WxAuthService wxAuthService; public WxLoginController(WxAuthService wxAuthService) &#123; this.wxAuthService = wxAuthService; &#125; @RequestMapping(&quot;/wxLogin&quot;) public String wxLogin(String code, String state) &#123; log.debug(&quot;微信扫码回调, code: &#123;&#125;, state: &#123;&#125;&quot;, code, state); if (StringUtils.isEmpty(code)) &#123; throw new RuntimeException(&quot;无code参数&quot;); &#125; XcUser xcUser = wxAuthService.wxAuth(code); String username = xcUser.getUsername(); return String.format(REDIRECT_URL, username); &#125;&#125; 请求令牌方法在ucenter.service下定义该方法的接口 WxAuthService，具体流程如下： 使用 code、appid、secret等参数去请求 access_token 使用 access_token 获取微信用户的基本信息 根据基本信息中的 unionid（用户在授权网站的唯一ID），判断微信用户是否注册，如果注册返回用户信息；否则将用户数据保存到项目数据库。 WxAuthService/** * 微信扫码接口 */public interface WxAuthService &#123; /** * 微信扫码认证，携带令牌查询用户信息、保存到自己数据库 * * @param code code * @return com.swx.ucenter.model.po.XcUser 用户信息 */ public XcUser wxAuth(String code);&#125; 实现放在 WxAuthServiceImpl 类中，添加实现父类 WxAuthService WxAuthServiceImpl/** * 微信扫码认证方式 */@Slf4j@RefreshScope@Service(&quot;wx_authService&quot;)public class WxAuthServiceImpl implements AuthService, WxAuthService &#123; @Value(&quot;$&#123;wechat.appid&#125;&quot;) private String appid; @Value(&quot;$&#123;wechat.secret&#125;&quot;) private String secret; private final RestTemplate restTemplate; private final XcUserService xcUserService; private final XcUserRoleService xcUserRoleService; private final TransactionTemplate transactionTemplate; public WxAuthServiceImpl(RestTemplate restTemplate, XcUserService xcUserService, XcUserRoleService xcUserRoleService, TransactionTemplate transactionTemplate) &#123; this.restTemplate = restTemplate; this.xcUserService = xcUserService; this.xcUserRoleService = xcUserRoleService; this.transactionTemplate = transactionTemplate; &#125; /** * 认证方法 * * @param dto 认证参数 * @return XcUserExt */ @Override public XcUserExt execute(AuthParamDTO dto) &#123; String username = dto.getUsername(); if (StringUtils.isEmpty(username)) &#123; throw new BizException(ResultCodeEnum.PARAM_INVALID); &#125; // 查询数据库 XcUser xcUser = xcUserService.getOne(Wrappers.&lt;XcUser&gt;lambdaQuery().eq(XcUser::getUsername, username)); if (xcUser == null) &#123; throw new BizException(ResultCodeEnum.DATA_NOT_EXIST); &#125; XcUserExt xcUserExt = new XcUserExt(); BeanUtils.copyProperties(xcUser, xcUserExt); return xcUserExt; &#125; /** * 微信扫码认证，申请令牌, 携带令牌查询用户信息、保存到自己数据库 * * @param code code * @return com.swx.ucenter.model.po.XcUser 用户信息 */ @Override public XcUser wxAuth(String code) &#123; // 申请令牌 Map&lt;String, String&gt; accessTokenMap = getAccessToken(code); String accessToken = accessTokenMap.get(&quot;access_token&quot;); String openid = accessTokenMap.get(&quot;openid&quot;); // 携带令牌查询用户信息 Map&lt;String, String&gt; userInfo = getUserInfo(accessToken, openid); // 保存到自己数据库 return transactionTemplate.execute((status) -&gt; &#123; try &#123; return addWxUser(userInfo); &#125; catch (Exception e) &#123; log.error(&quot;新增用户失败&quot;, e); status.setRollbackOnly(); &#125; return null; &#125;); &#125; public XcUser addWxUser(Map&lt;String, String&gt; userInfoMap) &#123; // unionid，用户在网站上的唯一ID。 String unionid = userInfoMap.get(&quot;unionid&quot;); String nickname = userInfoMap.get(&quot;nickname&quot;); XcUser xcUser = xcUserService.getOne(Wrappers.&lt;XcUser&gt;lambdaQuery().eq(StringUtils.hasText(unionid), XcUser::getWxUnionid, unionid)); // 已注册，直接返回 if (xcUser != null) &#123; return xcUser; &#125; // 新增用户 xcUser = new XcUser(); xcUser.setId(UUID.randomUUID().toString()); xcUser.setWxUnionid(unionid); xcUser.setPassword(unionid); xcUser.setUsername(unionid); xcUser.setNickname(nickname); xcUser.setName(nickname); xcUser.setCreateTime(LocalDateTime.now()); xcUser.setUtype(&quot;101001&quot;); xcUser.setStatus(&quot;1&quot;); xcUser.setSex(userInfoMap.get(&quot;sex&quot;)); xcUserService.save(xcUser); // 新增用户角色信息 XcUserRole xcUserRole = new XcUserRole(); xcUserRole.setUserId(xcUser.getId()); xcUserRole.setId(UUID.randomUUID().toString()); xcUserRole.setRoleId(&quot;17&quot;); // 17 表示学生角色 xcUserRole.setCreateTime(LocalDateTime.now()); xcUserRoleService.save(xcUserRole); return xcUser; &#125; /** * 通过code获取access_token * https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code * &#123; * &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, * &quot;expires_in&quot;:7200, * &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, * &quot;openid&quot;:&quot;OPENID&quot;, * &quot;scope&quot;:&quot;SCOPE&quot;, * &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; * &#125; * * @param code code */ private Map&lt;String, String&gt; getAccessToken(String code) &#123; // 填充url String url = String.format(WxAuthURLConstants.ACCESS_TOKEN, appid, secret, code); // 发起请求 ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(url, HttpMethod.POST, null, String.class); String result = exchange.getBody(); // 解析body return handleResult(result); &#125; /** * 获取用户个人信息 * https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID * &#123; * &quot;openid&quot;:&quot;OPENID&quot;, * &quot;nickname&quot;:&quot;NICKNAME&quot;, * &quot;sex&quot;:1, * &quot;province&quot;:&quot;PROVINCE&quot;, * &quot;city&quot;:&quot;CITY&quot;, * &quot;country&quot;:&quot;COUNTRY&quot;, * &quot;headimgurl&quot;: &quot;https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;, * &quot;privilege&quot;:[ * &quot;PRIVILEGE1&quot;, * &quot;PRIVILEGE2&quot; * ], * &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; * &#125; * * @param accessToken 令牌 * @param openId 用户的标识 */ private Map&lt;String, String&gt; getUserInfo(String accessToken, String openId) &#123; // 填充url String url = String.format(WxAuthURLConstants.USER_INFO, accessToken, openId); // 发起请求 ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(url, HttpMethod.GET, null, String.class); String result = exchange.getBody(); // 解析body return handleResult(result); &#125; /** * 解析body * * @param body body */ private Map&lt;String, String&gt; handleResult(String body) &#123; if (StringUtils.isEmpty(body)) &#123; log.error(&quot;请求access_token出错, body为空&quot;); throw new BizException(&quot;请求access_token出错&quot;); &#125; String body_utf8 = new String(body.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); // 将result转为Map Map&lt;String, String&gt; map = JSON.parseObject(body_utf8, new TypeReference&lt;HashMap&lt;String, String&gt;&gt;() &#123;&#125;); // 错误判断 if (StringUtils.hasText(map.get(&quot;errcode&quot;))) &#123; String errmsg = map.get(&quot;errmsg&quot;); String errcode = map.get(&quot;errcode&quot;); log.error(&quot;请求access_token出错, errcode: &#123;&#125;, errmsg: &#123;&#125;&quot;, errcode, errmsg); throw new BizException(errmsg); &#125; return map; &#125;&#125;"},{"title":"统一认证","path":"/wiki/learning-online/10-auth/unifyauth.html","content":"支持的认证方式有： 账号和密码认证 手机号加验证码认证 微信扫码认证 认证的流程如下图： 要点解析： AuthenticationManager 会委托 DaoAuthenticationProvider 进行认证，该类中的方法会校验从 loadUserByUsername() 返回的用户信息中的密码。我们项目中只有一种需要进行密码校验，所以我们需要自定义 DaoAuthenticationProvider，自己进行密码校验工作。 DaoAuthenticationProvider 会调用 UserDetailsService 的 loadUserByUsername方法，去获取 UserDetails 对象。我们的用户信息都存放在数据库，所以这里需要自定义 UserDetailsService 此外，因为username为单一对象，所以我们在传入username时，使用JSON数据，在后端使用JSON工具将其转为对象，从对象中获取登陆信息进行校验。 注意到第 6 步会返回一个 UserDetails，其中的username属性，会被放到JWT的数据部分，为了能让JWT携带更多的用户信息，在设置username属性时，可以设置为用户的JSON字符串。 前端请求 使用密码获取Token时，前端请求链接如需下： http://127.0.0.1:63010/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=&#123;&quot;username&quot;:&quot;t1&quot;, &quot;password&quot;:&quot;111111&quot;,&quot;authType&quot;:&quot;password&quot;,&quot;checkcode&quot;: &quot;4WHU&quot;,&quot;checkcodekey&quot;: &quot;checkcode:f2f2a238515e4c1a937fce77ab46bde3&quot;&#125; 参数解释：其中的username即为JSON字符串，包含了登录所需信息 client_id:XcWebAppclient_secret:XcWebAppgrant_type:passwordusername:&#123;&quot;username&quot;:&quot;t1&quot;, &quot;password&quot;:&quot;111111&quot;,&quot;authType&quot;:&quot;password&quot;,&quot;checkcode&quot;: &quot;4WHU&quot;,&quot;checkcodekey&quot;: &quot;checkcode:f2f2a238515e4c1a937fce77ab46bde3&quot;&#125; 项目中有两个前端项目，他们都会从本地cookie中获取登录时保存的JWT信息，这时要注意两个项目的域名。门户网站的域名为: www.51xuecheng.cn，管理网站的域名为: teacher.51xuecheng.cn，如果想让两个网站共享cookie，在保存cookie时域要设置到二级域名：.51xuecheng.cn。就先下面这样： 实体类接受登陆参数的AuthParamDTO AuthParamDTO@Datapublic class AuthParamDTO &#123; /** * 用户名 */ private String username; /** * 密码 */ private String password; /** * 手机号 */ private String cellphone; /** * 验证码 */ private String checkcode; /** * 验证码key */ private String checkcodekey; /** * 认证的类型 password 或 sms:短信模式 */ private String authType; /** * 附加数据 */ private Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();&#125; 保存到UserDetails中的信息 这里继承了XcUser，而不是直接使用。如果以后想添加别的内容可以直接在XcUserExt中添加。 @Data@EqualsAndHashCode(callSuper = true)public class XcUserExt extends XcUser &#123;&#125; 自定义DaoAuthenticationProvider我们项目中只有一种需要进行密码校验，所以我们需要自定义 DaoAuthenticationProvider，自己进行校验工作。 在auth.config包下创建 DaoAuthenticationProviderCustom 类，继承 DaoAuthenticationProvider，重写其中的密码校验方法，置空即可。 注意UserDetailsService引入我们自己定义的 DaoAuthenticationProviderCustomimport com.swx.ucenter.service.UserDetailsService;/** * 重写DaoAuthenticationProvider校验密码方式 * 有些校验方式不需要密码 */@Componentpublic class DaoAuthenticationProviderCustom extends DaoAuthenticationProvider &#123; @Autowired public void setUserDetailsService(UserDetailsService userDetailsService) &#123; super.setUserDetailsService(userDetailsService); &#125; @Override protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; &#125;&#125; 统一认证校验Service针对不同方式的校验（账户+密码、手机+验证码、微信扫码），使用策略模式，定义统一认证校验Service接口，并给予不同的实现类。 校验接口定义在ucenter.service包下定义统一认证的接口 /** * 统一认证接口 */public interface AuthService &#123; /** * 认证方法 * @param dto 认证参数 * @return XcUserExt */ public XcUserExt execute(AuthParamDTO dto);&#125; 账户密码实现类给该Bean的名称为 password_authService，其中password为认证方式，由前端传入，后面为固定字符串_authService，通过拼接方式可以拿到指定的BeanName 这里通过Feign远程调用了验证码微服务提供的校验方法，完成验证码校验。 CheckCodeClient/** * 远程调用校验验证码 */@FeignClient(value = &quot;checkcode&quot;, fallbackFactory = CheckCodeClientFallbackFactory.class)public interface CheckCodeClient &#123; @PostMapping(&quot;/checkcode/verify&quot;) public Boolean verify(@RequestParam(&quot;key&quot;) String key, @RequestParam(&quot;code&quot;) String code);&#125; CheckCodeClientFallbackFactory@Slf4j@Componentpublic class CheckCodeClientFallbackFactory implements FallbackFactory&lt;CheckCodeClient&gt; &#123; /** * @param throwable * @return */ @Override public CheckCodeClient create(Throwable throwable) &#123; return (key, code) -&gt; &#123; log.error(&quot;远程调用校验验证码服务失败，熔断降级, key: &#123;&#125;, code: &#123;&#125;&quot;, key, code); return false; &#125;; &#125;&#125; PasswordAuthServiceImpl/** * 密码认证方式实现类 */@Slf4j@Service(&quot;password_authService&quot;)public class PasswordAuthServiceImpl implements AuthService &#123; private final XcUserService xcUserService; private final PasswordEncoder passwordEncoder; private final CheckCodeClient checkCodeClient; public PasswordAuthServiceImpl(XcUserService xcUserService, PasswordEncoder passwordEncoder, CheckCodeClient checkCodeClient) &#123; this.xcUserService = xcUserService; this.passwordEncoder = passwordEncoder; this.checkCodeClient = checkCodeClient; &#125; /** * 认证方法 * * @param dto 认证参数 * @return XcUserExt */ @Override public XcUserExt execute(AuthParamDTO dto) &#123; String username = dto.getUsername(); // 校验验证码 String key = dto.getCheckcodekey(); String code = dto.getCheckcode(); if (StringUtils.isEmpty(key) || StringUtils.isEmpty(code)) &#123; log.debug(&quot;认证失败: 验证码参数不完整&quot;); throw new BadCredentialsException(&quot;验证码参数不完整&quot;); &#125; // 远程调用校验验证码服务，检验 Boolean verify = checkCodeClient.verify(key, code); if (!verify) &#123; log.debug(&quot;认证失败: 验证码不合法&quot;); throw new BadCredentialsException(&quot;验证码不合法&quot;); &#125; // 查询数据库 XcUser dbXcUser = Optional.ofNullable(xcUserService.getOne(Wrappers.&lt;XcUser&gt;lambdaQuery().eq(XcUser::getUsername, username))) .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;账号不存在&quot;)); //dbXcUser.getStatus() // 检验密码 String password = dbXcUser.getPassword(); if (!passwordEncoder.matches(dto.getPassword(), password)) &#123; log.debug(&quot;认证失败: 密码错误&quot;); throw new BadCredentialsException(&quot;密码错误&quot;); &#125; XcUserExt xcUserExt = new XcUserExt(); BeanUtils.copyProperties(dbXcUser, xcUserExt); return xcUserExt; &#125;&#125; 微信登录实现类/** * 微信扫码认证方式 */@Slf4j@RefreshScope@Service(&quot;wx_authService&quot;)public class WxAuthServiceImpl implements AuthService &#123; private final XcUserService xcUserService; public WxAuthServiceImpl(XcUserService xcUserService) &#123; this.xcUserService = xcUserService; &#125; /** * 认证方法 * * @param dto 认证参数 * @return XcUserExt */ @Override public XcUserExt execute(AuthParamDTO dto) &#123; String username = dto.getUsername(); if (StringUtils.isEmpty(username)) &#123; throw new BizException(ResultCodeEnum.PARAM_INVALID); &#125; // 查询数据库 XcUser xcUser = xcUserService.getOne(Wrappers.&lt;XcUser&gt;lambdaQuery().eq(XcUser::getUsername, username)); if (xcUser == null) &#123; throw new BizException(ResultCodeEnum.DATA_NOT_EXIST); &#125; XcUserExt xcUserExt = new XcUserExt(); BeanUtils.copyProperties(xcUser, xcUserExt); return xcUserExt; &#125;&#125; 自定义UserDetailsService定义 UserDetailsService，继承Spring Security的 UserDetailsService，实现 loadUserByUsername 方法 UserDetailsServicepublic interface UserDetailsService extends org.springframework.security.core.userdetails.UserDetailsService &#123; /** * 根据账号获取用户对象，获取不到直接抛异常 * * @param account 账号 * @return 用户完整信息 */ @Override UserDetails loadUserByUsername(String account) throws UsernameNotFoundException;&#125; 在impl包下实现该接口，传入的account参数，是从前端来的JSON字符对象，使用JSON工具将其转为 AuthParamDTO 对象： 以认证方式(AuthType)拼接beanName的方式获取指定的检验实现类，通过ApplicationContext获取到实现类对象，调用其中的 execute 方法完成校验。 将返回的用户信息转为JSON字符串，将其放到 UserDetails 中的 username 中，方便放到JWT的数据部分。 /** * 实现自定义UserDetailsService */@Slf4j@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; private final ApplicationContext applicationContext; public UserDetailsServiceImpl(ApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; &#125; /** * 根据账号获取用户对象，获取不到直接抛异常 * * @param account 账号 * @return 用户完整信息 */ @Override public UserDetails loadUserByUsername(String account) throws UsernameNotFoundException &#123; AuthParamDTO authParamDTO = null; try &#123; authParamDTO = JSON.parseObject(account, AuthParamDTO.class); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;认证请求参数不符合要求&quot;); &#125; String authType = authParamDTO.getAuthType(); if (StringUtils.isEmpty(authType)) &#123; throw new RuntimeException(&quot;未指定认证方式&quot;); &#125; String beanName = authType + &quot;_authService&quot;; // 根据认证类型从spring容器中取出指定Bean AuthService authService = applicationContext.getBean(beanName, AuthService.class); // 调用统一execute方法完成认证 XcUserExt xcUserExt = authService.execute(authParamDTO); return getUserPrincipal(xcUserExt); &#125; /** * 查询用户信息 * @param xcUserExt 用户信息 * @return UserDetails */ private UserDetails getUserPrincipal(XcUserExt xcUserExt) &#123; String password = xcUserExt.getPassword(); // 权限 String[] authorities = &#123;&quot;test&quot;&#125;; // 转JSON xcUserExt.setPassword(null); String userJson = JSON.toJSONString(xcUserExt); // 封装 UserDetails 对象 return User.withUsername(userJson) .password(password) .authorities(authorities).build(); &#125;&#125; 接口测试获取Token用户名+密码方式获取Token http://127.0.0.1:63010/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=&#123;&quot;username&quot;:&quot;t1&quot;, &quot;password&quot;:&quot;111111&quot;,&quot;authType&quot;:&quot;password&quot;&#125; 参数： &#123;\t&quot;client_id&quot;: &quot;XcWebApp&quot;,\t&quot;client_secret&quot;: &quot;XcWebApp&quot;,\t&quot;grant_type&quot;: &quot;password&quot;,\t&quot;username&quot;: &quot;&#123;\\&quot;username\\&quot;:\\&quot;t1\\&quot;, \\&quot;password\\&quot;:\\&quot;111111\\&quot;,\\&quot;authType\\&quot;:\\&quot;password\\&quot;&#125;&quot;&#125; client_id: 客户端密钥 client_secret: 客户端密匙 grant_type: 认证方式 username: 登陆参数 集成微信扫码登录网站应用微信登录开发获取access_token流程如下： 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数； 通过code参数加上AppID和AppSecret等，通过API换取access_token； 通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。 请求code的参数如下： self_redirect:true,id:&quot;login_container&quot;, appid: &quot;wxed9954c01bb89b47&quot;, scope: &quot;snsapi_login&quot;, redirect_uri: &quot;http://localhost:8160/api/auth/wxLogin&quot;,state: token,style: &quot;&quot;,href: &quot;&quot; 微信扫码回调接口在auth.controller包下创建 WxLoginController WxLoginController@Slf4j@Controllerpublic class WxLoginController &#123; private final String REDIRECT_URL = &quot;redirect:http://www.51xuecheng.cn/sign.html?username=%s&amp;authType=wx&quot;; private final WxAuthService wxAuthService; public WxLoginController(WxAuthService wxAuthService) &#123; this.wxAuthService = wxAuthService; &#125; @RequestMapping(&quot;/wxLogin&quot;) public String wxLogin(String code, String state) &#123; log.debug(&quot;微信扫码回调, code: &#123;&#125;, state: &#123;&#125;&quot;, code, state); if (StringUtils.isEmpty(code)) &#123; throw new RuntimeException(&quot;无code参数&quot;); &#125; XcUser xcUser = wxAuthService.wxAuth(code); String username = xcUser.getUsername(); return String.format(REDIRECT_URL, username); &#125;&#125; 请求令牌方法在ucenter.service下定义该方法的接口 WxAuthService，具体流程如下： 使用 code、appid、secret等参数去请求 access_token 使用 access_token 获取微信用户的基本信息 根据基本信息中的 unionid（用户在授权网站的唯一ID），判断微信用户是否注册，如果注册返回用户信息；否则将用户数据保存到项目数据库。 WxAuthService/** * 微信扫码接口 */public interface WxAuthService &#123; /** * 微信扫码认证，携带令牌查询用户信息、保存到自己数据库 * * @param code code * @return com.swx.ucenter.model.po.XcUser 用户信息 */ public XcUser wxAuth(String code);&#125; 实现放在 WxAuthServiceImpl 类中，添加实现父类 WxAuthService WxAuthServiceImpl/** * 微信扫码认证方式 */@Slf4j@RefreshScope@Service(&quot;wx_authService&quot;)public class WxAuthServiceImpl implements AuthService, WxAuthService &#123; @Value(&quot;$&#123;wechat.appid&#125;&quot;) private String appid; @Value(&quot;$&#123;wechat.secret&#125;&quot;) private String secret; private final RestTemplate restTemplate; private final XcUserService xcUserService; private final XcUserRoleService xcUserRoleService; private final TransactionTemplate transactionTemplate; public WxAuthServiceImpl(RestTemplate restTemplate, XcUserService xcUserService, XcUserRoleService xcUserRoleService, TransactionTemplate transactionTemplate) &#123; this.restTemplate = restTemplate; this.xcUserService = xcUserService; this.xcUserRoleService = xcUserRoleService; this.transactionTemplate = transactionTemplate; &#125; /** * 认证方法 * * @param dto 认证参数 * @return XcUserExt */ @Override public XcUserExt execute(AuthParamDTO dto) &#123; String username = dto.getUsername(); if (StringUtils.isEmpty(username)) &#123; throw new BizException(ResultCodeEnum.PARAM_INVALID); &#125; // 查询数据库 XcUser xcUser = xcUserService.getOne(Wrappers.&lt;XcUser&gt;lambdaQuery().eq(XcUser::getUsername, username)); if (xcUser == null) &#123; throw new BizException(ResultCodeEnum.DATA_NOT_EXIST); &#125; XcUserExt xcUserExt = new XcUserExt(); BeanUtils.copyProperties(xcUser, xcUserExt); return xcUserExt; &#125; /** * 微信扫码认证，申请令牌, 携带令牌查询用户信息、保存到自己数据库 * * @param code code * @return com.swx.ucenter.model.po.XcUser 用户信息 */ @Override public XcUser wxAuth(String code) &#123; // 申请令牌 Map&lt;String, String&gt; accessTokenMap = getAccessToken(code); String accessToken = accessTokenMap.get(&quot;access_token&quot;); String openid = accessTokenMap.get(&quot;openid&quot;); // 携带令牌查询用户信息 Map&lt;String, String&gt; userInfo = getUserInfo(accessToken, openid); // 保存到自己数据库 return transactionTemplate.execute((status) -&gt; &#123; try &#123; return addWxUser(userInfo); &#125; catch (Exception e) &#123; log.error(&quot;新增用户失败&quot;, e); status.setRollbackOnly(); &#125; return null; &#125;); &#125; public XcUser addWxUser(Map&lt;String, String&gt; userInfoMap) &#123; // unionid，用户在网站上的唯一ID。 String unionid = userInfoMap.get(&quot;unionid&quot;); String nickname = userInfoMap.get(&quot;nickname&quot;); XcUser xcUser = xcUserService.getOne(Wrappers.&lt;XcUser&gt;lambdaQuery().eq(StringUtils.hasText(unionid), XcUser::getWxUnionid, unionid)); // 已注册，直接返回 if (xcUser != null) &#123; return xcUser; &#125; // 新增用户 xcUser = new XcUser(); xcUser.setId(UUID.randomUUID().toString()); xcUser.setWxUnionid(unionid); xcUser.setPassword(unionid); xcUser.setUsername(unionid); xcUser.setNickname(nickname); xcUser.setName(nickname); xcUser.setCreateTime(LocalDateTime.now()); xcUser.setUtype(&quot;101001&quot;); xcUser.setStatus(&quot;1&quot;); xcUser.setSex(userInfoMap.get(&quot;sex&quot;)); xcUserService.save(xcUser); // 新增用户角色信息 XcUserRole xcUserRole = new XcUserRole(); xcUserRole.setUserId(xcUser.getId()); xcUserRole.setId(UUID.randomUUID().toString()); xcUserRole.setRoleId(&quot;17&quot;); // 17 表示学生角色 xcUserRole.setCreateTime(LocalDateTime.now()); xcUserRoleService.save(xcUserRole); return xcUser; &#125; /** * 通过code获取access_token * https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code * &#123; * &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, * &quot;expires_in&quot;:7200, * &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, * &quot;openid&quot;:&quot;OPENID&quot;, * &quot;scope&quot;:&quot;SCOPE&quot;, * &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; * &#125; * * @param code code */ private Map&lt;String, String&gt; getAccessToken(String code) &#123; // 填充url String url = String.format(WxAuthURLConstants.ACCESS_TOKEN, appid, secret, code); // 发起请求 ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(url, HttpMethod.POST, null, String.class); String result = exchange.getBody(); // 解析body return handleResult(result); &#125; /** * 获取用户个人信息 * https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID * &#123; * &quot;openid&quot;:&quot;OPENID&quot;, * &quot;nickname&quot;:&quot;NICKNAME&quot;, * &quot;sex&quot;:1, * &quot;province&quot;:&quot;PROVINCE&quot;, * &quot;city&quot;:&quot;CITY&quot;, * &quot;country&quot;:&quot;COUNTRY&quot;, * &quot;headimgurl&quot;: &quot;https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;, * &quot;privilege&quot;:[ * &quot;PRIVILEGE1&quot;, * &quot;PRIVILEGE2&quot; * ], * &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; * &#125; * * @param accessToken 令牌 * @param openId 用户的标识 */ private Map&lt;String, String&gt; getUserInfo(String accessToken, String openId) &#123; // 填充url String url = String.format(WxAuthURLConstants.USER_INFO, accessToken, openId); // 发起请求 ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(url, HttpMethod.GET, null, String.class); String result = exchange.getBody(); // 解析body return handleResult(result); &#125; /** * 解析body * * @param body body */ private Map&lt;String, String&gt; handleResult(String body) &#123; if (StringUtils.isEmpty(body)) &#123; log.error(&quot;请求access_token出错, body为空&quot;); throw new BizException(&quot;请求access_token出错&quot;); &#125; String body_utf8 = new String(body.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); // 将result转为Map Map&lt;String, String&gt; map = JSON.parseObject(body_utf8, new TypeReference&lt;HashMap&lt;String, String&gt;&gt;() &#123;&#125;); // 错误判断 if (StringUtils.hasText(map.get(&quot;errcode&quot;))) &#123; String errmsg = map.get(&quot;errmsg&quot;); String errcode = map.get(&quot;errcode&quot;); log.error(&quot;请求access_token出错, errcode: &#123;&#125;, errmsg: &#123;&#125;&quot;, errcode, errmsg); throw new BizException(errmsg); &#125; return map; &#125;&#125;"},{"title":"课程表服务","path":"/wiki/learning-online/11-learning/coursetable.html","content":"在learning-online-learning-api工程的com.swx.learning.api包下创建控制类 @Api(value = &quot;我的课程表接口&quot;, tags = &quot;我的课程表接口&quot;)@RestController@RequestMapping(&quot;/choosecourse&quot;)public class MyCourseTablesController &#123;&#125; 在learning-online-learning-service工程的com.swx.learning.service包下创建接口类 public interface MyCourseTablesService &#123; &#125; 实现类 /** * 选课相关服务 */@Servicepublic class MyCourseTablesServiceImpl implements MyCourseTablesService &#123;&#125; 查询学习资格一共有三个状态 &#123; &quot;702001&quot;: &quot;可学习&quot;, &quot;702002&quot;: &quot;没支付&quot;, &quot;702003&quot;: &quot;已过期&quot;,&#125; 接口信息 值 路径地址 http://localhost:63020/learning/choosecourse/learnstatus/12 请求方式 POST 请求参数 Long 返回结果 XcCourseTablesVO 返回结果VOCourseCategoryTreeVO@Data@EqualsAndHashCode(callSuper = true)public class XcCourseTablesVO extends XcCourseTables &#123; // 学习资格 public String learnStatus;&#125; 查询资格Service在 MyCourseTablesService 中定义查询学习资格方法 MyCourseTablesServicepublic interface MyCourseTablesService &#123; /** * 查询学习资格 * * @param userId 用户ID * @param courseId 课程ID * @return com.swx.learning.model.vo.XcChooseCourseVO 选课信息 */ public XcCourseTablesVO getLearningStatus(String userId, Long courseId);&#125; 实现该方法 MyCourseTablesServiceImpl/** * 选课相关服务 */@Servicepublic class MyCourseTablesServiceImpl implements MyCourseTablesService &#123; private final XcCourseTablesService xcCourseTablesService; public MyCourseTablesServiceImpl(XcCourseTablesService xcCourseTablesService) &#123; this.xcCourseTablesService = xcCourseTablesService; &#125; /** * 查询学习资格 * * @param userId 用户ID * @param courseId 课程ID * @return com.swx.learning.model.vo.XcChooseCourseVO 选课信息 */ @Override public XcCourseTablesVO getLearningStatus(String userId, Long courseId) &#123; // 查询我的课程表，有记录可学习 return xcCourseTablesService.getLearningStatus(userId, courseId); &#125;&#125; 查询学习资格找到 XcCourseTablesService 服务类，定义如下的方法 XcCourseTablesServicepublic interface XcCourseTablesService extends IService&lt;XcCourseTables&gt; &#123; /** * 查询学习资格 * * @param userId 用户ID * @param courseId 课程ID * @return String 学习资格 */ XcCourseTablesVO getLearningStatus(String userId, Long courseId);&#125; 实现上述方法： XcCourseTablesServiceImpl@Servicepublic class XcCourseTablesServiceImpl extends ServiceImpl&lt;XcCourseTablesMapper, XcCourseTables&gt; implements XcCourseTablesService &#123; /** * 查询学习资格 * * @param userId 用户ID * @param courseId 课程ID * @return String 学习资格 */ @Override public XcCourseTablesVO getLearningStatus(String userId, Long courseId) &#123; XcCourseTables courseTable = getCourseTable(userId, courseId); XcCourseTablesVO xcCourseTablesVO = new XcCourseTablesVO(); if (courseTable == null) &#123; // 选课没支付 xcCourseTablesVO.setLearnStatus(&quot;702002&quot;); return xcCourseTablesVO; &#125; boolean before = courseTable.getValidtimeEnd().isBefore(LocalDateTime.now()); BeanUtils.copyProperties(courseTable, xcCourseTablesVO); if (before) &#123; // 已过期 xcCourseTablesVO.setLearnStatus(&quot;702003&quot;); &#125; else &#123; // 可以学习 xcCourseTablesVO.setLearnStatus(&quot;702001&quot;); &#125; return xcCourseTablesVO; &#125;&#125; 查询资格ControllerMyCourseTablesController@Api(value = &quot;我的课程表接口&quot;, tags = &quot;我的课程表接口&quot;)@RestController@RequestMapping(&quot;/choosecourse&quot;)public class MyCourseTablesController &#123; private final MyCourseTablesService myCourseTablesService; public MyCourseTablesController(MyCourseTablesService myCourseTablesService) &#123; this.myCourseTablesService = myCourseTablesService; &#125; @ApiOperation(&quot;查询学习资格&quot;) @PostMapping(&quot;/learnstatus/&#123;courseId&#125;&quot;) public XcCourseTablesVO getLearningStatus(@PathVariable(&quot;courseId&quot;) Long courseId) &#123; // 获取userId SecurityUtil.XcUser user = SecurityUtil.getUser(); String userId = user.getId(); return myCourseTablesService.getLearningStatus(userId, courseId); &#125;&#125; 添加选课信息要判断课程是否收费以及详细信息，远程调用内容微服务，查询已发布的课程信息。具体业务流程如下： 接口信息 值 路径地址 http://localhost:63020/learning/choosecourse/12 请求方式 POST 请求参数 Long 返回结果 XcChooseCourseVO 返回结果VOCourseCategoryTreeVO@Data@EqualsAndHashCode(callSuper = true)public class XcChooseCourseVO extends XcChooseCourse &#123; // 学习资格 public String learnStatus;&#125; 查询已发布课程修改内容微服务，增加查询已发布课程的接口，新建client包，不使用@ResponseResult注解，可防止返回包装类，直接返回原始类型。 @RestControllerpublic class CoursePublishClient &#123; private final CoursePublishService coursePublishService; public CoursePublishClient(CoursePublishService coursePublishService) &#123; this.coursePublishService = coursePublishService; &#125; @ApiOperation(&quot;查询课程发布信息&quot;) @GetMapping(&quot;/r/coursepublish/&#123;courseId&#125;&quot;) public CoursePublish getCoursePublish(@PathVariable(&quot;courseId&quot;) Long courseId) &#123; return coursePublishService.getById(courseId); &#125;&#125; 在learning-online-learning-service工程下创建Feign的调用接口： @FeignClient(value = &quot;content-api&quot;, fallbackFactory = ContentServiceClientFallbackFactory.class)public interface ContentServiceClient &#123; @GetMapping(&quot;/content/r/coursepublish/&#123;courseId&#125;&quot;) public CoursePublish getCoursePublish(@PathVariable(&quot;courseId&quot;) Long courseId);&#125; 熔断降级 import org.springframework.cloud.openfeign.FallbackFactory;@Slf4j@Componentpublic class ContentServiceClientFallbackFactory implements FallbackFactory&lt;ContentServiceClient&gt; &#123; @Override public ContentServiceClient create(Throwable throwable) &#123; return courseId -&gt; &#123; log.error(&quot;远程调用内容服务熔断降级: 课程ID: &#123;&#125;&quot;, courseId); return null; &#125;; &#125;&#125; 添加选课Service在 MyCourseTablesService 中定义添加选课方法 MyCourseTablesServicepublic interface MyCourseTablesService &#123; /** * 添加选课 * * @param userId 用户ID * @param courseId 课程ID * @return com.swx.learning.model.vo.XcChooseCourseVO 选课信息 */ public XcChooseCourseVO addChooseCourse(String userId, Long courseId);&#125; 实现该方法 MyCourseTablesServiceImpl/** * 选课相关服务 */@Servicepublic class MyCourseTablesServiceImpl implements MyCourseTablesService &#123; private final XcChooseCourseService xcChooseCourseService; private final XcCourseTablesService xcCourseTablesService; private final ContentServiceClient contentServiceClient; public MyCourseTablesServiceImpl(XcChooseCourseService xcChooseCourseService, XcCourseTablesService xcCourseTablesService, ContentServiceClient contentServiceClient) &#123; this.xcChooseCourseService = xcChooseCourseService; this.xcCourseTablesService = xcCourseTablesService; this.contentServiceClient = contentServiceClient; &#125; /** * 添加选课 * * @param userId 用户ID * @param courseId 课程ID * @return com.swx.learning.model.vo.XcChooseCourseVO 选课信息 */ @Override @Transactional(rollbackFor = Exception.class) public XcChooseCourseVO addChooseCourse(String userId, Long courseId) &#123; // 远程调用内容管理查询课程的收费规则 CoursePublish coursePublish = Optional.ofNullable(contentServiceClient.getCoursePublish(courseId)) .orElseThrow(() -&gt; new BizException(&quot;课程不存在&quot;)); // 收费规则 String charge = coursePublish.getCharge(); // 选课记录 XcChooseCourse chooseCourse = null; if (&quot;201000&quot;.equals(charge)) &#123; // 免费课程，会向选课记录表和我的课程表写数据 chooseCourse = xcChooseCourseService.addFreeCourse(userId, coursePublish); XcCourseTables xcCourseTables = xcCourseTablesService.addCourseTables(chooseCourse); &#125; else &#123; // 收费课程，选课记录表写入数据 chooseCourse = xcChooseCourseService.addChargeCourse(userId, coursePublish); &#125; // 返回选课资格 XcChooseCourseVO xcChooseCourseVO = new XcChooseCourseVO(); BeanUtils.copyProperties(chooseCourse, xcChooseCourseVO); XcCourseTablesVO xcCourseTablesVO = getLearningStatus(userId, courseId); xcChooseCourseVO.setLearnStatus(xcCourseTablesVO.getLearnStatus()); return xcChooseCourseVO; &#125;&#125; 添加课程记录这里提供两个方法，分别是添加收费课程的记录和付费课程的记录 找到 XcChooseCourseService 服务类，定义上述两个方法： XcChooseCourseServicepublic interface XcChooseCourseService extends IService&lt;XcChooseCourse&gt; &#123; /** * 添加免费课程 * * @param userId 用户ID * @param coursePublish 课程信息 * @return com.swx.learning.model.po.XcChooseCourse 选课记录 */ XcChooseCourse addFreeCourse(String userId, CoursePublish coursePublish); /** * 添加收费课程 * * @param userId 用户ID * @param coursePublish 课程信息 * @return com.swx.learning.model.po.XcChooseCourse 选课记录 */ XcChooseCourse addChargeCourse(String userId, CoursePublish coursePublish);&#125; 实现该方法： XcChooseCourseServiceImpl@Servicepublic class XcChooseCourseServiceImpl extends ServiceImpl&lt;XcChooseCourseMapper, XcChooseCourse&gt; implements XcChooseCourseService &#123; /** * 添加免费课程 * * @param userId 用户ID * @param coursePublish 课程信息 * @return com.swx.learning.model.po.XcChooseCourse 选课记录 */ @Override @Transactional(rollbackFor = Exception.class) public XcChooseCourse addFreeCourse(String userId, CoursePublish coursePublish) &#123; return addCourse(userId, coursePublish, false); &#125; /** * 添加收费课程 * * @param userId 用户ID * @param coursePublish 课程信息 * @return com.swx.learning.model.po.XcChooseCourse 选课记录 */ @Override @Transactional(rollbackFor = Exception.class) public XcChooseCourse addChargeCourse(String userId, CoursePublish coursePublish) &#123; return addCourse(userId, coursePublish, true); &#125; /** * 添加课程 * * @param userId 用户ID * @param coursePublish 课程信息 * @param isCharge 是否收费 * @return com.swx.learning.model.po.XcChooseCourse 选课记录 */ public XcChooseCourse addCourse(String userId, CoursePublish coursePublish, boolean isCharge) &#123; String status = &quot;701001&quot;; // 选课成功 String orderType = &quot;700001&quot;; // 免费课程 if (isCharge) &#123; status = &quot;701002&quot;; // 待支付 orderType = &quot;700002&quot;; // 收费课程 &#125; Long courseId = coursePublish.getId(); // 查询是否已选 List&lt;XcChooseCourse&gt; chooseCourses = list(Wrappers.&lt;XcChooseCourse&gt;lambdaQuery() .eq(XcChooseCourse::getUserId, userId) .eq(XcChooseCourse::getCourseId, courseId) .eq(XcChooseCourse::getStatus, status) // 待支付 .eq(XcChooseCourse::getOrderType, orderType));// 收费课程 if (!chooseCourses.isEmpty()) &#123; return chooseCourses.get(0); &#125; // 向选课记录表写入数据 XcChooseCourse chooseCourse = new XcChooseCourse(); chooseCourse.setCourseId(courseId); chooseCourse.setCourseName(coursePublish.getName()); chooseCourse.setCompanyId(coursePublish.getCompanyId()); chooseCourse.setUserId(userId); chooseCourse.setOrderType(orderType); chooseCourse.setCreateDate(LocalDateTime.now()); chooseCourse.setCoursePrice(coursePublish.getPrice()); chooseCourse.setValidDays(365); chooseCourse.setStatus(status); chooseCourse.setValidtimeStart(LocalDateTime.now()); chooseCourse.setValidtimeEnd(chooseCourse.getValidtimeStart().plusDays(chooseCourse.getValidDays())); boolean save = save(chooseCourse); if (!save) &#123; throw new BizException(&quot;添加选课记录失败&quot;); &#125; return chooseCourse; &#125;&#125; 添加我的课程表免费课程可直接加入我的课程表，收费课程需要支付完成后方可加入我的课程表 找到 XcCourseTablesService 服务类，定义如下的方法 XcCourseTablesServicepublic interface XcCourseTablesService extends IService&lt;XcCourseTables&gt; &#123; /** * 添加到我的课程表 * * @param xcChooseCourse 选课记录 * @return com.swx.learning.model.po.XcCourseTables 课程表 */ XcCourseTables addCourseTables(XcChooseCourse xcChooseCourse); /** * 是否已存在课程表 * * @param userId 用户ID * @param courseId 课程ID * @return com.swx.learning.model.po.XcChooseCourse 选课表 */ XcCourseTables getCourseTable(String userId, Long courseId);&#125; 实现上述方法： XcCourseTablesServiceImpl@Servicepublic class XcCourseTablesServiceImpl extends ServiceImpl&lt;XcCourseTablesMapper, XcCourseTables&gt; implements XcCourseTablesService &#123; /** * 添加到我的课程表 * * @param xcChooseCourse 选课记录 * @return com.swx.learning.model.po.XcCourseTables 课程表 */ @Override @Transactional(rollbackFor = Exception.class) public XcCourseTables addCourseTables(XcChooseCourse xcChooseCourse) &#123; String status = xcChooseCourse.getStatus(); if (!status.equals(&quot;701001&quot;)) &#123; throw new BizException(&quot;选课没有成功，无法添加到课程表&quot;); &#125; XcCourseTables courseTables = getCourseTable(xcChooseCourse.getUserId(), xcChooseCourse.getCourseId()); if (courseTables != null) &#123; return courseTables; &#125; courseTables = new XcCourseTables(); BeanUtils.copyProperties(xcChooseCourse, courseTables); courseTables.setChooseCourseId(xcChooseCourse.getId()); // 记录选课表的主键 courseTables.setCourseType(xcChooseCourse.getOrderType()); courseTables.setUpdateDate(LocalDateTime.now()); boolean save = save(courseTables); if (!save) &#123; throw new BizException(&quot;添加我的课程表失败&quot;); &#125; return courseTables; &#125; /** * 是否已存在课程表 * * @param userId 用户ID * @param courseId 课程ID * @return com.swx.learning.model.po.XcChooseCourse 选课表 */ @Override public XcCourseTables getCourseTable(String userId, Long courseId) &#123; return getOne(Wrappers.&lt;XcCourseTables&gt;lambdaQuery() .eq(XcCourseTables::getUserId, userId) .eq(XcCourseTables::getCourseId, courseId)); &#125;&#125; 添加选课ControllerMyCourseTablesController@Api(value = &quot;我的课程表接口&quot;, tags = &quot;我的课程表接口&quot;)@RestController@RequestMapping(&quot;/choosecourse&quot;)public class MyCourseTablesController &#123; private final MyCourseTablesService myCourseTablesService; public MyCourseTablesController(MyCourseTablesService myCourseTablesService) &#123; this.myCourseTablesService = myCourseTablesService; &#125; @ApiOperation(&quot;添加选课&quot;) @PostMapping(&quot;/&#123;courseId&#125;&quot;) public XcChooseCourseVO addChooseCourse(@PathVariable(&quot;courseId&quot;) Long courseId) &#123; // 获取userId SecurityUtil.XcUser user = SecurityUtil.getUser(); String userId = user.getId(); return myCourseTablesService.addChooseCourse(userId, courseId); &#125;&#125; 查询课程表接口信息 值 路径地址 http://localhost:63020/learning/mycoursetable 请求方式 POST 请求参数 MyCourseTableParamsDTO 返回结果 PageResult 参数DTO@Datapublic class MyCourseTableParamsDTO &#123; String userId; private String courseType; private String sortType; private String expiresType; int page = 1; int startIndex; int size = 4;&#125; 查询Service在 MyCourseTablesService 中定义查询我的课程表方法 MyCourseTablesService/** * 查询我的课程表 * @param dto 查询参数 */PageResult&lt;XcCourseTables&gt; getMyCourseTables(MyCourseTableParamsDTO dto); 实现该方法： MyCourseTablesServiceImpl/** * 查询我的课程表 * * @param dto 查询参数 */@Overridepublic PageResult&lt;XcCourseTables&gt; getMyCourseTables(MyCourseTableParamsDTO dto) &#123; String userId = dto.getUserId(); int size = dto.getSize(); int pageNo = dto.getPage(); Page&lt;XcCourseTables&gt; iPage = new Page&lt;&gt;(pageNo, size); Page&lt;XcCourseTables&gt; pageResult = xcCourseTablesService.page(iPage, Wrappers.&lt;XcCourseTables&gt;lambdaQuery() .eq(XcCourseTables::getUserId, userId)); return new PageResult&lt;&gt;(pageResult.getRecords(), pageResult.getTotal(), pageNo, size);&#125; 查询ControllerMyCourseTablesController@ApiOperation(&quot;我的课程表&quot;)@GetMapping(&quot;/mycoursetable&quot;)public PageResult&lt;XcCourseTables&gt; getMyCourseTables(MyCourseTableParamsDTO dto) &#123; SecurityUtil.XcUser user = SecurityUtil.getUser(); dto.setUserId(user.getId()); return myCourseTablesService.getMyCourseTables(dto);&#125;"},{"title":"初始化工程","path":"/wiki/learning-online/11-learning/init.html","content":"创建媒资管理工程，分为三个子模块 learning-online-learning├── learning-online-learning-api├── learning-online-learning-model└── learning-online-learning-service 创建工程结构在learning-online-learning-model模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在learning-online-learning-service模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-learning-model&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Feign远程调用 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在learning-online-learning-api模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-learning-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类，在learning-online-learning-api工程的com.swx.learning包下创建启动类LearningApplication，内容如下： LearningApplication@SpringBootApplication@EnableTransactionManagement@MapperScan(basePackages = &quot;com.swx.learning.mapper&quot;)@EnableFeignClients(basePackages = &quot;com.swx.learning.client&quot;)public class LearningApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LearningApplication.class, args); &#125;&#125; 项目配置信息，在learning-online-learning-api工程的resources下创建bootstrap.yml bootstrap.ymlspring: application: name: learning-api cloud: nacos: discovery: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project config: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project file-extension: yaml refresh-enabled: true extension-configs: - data-id: learning-service-$&#123;spring.profiles.active&#125;.yaml group: learning-online-project refresh: true shared-configs: - data-id: logging-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true - data-id: feign-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true profiles: active: dev 日志配置，在learning-online-learning-api工程的resources下创建log4j2-dev.xml log4j2-dev.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration monitorInterval=&quot;180&quot; packages=&quot;&quot;&gt; &lt;properties&gt; &lt;property name=&quot;logdir&quot;&gt;logs&lt;/property&gt; &lt;property name=&quot;PATTERN&quot;&gt;%date&#123;YYYY-MM-dd HH:mm:ss,SSS&#125; %level [%thread][%file:%line] - %msg%n%throwable&lt;/property&gt; &lt;/properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;ErrorAppender&quot; fileName=&quot;$&#123;logdir&#125;/error.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/error.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;DebugAppender&quot; fileName=&quot;$&#123;logdir&#125;/info.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/info.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;!--异步appender--&gt; &lt;Async name=&quot;AsyncAppender&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;ErrorAppender&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Async&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的debug信息 &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt;--&gt; &lt;logger name=&quot;cn.itcast.wanxinp2p.consumer.mapper&quot; level=&quot;DEBUG&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;springfox&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;com.netflix.discovery&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqCommon&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqRemoting&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqClient&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.lottery&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.bonuspoint&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;!--OFF 0--&gt; &lt;!--FATAL 100--&gt; &lt;!--ERROR 200--&gt; &lt;!--WARN 300--&gt; &lt;!--INFO 400--&gt; &lt;!--DEBUG 500--&gt; &lt;!--TRACE 600--&gt; &lt;!--ALL Integer.MAX_VALUE--&gt; &lt;Root level=&quot;DEBUG&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;AsyncAppender&quot;/&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 基础代码实体类使用代码生成工具生成lo_learning表的实体类，将其拷贝到learning-online-learning-model工程的com.swx.learning.model.po包下，暂时所需实体类如下： XcChooseCourse.java XcCourseTables.java XcLearnRecord.java Mapper层将代码生成的所有Mapper.java文件拷贝到learning-online-learning-service工程下的com.swx.learning.mapper包下。 将代码生成的所有Mapper.xml文件拷贝到learning-online-learning-service工程下的resources/mapper目录下。 Service层将代码生成的所有Service和ServiceImpl文件拷贝到learning-online-learning-service工程下的com.swx.learning.service包下。 集成微服务集成方式见认证授权工程的[集成Spring Security](#集成Spring Security)"},{"title":"获取章节视频","path":"/wiki/learning-online/11-learning/learning.html","content":"从学习中心章节视频的学习资格，通过远程调用内容服务判断课程收费情况，免费远程调用媒资服务，查询视频URL，返回前端；收费视频判断是否到期等 接口信息 值 路径地址 http://localhost:63020/learning/open/learn/getvideo/{courseId}/{teachplanId}/{mediaId} 请求方式 POST 请求参数 返回结果 R 查询Servicepublic interface LearningService &#123; /** * 获取视频的学习资格 * * @param userId 用户ID * @param courseId 课程ID * @param teachplanId 课程计划ID * @param mediaId 媒资ID */ R getvideo(String userId, Long courseId, Long teachplanId, String mediaId);&#125; 实现该方法 @Servicepublic class LearningServiceImpl implements LearningService &#123; private final MyCourseTablesService myCourseTablesService; private final ContentServerClient contentServerClient; private final MediaServerClient mediaServerClient; public LearningServiceImpl(MyCourseTablesService myCourseTablesService, ContentServerClient contentServerClient, MediaServerClient mediaServerClient) &#123; this.myCourseTablesService = myCourseTablesService; this.contentServerClient = contentServerClient; this.mediaServerClient = mediaServerClient; &#125; /** * 获取视频的学习资格 * * @param userId 用户ID * @param courseId 课程ID * @param teachplanId 课程计划ID * @param mediaId 媒资ID */ @Override public R getvideo(String userId, Long courseId, Long teachplanId, String mediaId) &#123; // 远程调用查询已发布课程 CoursePublish coursePublish = contentServerClient.getCoursePublish(courseId); if (coursePublish == null) &#123; return R.fail(-1, &quot;课程不存在，无法预览&quot;); &#125; // TODO 判断该视频视频所在课程小节是否支持试学 if (StringUtils.isEmpty(userId)) &#123; // 用户未登录 if (coursePublish.getCharge().equals(&quot;201000&quot;)) &#123; String url = mediaServerClient.getPlayUrlByMediaId(mediaId); return R.success(url); &#125; return R.fail(-1, &quot;请登陆后选课学习&quot;); &#125; // 查询学习资格 XcCourseTablesVO learningStatus = myCourseTablesService.getLearningStatus(userId, courseId); String learnStatus = learningStatus.getLearnStatus(); if (learnStatus.equals(&quot;702002&quot;)) &#123; return R.fail(-1, &quot;无法学习，未选课或选课后没有支付&quot;); &#125; else if (learnStatus.equals(&quot;702003&quot;)) &#123; return R.fail(-1, &quot;已过期需要申请续费或重新支付&quot;); &#125; // 有资格, 远程调用媒资获取视频地址 String url = mediaServerClient.getPlayUrlByMediaId(mediaId); return R.success(url); &#125;&#125; 查询ControllerMyLearningController@Api(value = &quot;学习过程管理接口&quot;, tags = &quot;学习过程管理接口&quot;)@RestControllerpublic class MyLearningController &#123; private final LearningService learningService; public MyLearningController(LearningService learningService) &#123; this.learningService = learningService; &#125; @ApiOperation(&quot;获取视频&quot;) @GetMapping(&quot;/open/learn/getvideo/&#123;courseId&#125;/&#123;teachplanId&#125;/&#123;mediaId&#125;&quot;) public R getVideo(@PathVariable(&quot;courseId&quot;) Long courseId, @PathVariable(&quot;teachplanId&quot;) Long teachplanId, @PathVariable(&quot;mediaId&quot;) String mediaId) &#123; String userId = null; try &#123; SecurityUtil.XcUser user = SecurityUtil.getUser(); userId = user.getId(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return learningService.getvideo(userId, courseId, teachplanId, mediaId); &#125;&#125;"},{"title":"Nacos配置","path":"/wiki/learning-online/11-learning/nacos.html","content":"找到Nacos配置列表，选择开发环境learning-online-dev 创建内容管理工程配置：learning-api-dev.yaml ID：learning-api-dev.yaml Group：learning-online-project 描述：学成在线内容管理微服务开发环境配置 配置内容： learning-api-dev.yamlserver: port: 63020 servlet: context-path: /learningspring: cloud: config: # 本地优先 override-none: true 创建内容管理工程配置：learning-service-dev.yaml ID：learning-service-dev.yaml Group：learning-online-project 配置内容： learning-service-dev.yamlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///lo_learning?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: swx852345mybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.learning.model.po"},{"title":"集成阿里支付","path":"/wiki/learning-online/12-orders/alipay.html","content":"沙箱账号申请项目使用阿里提供的沙箱环境做开发，首先需要申请沙箱账号，使用沙箱账号登录安装的沙箱版支付宝 手机网站支付快速接入文档 申请沙箱账号 在沙箱应用中可以找到：APPID、应用私钥、支付宝公钥、支付宝网关地址 配置文件配置基本的参数： AlipayConfig/** * 支付宝配置参数 */public class AlipayConfig &#123; // 服务器异步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 public static String notify_url = &quot;http://hgg77b.natappfree.cc/orders/paynotify&quot;; // 页面跳转同步通知页面路径 需http://或者https://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 商户可以自定义同步跳转地址 public static String return_url = &quot;http://商户网关地址/alipay.trade.wap.pay-JAVA-UTF-8/return_url.jsp&quot;; // 请求网关地址 public static String URL = &quot;https://openapi-sandbox.dl.alipaydev.com/gateway.do&quot;; // 编码 public static String CHARSET = &quot;UTF-8&quot;; // 返回格式 public static String FORMAT = &quot;json&quot;; // 支付宝公钥// public static String ALIPAY_PUBLIC_KEY = &quot;&quot;; // 日志记录目录 public static String log_path = &quot;/log&quot;; // RSA2 public static String SIGNTYPE = &quot;RSA2&quot;;&#125;"},{"title":"生成支付二维码","path":"/wiki/learning-online/12-orders/createorder.html","content":"当用户点击支付宝支付时，在添加选课记录后，请求订单微服务下单，生成支付二维码。 接口信息 值 路径地址 http://localhost:63020/orders/generatepaycode 请求方式 POST 请求参数 AddOrderDTO 返回结果 PayRecordVO 参数DTOAddOrderDTO/** * 创建商品订单 */@Data@ToStringpublic class AddOrderDTO &#123; /** * 总价 */ @NotNull(message = &quot;价格不能为空&quot;) private Float totalPrice; /** * 订单类型 */ @NotEmpty(message = &quot;未知订单类型&quot;) private String orderType; /** * 订单名称 */ private String orderName; /** * 订单描述 */ @NotEmpty(message = &quot;请添加订单描述&quot;) private String orderDescrip; /** * 订单明细json，不可为空 * [&#123;&quot;goodsId&quot;:&quot;&quot;,&quot;goodsType&quot;:&quot;&quot;,&quot;goodsName&quot;:&quot;&quot;,&quot;goodsPrice&quot;:&quot;&quot;,&quot;goodsDetail&quot;:&quot;&quot;&#125;,&#123;...&#125;] */ @NotEmpty(message = &quot;订单明细不可为空&quot;) private String orderDetail; /** * 外部系统业务id */ @NotEmpty(message = &quot;请先选课&quot;) private String outBusinessId;&#125; 视图VOPayRecordVO/** * 支付记录dto */@Data@ToString@EqualsAndHashCode(callSuper = true)public class PayRecordVO extends XcPayRecord &#123; //二维码 private String qrcode;&#125; 流程分析用户点击支付宝支付，请求二维码接口，生成订单记录，商品信息，和支付记录；携带支付记录中的支付编号返回给前端；用户使用支付宝APP扫码时，会请求二维码中的地址，其中就有支付编号。 二维码信息如下，该地址为扫码下单接口地址，即本项目的地址。由支付宝发起请求 http://mb25gx.natappfree.cc/orders/requestpay?payNo=%s 二维码工具在learning-online-base工程的pom文件中添加二维码生成的依赖： pom.xml&lt;!-- 二维码生成 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;&lt;/dependency&gt; 二维码生成工具 QRCodeUtil/** * 二维码生成工具 */public class QRCodeUtil &#123; private final Logger log = LoggerFactory.getLogger(QRCodeUtil.class); /** * 生成二维码 * * @param content 二维码对应的URL * @param width 二维码图片宽度 * @param height 二维码图片高度 * @return base64图片 */ public String createQRCode(String content, int width, int height) throws IOException &#123; String resultImage = &quot;&quot;; //除了尺寸，传入内容不能为空 if (!StringUtils.isEmpty(content)) &#123; ServletOutputStream stream = null; ByteArrayOutputStream os = new ByteArrayOutputStream(); //二维码参数 @SuppressWarnings(&quot;rawtypes&quot;) HashMap&lt;EncodeHintType, Comparable&gt; hints = new HashMap&lt;&gt;(); //指定字符编码为“utf-8” hints.put(EncodeHintType.CHARACTER_SET, &quot;utf-8&quot;); //L M Q H四个纠错等级从低到高，指定二维码的纠错等级为M //纠错级别越高，可以修正的错误就越多，需要的纠错码的数量也变多，相应的二维吗可储存的数据就会减少 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M); //设置图片的边距 hints.put(EncodeHintType.MARGIN, 1); try &#123; //zxing生成二维码核心类 QRCodeWriter writer = new QRCodeWriter(); //把输入文本按照指定规则转成二维吗 BitMatrix bitMatrix = writer.encode(content, BarcodeFormat.QR_CODE, width, height, hints); //生成二维码图片流 BufferedImage bufferedImage = MatrixToImageWriter.toBufferedImage(bitMatrix); //输出流 ImageIO.write(bufferedImage, &quot;png&quot;, os); // 原生转码前面没有 data:image/png;base64 这些字段，返回给前端是无法被解析，所以加上前缀 resultImage = &quot;data:image/png;base64,&quot; + EncryptUtil.encodeBase64(os.toByteArray()); return resultImage; &#125; catch (Exception e) &#123; log.error(&quot;生成二维码出错&quot;, e); throw new RuntimeException(&quot;生成二维码出错&quot;); &#125; finally &#123; if (stream != null) &#123; stream.flush(); stream.close(); &#125; &#125; &#125; return null; &#125;&#125; 编码工具 EncryptUtilpublic class EncryptUtil &#123; private static final Logger logger = LoggerFactory.getLogger(EncryptUtil.class); public static String encodeBase64(byte[] bytes)&#123; String encoded = Base64.getEncoder().encodeToString(bytes); return encoded; &#125; public static byte[] decodeBase64(String str)&#123; byte[] bytes = null; bytes = Base64.getDecoder().decode(str); return bytes; &#125; public static String encodeUTF8StringBase64(String str)&#123; String encoded = null; try &#123; encoded = Base64.getEncoder().encodeToString(str.getBytes(&quot;utf-8&quot;)); &#125; catch (UnsupportedEncodingException e) &#123; logger.warn(&quot;不支持的编码格式&quot;,e); &#125; return encoded; &#125; public static String decodeUTF8StringBase64(String str)&#123; String decoded = null; byte[] bytes = Base64.getDecoder().decode(str); try &#123; decoded = new String(bytes,&quot;utf-8&quot;); &#125;catch(UnsupportedEncodingException e)&#123; logger.warn(&quot;不支持的编码格式&quot;,e); &#125; return decoded; &#125; public static String encodeURL(String url) &#123; String encoded = null; try &#123; encoded = URLEncoder.encode(url, &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; logger.warn(&quot;URLEncode失败&quot;, e); &#125; return encoded; &#125; public static String decodeURL(String url) &#123; String decoded = null; try &#123; decoded = URLDecoder.decode(url, &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; logger.warn(&quot;URLDecode失败&quot;, e); &#125; return decoded; &#125; public static void main(String [] args)&#123; String str = &quot;abcd&#123;&#x27;a&#x27;:&#x27;b&#x27;&#125;&quot;; String encoded = EncryptUtil.encodeUTF8StringBase64(str); String decoded = EncryptUtil.decodeUTF8StringBase64(encoded); System.out.println(str); System.out.println(encoded); System.out.println(decoded); String url = &quot;== wo&quot;; String urlEncoded = EncryptUtil.encodeURL(url); String urlDecoded = EncryptUtil.decodeURL(urlEncoded); System.out.println(url); System.out.println(urlEncoded); System.out.println(urlDecoded); &#125;&#125; 创建订单Service在com.swx.orders.service包下的 OrderService 中定义创建订单方法： XcOrdersService/** * 订单相关Service */public interface OrderService &#123; /** * 创建订单 * 新增订单信息，新增支付记录，生成支付二维码 * * @param userId 用户id * @param dto 订单信息 * @return 二维码 */ public PayRecordVO createOrder(String userId, AddOrderDTO dto);&#125; 在实现类中实现该方法 OrderServiceImpl@Slf4j@Servicepublic class OrderServiceImpl implements OrderService &#123; private final XcOrdersService xcOrdersService; private final XcPayRecordService xcPayRecordService; @Value(&quot;$&#123;pay.qrcodeUrl&#125;&quot;) private String qrcodeUrl; public OrderServiceImpl(XcOrdersService xcOrdersService, XcPayRecordService xcPayRecordService) &#123; this.xcOrdersService = xcOrdersService; this.xcPayRecordService = xcPayRecordService; &#125; /** * 创建订单 * 新增订单信息，新增支付记录，生成支付二维码 * * @param userId 用户id * @param dto 订单信息 * @return 二维码 */ @Override @Transactional(rollbackFor = Exception.class) public PayRecordVO createOrder(String userId, AddOrderDTO dto) &#123; // 新增订单信息 XcOrders orders = xcOrdersService.saveXcOrders(userId, dto); if (orders.getStatus().equals(&quot;601002&quot;)) &#123; // 已支付 throw new BizException(&quot;订单已支付&quot;); &#125; // 新增支付记录 XcPayRecord payRecord = xcPayRecordService.createPayRecord(orders); String url = String.format(qrcodeUrl, payRecord.getPayNo()); QRCodeUtil qrCodeUtil = new QRCodeUtil(); // 二维码图片 String qrCode = null; try &#123; qrCode = qrCodeUtil.createQRCode(url, 200, 200); &#125; catch (IOException e) &#123; throw new BizException(&quot;生成二维码出错&quot;); &#125; PayRecordVO payRecordVO = new PayRecordVO(); BeanUtils.copyProperties(payRecord, payRecordVO); payRecordVO.setQrcode(qrCode); return payRecordVO; &#125;&#125; 新增订单Service首先根据用户ID和选课ID查询订单信息，确保一个用户只能对一个选课创建一个订单，然后根据参数组装 XcOrders 实体类，使用雪花算法生成订单号，并将数据保存到数据库中。 在com.swx.orders.service包下的 XcOrdersService 中定义新增订单方法： XcOrdersServicepublic interface XcOrdersService extends IService&lt;XcOrders&gt; &#123; /** * 保存订单信息 * * @param userId 用户ID * @param dto 订单信息 */ XcOrders saveXcOrders(String userId, AddOrderDTO dto);&#125; 在实现类中实现该方法 XcOrdersServiceImpl@Servicepublic class XcOrdersServiceImpl extends ServiceImpl&lt;XcOrdersMapper, XcOrders&gt; implements XcOrdersService &#123; private final XcOrdersGoodsService xcOrdersGoodsService; public XcOrdersServiceImpl(XcOrdersGoodsService xcOrdersGoodsService) &#123; this.xcOrdersGoodsService = xcOrdersGoodsService; &#125; /** * 保存订单信息 * * @param userId 用户ID * @param dto 订单信息 */ @Override public XcOrders saveXcOrders(String userId, AddOrderDTO dto) &#123; // 进行幂等性判断，同一个选课记录只能有一个订单 XcOrders order = getOneByBizId(userId, dto.getOutBusinessId()); if (order != null) &#123; return order; &#125; // 插入订单表 order = new XcOrders(); // 使用雪花算法生成订单号 BeanUtils.copyProperties(dto, order); order.setId(IdWorkerUtil.getInstance().nextId()); order.setCreateDate(LocalDateTime.now()); order.setStatus(&quot;600001&quot;); // 未支付 order.setUserId(userId); order.setOrderType(&quot;60201&quot;); // 业务订单类型，购买课程 boolean save = save(order); if (!save) &#123; throw new BizException(&quot;添加订单失败&quot;); &#125; Long orderId = order.getId(); String orderDetailJson = dto.getOrderDetail(); List&lt;XcOrdersGoods&gt; xcOrdersGoods = JSON.parseArray(orderDetailJson, XcOrdersGoods.class); for (XcOrdersGoods xcOrdersGood : xcOrdersGoods) &#123; xcOrdersGood.setOrderId(orderId); &#125; boolean saveGoods = xcOrdersGoodsService.saveBatch(xcOrdersGoods); return order; &#125; /** * 根据业务ID查询一条记录 * * @param userId 用户ID * @param bizId 业务ID * @return com.swx.orders.model.po.XcOrders 订单 */ public XcOrders getOneByBizId(String userId, String bizId) &#123; return getOne(Wrappers.&lt;XcOrders&gt;lambdaQuery().eq(XcOrders::getUserId, userId).eq(XcOrders::getOutBusinessId, bizId)); &#125;&#125; 新增支付记录Service创建支付记录，此时的支付状态为：未支付。 在com.swx.orders.service包下的 XcPayRecordService 中定义新增订单方法： XcPayRecordServicepublic interface XcPayRecordService extends IService&lt;XcPayRecord&gt; &#123; /** * 创建支付记录 * * @param orders 订单 */ XcPayRecord createPayRecord(XcOrders orders);&#125; 在实现类中实现该方法 XcPayRecordServiceImpl/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-09-04 */@Servicepublic class XcPayRecordServiceImpl extends ServiceImpl&lt;XcPayRecordMapper, XcPayRecord&gt; implements XcPayRecordService &#123; /** * 创建支付记录 * * @param orders 订单 */ @Override public XcPayRecord createPayRecord(XcOrders orders) &#123; XcPayRecord xcPayRecord = new XcPayRecord(); xcPayRecord.setPayNo(IdWorkerUtil.getInstance().nextId()); xcPayRecord.setOrderId(orders.getId()); xcPayRecord.setOrderName(orders.getOrderName()); xcPayRecord.setTotalPrice(orders.getTotalPrice()); xcPayRecord.setCurrency(&quot;CNY&quot;); xcPayRecord.setCreateDate(LocalDateTime.now()); xcPayRecord.setStatus(&quot;601001&quot;); // 未支付 xcPayRecord.setUserId(orders.getUserId()); boolean save = save(xcPayRecord); if (!save) &#123; throw new BizException(&quot;添加支付记录失败&quot;); &#125; return xcPayRecord; &#125;&#125; 创建订单Controller@Api(value = &quot;订单支付接口&quot;, tags = &quot;订单支付接口&quot;)@RestControllerpublic class OrderController &#123; private final OrderService orderService; public OrderController(OrderService orderService) &#123; this.orderService = orderService; &#125; @ApiOperation(&quot;生成支付二维码&quot;) @PostMapping(&quot;/generatepaycode&quot;) public PayRecordVO generatePayCode(@RequestBody AddOrderDTO dto) &#123; SecurityUtil.XcUser user = SecurityUtil.getUser(); String userId = user.getId(); return orderService.createOrder(userId, dto); &#125;&#125;"},{"title":"初始化工程","path":"/wiki/learning-online/12-orders/init.html","content":"创建媒资管理工程，分为三个子模块 learning-online-orders├── learning-online-orders-api├── learning-online-orders-model└── learning-online-orders-service 创建工程结构在learning-online-orders-model模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在learning-online-orders-service模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-orders-model&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.38.61.ALL&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 消息队列 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-message-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在learning-online-orders-api模块的pom文件中添加如下依赖： pom.xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-orders-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类，在learning-online-orders-api工程的com.swx.orders包下创建启动类OrdersApplication，内容如下： OrdersApplication@SpringBootApplication@EnableTransactionManagementpublic class OrdersApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrdersApplication.class, args); &#125;&#125; 项目配置信息，在learning-online-orders-api工程的resources下创建bootstrap.yml bootstrap.ymlspring: application: name: orders-api cloud: nacos: discovery: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project config: server-addr: 124.221.23.47:8848 namespace: learning-online-dev group: learning-online-project file-extension: yaml refresh-enabled: true extension-configs: - data-id: orders-service-$&#123;spring.profiles.active&#125;.yaml group: learning-online-project refresh: true shared-configs: - data-id: logging-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true - data-id: rabbitmq-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true profiles: active: dev 日志配置，在learning-online-orders-api工程的resources下创建log4j2-dev.xml log4j2-dev.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration monitorInterval=&quot;180&quot; packages=&quot;&quot;&gt; &lt;properties&gt; &lt;property name=&quot;logdir&quot;&gt;logs&lt;/property&gt; &lt;property name=&quot;PATTERN&quot;&gt;%date&#123;YYYY-MM-dd HH:mm:ss,SSS&#125; %level [%thread][%file:%line] - %msg%n%throwable&lt;/property&gt; &lt;/properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;ErrorAppender&quot; fileName=&quot;$&#123;logdir&#125;/error.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/error.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;DebugAppender&quot; fileName=&quot;$&#123;logdir&#125;/info.log&quot; filePattern=&quot;$&#123;logdir&#125;/$$&#123;date:yyyy-MM-dd&#125;/info.%d&#123;yyyy-MM-dd-HH&#125;.log&quot; append=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;!--异步appender--&gt; &lt;Async name=&quot;AsyncAppender&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;ErrorAppender&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Async&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的debug信息 &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt;--&gt; &lt;logger name=&quot;cn.itcast.wanxinp2p.consumer.mapper&quot; level=&quot;DEBUG&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;springfox&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;com.netflix.discovery&quot; level=&quot;INFO&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqCommon&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqRemoting&quot; level=&quot;INFO&quot; &gt; &lt;/logger&gt; &lt;logger name=&quot;RocketmqClient&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.lottery&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.dromara.hmily.bonuspoint&quot; level=&quot;WARN&quot;&gt; &lt;/logger&gt; &lt;!--OFF 0--&gt; &lt;!--FATAL 100--&gt; &lt;!--ERROR 200--&gt; &lt;!--WARN 300--&gt; &lt;!--INFO 400--&gt; &lt;!--DEBUG 500--&gt; &lt;!--TRACE 600--&gt; &lt;!--ALL Integer.MAX_VALUE--&gt; &lt;Root level=&quot;DEBUG&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;AsyncAppender&quot;/&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;DebugAppender&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 基础代码实体类使用代码生成工具生成lo_orders表的实体类，将其拷贝到learning-online-orders-model工程的com.swx.orders.model.po包下，暂时所需实体类如下： XcOrders.java XcOrdersGoods.java XcPayRecord.java Mapper层将代码生成的所有Mapper.java文件拷贝到learning-online-orders-service工程下的com.swx.orders.mapper包下。 将代码生成的所有Mapper.xml文件拷贝到learning-online-orders-service工程下的resources/mapper目录下。 Service层将代码生成的所有Service和ServiceImpl文件拷贝到learning-online-orders-service工程下的com.swx.orders.service包下。 集成微服务集成方式见认证授权工程的[集成Spring Security](#集成Spring Security)"},{"title":"查询异步通知","path":"/wiki/learning-online/12-orders/notifyresult.html","content":"支付完成后，第三方支付系统会主动通知支付结果，要实现主动通知，需要在请求支付系统下单时传入NotifyUrl，如果支付成功，使用消息队列通知学习中心添加选课记录到我的课程表。 查询Controller@RequestMapping(&quot;/paynotify&quot;)public void paynotify(HttpServletRequest request, HttpServletResponse response) throws IOException, AlipayApiException &#123; // 获取支付宝POST过来的反馈信息 HashMap&lt;String, String&gt; params = new HashMap&lt;&gt;(); Map&lt;String, String[]&gt; requestParams = request.getParameterMap(); for (Iterator&lt;String&gt; iterator = requestParams.keySet().iterator(); iterator.hasNext();) &#123; String name = iterator.next(); String[] values = requestParams.get(name); String valueStr = &quot;&quot;; for (int i = 0; i &lt; values.length; i++) &#123; valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;; &#125; // 解决乱码 params.put(name, valueStr); &#125; boolean signVerified = AlipaySignature.rsaCheckV1(params, ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, AlipayConfig.SIGNTYPE); //调用SDK验证签名 if (signVerified) &#123; // 商户订单号 String outTradNo = new String(request.getParameter(&quot;out_trade_no&quot;).getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); // 支付宝交易号 String tradeNo = new String(request.getParameter(&quot;trade_no&quot;).getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); // 交易状态 String tradeStatus = new String(request.getParameter(&quot;trade_status&quot;).getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); // 交易金额 String totalAmount = new String(request.getParameter(&quot;total_amount&quot;).getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); // 验证成功 if (tradeStatus.equals(&quot;TRADE_SUCCESS&quot;)) &#123; PayStatusDTO payStatusDTO = new PayStatusDTO(); payStatusDTO.setOut_trade_no(outTradNo); payStatusDTO.setTrade_no(tradeNo); payStatusDTO.setTrade_status(tradeStatus); payStatusDTO.setApp_id(APP_ID); payStatusDTO.setTotal_amount(totalAmount); orderService.saveAlipayStatus(payStatusDTO); &#125; response.getWriter().write(&quot;success&quot;); &#125; else &#123; response.getWriter().write(&quot;fail&quot;); &#125;&#125;"},{"title":"Nacos配置","path":"/wiki/learning-online/12-orders/nacos.html","content":"找到Nacos配置列表，选择开发环境learning-online-dev 创建订单管理工程配置：orders-api-dev.yaml ID：orders-api-dev.yaml Group：learning-online-project 描述：订单微服务配置类 配置内容： orders-api-dev.yamlserver: port: 63030 servlet: context-path: /ordersspring: cloud: config: # 本地优先 override-none: true 创建订单管理工程配置：orders-service-dev.yaml ID：orders-service-dev.yaml Group：learning-online-project 配置内容： orders-service-dev.yamlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///lo_orders?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: swx852345mybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.orders.model.popay: qrcodeUrl: http://mb25gx.natappfree.cc/orders/requestpay?payNo=%s alipay: APP_ID: 9021000126649557 APP_PRIVATE_KEY: # 沙盒环境应用私钥 ALIPAY_PUBLIC_KEY: # 沙盒环境支付宝公钥 NOTIFY_URL: http://mb25gx.natappfree.cc/orders/paynotify # 支付宝通知回调地址 创建消息队列配置：rabbitmq-dev.yaml ID：rabbitmq-dev.yaml Group：learning-online-common 配置内容： rabbitmq-dev.yamlspring: rabbitmq: host: 124.221.23.47 port: 5672 username: swcode password: 123321 virtual-host: / publisher-confirm-type: correlated #correlated 异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback publisher-returns: true #开启publish-return功能，同样是基于callback机制，需要定义ReturnCallback template: mandatory: true #定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息 listener: simple: prefetch: 1 #每次只能获取一条消息，处理完成才能获取下一个消息 acknowledge-mode: auto #auto:出现异常时返回unack，消息回滚到mq；没有异常，返回ack ,manual:手动控制,none:丢弃消息，不回滚到mq retry: enabled: false #开启消费者失败重试 initial-interval: 5000ms #初识的失败等待时长为1秒 multiplier: 1 #失败的等待时长倍数，下次等待时长 = multiplier * last-interval max-attempts: 3 #最大重试次数 stateless: true #true无状态；false有状态。如果业务中包含事务，这里改为false"},{"title":"扫码支付服务","path":"/wiki/learning-online/12-orders/payreq.html","content":"当使用手机支付宝扫码之后，支付宝会解析二维码中的网址，向我们的服务器发起请求；此时拿到请求携带的订单编号，查询支付记录；如果已支付则直接返回，否则拼接参数向支付宝发起支付请求，支付宝会返回一个form表单页面，用于拉取支付宝手机支付。 接口信息 值 路径地址 http://localhost:63020/orders/requestpay 请求方式 GET 请求参数 String 返回结果 支付记录Service根据订单编号查询支付记录 在com.swx.orders.service包下的 XcPayRecordService 中定义查询支付记录方法： XcPayRecordServicepublic interface XcPayRecordService extends IService&lt;XcPayRecord&gt; &#123; /** * 根据交易编号查询记录 * * @param payNo 交易编号 * @return com.swx.orders.model.po.XcPayRecord 支付记录 */ XcPayRecord getOneByPayNo(String payNo);&#125; 在实现类中实现该方法 XcPayRecordServiceImpl/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-09-04 */@Servicepublic class XcPayRecordServiceImpl extends ServiceImpl&lt;XcPayRecordMapper, XcPayRecord&gt; implements XcPayRecordService &#123; /** * 根据交易编号查询记录 * * @param payNo 交易编号 * @return com.swx.orders.model.po.XcPayRecord 支付记录 */ @Override public XcPayRecord getOneByPayNo(String payNo) &#123; return getOne(Wrappers.&lt;XcPayRecord&gt;lambdaQuery().eq(XcPayRecord::getPayNo, payNo)); &#125;&#125; 扫码下单ControllerOrderController@ApiOperation(&quot;扫码下单接口&quot;)@RequestMapping(&quot;/requestpay&quot;)public void requestPay(String payNo, HttpServletResponse httpResponse) throws IOException &#123; // 判断支付记录号是否存在 XcPayRecord xcPayRecord = xcPayRecordService.getOneByPayNo(payNo); if (xcPayRecord == null) &#123; throw new BizException(&quot;支付记录不存在&quot;); &#125; if (xcPayRecord.getStatus().equals(&quot;601002&quot;)) &#123; // 该支付记录已成功支付 throw new BizException(&quot;已支付，无需重复支付&quot;); &#125; // 发起支付请求 AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE); AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest(); // 异步接收地址，仅支持http/https，公网可访问 request.setNotifyUrl(NOTIFY_URL); /******必传参数******/ JSONObject bizContent = new JSONObject(); //商户订单号，商家自定义，保持唯一性 bizContent.put(&quot;out_trade_no&quot;, payNo); //支付金额，最小值0.01元 bizContent.put(&quot;total_amount&quot;, xcPayRecord.getTotalPrice()); //订单标题，不可使用特殊符号 bizContent.put(&quot;subject&quot;, xcPayRecord.getOrderName()); /******可选参数******/ //手机网站支付默认传值FAST_INSTANT_TRADE_PAY bizContent.put(&quot;product_code&quot;, &quot;QUICK_WAP_WAY&quot;); request.setBizContent(bizContent.toString()); String form = &quot;&quot;; try &#123; form = alipayClient.pageExecute(request).getBody(); &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); throw new BizException(&quot;拉取支付宝支付失败&quot;); &#125; httpResponse.setContentType(&quot;text/html;charset=&quot; + AlipayConfig.CHARSET); httpResponse.getWriter().write(form); httpResponse.getWriter().flush();&#125;"},{"title":"查询支付结果","path":"/wiki/learning-online/12-orders/queryresult.html","content":"在支付完成后可以主动向支付宝查询支付的结果，用于更新支付记录和订单的状态；支付成功，通过消息队列的方式异步通知学习中心微服务，将选课记录添加到我的课表中。 接口信息 值 路径地址 http://localhost:63020/orders/payresult 请求方式 GET 请求参数 String 返回结果 PayRecordVO RabbitMQ消息队列是异步调用的实现方式之一，本项目选择RabbitMQ框架完成异步通知： 发送消息前，将消息保存到本地数据库； 消息成功发送到交换机（exchange）时，删除数据库消息记录，即保存到历史消息表中； 当消息从交换机（exchange）到队列（queue）时发生异常，也要将消息保存到数据库 安装RabbitMQ使用Docker方式进行安装 docker pull rabbitmq 使用下面命令启动MQ容器 docker run \\-d \\--hostname mq1 \\--name mq \\-p 15672:15672 \\-p 5672:5672 \\-e RABBITMQ_DEFAULT_USER=swcode \\-e RABBITMQ_DEFAULT_PASS=123321 \\rabbitmq:3-management Maven依赖 &lt;!-- 消息队列 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 发布订阅常见exchange类型包括： Fanout：广播 Direct：路由 Topic：话题 注意：exchange负责消息路由，而不是存储，路由失败则消息丢失 生产者消息确认RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。 返回结果有两种方式： publisher-confirm，发送者确认消息成功投递到交换机，返回ack消息未投递到交换机，返回nack publisher-return，发送者回执消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。注意：确认机制发送消息时，需要给每个消息设置一个全局唯一id，以区分不同消息，避免ack冲突 再配置文件中开启： spring: rabbitmq: publisher-confirm-type: correlated # 开启publisher-confirm，且选择correlated：【异步】回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback publisher-returns: true # 开启publish-return功能 template: mandatory: true # 定义当消息从交换机路由到队列失败时的策略。【true，则调用ReturnCallback；false：则直接丢弃消息】 消息队列配置创建交换机和队列，并绑定队列和交换机，同时在回调中处理失败消息。 在learning-online-orders-service工程中（生产者）创建配置类 PayNotifyConfig PayNotifyConfig@Slf4j@Configurationpublic class PayNotifyConfig implements ApplicationContextAware &#123; // 交换机 public static final String PAY_NOTIFY_EXCHANGE_FANOUT = &quot;pay_notify_exchange_fanout&quot;; // 支付结果通知消息类型 public static final String Message_TYPE = &quot;pay_result_notify&quot;; // 支付通知队列 public static final String PAY_NOTIFY_QUEUE = &quot;pay_notify_queue&quot;; // 声明交换机，且持久化 @Bean(PAY_NOTIFY_EXCHANGE_FANOUT) public FanoutExchange payNotifyExchangeFanout() &#123; // 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除 return new FanoutExchange(PAY_NOTIFY_EXCHANGE_FANOUT, true, false); &#125; // 支付通知队列 @Bean(PAY_NOTIFY_QUEUE) public Queue coursePublishQueue() &#123; return QueueBuilder.durable(PAY_NOTIFY_QUEUE).build(); &#125; // 交换机和支付队列绑定 @Bean public Binding bindingCoursePublishQueue(@Qualifier(PAY_NOTIFY_QUEUE) Queue queue, @Qualifier(PAY_NOTIFY_EXCHANGE_FANOUT) FanoutExchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange); &#125; /** * 当消息投递失败时，将消息写入到本地消息表 * exchange到queue失败 */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; // 获取RabbitTemplate RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class); // 消息处理service MqMessageService mqMessageService = applicationContext.getBean(MqMessageService.class); // 设置ReturnCallback rabbitTemplate.setReturnCallback(((message, replyCode, replyText, exchange, routingKey) -&gt; &#123; // 交换机到队列投递失败，记录日志 log.info(&quot;消息发送失败, 应答码: &#123;&#125;, 原因: &#123;&#125;, 交换机: &#123;&#125;, 路由键: &#123;&#125;, 消息: &#123;&#125;&quot;, replyCode, replyText, exchange, routingKey, message); MqMessage mqMessage = JSON.parseObject(message.toString(), MqMessage.class); // 将消息添加到消息表 mqMessageService.addMessage(mqMessage.getMessageType(), mqMessage.getBusinessKey1(), mqMessage.getBusinessKey2(), mqMessage.getBusinessKey3()); &#125;)); &#125;&#125; 每个 RabbitTemplate 只能配置一个ReturnCallback，因此需要在项目加载时添加配置，为此需要实现ApplicationContextAware（实现了ApplicationContextAware接口的实现类，在Spring容器的Bean工厂创建完毕后会通知该实现类） ReturnCallback的回调函数：当消息成功发送到交换机，但是没有成功发送到消息队列时，回退到回调函数，应该如何处理？就是回调函数里面的内容 在learning-online-learning-service工程中（消费者）创建配置类 PayNotifyConfig 消费端配置一份，保证消费端先启动时不会报错 PayNotifyConfig/** * 消费端配置一份，保证消费端先启动时不会报错 */@Configurationpublic class PayNotifyConfig &#123; // 交换机 public static final String PAY_NOTIFY_EXCHANGE_FANOUT = &quot;pay_notify_exchange_fanout&quot;; // 支付结果通知消息类型 public static final String Message_TYPE = &quot;pay_result_notify&quot;; // 支付通知队列 public static final String PAY_NOTIFY_QUEUE = &quot;pay_notify_queue&quot;; // 声明交换机，且持久化 @Bean(PAY_NOTIFY_EXCHANGE_FANOUT) public FanoutExchange payNotifyExchangeFanout() &#123; // 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除 return new FanoutExchange(PAY_NOTIFY_EXCHANGE_FANOUT, true, false); &#125; // 支付通知队列 @Bean(PAY_NOTIFY_QUEUE) public Queue coursePublishQueue() &#123; return QueueBuilder.durable(PAY_NOTIFY_QUEUE).build(); &#125; // 交换机和支付队列绑定 @Bean public Binding bindingCoursePublishQueue(@Qualifier(PAY_NOTIFY_QUEUE) Queue queue, @Qualifier(PAY_NOTIFY_EXCHANGE_FANOUT) FanoutExchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange); &#125;&#125; 查询service在com.swx.orders.service包下的 OrderService 中定义查询结果方法： OrderService/** * 查询支付结果 * * @param payNo 支付交易号 * @return 交付结果 */PayRecordVO queryRequestPay(String payNo); 在实现类中实现该方法 ConfirmCallback【可以在发送消息时指定】因为每个业务处理confirm成功或失败的逻辑不一定相同 注意：确认机制发送消息时，需要给每个消息设置一个全局唯一id，以区分不同消息，避免ack冲突 XcPayRecordServiceImpl/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author sw-code * @since 2023-09-04 */@Servicepublic class XcPayRecordServiceImpl extends ServiceImpl&lt;XcPayRecordMapper, XcPayRecord&gt; implements XcPayRecordService &#123; private final XcOrdersService xcOrdersService; private final XcPayRecordService xcPayRecordService; private final TransactionTemplate transactionTemplate; private final RabbitTemplate rabbitTemplate; private final MqMessageService mqMessageService; @Value(&quot;$&#123;pay.qrcodeUrl&#125;&quot;) private String qrcodeUrl; public OrderServiceImpl(XcOrdersService xcOrdersService, XcPayRecordService xcPayRecordService, TransactionTemplate transactionTemplate, RabbitTemplate rabbitTemplate, MqMessageService mqMessageService) &#123; this.xcOrdersService = xcOrdersService; this.xcPayRecordService = xcPayRecordService; this.transactionTemplate = transactionTemplate; this.rabbitTemplate = rabbitTemplate; this.mqMessageService = mqMessageService; &#125; /** * 查询支付结果 * * @param payNo 支付交易号 * @return 交付结果 */ @Override public PayRecordVO queryRequestPay(String payNo) &#123; PayStatusDTO payStatusDTO = queryPayResultFromAlipay(payNo); // 更新 transactionTemplate.executeWithoutResult(status -&gt; &#123; try &#123; saveAlipayStatus(payStatusDTO); &#125; catch (Exception e) &#123; status.setRollbackOnly(); &#125; &#125;); XcPayRecord oneByPayNo = xcPayRecordService.getOneByPayNo(payNo); PayRecordVO payRecordVO = new PayRecordVO(); BeanUtils.copyProperties(oneByPayNo, payRecordVO); return payRecordVO; &#125; /** * 更新支付记录和订单状态 * @param dto 支付宝支付状态 */ @Transactional(rollbackFor = Exception.class) @Override public void saveAlipayStatus(PayStatusDTO dto) &#123; String payNo = dto.getOut_trade_no(); XcPayRecord oneByPayNo = xcPayRecordService.getOneByPayNo(payNo); if (oneByPayNo == null) &#123; throw new BizException(&quot;找不到相关的支付记录&quot;); &#125; Long orderId = oneByPayNo.getOrderId(); XcOrders xcOrder = xcOrdersService.getById(orderId); if (xcOrder == null) &#123; throw new BizException(&quot;找不到相关连的订单&quot;); &#125; String status = oneByPayNo.getStatus(); if (status.equals(&quot;601002&quot;)) &#123; return; &#125; String tradeStatus = dto.getTrade_status(); if (!tradeStatus.equals(&quot;TRADE_SUCCESS&quot;)) &#123; return; &#125; oneByPayNo.setStatus(&quot;601002&quot;); // 支付宝订单号 oneByPayNo.setOutPayNo(dto.getTrade_no()); oneByPayNo.setOutPayChannel(&quot;Alipay&quot;); oneByPayNo.setPaySuccessTime(LocalDateTime.now()); xcPayRecordService.updateById(oneByPayNo); // 更新订单表状态 xcOrder.setStatus(&quot;600002&quot;); xcOrdersService.updateById(xcOrder); // 消息写入数据库, 消息类型，选课ID，购买课程（订单类型），null MqMessage mqMessage = mqMessageService.addMessage(&quot;pay_result_notify&quot;, xcOrder.getOutBusinessId(), xcOrder.getOrderType(), null); // 发送消息 notifyPayResult(mqMessage); &#125; /** * 通知支付结果 * * @param mqMessage 结果 */ @Override public void notifyPayResult(MqMessage mqMessage) &#123; // 1. 将消息体转为Json String jsonMsg = JSON.toJSONString(mqMessage); // 2. 设消息的持久化方式为PERSISTENT，即消息会被持久化到磁盘上，确保即使在RabbitMQ服务器重启后也能够恢复消息。 Message msgObj = MessageBuilder.withBody(jsonMsg.getBytes()).setDeliveryMode(MessageDeliveryMode.PERSISTENT).build(); // 3. 封装CorrelationData，用于跟踪消息的相关信息 CorrelationData correlationData = new CorrelationData(mqMessage.getId().toString()); // 3.1 添加一个Callback对象，该对象用于在消息确认时处理消息的结果 correlationData.getFuture().addCallback(result -&gt; &#123; if (result != null &amp;&amp; result.isAck()) &#123; // 3.2 消息成功发送到交换机，删除消息表中的记录 log.debug(&quot;消息发送成功：&#123;&#125;&quot;, jsonMsg); mqMessageService.completed(mqMessage.getId()); &#125; else &#123; // 3.3 消息发送失败 log.error(&quot;消息发送失败，id：&#123;&#125;，原因：&#123;&#125;&quot;, mqMessage.getId(), result); &#125; &#125;, ex -&gt; &#123; // 3.4 消息异常 log.error(&quot;消息发送异常，id：&#123;&#125;，原因：&#123;&#125;&quot;, mqMessage.getId(), ex.getMessage()); &#125;); // 4. 发送消息 // 发送消息 rabbitTemplate.convertAndSend(PayNotifyConfig.PAY_NOTIFY_EXCHANGE_FANOUT, &quot;&quot;, msgObj , correlationData); &#125; /** * 查询支付宝，获取支付状态 * * @param payNo 支付交易号 * @return 交付结果 */ public PayStatusDTO queryPayResultFromAlipay(String payNo) &#123; AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE); AlipayTradeQueryRequest request = new AlipayTradeQueryRequest(); JSONObject bizContent = new JSONObject(); bizContent.put(&quot;out_trade_no&quot;, payNo); request.setBizContent(bizContent.toString()); AlipayTradeQueryResponse response = null; try &#123; response = alipayClient.execute(request); &#125; catch (AlipayApiException e) &#123; throw new BizException(&quot;请求支付查询支付结果异常&quot;); &#125; if (!response.isSuccess()) &#123; throw new BizException(&quot;请求支付查询支付结果失败&quot;); &#125; String body = response.getBody(); // 解析支付结果 Map bodyMap = JSON.parseObject(body, Map.class); Map alipayTradeQueryResponse = (Map) bodyMap.get(&quot;alipay_trade_query_response&quot;); String tradeNo = (String) alipayTradeQueryResponse.get(&quot;trade_no&quot;); String tradeStatus = (String) alipayTradeQueryResponse.get(&quot;trade_status&quot;); String totalAmount = (String) alipayTradeQueryResponse.get(&quot;total_amount&quot;); PayStatusDTO payStatusDTO = new PayStatusDTO(); payStatusDTO.setOut_trade_no(payNo); payStatusDTO.setTrade_no(tradeNo); payStatusDTO.setTrade_status(tradeStatus); payStatusDTO.setApp_id(APP_ID); payStatusDTO.setTotal_amount(totalAmount); return payStatusDTO; &#125;&#125; 学习中心微服务在学习中心微服务中添加消息队列的依赖信息，并添加yaml配置 &lt;!-- 消息队列 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;learning-online-message-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; shared-configs: - data-id: rabbitmq-$&#123;spring.profiles.active&#125;.yaml group: learning-online-common refresh: true 监听消息队列 在learning-online-learning-service工程的service.impl包下创建监听类ReceivePayNotifyService ReceivePayNotifyService@Slf4j@Servicepublic class ReceivePayNotifyService &#123; private final MyCourseTablesService myCourseTablesService; public ReceivePayNotifyService(MyCourseTablesService myCourseTablesService) &#123; this.myCourseTablesService = myCourseTablesService; &#125; @RabbitListener(queues = PayNotifyConfig.PAY_NOTIFY_QUEUE) public void receive(Message message) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; log.debug(&quot;消费睡眠异常:&quot;, e); &#125; // 解析消息，转为对象 String jsonMessage = new String(message.getBody()); MqMessage mqMessage = JSON.parseObject(jsonMessage, MqMessage.class); // 订单类型 String orderType = mqMessage.getBusinessKey2(); if (!orderType.equals(&quot;60201&quot;)) &#123; // 不是购买课程的订单类型 return; &#125; String chooseCourseId = mqMessage.getBusinessKey1(); // 更新选课记录表 boolean b = myCourseTablesService.payChooseCourseSuccess(chooseCourseId); if (b) &#123; throw new BizException(&quot;保存选课记录状态失败&quot;); &#125; &#125;&#125; 查询ControllerOrderController@ApiOperation(&quot;查询支付结果&quot;)@RequestMapping(&quot;/payresult&quot;)public PayRecordVO payResult(String payNo) &#123; return orderService.queryRequestPay(payNo);&#125;"},{"title":"Redis缓存","path":"/wiki/redis/03_cache/index.html","content":"什么是缓存缓存就是数据交换的缓冲区（称作Cache），是存贮数据的临时地方，一般读写性能较高。 缓存的作用 降低后端负载 提高读写效率，降低响应时间 缓存的成本 数据一致性成本 代码维护成本 运维成本 添加Redis缓存缓存工作模型 代码实现import cn.hutool.core.util.StrUtil;import cn.hutool.json.JSONUtil;public static final String CACHE_SHOP_KEY = &quot;cache:shop:&quot;;@Servicepublic class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Shop queryById(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; // 从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 判断是否存在 if (StrUtil.isNotBlank(shopJson)) &#123; // 存在 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return shop; &#125; // 不存在，查询数据库 Shop shop = getById(id); if (shop != null) &#123; // 存在，写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop)); &#125; return shop; &#125;&#125; 缓存更新策略三种策略 内存淘汰 超时剔除 主动更新 说明 不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存 给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存 编写业务逻辑，在修改数据库的同时，更新缓存 一致性 差 一般 好 维护成本 无 低 高 业务场景： 低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存 高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存 主动更新策略三种模式 Cache Aside Pattern：由缓存的调用者，在更新数据库的同时更新缓存。 ✅ Read&#x2F;Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。 Write Behind Caching Pattern：调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致。 三个问题 删除缓存还是更新缓存？ 更新缓存：每次更新数据时都更新缓存，无效写操作太多 ❌ 删除缓存：更新数据库时让缓存失效，查询时再更新缓存 ✅ 如何保证缓存与数据库的操作的同时成功或失败？ 单体系统，将缓存与数据库操作放在同一个事务 分布式系统，利用TCC等分布式事务方案 先操作缓存还是先操作数据库？ 先删除缓存，再操作数据库 先操作数据库，再删除缓存 ✅ 最佳实践方案 第一致性需求：使用Redis自带的内存淘汰机制 高一致性需求：主动更新，并以超时剔除作为兜底方案 读操作： 缓存命中则直接返回 缓存未命中查询数据库，并写入缓存，设定超时时间 写操作 先写数据库，然后再删除缓存 要确保数据库与缓存操作的原子性 代码实操在查询操作中添加超时时间 @Servicepublic class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Shop queryById(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; // 从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 判断是否存在 if (StrUtil.isNotBlank(shopJson)) &#123; // 存在 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return shop; &#125; // 不存在，查询数据库 Shop shop = getById(id); if (shop != null) &#123; // 存在，写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); &#125; return shop; &#125;&#125; 更新操作 @Servicepublic class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override @Transactional public Boolean update(Shop shop) &#123; Long id = shop.getId(); if (id == null) &#123; return null; &#125; // 1.更新数据库 Boolean state1 = updateById(shop); // 2.删除缓存 String key = RedisConstants.CACHE_SHOP_KEY + shop.getId(); Boolean state2 = stringRedisTemplate.delete(key); return state1 &amp;&amp; state2; &#125;&#125; 缓存穿透缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会到达数据库。 常见的两种解决方案 缓存空对象 优点：实现简单 缺点：额外的内存消耗，可能造成短期的不一致 布隆过滤 优点：内存占用少，没有多余key 缺点：实现复杂，存在误判可能 通常采用第一种方式 实现思路 代码实操更新之前的查询代码，解决内存穿透问题 @Overridepublic Shop queryById(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; // 从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 判断是否存在 if (StrUtil.isNotBlank(shopJson)) &#123; // 存在 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return shop; &#125; // 判断命中的是否为空值 =&gt; shopJson == &quot;&quot; if (shopJson != null) &#123; // 返回错误信息 return null; &#125; // 不存在，查询数据库 Shop shop = getById(id); if (shop != null) &#123; // 存在，写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); &#125; else &#123; // 不存在，写入空值，解决内存穿透问题 stringRedisTemplate.opsForValue().set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); &#125; return shop;&#125; 当查询不存在的数据时，缓存为空值 总结缓存穿透产生的原因是什么？ 用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大的压力 缓存穿透的解决方案有哪些？ 缓存null值 布隆过滤 增强id的复杂度，避免被猜测id规律 做好数据的基础格式校验 加强用户权限校验 做好热点参数的限流 缓存雪崩缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力 解决方案 给不同的Key的TTL添加随机值 利用Redi集群提高服务的可用性 给缓存业务添加降级限流策略 给业务添加多级缓存 缓存击穿缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大冲击。 解决方案 互斥锁 逻辑过期 KEY VALUE heima:user:1 {name:”Jack”, age:”21”, expire:”114514114514”} 优缺点 解决方案 优点 缺点 互斥锁 没有额外的内存消耗保证一致性实现简单 线程需要等待，性能受影响 可能有死锁风险 逻辑过期 线程无需等待，性能较好 不保证一致性有额外的内存消耗实现复杂 互斥锁 优点 没有额外的内存消耗 保证一致性 实现简单 缺点 线程需要等待，性能受影响 可能有死锁风险 逻辑过期 优点 线程无需等待，性能较好 缺点 不保证一致性 有额外的内存消耗 实现复杂 代码实操互斥锁解决 利用互斥锁解决缓存击穿问题 public Shop queryWithMutex(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; // 从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 判断是否存在 if (StrUtil.isNotBlank(shopJson)) &#123; // 存在 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return shop; &#125; // 判断命中的是否为空值 =&gt; shopJson == &quot;&quot; if (&quot;&quot;.equals(shopJson)) &#123; // 返回错误信息 return null; &#125; // 实现缓存重建 // 获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY + id; Shop shop = null; try &#123; boolean isLock = tryLock(lockKey); if (!isLock) &#123; // 失败，休眠并重试 Thread.sleep(50); return queryWithMutex(id); &#125; // 成功，查询数据库 shop = getById(id); if (shop != null) &#123; // 存在，写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); &#125; else &#123; // 不存在，写入空值，解决内存穿透问题 stringRedisTemplate.opsForValue().set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); &#125; &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; finally &#123; // 释放互斥锁 unLock(lockKey); &#125; return shop;&#125;// 获取锁private boolean tryLock(String key) &#123; Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag);&#125;// 释放锁private void unLock(String key) &#123; stringRedisTemplate.delete(key);&#125; 逻辑过期解决 基于逻辑过期方式解决缓存击穿问题，数据需要提前写入Redis 代码 private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);public Shop queryWithLogicalExpire(Long id) &#123; String key = CACHE_SHOP_KEY + id; // 从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 判断是否存在 if (StrUtil.isBlank(shopJson)) &#123; // 不存在，直接返回 return null; &#125; // 命中，需要先把json反序列化为对象 RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class); Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class); LocalDateTime expireTime = redisData.getExpireTime(); // 判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) &#123; // 未过期，直接返回店铺信息 return shop; &#125; // 过期，需要重建缓存 // 缓存重建 // 获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey); // 判断是否获取锁成功 if (isLock) &#123; // DoubleCheck String doubleShopJson = stringRedisTemplate.opsForValue().get(key); RedisData doubleRedisData = JSONUtil.toBean(doubleShopJson, RedisData.class); if (doubleRedisData.getExpireTime().isAfter(LocalDateTime.now())) &#123; // 未过期，直接返回店铺信息 return JSONUtil.toBean((JSONObject) doubleRedisData.getData(), Shop.class); &#125; // 成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123; try &#123; // 重建缓存 saveShop2Redis(id, 1800L); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; // 释放锁 unLock(lockKey); &#125; &#125;); &#125; // 返回过期的商铺信息 return shop;&#125;// 数据预热private void saveShop2Redis(Long id, Long expireSeconds) &#123; // 查询店铺数据 Shop shop = getById(id); // 逻辑过期时间 RedisData redisData = new RedisData(); redisData.setData(shop); redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); // 写入redis String key = RedisConstants.CACHE_SHOP_KEY + id; stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));&#125; 缓存工具封装基于StringRedisTemplate封装一个缓存工具类，满足下列需求： 方法1：将任意java对象序列化为json并存储在string类型中的key中，并且可以设置TTL过期时间 方法2：将任意java对象序列化为json并存储在string类型中的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题。 方法3：根据指定key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题 方法4：根据指定key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题 方法1+方法3：设置过期时间，解决缓存穿透 方法2+方法4：针对热点key，解决缓存击穿 工具类工具类代码@Slf4j@Componentpublic class CacheClient &#123; private final StringRedisTemplate stringRedisTemplate; public CacheClient(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; public void set(String key, Object value, Long time, TimeUnit unit) &#123; stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit); &#125; public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) &#123; // 设置逻辑过期 RedisData redisData = new RedisData(); redisData.setData(value); redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time))); // 写入Redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); &#125; // 解决缓存穿透问题 public &lt;R, ID&gt; R queryWithPassThrough( String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123; String key = keyPrefix + id; // 从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); // 判断是否存在 if (StrUtil.isNotBlank(json)) &#123; // 存在 return JSONUtil.toBean(json, type); &#125; // 判断命中的是否为空值 =&gt; &quot;&quot;.equals(shopJson) if (json != null) &#123; // 返回错误信息 return null; &#125; // 不存在，查询数据库 R r = dbFallback.apply(id); if (r != null) &#123; // 存在，写入redis this.set(key, r, time, unit); &#125; else &#123; // 不存在，写入空值，解决内存穿透问题 stringRedisTemplate.opsForValue().set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); &#125; return r; &#125; // 解决缓存击穿问题，逻辑过期 private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); public &lt;R, ID&gt; R queryWithLogicalExpire(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123; String key = keyPrefix + id; // 从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); // 判断是否存在 if (StrUtil.isBlank(json)) &#123; // 不存在，直接返回 return null; &#125; // 命中，需要先把json反序列化为对象 RedisData redisData = JSONUtil.toBean(json, RedisData.class); R r = JSONUtil.toBean((JSONObject) redisData.getData(), type); LocalDateTime expireTime = redisData.getExpireTime(); // 判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) &#123; // 未过期，直接返回店铺信息 return r; &#125; // 过期，需要重建缓存 // 缓存重建 // 获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey); // 判断是否获取锁成功 if (isLock) &#123; // DoubleCheck String json2 = stringRedisTemplate.opsForValue().get(key); RedisData redisData2 = JSONUtil.toBean(json2, RedisData.class); if (redisData2.getExpireTime().isAfter(LocalDateTime.now())) &#123; // 未过期，直接返回店铺信息 return JSONUtil.toBean((JSONObject) redisData2.getData(), type); &#125; // 成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123; try &#123; // 重建缓存 R r1 = dbFallback.apply(id); this.setWithLogicalExpire(key, r1, time, unit); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; // 释放锁 unLock(lockKey); &#125; &#125;); &#125; // 返回过期的商铺信息 return r; &#125; private boolean tryLock(String key) &#123; Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); &#125; private void unLock(String key) &#123; stringRedisTemplate.delete(key); &#125;&#125; 使用方法@Overridepublic Shop queryById(Long id) &#123; // 缓存穿透 Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES); // 逻辑过期解决缓存击穿 // Shop shop = cacheClient.queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES); return shop;&#125;"},{"title":"Redis客户端","path":"/wiki/redis/02_start/cli.html","content":"安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括： 命令行客户端 图形化桌面客户端 变成客户端 命令行客户端Redis安装完成后就自带了命令行客户端：redis-cli 使用如下命令 redis-cli [options] [commonds] 其中常见的options有： -h 127.0.0.1：指定要连接的redis节点的IP地址，默认是127.0.0.1 -p 6379：指定要连接的redis节点的端口，默认是6379 -a 123123：指定redis的访问密码 其中的commands就是Redis的操作命令，例如： ping：与redis服务端做心跳测试，服务端正常会返回pong 不指定，则进入redis-cli的交互控制台 图形化桌面客户端 下载地址：AnotherRedisDesktopManager、RedisDesktopManager 安装完成后就可以使用了 Java客户端在Redis官网提供了各种语言的客户端，地址：https://redis.io/clients Java常用客户端 Jedis lettuce SpringDataRedis Jedis Jedis官网地址：https://github.com/redis/jedis 快速入门 新建Maven工程，引入下面的依赖 &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 编写测试类，与Redis建立连接 private Jedis jedis;@BeforeEachvoid setUp() &#123; // 获取连接 jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); // 设置密码 jedis.auth(&quot;123123&quot;); // 选择库 jedis.select(0);&#125; 操作方法 @Testvoid testString() &#123; String result = jedis.set(&quot;name&quot;, &quot;swcode&quot;); System.out.println(&quot;result = &quot; + result); // 获取数据 String name = jedis.get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name);&#125; 释放资源 @AfterEachvoid tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125;&#125; Jedis连接池 Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式 public class JedisConnectionFactory &#123; private static final JedisPool jedisPool; static &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(8); poolConfig.setMaxIdle(8); poolConfig.setMinIdle(0); poolConfig.setMaxWaitMillis(1000); // 创建连接池对象 jedisPool = new JedisPool(poolConfig,&quot;127.0.0.1&quot;, 6379, 1000, &quot;123123&quot;); &#125; public static Jedis getJedis() &#123; return jedisPool.getResource(); &#125;&#125; 从连接池中获取jedis对象 jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);// 改为jedis = JedisConnectionFactory.getJedis(); SpringDataRedis SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis 官网地址：https://spring.io/projects/spring-data-redis 提供了对不同Redis客户端的整合（Lettuce和Jedis） 提供了对不同RedisTemplate同一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： 快速入门SpringBoot已经提供了对SpringDataRedis的支出，使用非常简单： 使用Spring Initializr创建SpringBoot项目，选择以下依赖： Lombok Spring Data Redis 确保引入以下依赖 &lt;!-- Redis依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 连接池依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 编写配置文件 spring: redis: host: 127.0.0.1 port: 6379 password: 123123 lettuce: pool: max-active: 8 max-idle: 8 min-idle: 8 max-wait: 100ms 编写测试类执行测试方法 @SpringBootTestclass RedisDemoApplicationTests &#123; @Autowired private RedisTemplate redisTemplate; @Test void testString() &#123; redisTemplate.opsForValue().set(&quot;name&quot;, &quot;Google&quot;); Object name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(name); &#125;&#125; RedisSerializer配置 RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化 得到的结果是这样的： 缺点： 可读性差 内存占用较大 解决方案： 配置Reids @Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; // 1.创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 2.设置连接工厂 template.setConnectionFactory(connectionFactory); // 3.创建序列化对象 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 4.设置key和hashKey采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); template.setHashKeySerializer(stringRedisSerializer); // 5.设置value和hashValue采用json的序列化方式 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); return template; &#125;&#125; 此时我们已经将RedisTemplate的key设置为String序列化，value设置为Json序列化的方式，再来执行方法测试 由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个对象 @Testvoid testSaveUser() &#123; redisTemplate.opsForValue().set(&quot;user:100&quot;, new User(&quot;swcode&quot;, 21)); Object name = redisTemplate.opsForValue().get(&quot;user:100&quot;); System.out.println(name);&#125; 尽管Json序列化可以满足我们的需求，但是依旧存在一些问题。 如上图所示，为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。 那么我们如何解决这个问题呢？我们可以通过下文的StringRedisTemplate来解决这个问题。 StringRedisTemplate 为了节省内存空间，直接使用String序列化器，只储存String类型的key和value。存储对象时，手动完成对象的序列化和反序列化 Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程 测试StringReidsTemplate @SpringBootTestclass RedisDemoApplicationTests &#123; @Autowired private StringRedisTemplate stringRedisTemplate; ObjectMapper objectMapper = new ObjectMapper(); @Test void testStringSaveObj() throws JsonProcessingException &#123; User user = new User(&quot;胡歌&quot;, 21); String json = objectMapper.writeValueAsString(user); stringRedisTemplate.opsForValue().set(&quot;user:101&quot;,json); // 获取数据 String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:101&quot;); User user1 = objectMapper.readValue(jsonUser, User.class); System.out.println(&quot;user = &quot; + user1); &#125;&#125; 在图形客户端查看结果 总结 RedisTemplate的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，手动把对象序列化JSON 读取Redis时，手动把读取到的JSON反序列化为对象"},{"title":"Redis","path":"/wiki/redis/02_start/index.html","content":"​ Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 认识NoSQL什么是NOSQL NoSQL最常见的解释是”non-relational“， 很多人也说它是”Not Only SQL“ NoSQL仅仅是一个概念，泛指非关系型的数据库 区别于关系数据库，它们不保证关系数据的ACID特性 NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入 常见的NoSQL数据库有：Redis、MemCache、MongoDB等 SQL和NoSQL的差别 SQL No SQL 数据结构 结构化 非结构化 数据关联 关联的 无关联的 查询方式 SQL查询 非SQL 事务特性 ACID BASE 存储方式 磁盘 内存 扩展性 垂直 水平 使用场景 1）数据结构固定2）相关业务对数据安全性、一致性要求较高 1）数据结构不稳定2）对一致性、安全性要求不高3）对性能要求 认识Redis Redis诞生于2009年全称是**Remote Dictionary Server**，远程词典服务器，是一个基于内存的键值型NoSQL数据库。 Redis的特征： 键值（key-value）型，value支持多种不同数据结构，功能丰富。 单线程，每个命令具备原子性（新版本网络多线程）。 低延迟，速度快（基于内存、IO多路复用、良好的编码）。 支持数据持久化 支持主从集群、分片集群 支持多语言客户端","tags":[null],"categories":[null]},{"title":"Redis的安装","path":"/wiki/redis/02_start/redis-install.html","content":"本次安装基于Mac系统，使用brew进行安装，其他系统以及其他方式可自行百度 redis官网：https://redis.io 准备 使用mac的包管理工具brew安装，若未安装brew，可在命令行输入下面命令进行安装 /bin/bash -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 安装 在终端运行下面命令： brew install redis 安装信息 ==&gt; Downloading https://mirrors.ustc.edu.cn/homebrew-bottles/bottles/redis-6.0.1######################################################################## 100.0%==&gt; Pouring redis-6.0.1.mojave.bottle.tar.gz==&gt; CaveatsTo have launchd start redis now and restart at login: brew services start redisOr, if you don&#x27;t want/need a background service you can just run: redis-server /usr/local/etc/redis.conf==&gt; Summary🍺 /usr/local/Cellar/redis/6.0.1: 13 files, 3.7MB redis默认安装在/usr/local/Cellar下，配置文件redis.conf在/usr/local/etc下。 Redis启停 启动redis brew services start redis 查看redis启动状态 brew services info redis 如果redis正在运行，你将看到下面信息 redis (homebrew.mxcl.redis)Running: ✔Loaded: ✔User: mirandaPID: 67975 关闭redis brew services stop redis 配置Redis打开配置文件 使用下面命令，打开目录 open /usr/local/etc 找到redis.conf，使用文本编辑器打开 修改配置文件 修改配置文件 # 监听的地址，默认是127.0.0.1，会导致只能在本地访问，修改为0.0.0.0可在任意地址访问bind 0.0.0.0# 设置守护进程，后台运行daemonize yes# 设置密码requirepass 123123 其他常见配置，可不修改 # 监听的端口prot 6397# 工作目录dir .# 数据库数量databases 16# 设置redis能够使用的最大内存maxmemory 512mb# 日志文件，默认为空 logfile &quot;redis.log&quot;"},{"title":"Redis常见数据结构","path":"/wiki/redis/02_start/struct.html","content":"Redis数据结构介绍 Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样 官方学习文档 https://redis.io/commands/ Redis通用命令 KEYS：查看符合模板的所有key，不建议在生产环境设备上使用 DEL：删除一个指定的key EXISTS：判断key是否存在 EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除 EXPIRE name 10 # 10s TTL：查看一个KEY的剩余有效期 可以通过help [command] 可以查看一个命令的具体用法！ String类型 String类型，也就是字符串类型，是Redis中最简单的存储类型。 其value是字符串，不过根据字符串的格式不同，又可分为3类： string：普通字符串 int：整数类型，可做自增、自减操作 float：浮点类型，可做自增、自减操作 不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m. KEY VALUE msg Hello world num 10 score 92.5 String常见命令有： SET：添加或者修改已存在的一个String类型的键值对 GET：根据key获取String类型的value MSET：批量添加多个String类型的键值对 MGET：根据多个key获取多个String类型的value INCR：让一个整型key自增1 INCRBY：让一个整型key自增并且指定步长，例如： INCRBY age -1 # 自减，等同DECR INCRBYFLOAT：让一个浮点类型的数字自增并指定步长 SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX：添加一个String类型的键值对，并且指定有效期 Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下： 项目名:业务名:类型:id 这个格式并非固定，也可以根据自己的需求来删除或添加词条。 例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key： user相关的key：heima:user:1 product相关的key：heima:product:1 如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储 KEY VALUE heima:user:1 {“id”:1, “name”: “Jack”, “age”: 21} heima:product:1 {“id”:1, “name”: “小米11”, “price”: 4999} Hash类型 Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD Hash常见的命令 HSET key field value：添加或者修改hash类型的key的field值 HGET key field：获取一个hash类型key的field值 HMSET：批量添加多个hash类型key的field值 HMGET：批量获取多个hash类型的key的field值 HGETALL：获取一个hash类型的key中所有field和value HKEYS：获取一个hash类型的key中的所有的field HVALS：获取一个hash类型的key中的所有的value HINCRBY：让一个hash类型key的字段自增且指定步长 HINCRBY test:hash age 2 HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 List类型 Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。 特征也与LinkedList类似： 有序 元素可重复 插入和删除块 查询速度一般 常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等. List常见的命令： LPUSH key [element]：向列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有返回null RPUSH key [element]：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key star end：返回一段角标范围内的所有元素 BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回null 思考 如何利用List结构模拟一个栈？ 先进后出，入口和出口在同一边 如何利用List结构模拟一个队列 先进先出，入口和出口在不同边 如何利用List结构模拟一个阻塞队列？ 入口和出口在不同边 出队时采用BLPOP或BRPOP Set类型 Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。 因为也是一个hash表，因此具备与HashSet类似的特征： 无序 元素不可重复 查找快 支持交集、并集、差集等功能 Set类型常见的命令 SADD key member：向set中添加一个或多个元素 SREM ley member：移除set中的指定元素 SCARD key：返回set中元素个数 SISMEMBER key member：判断一个元素是否存在于set中 SMEMBERS：获取set中的所有元素 SINTER key1 key2：求key1与key2的交集 SDIFF key1 key2：求key1与key2的差集 SUNION key1 key2：求key1与key2的并集 SortedSet类型 Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。 SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet类型常见的命令 ZADD key score member：添加一个或多个元素到sorted set，如果已经存在则更新其score值 ZREM key member：删除sorted set中的一个指定元素 ZSCORE key member：获取sorted set中指定元素的score值 ZRANK key member：获取sorted set中指定元素的排名 ZCARD key：获取sorted set中元素的个数 ZCOUNT key min max：统计score值在给定范围内所有元素的个数 ZINCRBY key increment member：让sorted set中指定元素自增，步长为指定的increment值 ZRANGE key min max：按照score排序后，获取指定范围排名内的元素 ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素 ZDIFF、ZINTER、ZUNION：求差、交集、并集 注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可"},{"title":"GEO数据结构","path":"/wiki/redis/geo/index.html","content":"GEO就是Geolocation的简写形式，代表地理坐标。Redis在6.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。 常见命令 GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member） GEODIST：计算指定的两个点之间的距离并返回 GEOHASH：将指定member的坐标转化为hash字符串形式并返回 GEOPOS：返回指定member的坐标 GEORADIUS：指定圆心、半径，找到该园内包含的所有member，并按照与圆心之间的距离排序后返回。6.2以后已废弃 GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2以后新功能。 GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。6.2以后新功能。 使用案例需求： 添加下面几条数据： 北京南站（116.378248 39.865275） 北京站（116.42803 39.903738） 北京西站（116.322287 39.893729） 计算北京西站到北京站的距离 搜索天安门（116.397904 39.909005）附近10km内的所有火车站，并按照距离升序排序 添加命令 GEOADD g1 116.378248 39.865275 bjn 116.42803 39.903738 bjz 116.322287 39.893729 bjx 计算距离 GEODIST g1 bjx bjz km&quot;9.0916&quot; 搜索 GEOSEARCH g1 FROMLONLAT 116.397904 39.909005 BYRADIUS 10 km WITHDIST1) 1) &quot;bjz&quot; 2) &quot;2.6361&quot;2) 1) &quot;bjn&quot; 2) &quot;5.1452&quot;3) 1) &quot;bjx&quot; 2) &quot;6.6723&quot;"},{"title":"分布式缓存","path":"/wiki/redis/04_advance/dispersed-cache.html","content":"单点Redis的问题数据丢失问题：Redis是内存存储，服务器重启可能丢失数据 实现Redis数据持久化 并发能力问题：单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景 搭建主从集群，实现读写分离 故障恢复问题：如果Redis宕机，则服务不可用，需要一种自动恢复手段 利用Redis哨兵，实现健康检测和自动恢复 存储能力问题：Redis基于内存，单节点存储的数据量难以满足海量数据需求 搭建分片集群，利用插槽机制实现动态扩容 Redis持久化RDB持久化RDB全称Redis Database Backup file（Redis数据备份文件），也叫Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。 快照文件成为RDB，默认保存在当前运行目录 save：由Redis主进程来执行RDB，会阻塞所有命令 bgsave：开启子进程执行RDB，避免主进程收到影响 Reids停机会执行一次RDB Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下 # 900秒内，如果至少有一个key被修改，则执行bgsace，如果是save &quot;&quot;则表示禁用RDBsave 900 1save 200 10save 60 10000 RDB的其他配置也可以在redis.conf文件中设置： # 是否压缩，不建议开启，压缩也会消耗CPU，磁盘的话不值钱rdbcompression yes# RDB文件名称dbfilename dump.rdb# 文件保存的路径目录dir ./ bgsave开始会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件 fork采用的是copy-on-write技术： 当主进程执行读操作时，访问共享内存 当主进程执行写操作时，则会拷贝一份数据，执行写操作。 总结 RDB方式bgsave的基本流程 fork主进程得到一个子进程，共享内存空间 子进程读取内存数据并写入新的RDB文件 用新RDB文件替换旧的RDB文件 RDB会在什么时候执行？save 60 1000代表什么含义？ 默认时服务停止时。 代表60秒内至少执行1000次修改则触发RDB RDB的缺点？ RDB执行时隔时间长，两次RDB之间写数据有丢失的风险 fork子进程、压缩、写出RDB文件都比较耗时 AOF持久化AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。恢复时，从头执行文件中的命令。 AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF： # 是否开启AOF功能，默认是noappendonly yes# AOF文件的名称appendfilename &quot;appendonly.aof&quot; AOF的命令记录的频率也可以通过redis.conf文件来配： # 表示每执行一次写命令，立即记录到AOF文件appendfsync always# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案appendfsync everysec# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘appendfsync no no: don’t fsync, just let the OS flush the data when it wants. Faster. always: fsync after every write to the append only log. Slow, Safest. everysec: fsync only one time every second. Compromise. 配置项 刷盘时机 优点 缺点 always 同步刷盘 可靠性高，几乎不丢数据 性能影响大 everysec 每秒刷盘 性能适中 最多丢失1s数据 no 操作系统控制 性能最好 可靠性差，肯能丢失大量数据 重写 因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。 127.0.0.1:6379&gt; BGREWRITEAOFBackground append only file rewriting started Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置 # AOF文件比上次文件增长超过多少百分比则触发重写auto-aof-rewrite-percentage 100# AOF文件体积最小多大以上才触发重写auto-aof-rewrite-min-size 64mb 比较RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。 RDB AOF 持久化方式 定时对整个内存做快照 记录每一次执行的命令 数据完整性 不完整，两次备份之间会丢失 相对完整，取决于刷盘策略 文件大小 会有压缩，文件体积小 记录命令，文件体积很大 宕机恢复速度 很快 慢 数据恢复优先级 低，因为数据完整性不如AOF 高，因为数据完整性更高 系统资源占用 高，大量CPU和内存消耗 低，主要是磁盘IO资源但AOF重写时会占用大量CPU和内存 使用场景 可以容忍数分钟的数据丢失追求更快的启动速度 对数据安全性要求较高常见 Redis主从单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。 搭建主从集群详情查看： Redis主从集群搭建https://sx-code.github.io/2022/11/16/Redis安装系列教程/#Redis主从集群 数据同步原理全量同步主从第一次同步是全量同步： master如何判断slave是不是第一次来同步数据？这里会用到两个很重要的概念： Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有一个唯一的replid，slave则会继承master节点的replid offset：偏移量，随记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。 因此slave做数据同步，必须向master声明自己的replication id和offset，master才可以判断到底需要同步哪些数据。 详情可以查看打印的日志。 总结 简述全量同步的流程？ slave节点请求增量同步 master节点判断replid，发现不一致，拒绝增量同步 master将完整内存数据生成RDB，发送RDB到slave slave清空本地数据，加载master的RDB master将RDB期间的命令记录在real_baklog，并持续将log中的命令发送给slave slave执行接受到的命令，保持与master之间的同步 增量同步如果slave重启后同步，则执行增量同步 repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做数据增量同步，只能再次全量同步 优化可以从以下几个方面来优化Redis主从集群： 在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。 Redis单节点的内存占用不要太大，减少RDB导致过多的磁盘IO。 适当提高repl_baklog的大小，发现slave宕机时尽快故障恢复，尽可能避免全量同步。 限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力 总结简述全量同步和增量同步的区别？ 全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。 增量同步：slave提交给自己的offset到master，master获取real_baklog中从offset之后的命令给slave 什么时候执行全量同步？ slave节点第一次连接master节点时 slave节点断开时间太久，repl_baklog中的offset已经被覆盖时 什么时候执行增量同步？ slave节点断开又恢复，并且在repl_baklog中能找到offset时 Redis哨兵slave节点宕机恢复后可以找master节点同步数据，那master节点宕机怎么办？ 哨兵的作用和原理哨兵的作用Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下： 监控：Sentinel会不断检查您的master和slave是否按预期工作 自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。 通知：Sentinel充当Redis客户端的服务来源，当集群发生故障转移时，会讲最新信息推送给Redis的客户端 服务状态监控Sentinel基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令： 主观下线：如果sentinel节点发现某实例未在规定时间响应，则认为实例主观下线。 客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。 选举新的master一旦发现master故障，sentinel需要在slave中选择一个作为新的master，依据是这样的： 首先会判断salve节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高 最后是判断slave节点的运行id大小，越小优先级越高。 如何实现故障转移当选中了其中一个slave为新的master后（例如slave1），故障的转移的步骤如下： sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master sentinel给所有其他slave发送slaveof 192.168.150.101 7002命令，让这些slave成为新master的从节点，开始从新的master上同步数据。 最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点。 总结Sentinel的三个作用是什么？ 监控 故障转移 通知 Sentinel如和判断一个redis实例是否健康？ 每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线 如果大多数sentinel都认为实例主观下线，则判定服务下线 故障转移步骤有哪些？ 首先选定一个slave作为新的master，执行slaveof no one 然后让所有节点都执行slaveof 新master 修改故障节点配置，添加slaveof 新master 搭建哨兵集群搭建过程可查看： 搭建哨兵集群https://sx-code.github.io/2022/11/16/Redis安装系列教程/#搭建哨兵集群 RedisTemplate的哨兵模式在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。 搭建项目 新建一个Spring Boot项目，在pom中引入redis的starter依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 然后在配置文件application.yml中指定sentinel相关信息： logging: level: io.lettuce.core: debug pattern: dateformat: MM-dd HH:mm:ss:SSSspring: redis: sentinel: master: mymaster nodes: - 192.168.52.101:27001 - 192.168.52.101:27002 - 192.168.52.101:27003 配置主从读写分离 @Beanpublic LettuceClientConfigurationBuilderCustomizer configurationBuilderCustomizer() &#123; return clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);&#125; 这里的ReadFrom是配置Redis的读写策略，是一个枚举，包括下面选择： MASTER：从主节点读取 MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica REPLICA：从slave（replica）节点读取 REPLICA_PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master 写一个Controller @RestControllerpublic class HelloController &#123; private final StringRedisTemplate stringRedisTemplate; public HelloController(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @GetMapping(&quot;/get/&#123;key&#125;&quot;) public String hi(@PathVariable(&quot;key&quot;) String key) &#123; return stringRedisTemplate.opsForValue().get(key); &#125; @GetMapping(&quot;/set/&#123;key&#125;/&#123;value&#125;&quot;) public String hi(@PathVariable(&quot;key&quot;) String key, @PathVariable(&quot;value&quot;) String value) &#123; stringRedisTemplate.opsForValue().set(key, value); return &quot;success&quot;; &#125;&#125; 测试访问http://localhost:8080/get/num，可以在日志中看到读命令是交给了slave7003 dispatching command AsyncCommand [type=GET, output=ValueOutput [output=null, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command][channel=0xd02617c1, /192.168.52.1:49821 -&gt; /192.168.52.101:7003, epid=0x8] write() writeAndFlush command AsyncCommand [type=GET, output=ValueOutput [output=null, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command][channel=0xd02617c1, /192.168.52.1:49821 -&gt; /192.168.52.101:7003, epid=0x8] write() done 访问http://localhost:8080/set/num/666，可以在日志中看到写命令是交给了master7002 dispatching command AsyncCommand [type=SET, output=StatusOutput [output=null, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command][channel=0xf240bccb, /192.168.52.1:49823 -&gt; /192.168.52.101:7002, epid=0xa] write() writeAndFlush command AsyncCommand [type=SET, output=StatusOutput [output=null, [channel=0xf240bccb, /192.168.52.1:49823 -&gt; /192.168.52.101:7002, epid=0xa] write() done 此时我们将主节点7002关掉，等待一段时间后，会看到7001成功成为新的master，来到IDEA项目的日志窗口，会看到打印了很多日志 [channel=0xbdf66d4c, /192.168.52.1:49846 -&gt; /192.168.52.101:27001, epid=0xe, chid=0x19] Completing command SubscriptionCommand [type=SENTINEL, output=MapOutput [output=&#123;name=mymaster, ip=192.168.52.101, port=7001, runid=15057e012c11ea30ae9e20fe1f9e2ea2243efa70, flags=master, link-pending-commands=0, link-refcount=1, last-ping-sent=0, last-ok-ping-reply=451, last-ping-reply=451, down-after-milliseconds=5000, info-refresh=7803, role-reported=master, role-reported-time=10012, config-epoch=7, num-slaves=2, num-other-sentinels=2, quorum=2, failover-timeout=60000, parallel-syncs=1&#125;, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command] 可以看到到7001的flag=master 再次访问http://localhost:8080/get/num，可以看到是slave7003处理了GET命令。 dispatching command AsyncCommand [type=GET, output=ValueOutput [output=null, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command][channel=0x8764567f, /192.168.52.1:49839 -&gt; /192.168.52.101:7003, epid=0x8] write() writeAndFlush command AsyncCommand [type=GET, output=ValueOutput [output=null, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command][channel=0x8764567f, /192.168.52.1:49839 -&gt; /192.168.52.101:7003, epid=0x8] write() done Redis分片集群分片集群结构主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题还没有解决： 海量数据存储问题 高并发写的问题 使用分片集群可解决上述问题，分片集群特征： 集群中有多个master，每个master保持不同数据 每个master都可以有多个slave节点 master之间通过ping检测彼此健康状态 客户端请求可以访问集群人意节点，最终都会被转发到正确节点 需要说明的是，分片集群里面的主从是不需要依赖哨兵的，当其中一个主节点宕机也是可以由另外的从节点顶替上 搭建分片集群搭建过程可查看： 搭建分片集群https://sx-code.github.io/2022/11/16/Redis安装系列教程/#搭建分片集群 散列插槽Redis会把每个master节点映射到0～16383共16384个插槽（hash slot）上，查看集群信息时就能看到： 数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况： key中包含”{}”，且”{}”中至少包含1个字符，”{}”中的部分时有效部分 key中不包含”{}”，整个key都是有效部分 例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方法是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。 测试使用下面命令连接Redis集群 redis-cli -c -p 7001 set一个值 127.0.0.1:7001&gt; set num 123OK 再set一个值 set a 1-&gt; Redirected to slot [15495] located at 192.168.52.101:7003OK192.168.52.101:7003&gt; a计算得到的hash值为15495，该值所在的节点为7003 get一个值 192.168.52.101:7003&gt; get a&quot;1&quot; 再get一个值 192.168.52.101:7003&gt; get num-&gt; Redirected to slot [2765] located at 192.168.52.101:7001&quot;123&quot;192.168.52.101:7001&gt; 可以看到已经切换到7001了 总结Redis如何判断某个key应该在哪个实例？ 将16384个插槽分配到不同实例 根据key的有效部分计算哈希值，对16384取余 余数作为插槽，寻找插槽所在的实例即可 如何将同一类数据固定的保持在同一个Redis实例？ 这一类数据使用相同的有效部分，例如key都以{typeId}为前缀 集群伸缩添加一个节点到集群redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看： redis-cli --cluster help 比如，添加节点和删除节点命令 add-node new_host:new_port existing_host:existing_port --cluster-slave --cluster-master-id &lt;arg&gt;del-node host:port node_id 添加一个新的master节点，并向其中存储num&#x3D;10，其步骤如下： 启动一个新的redis实例，端口为7004 添加7004到之前的集群，并作为一个master节点 给7004节点分配插槽，使得num这个key可以存储到7004实例 具体操作 创建并启动实例 mkdir 7004cp redis.conf 7004/sed -i s/6379/7004/g 7004/redis.confredis-server 7004/redis.conf 查看是否成功启动 ps -ef | grep redis 添加到集群 redis-cli --cluster add-node 192.168.52.101:7004 192.168.52.101:7001 查看是否添加成功 redis-cli -p 7001 cluster nodes 分配插槽，从7001到7004 redis-cli --cluster reshard 192.168.52.101:7001 接下来的步骤会提示下面信息，根据自己需要填写即可 How many slots do you want to move (from 1 to 16384)? 这里我们直接输入3000，因为num的hash值是2765 What is the receiving node ID? 我们是要移动到7004，所以输入7004的ID，可以从上面复制 Please enter all the source node IDs. ​\tType ‘all’ to use all the nodes as source nodes for the hash slots. Type ‘done’ once you entered all the source nodes IDs. 插槽的数据源，我们是7001，所以填入7001的ID，同样从上面复制 输入done继续 Do you want to proceed with the proposed reshard plan (yes&#x2F;no)? 输入yes 查看是否分配成功 [root@localhost opt]# redis-cli -p 7001 cluster nodese5850b5810751d294a82607dd7931687561c73f7 192.168.52.101:7004@17004 master - 0 1668781636405 7 connected 0-2999 get一下num值 redis-cli -c -p 7001127.0.0.1:7001&gt; get num# 会自动跳转到7004Redirected to slot [2765] located at 192.168.52.101:7004&quot;123&quot;192.168.52.101:7004&gt; 设置num的值为10 192.168.52.101:7004&gt; set num 10OK 从集群删除一个节点删除slave节点 redis-cli --cluster del-node 节点ip:port 节点id 删除master节点 先对节点进行分片工作，防止数据丢失 redis-cli --cluster reshard 欲删除节点ip:port 移除节点 redis-cli --cluster del-node 节点ip:port 节点id 使用下面命令删除7004节点 redis-cli --cluster reshard 192.168.52.101:7004redis-cli --cluster del-node 192.168.52.101:7004 e5850b5810751d294a82607dd7931687561c73f7 分配步骤参考添加节点，目标是移动7004上的3000个插槽到7001 验证是否成功 redis-cli -p 7001 cluster nodes 故障转移当集群中有一个master宕机会发生什么呢？ 我们使用watch命令监听集群 watch redis-cli -p 7001 cluster nodes 再开启一个窗口，停止7002 cd /optredis-cli -p 7002 shutdown 等待一会我们看到7002 fail，而8002成为了master 我们再次启动7002 cd /optredis-server 7002/redis.conf 启动瞬间，7002成功连接集群，成为slave，实现了主从故障切换 数据迁移利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下： 手动的Failover支持三种不同模式： 缺省：默认的流程，如图1～6步 force：省略了对offset的一致性校验 takeover：直接执行第5步，忽略数据一致性、忽略master状态和其他master的意见 在7002这个slave节点执行手动故障转移，重新夺回master地位 步骤如下： 利用redis-cli连接7002这个节点 redis-cli -c -p 7002 执行cluster failover命令 CLUSTER FAILOVER 切换后通过命令查看状态 redis-cli -p 7001 cluster nodes RedisTemplate访问分片集群RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致： 搭建项目 新建一个Spring Boot项目，在pom中引入redis的starter依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 然后在配置文件application.yml中指定sentinel相关信息： logging: level: io.lettuce.core: debug pattern: dateformat: MM-dd HH:mm:ss:SSSspring: redis: cluster: nodes: - 192.168.52.101:7001 - 192.168.52.101:7002 - 192.168.52.101:7003 - 192.168.52.101:8001 - 192.168.52.101:8002 - 192.168.52.101:8003 配置主从读写分离，可省略 @Beanpublic LettuceClientConfigurationBuilderCustomizer configurationBuilderCustomizer() &#123; return clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);&#125; 这里的ReadFrom是配置Redis的读写策略，是一个枚举，包括下面选择： MASTER：从主节点读取 MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica REPLICA：从slave（replica）节点读取 REPLICA_PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master 写一个Controller @RestControllerpublic class HelloController &#123; private final StringRedisTemplate stringRedisTemplate; public HelloController(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @GetMapping(&quot;/get/&#123;key&#125;&quot;) public String hi(@PathVariable(&quot;key&quot;) String key) &#123; return stringRedisTemplate.opsForValue().get(key); &#125; @GetMapping(&quot;/set/&#123;key&#125;/&#123;value&#125;&quot;) public String hi(@PathVariable(&quot;key&quot;) String key, @PathVariable(&quot;value&quot;) String value) &#123; stringRedisTemplate.opsForValue().set(key, value); return &quot;success&quot;; &#125;&#125; 测试访问http://localhost:8080/get/num num是在7001中存储，日志中可以看出最后是交给了7001的从节点8001来执行，成功。 [channel=0x0992eeda, /192.168.52.1:49901 -&gt; /192.168.52.101:8001, epid=0x8, chid=0x8] Completing command AsyncCommand [type=READONLY, output=StatusOutput [output=OK, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command][channel=0x0992eeda, /192.168.52.1:49901 -&gt; /192.168.52.101:8001, epid=0x8] write() writeAndFlush command ClusterCommand [command=AsyncCommand [type=GET, output=ValueOutput [output=null, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command], redirections=0, maxRedirections=5][channel=0x0992eeda, /192.168.52.1:49901 -&gt; /192.168.52.101:8001, epid=0x8] write() done 访问http://localhost:8080/set/num/666 set操作交给了7001，成功。 [channel=0x08f375e0, /192.168.52.1:49902 -&gt; /192.168.52.101:7001, epid=0x9] write() writeAndFlush command ClusterCommand [command=AsyncCommand [type=SET, output=StatusOutput [output=null, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command], redirections=0, maxRedirections=5][channel=0x08f375e0, /192.168.52.1:49902 -&gt; /192.168.52.101:7001, epid=0x9] write() done 访问http://localhost:8080/set/a/666 set a 666的命令是切换到了7003来执行，成功。 [channel=0x85d2adbb, /192.168.52.1:49918 -&gt; /192.168.52.101:7003] writing command ClusterCommand [command=AsyncCommand [type=SET, output=StatusOutput [output=null, error=&#x27;null&#x27;], commandType=io.lettuce.core.protocol.Command], redirections=0, maxRedirections=5][channel=0x85d2adbb, /192.168.52.1:49918 -&gt; /192.168.52.101:7003, epid=0xa] write() done","tags":[null]},{"title":"单点Redis的问题","path":"/wiki/redis/04_advance/index.html","content":"数据丢失问题 Redis是内存存储，服务器重启可能丢失数据 实现Redis数据持久化 并发能力问题 单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景 搭建主从集群，实现读写分离 故障恢复问题 如果Redis宕机，则服务不可用，需要一种自动恢复手段 利用Redis哨兵，实现健康检测和自动恢复 存储能力问题 Redis基于内存，单节点存储的数据量难以满足海量数据需求 搭建分片集群，利用插槽机制实现动态扩容","tags":[null]},{"title":"多级缓存","path":"/wiki/redis/04_advance/multi-cache.html","content":"多级缓存","tags":[null]},{"title":"笔记简介","path":"/wiki/redis/introduce/index.html","content":"在学习Redis时，发现了黑马程序员的一个实战项目（张虎翼老师），于是跟着学习，并用笔记的方式记录学习的过程 可能是史上最懂你的Redis实战课程-2022版课程分为四大篇章，涵盖了Redis的各种数据结构和命令，Redis的各种常见Java客户端的应用和最佳实践。还有Redis在企业中的应用方案，例如共享session、缓存及缓存更新策略、分布式锁、消息队列、秒杀等场景。另外还有Redis的主从、哨兵、集群等的搭建和原理，使用运维过程中的最佳实践方案。最后还会深入学习Redis底层原理、网络模型、通信模型、内存淘汰策略等内容 链接地址： 黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目https://www.bilibili.com/video/BV1cr4y1671t/"},{"title":"饥荒服务器","path":"/wiki/server/DSTServer/index.html","content":"饥荒联机方式 首先明确一点，饥荒的联机方式分为两种： 开房间：通过饥荒客户端创建房间或者恢复房间，其他人通过搜索可进入房间。 服务器：饥荒服务器不同于客户端，可以理解为没有画面的客户端，它能加载存档。服务器开启后其他人可通过搜索方式进入。 服务器种类 服务器有两个类别 本地服务器：顾名思义，服务器搭建在自己的电脑上。当然如果你电脑配置低或者网络不好，仍会导致卡顿问题（可通过内网穿透缓解）。据说电脑好点能解决开房间后期卡顿问题。 云服务器：将饥荒服务器搭建在云平台上。云平台也是一台电脑，只不过它的网络拥有公网IP，我们每个人到达其网络距离都很短，这也是为什么云服务器不会卡顿。 云服务器系统 云服务有系统之分 Windows Server系统，也有不同的版本，例如2012，2016，2019，2022等。 Linux系统，常见的发行版本有：CentOS和Ubuntu。 不同系统的安装方式也有所不同，请按自己需要选择云服务器系统。"},{"title":"项目搭建","path":"/wiki/trip-cloud/02_init/index.html","content":"微服务拆分划分原则基于业务逻辑根据业务需求，模块功能进行拆分，容易产生耦合 基于稳定性稳定性的服务和不稳定的服务不易放在一起，不稳定的服务在更新变化时会影响到稳定性的服务 基于可靠性同样，将系统中的业务模块按照可靠性进行排序。对可靠性要求较高的核心模块归到一起，对可靠性要求不高的非核心模块归在一块。 基于高性能对用户访问量高的核心模块进行拆分，对访问量低的业务进行合并。 项目二拆分用户服务登陆&#x2F;注册功能 文章服务目的地&#x2F;攻略&#x2F;游记管理 点评服务文章评论管理 数据服务负责文章数据统计 搜索服务基于ES全文搜索 项目结构trip-parent # 父项目├── trip-gateway # 网关├── trip-website # 前端├── trip-mgrsite # 前端├── trip-common # 公共模块父项目│ ├── trip-common-core # 核心公共模块│ ├── trip-common-redis # redis公共模块│ └── trip-common-xxx # xxx公共模块├── trip-module-api # 微服务api父项目│ ├── trip-article-api # 文章api│ ├── trip-comment-api # 评论api│ ├── trip-user-api # 用户api│ ├── trip-data-api # 数据api│ └── trip-serch-api # 搜索api├── trip-server # 微服务│ ├── trip-server-article # 文章│ ├── trip-server-comment # 评论│ ├── trip-server-user # 用户│ ├── trip-server-data # 数据│ └── trip-server-serch # 搜索 创建项目父项目创建一个普通的Maven项目，删除其中的src目录，只保留pom.xml。 在父项目的pom中添加如下版本控制 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip_cloud&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!-- 父项目，只负责管理 pom 文件的依赖，不负责代码编译等功能 --&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 父工程 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- 依赖版本的锁定 --&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring-cloud.version&gt;Hoxton.SR10&lt;/spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2.2.5.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;/properties&gt; &lt;!-- 父项目进行统一的依赖版本管理 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 网关模块在trip_cloud父项目下创建子模块trip-gateway，pom文件内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip_cloud&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-gateway&lt;/artifactId&gt; &lt;description&gt;网关服务，作为整个系统的统一入口&lt;/description&gt; &lt;dependencies&gt; &lt;!-- gateway网关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- nacos客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;"},{"title":"笔记简介","path":"/wiki/trip-cloud/01_introduce/index.html","content":"介绍 旅游项目是一个类似蚂蜂窝的旅游网，主要包含下面的功能： 用户登陆&#x2F;注册：使用JWT生成请求Token，使用Redis 控制 Token 的过期时间，使用拦截器解析请求中的Token，根据解析的数据从 Redis 获取用户信息保存到 ThreadLocal 方便获取用户信息。 攻略服务：用户可以在首页根据目的地，分类，主题分组分页查询攻略，对攻略进行评论，点赞，收藏等。 游记服务：游记是由用户发布的，功能同攻略类似，可以根据出发时间范围，人均花费范围，出行天数范围查询游记并根据游记发布时间和热度排序。 评论服务：使用 MongoDB 保存评论数据，实现增删改和分页查询。 搜索服务：使用策略模式设计数据初始化到ES的接口，请求不同的参数可以初始化不同的数据到ES，使用Elasticsearch实现站内数据的搜索，并高亮显示关键词。 后端技术：Spring Cloud + Spring Cloud Alibaba + Mybatis Plus + MySQL + Redis + MongoDB 开发工具：IntelliJ IDEA、ApiPost7 项目亮点 1、SpringCloud从零搭建项目 2、阿里云OSS文件上传 3、JWT + Redis + ThreadLocal实现用户登陆功能，维护 Token 的有效期以及从ThreadLocal获取用户信息。 4、创建线程池，使用多线程执行任务。 5、使用 MongoDB 保存用户评论数据，并实现分页查询。 6、Spring统一异常处理、事件监听、参数解析器定制开发 7、使用策略模式设计数据初始化接口，访问携带不同的参数可以初始化不同的数据到ES，且使用Redis状态保证接口只能执行一次。 项目预览 旅游项目https://sx-code.github.io/wiki/trip-cloud/01_introduce/index.html 页面展示"},{"title":"网关服务","path":"/wiki/trip-cloud/04_gateway/index.html","content":"依赖文件在项目搭建时已经添加，这里进行完善 配置文件新建bootstrap.yaml配置文件，内容如下： spring: application: name: trip-gateway cloud: nacos: server-addr: xxx.xxx.xxx.xxx:8848 config: file-extension: yaml namespace: trip_cloud_dev profiles: active: dev Nacos配置文件 ID：trip-gateway-dev.yaml Group：DEFAULT_GROUP 描述：旅游项目网关配置 配置内容： feign-dev.yamlserver: port: 9000spring: cloud: nacos: server-addr: 124.221.23.47:8848 discovery: namespace: $&#123;spring.cloud.nacos.config.namespace&#125; gateway: discovery: locator: enabled: true globalcors: cors-configurations: &#x27;[/**]&#x27;: allowedOrigins: &quot;*&quot; allowedMethods: - GET - POST - PUT - PATCH - DELETE - OPTIONS allowedHeaders: &quot;*&quot; allowCredentials: true routes: - id: trip_user uri: lb://user-service predicates: - Path=/users/** - Path=/sms/** 启动类创建包com.swx.gateway，创建启动类 TripGatewayApplication TripGatewayApplication@SpringBootApplication@EnableDiscoveryClientpublic class TripGatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TripGatewayApplication.class, args); &#125;&#125; 启动时，需要先启动Nacos"},{"title":"核心模块","path":"/wiki/trip-cloud/03_common/core.html","content":"统一返回结果找到模块 trip-common-core，创建包com.swx.common.core.utils，创建R R@Setter@Getter@NoArgsConstructorpublic class R&lt;T&gt; &#123; public static final int CODE_SUCCESS = 200; public static final String MSG_SUCCESS = &quot;操作成功&quot;; public static final int CODE_NOLOGIN = 401; public static final String MSG_NOLOGIN = &quot;请先登陆&quot;; public static final int CODE_ERROR = 500; public static final int CODE_REGISTER_ERROR = 500; public static final String MSG_ERROR = &quot;系统异常，请联系管理员&quot;; public static final int CODE_ERROR_PARAM = 501; private int code; private String msg; private T data; public R(int code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125; public static &lt;T&gt; R&lt;T&gt; ok(T data) &#123; return new R&lt;&gt;(CODE_SUCCESS, MSG_SUCCESS, data); &#125; public static &lt;T&gt; R&lt;T&gt; ok() &#123; return new R&lt;&gt;(CODE_SUCCESS, MSG_SUCCESS, null); &#125; public static &lt;T&gt; R&lt;T&gt; error(int code, String msg, T data) &#123; return new R&lt;&gt;(code, msg, data); &#125; public static &lt;T&gt; R&lt;T&gt; error(int code, String msg) &#123; return new R&lt;&gt;(code, msg, null); &#125; public static &lt;T&gt; R&lt;T&gt; defaultError() &#123; return new R&lt;&gt;(CODE_ERROR, MSG_ERROR, null); &#125; public static &lt;T&gt; R&lt;T&gt; noLogin() &#123; return new R&lt;&gt;(CODE_NOLOGIN, MSG_NOLOGIN, null); &#125; public static &lt;T&gt; R&lt;T&gt; noPermission() &#123; return new R&lt;&gt;(403, &quot;非法访问&quot;, null); &#125; public T checkAndGet() &#123; if (this.code != CODE_SUCCESS) &#123; throw new BizException(code, msg); &#125; return data; &#125;&#125; 自定义异常创建包com.swx.common.core.exception，新建 BizException BizException/** * 自定义的业务异常 */@Getterpublic class BizException extends RuntimeException &#123; private Integer code = R.CODE_ERROR; public BizException() &#123; super(R.MSG_ERROR); &#125; public BizException(String message) &#123; super(message); &#125; public BizException(Integer code, String message) &#123; super(message); this.code = code; &#125;&#125; Md5Utils包com.swx.common.core.utils，创建 Md5Utils Md5Utils/** * Md5工具类 * */public class Md5Utils &#123; /** * @Description: 生成MD5 * @param message * @return */ public static String getMD5(String message) &#123; String md5 = &quot;&quot;; try &#123; MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); // 创建一个md5算法对象 byte[] messageByte = message.getBytes(&quot;UTF-8&quot;); byte[] md5Byte = md.digest(messageByte); // 获得MD5字节数组,16*8=128位 md5 = bytesToHex(md5Byte); // 转换为16进制字符串 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return md5; &#125; /** * @Description: 二进制转十六进制 * @param bytes * @return */ private static String bytesToHex(byte[] bytes) &#123; StringBuffer hexStr = new StringBuffer(); int num; for (int i = 0; i &lt; bytes.length; i++) &#123; num = bytes[i]; if (num &lt; 0) &#123; num += 256; &#125; if (num &lt; 16) &#123; hexStr.append(&quot;0&quot;); &#125; hexStr.append(Integer.toHexString(num)); &#125; return hexStr.toString().toUpperCase(); &#125; /** * * @Description: 签名：请求参数排序并后面补充key值，最后进行MD5加密，返回大写结果 * @param params 参数内容 * @return */ public static String signatures(Map&lt;String, Object&gt; params)&#123; String signatures = &quot;&quot;; try &#123; List&lt;String&gt; paramsStr = new ArrayList&lt;String&gt;(); for (String key1 : params.keySet()) &#123; if(null != key1 &amp;&amp; !&quot;&quot;.equals(key1))&#123; paramsStr.add(key1); &#125; &#125; Collections.sort(paramsStr); StringBuilder sbff = new StringBuilder(); for (String kk : paramsStr) &#123; String value = params.get(kk).toString(); if (&quot;&quot;.equals(sbff.toString())) &#123; sbff.append(kk + &quot;=&quot; + value); &#125; else &#123; sbff.append(&quot;&amp;&quot; + kk + &quot;=&quot; + value); &#125; &#125; //加上key值 signatures = getMD5(sbff.toString()).toUpperCase(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; return signatures; &#125; public static void main(String[] args) &#123; String str = &quot;12345618888888888&quot;; String pass = Md5Utils.getMD5(str); System.out.println(pass); &#125;&#125;"},{"title":"统一异常处理","path":"/wiki/trip-cloud/03_common/exception.html","content":"将下面代码放到微服务下，即可拦截抛出的异常 ControllerExceptionAdvice@Slf4j@RestControllerAdvicepublic class ControllerExceptionAdvice &#123; @ExceptionHandler(Exception.class) public R&lt;?&gt; commonExceptionHandler(Exception e) &#123; log.error(&quot;[统一异常处理] 拦截到其他异常&quot;, e); return R.defaultError(); &#125; @ExceptionHandler(BizException.class) public R&lt;?&gt; businessException(BizException e) &#123; if (log.isDebugEnabled()) &#123; log.debug(&quot;[统一异常处理] 拦截到业务异常&quot;, e); &#125; else &#123; log.warn(&quot;[统一异常处理] 拦截到业务异常, code=&#123;&#125;, message=&#123;&#125;&quot;, e.getCode(), e.getMessage()); &#125; return R.error(e.getCode(), e.getMessage()); &#125;&#125; 使用方法 if (article == null) &#123;\tthrow new BizException(&quot;没有数据&quot;);&#125;"},{"title":"Redis模块","path":"/wiki/trip-cloud/03_common/redis.html","content":"初始化模块在trip_common父模块下创建子模块trip-common-redis，pom文件内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-common-redis&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建包名：com.swx.common.redis 配置类创建包名：com.swx.common.redis.configure 序列化配置创建：FastJson2JsonRedisSerializer public class Constants &#123; /** * 自动识别json对象白名单配置（仅允许解析的包名，范围越小越安全） */ public static final String[] JSON_WHITELIST_STR = &#123; &quot;org.springframework&quot;, &quot;com.swx&quot; &#125;;&#125; FastJson2JsonRedisSerializer/** * Redis使用FastJson序列化 * * @author ruoyi */public class FastJson2JsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;&#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); static final Filter AUTO_TYPE_FILTER = JSONReader.autoTypeFilter(Constants.JSON_WHITELIST_STR); private Class&lt;T&gt; clazz; public FastJson2JsonRedisSerializer(Class&lt;T&gt; clazz) &#123; super(); this.clazz = clazz; &#125; @Override public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; return JSON.toJSONString(t, JSONWriter.Feature.WriteClassName).getBytes(DEFAULT_CHARSET); &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz, AUTO_TYPE_FILTER); &#125;&#125; Redis配置创建类：RedisConfig RedisConfig/** * redis配置 * */@Configuration@EnableCaching@AutoConfigureBefore(RedisAutoConfiguration.class)public class RedisConfig extends CachingConfigurerSupport&#123; @Bean @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); FastJson2JsonRedisSerializer serializer = new FastJson2JsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; &#125;&#125; Redis工具服务创建包名：com.swx.common.redis.service，并创建类：RedisService RedisServiceimport java.util.Collection;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.BoundSetOperations;import org.springframework.data.redis.core.HashOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;/** * spring redis 工具类 * * @author ruoyi **/@SuppressWarnings(value = &#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)@Componentpublic class RedisService &#123; @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Long timeout, final TimeUnit timeUnit) &#123; redisTemplate.opsForValue().set(key, value, timeout, timeUnit); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) &#123; return expire(key, timeout, TimeUnit.SECONDS); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) &#123; return redisTemplate.expire(key, timeout, unit); &#125; /** * 获取有效时间 * * @param key Redis键 * @return 有效时间 */ public long getExpire(final String key) &#123; return redisTemplate.getExpire(key); &#125; /** * 判断 key是否存在 * * @param key 键 * @return true 存在 false不存在 */ public Boolean hasKey(String key) &#123; return redisTemplate.hasKey(key); &#125; /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; T getCacheObject(final String key) &#123; ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue(); return operation.get(key); &#125; /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) &#123; return redisTemplate.delete(key); &#125; /** * 删除集合对象 * * @param collection 多个对象 * @return */ public boolean deleteObject(final Collection collection) &#123; return redisTemplate.delete(collection) &gt; 0; &#125; /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) &#123; Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; &#125; /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) &#123; return redisTemplate.opsForList().range(key, 0, -1); &#125; /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) &#123; BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key); Iterator&lt;T&gt; it = dataSet.iterator(); while (it.hasNext()) &#123; setOperation.add(it.next()); &#125; return setOperation; &#125; /** * 获得缓存的set * * @param key * @return */ public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) &#123; return redisTemplate.opsForSet().members(key); &#125; /** * 缓存Map * * @param key * @param dataMap */ public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) &#123; if (dataMap != null) &#123; redisTemplate.opsForHash().putAll(key, dataMap); &#125; &#125; /** * 获得缓存的Map * * @param key * @return */ public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) &#123; redisTemplate.opsForHash().put(key, hKey, value); &#125; /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) &#123; HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); &#125; /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) &#123; return redisTemplate.opsForHash().multiGet(key, hKeys); &#125; /** * 删除Hash中的某条数据 * * @param key Redis键 * @param hKey Hash键 * @return 是否成功 */ public boolean deleteCacheMapValue(final String key, final String hKey) &#123; return redisTemplate.opsForHash().delete(key, hKey) &gt; 0; &#125; /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection&lt;String&gt; keys(final String pattern) &#123; return redisTemplate.keys(pattern); &#125;&#125; 自动装配 在其他模块依赖本模块时，自动导入配置类 在resource下创建目录: META-INF，在该目录下创建文件 spring.factories:，内容如下： org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.swx.common.redis.configure.RedisConfig, \\ com.swx.common.redis.service.RedisService Redis Key设计 Redis Key的设计有两种方案：常量类和枚举类，其中枚举类适合单体项目，对于分布式项目应该采用常量类，为Key设计一套规范。 创建包名：com.swx.common.redis.key，并创建接口：KeyPrefix KeyPrefix/** * Redis key 通用规范设计 */public interface KeyPrefix &#123; /** * @return redis key 前缀 */ String getPrefix(); /** * @return 超时时间, -1 表示没有超时时间 */ default Long getTimeout() &#123; return -1L; &#125; /** * @return 超时时间, 如果有超时时间，必须要有单位，没有可不设置 */ default TimeUnit getUnit() &#123; return null; &#125; /** * 拼接完整的key * @param suffix 待拼接 * @return 完整的key */ default String fullKey(String... suffix) &#123; StringBuilder sb = new StringBuilder(100); sb.append(getPrefix()); for (String s : suffix) &#123; sb.append(&quot;:&quot;).append(s); &#125; return sb.toString(); &#125;&#125; 创建类：BaseKeyPrefix，实现 KeyPrefix 接口 BaseKeyPrefix/** * 基础 Redis Key 前缀 */@Setterpublic class BaseKeyPrefix implements KeyPrefix &#123; private String prefix; private Long timeout; private TimeUnit unit; public BaseKeyPrefix(String prefix) &#123; this(prefix, -1L, null); &#125; public BaseKeyPrefix(String prefix, Long timeout, TimeUnit unit) &#123; this.prefix = prefix; this.timeout = timeout; this.unit = unit; &#125; @Override public String getPrefix() &#123; return this.prefix; &#125; @Override public Long getTimeout() &#123; return this.timeout; &#125; @Override public TimeUnit getUnit() &#123; return this.unit; &#125;&#125;"},{"title":"安全模块","path":"/wiki/trip-cloud/03_common/security.html","content":"登陆拦截器： 从请求中获取到 JWT 令牌 利用 JWT 的 SDK 对令牌进行解析，判断是否能够通过校验 只要令牌解析可以通过，就代表令牌是有效的，用户是登陆过的。 Token 续期： 使用 access_token 和 refresh_token，其中 refresh_token 的过期时间是 access_token 的两倍，当 access_token 过期后使用 refresh_token 重新获取 access_token 和 refresh_token，如果 refresh_token 过期则重新登陆。 使用 Redis + JWT：JWT不设置过期时间，其中保存Redis key，拦截器解析出token中的Redis key，从Redis中获取用户信息，从用户信息中取出过期时间，在过期前重新设置Redis key的过期时间以及更新用户的过期时间和登陆时间属性 拦截哪些方法？： 使用自定注解的方式，需要登陆的接口添加自定义注解即可 初始化模块在trip_common父模块下创建子模块trip-common-security，pom文件内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-common-security&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- JWT --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;!-- or jjwt-gson if Gson is preferred --&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建包名：com.swx.common.security 配置类创建包名：com.swx.common.redis.configure Jwt配置类创建：JwtProperties，需要从配置文件中读取两个配置信息。 JwtProperties@Getter@Setter@ConfigurationProperties(prefix = &quot;jwt&quot;)public class JwtProperties &#123; private String secret; private Integer expireTime;&#125; Web配置类注册自定义的拦截器 WebConfig@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; private final LoginInterceptor loginInterceptor; public WebConfig(LoginInterceptor loginInterceptor) &#123; this.loginInterceptor = loginInterceptor; &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(loginInterceptor); WebMvcConfigurer.super.addInterceptors(registry); &#125;&#125; 自动配置类创建：JwtAutoConfiguration，用于引入其他配置 JwtAutoConfiguration@Configuration@Import(WebConfig.class)@EnableConfigurationProperties(JwtProperties.class)public class JwtAutoConfiguration &#123; @Bean public LoginInterceptor loginInterceptor(TokenService tokenService) &#123; return new LoginInterceptor(tokenService); &#125;&#125; Redis Key 安全模块下的Redis Key 应该遵循设计规范，因此创建类： LoginRedisKeyPrefix，继承 BaseKeyPrefix 在模块trip-common-security中创建包：com.swx.common.security.key，在该包下创建类：LoginRedisKeyPrefix LoginRedisKeyPrefixpublic class LoginRedisKeyPrefix extends BaseKeyPrefix &#123; public static final LoginRedisKeyPrefix USER_LOGIN_INFO_STRING = new LoginRedisKeyPrefix(&quot;USER:LOGIN:INFO&quot;); public LoginRedisKeyPrefix(String prefix) &#123; super(prefix); &#125; public LoginRedisKeyPrefix(String prefix, Long timeout, TimeUnit unit) &#123; super(prefix, timeout, unit); &#125;&#125; Token工具服务主要负责生成 JWT Token，从Token中解析Redis key，并从Redis中获取用户信息，登陆状态的续期 需要定义一个能保存用户信息和登陆时间过期时间的对象类，用于续期 在com.swx.common.security.vo下创建: LoginUser @Getter@Setterpublic class LoginUser &#123; private Long id; private String nickname; // 昵称 private Long loginTime; // 登陆时间 private Long expireTime; // 过期时间 private String token;&#125; TokenService/** * token验证处理 */@Componentpublic class TokenService &#123; public static final String TOKEN_HEADER = &quot;Token&quot;; private static final String LOGIN_USER_REDIS_UUID = &quot;uuid&quot;; private static final long MINUTES_MILLISECONDS = 60 * 1000L; private static final long TWENTY_MILLISECONDS = 20 * MINUTES_MILLISECONDS; private final SecretKey key; private final JwtProperties jwtProperties; private final RedisService redisService; public TokenService(JwtProperties jwtProperties, RedisService redisService) &#123; this.jwtProperties = jwtProperties; this.redisService = redisService; this.key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtProperties.getSecret())); &#125; /** * 创建 Token * @param loginUser 用户信息 * @return token */ public String createToken(LoginUser loginUser) &#123; // 设置登陆时间和过期时间 long now = System.currentTimeMillis(); loginUser.setLoginTime(now); long expireTime = now + jwtProperties.getExpireTime() * MINUTES_MILLISECONDS; loginUser.setExpireTime(expireTime); // 生成UUID String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); loginUser.setToken(uuid); // 将用户信息缓存到Redis中, 设置过期时间 String redisKey = UserRedisKeyPrefix.USER_LOGIN_INFO_STRING.fullKey(uuid); redisService.setCacheObject(redisKey, loginUser, expireTime, TimeUnit.MICROSECONDS); // 4. 使用JWT生成TOKEN，存入基础信息 return Jwts.builder() .id(loginUser.getId().toString()) .claim(LOGIN_USER_REDIS_UUID, uuid) .signWith(key).compact(); &#125; /** * 获取用户身份信息 * * @return 用户信息 */ public LoginUser getLoginUser(String token) &#123; // 判断 Token 是否有效 SecretKey key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtProperties.getSecret())); Claims body = Jwts.parser().verifyWith(key).build().parseSignedClaims(token).getPayload(); String uuid = (String) body.get(LOGIN_USER_REDIS_UUID); // 从Redis中获取用户对象 String redisKey = UserRedisKeyPrefix.USER_LOGIN_INFO_STRING.fullKey(uuid); return redisService.getCacheObject(redisKey); &#125; /** * 刷新令牌有效期 * * @param loginUser 登录信息 */ public void refreshToken(LoginUser loginUser) &#123; long loginTime; if ((loginUser.getExpireTime() - (loginTime = System.currentTimeMillis())) &lt;= TWENTY_MILLISECONDS) &#123; // 如果用户过期剩余时间小于20分钟，刷新过期时间 loginUser.setLoginTime(loginTime); long expireTime = loginTime + jwtProperties.getExpireTime() * MINUTES_MILLISECONDS; loginUser.setExpireTime(expireTime); // 将刷新后的时间覆盖Redis String redisKey = UserRedisKeyPrefix.USER_LOGIN_INFO_STRING.fullKey(loginUser.getToken()); redisService.setCacheObject(redisKey, loginUser, expireTime, TimeUnit.MICROSECONDS); &#125; &#125; public static void main(String[] args) &#123; Key key = Jwts.SIG.HS256.key().build(); String secretString = Encoders.BASE64.encode(key.getEncoded()); System.out.println(secretString); &#125;&#125; 获取用户工具创建包：com.swx.common.security.util，在包下创建类: AuthenticationUtil public class AuthenticationUtil &#123; private static final ThreadLocal&lt;LoginUser&gt; USER_HOLDER = new ThreadLocal&lt;&gt;(); public static HttpServletRequest getRequest() &#123; ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (requestAttributes == null) &#123; throw new BizException(&quot;该方法只能在Spring MVC 环境下调用&quot;); &#125; return requestAttributes.getRequest(); &#125; public static String getToken() &#123; return getRequest().getHeader(TokenService.TOKEN_HEADER); &#125; /** * 从Token或者缓存中获取User * @return 登陆用户 */ public static LoginUser getLoginUser() &#123; LoginUser cacheUser = USER_HOLDER.get(); if (cacheUser != null) &#123; return cacheUser; &#125; String token = getToken(); if (StringUtils.isEmpty(token) || token.equals(&quot;undefined&quot;)) &#123; return null; &#125; TokenService tokenService = SpringContextUtil.getBean(TokenService.class); LoginUser loginUser = tokenService.getLoginUser(token); USER_HOLDER.set(loginUser); return loginUser; &#125; /** * 清空缓存中的User */ public static void removeUser() &#123; USER_HOLDER.remove(); &#125;&#125; 为了方便在非Spring管理的类中获取Srping Bean，我们需要使用如下工具 SpringContextUtil/** * Spring工具类,获取Spring上下文对象等 * * @author swcode * @since 2023/10/26 13:31 */@Componentpublic class SpringContextUtil implements ApplicationContextAware &#123; private static ApplicationContext applicationContext = null; /** * 1. SpringContextUtil 被 JVM 加载时, applicationContext 作为静态属性, 就被初始化了, 但是此时是 null 值 * 2. 当 Spring 容器初始化以后, 会管理 SpringContextUtil Bean 对象 * 3. 当 Spring 创建 SpringContextUtil 实例对象时, * 在初始化阶段会自动调用实现了 ApplicationContextAware 的 setApplicationContext 方法, * 此时该类中原本静态容器属性就从 null 变成了容器对象 * 4. 当容器启动成功后, 其他业务代码通过该类的静态成员, 就可以直接的访问容器对象, 从容器对象中获取其他 Bean 对象 */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; if (SpringContextUtil.applicationContext == null) &#123; SpringContextUtil.applicationContext = applicationContext; System.out.println(&quot;----------&quot; + applicationContext); &#125; &#125; public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; public static Object getBean(String name) &#123; return getApplicationContext().getBean(name); &#125; public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(clazz); &#125; public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(name, clazz); &#125;&#125; 登陆拦截器创建包：com.swx.common.security.interceptor，在包下创建类: LoginInterceptor 流程如下： 从request中解析Token信息 校验并解析Token中的Redis key，从Redis中获取用户信息 登陆状态续期 LoginInterceptor@Slf4j@Componentpublic class LoginInterceptor implements HandlerInterceptor &#123; private final TokenService tokenService; public LoginInterceptor(TokenService tokenService) &#123; this.tokenService = tokenService; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (!(handler instanceof HandlerMethod)) &#123; // handler =&gt; 静态资源 // handler =&gt; CORS 的预请求 return true; &#125; // 将 handler 对象转换为 HandlerMethod 对象 HandlerMethod handlerMethod = (HandlerMethod) handler; // 从 HandlerMethod 对象中获取对应的 Controller 对象 Class&lt;?&gt; clazz = handlerMethod.getBeanType(); Method method = handlerMethod.getMethod(); // 从 Controller 和 HandlerMethod 上获取 @RequireLogin 注解 if (clazz.isAnnotationPresent(RequireLogin.class) || method.isAnnotationPresent(RequireLogin.class)) &#123; // 1. 从请求头中获取 jwt token String token = request.getHeader(TokenService.TOKEN_HEADER); // 2. 基于 jwt sdk 解析 token，解析失败 try &#123; LoginUser loginUser = tokenService.getLoginUser(token); if (loginUser == null) &#123; throw new BizException(401, &quot;Token 已失效&quot;); &#125; // 未失效，刷新Token tokenService.refreshToken(loginUser); &#125; catch (BizException e) &#123; throw e; &#125; catch (Exception e) &#123; log.warn(&quot;[登陆拦截] jwt token 解析失败&quot;); throw new BizException(401, &quot;用户未认证&quot;); &#125; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // 请求执行完成之后，准备响应之前 // 线程即将完成本次请求，将当前线程存储的数据清楚 AuthenticationUtil.removeUser(); &#125;&#125; 别忘了注册登陆拦截器 自动装配 在其他模块依赖本模块时，自动导入配置类 在resource下创建目录: META-INF，在该目录下创建文件 spring.factories:，内容如下： org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.swx.common.security.configure.JwtAutoConfiguration, \\ com.swx.common.security.service.TokenService"},{"title":"初始化模块","path":"/wiki/trip-cloud/05_user/init.html","content":"API模块在trip_modules-api父模块下创建子模块trip-users-api，pom文件内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-modules-api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-users-api&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 只在编译和测试生效，运行时不生效，阻止依赖的传递性 --&gt; &lt;/dependency&gt; &lt;!-- Redis模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common-redis&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建数据库实体类：UserInfo，首先创建com.swx.user.domain包，在该包下创建实体类。 UserInfo@Getter@Setter@TableName(&quot;userinfo&quot;)public class UserInfo &#123; public static final int GENDER_SECRET = 0; // 保密 public static final int GENDER_MALE = 1; // 男 public static final int GENDER_FEMALE = 2; // 女 public static final int STATE_NORMAL = 0; // 正常 public static final int STATE_DISABLE = 1; // 冻结 @TableId(type = IdType.AUTO) private Long id; private String nickname; // 昵称 private String phone; // 手机 private String email; // 邮箱 private String password; // 密码 private Integer gender = GENDER_SECRET; // 性别 private Integer level = 0; // 用户级别 private String city; // 所在城市 private String headImgUrl; // 头像 private String info; // 个性签名 private Integer state = STATE_NORMAL; // 状态&#125; 微服务模块 API模块不需要启动类，在运行时不需要Mybatis Plus的依赖，但是开发时使用到了注解，所需使用scope限制只在编译和测试依赖，并且阻止依赖的传递性。而Server需要运行时依赖，所以不使用scope。 api和server都引入了依赖，但是使用scope限制api中依赖的传递。这样的好处是，当service不需要api中的依赖时，能避免因为引入依赖而没有配置导致项目启动失败。 在trip_modules父模块下创建子模块trip-users-server，pom文件内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip_modules&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-users-server&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-users-api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Nacos注册中心 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置文件：bootstrap.yaml，内容如下： spring: application: name: user-service cloud: nacos: server-addr: xxx.xxx.xxx.xxx:8848 config: file-extension: yaml namespace: trip_cloud_dev profiles: active: dev Nacos配置文件 ID：user-service-dev.yaml Group：DEFAULT_GROUP 描述：用户微服务配置 配置内容： user-service-dev.yamlserver: port: 8091spring: cloud: nacos: server-addr: xxx.xxx.xxx.xxx:8848 discovery: namespace: $&#123;spring.cloud.nacos.config.namespace&#125; datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///trip-user?serverTimezone=GMT%2B8&amp;useSSL=false&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: xxxxxx 配置网关路由 ID：trip-gateway-dev.yaml Group：DEFAULT_GROUP 描述：旅游项目网关配置 配置内容： trip-gateway-dev.yaml- id: trip_user uri: lb://user-service predicates: # 路径匹配, 前缀匹配方式, 只要以 /product-serv/ 开头的请求, 都会被转发到 uri 上去 - Path=/u/** # 过滤器, 执行真正的转发之前, 要执行哪些过滤器 filters: # StripPrefix: 跳过前缀的过滤器, 此处配置为 1 则表示在转发请求前, 自动将第一个前缀删除 # 例如: 请求地址为 /product-serv/products/1, 此时将前缀删除后, 会变成 /products/1 - StripPrefix=1 创建启动类：TripUsersApplication，首先创建com.swx.user包，在该包下创建。 TripUsersApplication@SpringBootApplication@MapperScan(&quot;com.swx.user.mapper&quot;)public class TripUsersApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TripUsersApplication.class, args); &#125;&#125; 创建 UserInfoMapper，首先创建com.swx.user.mapper包，在该包下创建。 继承Mybatis Plus的BaseMapper UserInfoMapperpublic interface UserInfoMapper extends BaseMapper&lt;UserInfo&gt; &#123;&#125; 创建 UserInfoService，首先创建com.swx.user.service包，在该包下创建。 继承Mybatis Plus的IService UserInfoServicepublic interface UserInfoService extends IService&lt;UserInfo&gt; &#123;&#125; 实现 UserInfoService，首先创建com.swx.user.service.impl包，在该包下创建。 继承Mybatis Plus的ServiceImpl，同时实现自己的UserInfoService UserServiceImpl@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt; implements UserInfoService &#123;&#125; 创建 UserInfoController，，首先创建com.swx.user.controller包，在该包下创建。 注意：这里使用了构造器注入方式，因为对象是 final，可以有效避免下面这种情况 userInfoService = null; UserInfoController@RestController@RequestMapping(&quot;/user&quot;)public class UserInfoController &#123; private final UserInfoService userInfoService; public UserInfoController(UserInfoService userInfoService) &#123; this.userInfoService = userInfoService; &#125; @GetMapping(&quot;/test&quot;) public List&lt;UserInfo&gt; test()&#123; return userInfoService.list(); &#125;&#125; Redis Key 用户模块下的Redis Key 应该遵循设计规范，因此创建类： UserRedisKeyPrefix，继承 BaseKeyPrefix 在模块trip-users-api中创建包：com.swx.user.redis.key，在该包下创建类：UserRedisKeyPrefix UserRedisKeyPrefixpublic class UserRedisKeyPrefix extends BaseKeyPrefix &#123; public static final UserRedisKeyPrefix USER_REGISTER_VERIFY_CODE_STRING = new UserRedisKeyPrefix(&quot;USERS:REGISTER:VERIFY_CODE:&quot;, 10L, TimeUnit.MINUTES); public UserRedisKeyPrefix(String prefix) &#123; super(prefix); &#125; public UserRedisKeyPrefix(String prefix, Long timeout, TimeUnit unit) &#123; super(prefix, timeout, unit); &#125;&#125;"},{"title":"用户登陆功能","path":"/wiki/trip-cloud/05_user/login.html","content":"Session登陆方案的优缺点： 优点：Servlet容器自带，使用方便，性能高效 缺点：协议变成有状态，无法实现集群下的 session 共享 Token + Redis 登陆方案： 登陆流程： 登陆接口接收前端传入的用户名密码参数 验证用户名和密码是否正确 基于当前用户信息，生成JWT令牌 返回 JWT 令牌给前端 登陆拦截器： 从请求中获取到 JWT 令牌 利用 JWT 的 SDK 对令牌进行解析，判断是否能够通过校验 只要令牌解析可以通过，就代表令牌是有效的，用户是登陆过的。 Token 续期： 使用 access_token 和 refresh_token，其中 refresh_token 的过期时间是 access_token 的两倍，当 access_token 过期后使用 refresh_token 重新获取 access_token 和 refresh_token，如果 refresh_token 过期则重新登陆。 使用 Redis + JWT 登陆拦截 该部分内容见：安全模块 引入安全模块的依赖 &lt;!-- 安全模块，做登陆拦截 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common-security&lt;/artifactId&gt;&lt;/dependency&gt; 接口信息 值 路径地址 http://localhost:9000/users/login 请求方式 POST 请求参数 username, password 返回结果 { token, userInfoVo } 返回VO 使用返回VO而非完整用户对象，可以避免返回敏感信息，被分析出表结构。 在 trip-users-api 模块中新建包 com.swx.user.vo，在该包下定义 LoginUserVo 类，用于接收请求参数 LoginUserVo@Getter@Setterpublic class LoginUserVo &#123; private Long id; private String nickname; // 昵称 private String phone; // 手机 private String email; // 邮箱 private Integer gender; // 性别 private String city; // 所在城市 private String headImgUrl; // 头像 private String info; // 个性签名&#125; 定义Service找到 UserInfoService，定义登陆方法： UserInfoService/** * 登陆接口 * * @param username 用户名 * @param password 密码 * @return &#123;token, 用户&#125; */Map&lt;String, Object&gt; login(String username, String password); 在 UserServiceImpl 中实现该方法： UserServiceImpl@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt; implements UserInfoService &#123; private final TokenService tokenService; public UserServiceImpl(TokenService tokenService) &#123; this.tokenService = tokenService; &#125;\t/** * 登陆接口 * * @param username 用户名 * @param password 密码 * @return &#123;token, 用户&#125; */ @Override public Map&lt;String, Object&gt; login(String username, String password) &#123; // 1. 基于用户名查询用户对象 UserInfo userInfo = this.findByPhone(username); if (userInfo == null) &#123; throw new BizException(500401, &quot;用户名或密码错误&quot;); &#125; // 2. 对参数密码进行加密 String encryptPassword = Md5Utils.getMD5(password + username); // 3. 校验前端密码和数据库密码是否一致 if (!encryptPassword.equalsIgnoreCase(userInfo.getPassword())) &#123; throw new BizException(500401, &quot;用户名或密码错误&quot;); &#125; // 根据用户信息生成 jwt token LoginUser loginUser = new LoginUser(); BeanUtils.copyProperties(userInfo, loginUser); String jwtToken = tokenService.createToken(loginUser); // 构建 Map 对象，存入Token 和用户对象，返回 Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(); LoginUserVo loginUserVo = new LoginUserVo(); BeanUtils.copyProperties(userInfo, loginUserVo); data.put(&quot;token&quot;, jwtToken); data.put(&quot;user&quot;, loginUserVo); return data; &#125;&#125; 定义Controller在 UserInfoController 下定义登陆方法： UserInfoController@PostMapping(&quot;/login&quot;)public R&lt;Map&lt;String, Object&gt;&gt; login(String username, String password) &#123; Map&lt;String, Object&gt; map = userInfoService.login(username, password); return R.ok(map);&#125;"},{"title":"用户注册功能","path":"/wiki/trip-cloud/05_user/register.html","content":"本项目仅仅支持手机号注册 填入手机号，请求校验账号； 完善账号昵称和密码，发送验证码； 完成注册。 手机号校验前端和后端都需要对手机号格式进行校验，同时后端也应该检查账户是否已经注册。 接口信息 值 路径地址 http://localhost:9000/users/phone/exists 请求方式 GET 请求参数 phone&#x3D;手机号 返回结果 true|false 定义Service找到 UserInfoService，定义检查手机号方法： UserInfoServicepublic interface UserInfoService extends IService&lt;UserInfo&gt; &#123; /** * 基于手机号查询用户对象 * * @param phone 手机号 * @return 用户对象 */ UserInfo findByPhone(String phone);&#125; 在 UserServiceImpl 中实现该方法： UserServiceImpl@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt; implements UserInfoService &#123; /** * 基于手机号查询用户对象 * * @param phone 手机号 * @return 用户对象 */ @Override public UserInfo findByPhone(String phone) &#123; return getOne(Wrappers.&lt;UserInfo&gt;lambdaQuery().eq(UserInfo::getPhone, phone)); &#125;&#125; 定义Controller在 UserInfoController 下定义接口 UserInfoController@RestController@RequestMapping(&quot;/users&quot;)public class UserInfoController &#123; private final UserInfoService userInfoService; public UserInfoController(UserInfoService userInfoService) &#123; this.userInfoService = userInfoService; &#125; @GetMapping(&quot;/phone/exists&quot;) public R&lt;Boolean&gt; checkExists(String phone)&#123; return R.ok(userInfoService.findByPhone(phone) != null); &#125;&#125; 验证码服务验证码服务需要提供如下服务： 首先生成验证码 然后将验证码保存到Redis中 调用三方接口向手机号发送验证码 校验验证码是否一致 验证码存储方案： 技术方案 效率 时效性 跨服务共享 mysql 一般 无 支持 session 高 有 不支持 map 高 无 不支持 redis 高 有 支持 验证码存入 Redis 的数据结构 STRING: 直接就是 key&#x2F;value 形式，操作简单，redis中外部key数量增加，会导致redis整体性能收到影响 MAP：一个外部key，可以保存多个内部key&#x2F;value键值对，可以避免外部key占用过多 单个map对象数据量过大 &#x3D;&gt; 大key map 的时效性只针对外部key，无法针对内部key做过期时间 采用 STRING 结构存储验证码，key需要满足唯一性&#x2F;可读性&#x2F;扩展性 USERS:REGIST:VERIFY_CODE:手机号 集成Redis 代码部分参考集成Redis部分 在模块trip-users-api的pom文件中添加Redis模块的依赖 &lt;!-- Redis模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common-redis&lt;/artifactId&gt;&lt;/dependency&gt; 接口信息 值 路径地址 http://localhost:9000/sms/register 请求方式 POST 请求参数 phone&#x3D;手机号 返回结果 定义Service新建 SmsService，定义发送短信方法： SmsServicepublic interface SmsService &#123; /** * 注册发送短信功能 * * @param phone 手机号 */ void registerSmsSend(String phone);&#125; 创建 SmsServiceImpl 并实现该方法： SmsServiceImpl@Slf4j@Servicepublic class SmsServiceImpl implements SmsService &#123; private final RedisService redisService; public SmsServiceImpl(RedisService redisService) &#123; this.redisService = redisService; &#125; /** * 注册发送短信功能 * * @param phone 手机号 */ @Override public void registerSmsSend(String phone) &#123; // TODO 1. 验证手机合法性 // TODO 如何实现60s限制 // TODO 针对发送短信类的接口，是否需要进行限流？限流的频率设置多少合适？ // 2. 生成验证码 String code = this.generateVerifyCode(&quot;LETTER&quot;, 4); // 3. 缓存验证码 UserRedisKeyPrefix keyPrefix = UserRedisKeyPrefix.USER_REGISTER_VERIFY_CODE_STRING; redisService.setCacheObject(keyPrefix.fullKey(phone), code, keyPrefix.getTimeout(), keyPrefix.getUnit()); // TODO 4. 调用第三方接口，发送验证码 &#125; private String generateVerifyCode(String type, int len) &#123; String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); String code = uuid.substring(0, len); log.info(&quot;[短信服务] 生成验证码 ===== type=&#123;&#125;, len=&#123;&#125;, code=&#123;&#125;&quot;, type, len, code); return code; &#125;&#125; 定义Controller新建 SmsController SmsController@RestController@RequestMapping(&quot;/sms&quot;)public class SmsController &#123; private final SmsService smsService; public SmsController(SmsService smsService) &#123; this.smsService = smsService; &#125; @PostMapping(&quot;register&quot;) public R&lt;?&gt; registerVerifyCode(String phone) &#123; smsService.registerSmsSend(phone); return R.ok(); &#125;&#125; 账号注册实现步骤： 基于手机号查询是否已经存在该手机号，如果存在则返回异常 从 redis 中获取验证码与前端传入的验证码进行校验是否一致，如果不一致则抛出异常 将验证码从 redis 中删除 创建用户对象，填入参数并补充其他默认值 对密码进行加密操作 保存用户对象到数据库 接口信息 值 路径地址 http://localhost:9000/users/register 请求方式 POST 请求参数 phone, nickname, password, code 返回结果 请求参数 使用请求参数而非完整用户对象，可以避免接收多余参数，防止小人加入其他参数。 在 trip-users-api 模块中新建包 com.swx.user.vo，在该包下定义 RegisterRequest 类，用于接收请求参数 RegisterRequest/** * 用于接收注册请求传递的参数 */@Getter@Setterpublic class RegisterRequest &#123; private String phone; private String nickname; private String password; private String verifyCode;&#125; 定义Service找到 UserInfoService，定义注册账号方法： UserInfoService/** * 注册接口 * @param req 注册请求对象 */void register(RegisterRequest req); 在 UserServiceImpl 中实现该方法： UserServiceImpl@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt; implements UserInfoService &#123; private final RedisService redisService; public UserServiceImpl(RedisService redisService) &#123; this.redisService = redisService; &#125; /** * 注册接口 * * @param req 注册请求对象 */ @Override public void register(RegisterRequest req) &#123; // 1. 基于手机号查询是否已经存在该手机号，如果存在则返回异常 UserInfo byPhone = findByPhone(req.getPhone()); if (byPhone != null) &#123; throw new BizException(R.CODE_REGISTER_ERROR, &quot;手机号已存在，请不要重复注册&quot;); &#125; // 2. 从 redis 中获取验证码与前端传入的验证码进行校验是否一致，如果不一致则抛出异常 UserRedisKeyPrefix keyPrefix = UserRedisKeyPrefix.USER_REGISTER_VERIFY_CODE_STRING; String code = redisService.getCacheObject(keyPrefix.fullKey(req.getPhone())); if (!req.getVerifyCode().equalsIgnoreCase(code)) &#123; throw new BizException(R.CODE_REGISTER_ERROR, &quot;验证码错误&quot;); &#125; // 3. 将验证码从 redis 中删除 redisService.deleteObject(keyPrefix.fullKey(req.getPhone())); // 4. 创建用户对象，填入参数并补充其他默认值 UserInfo userInfo = this.buildUserInfo(req); // 5. 对密码进行加密操作，加盐 + 散列(hash)次数 String encryptPassword = Md5Utils.getMD5(userInfo.getPassword() + userInfo.getPhone()); userInfo.setPassword(encryptPassword); // 6. 保存用户对象到数据库 super.save(userInfo); &#125; /** * 构建用户对象 * @param req 请求对象参数 * @return 用户对象 */ private UserInfo buildUserInfo(RegisterRequest req) &#123; UserInfo userInfo = new UserInfo(); BeanUtils.copyProperties(req, userInfo); userInfo.setInfo(&quot;这个人很懒，什么都没写&quot;); userInfo.setHeadImgUrl(&quot;/images/default.jpg&quot;); return userInfo; &#125;&#125; 定义Controller在 UserInfoController 下定义接口 UserInfoController@PostMapping(&quot;register&quot;)public R&lt;?&gt; register(RegisterRequest req) &#123; userInfoService.register(req); return R.ok();&#125;"},{"title":"攻略分类服务","path":"/wiki/trip-cloud/06_article/catalog.html","content":"数据库攻略分类表 CREATE TABLE `strategy_catalog` ( `id` bigint NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `dest_id` bigint DEFAULT NULL, `state` int DEFAULT NULL, `seq` int DEFAULT NULL, `dest_name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC; 实体类找到模块：trip-article-api，找到包com.swx.article.domain，创建攻略分类实体类 StrategyCatalog@Getter@Setter@TableName(&quot;strategy_catalog&quot;)public class StrategyCatalog &#123; public static final int STATE_NORMAL = 1; public static final int STATE_DISABLE = 0; @TableId(type = IdType.AUTO) private Long id; private String name; // 类别名称 private Long destId; // 目的地 private String destName; // 目的地名称 private Integer state = STATE_NORMAL; // 类别状态 private Integer seq; // 类别序号 @TableField(exist = false) private List&lt;Strategy&gt; strategies = new ArrayList&lt;&gt;();&#125; 基础服务分页查询接口信息 值 路径地址 http://localhost:9000/article/strategies/catalogs/query 请求方式 GET 请求参数 Page 返回结果 Page Controller StrategyCatalogController@RestController@RequestMapping(&quot;/strategies/catalogs&quot;)public class StrategyCatalogController &#123; private final StrategyCatalogService strategyCatalogService; public StrategyCatalogController(StrategyCatalogService strategyCatalogService) &#123; this.strategyCatalogService = strategyCatalogService; &#125; @GetMapping(&quot;/query&quot;) public R&lt;Page&lt;StrategyCatalog&gt;&gt; pageList(Page&lt;StrategyCatalog&gt; page) &#123; return R.ok(strategyCatalogService.page(page)); &#125;&#125; 主键查询接口信息 值 路径地址 http://localhost:9000/article/strategies/catalogs/detail 请求方式 GET 请求参数 id 返回结果 StrategyCatalog Controller StrategyCatalogController@GetMapping(&quot;/detail&quot;)public R&lt;StrategyCatalog&gt; getById(Long id) &#123; return R.ok(strategyCatalogService.getById(id));&#125; 保存攻略类型 在保存攻略类型时，需要填充其对应目的地的名称 接口信息 值 路径地址 http://localhost:9000/article/strategies/catalogs/save 请求方式 POST 请求参数 StrategyCatalog 返回结果 Controller StrategyCatalogController@RestController@RequestMapping(&quot;/strategies/catalogs&quot;)public class StrategyCatalogController &#123; private final StrategyCatalogService strategyCatalogService; private final DestinationService destinationService; public StrategyCatalogController(StrategyCatalogService strategyCatalogService, DestinationService destinationService) &#123; this.strategyCatalogService = strategyCatalogService; this.destinationService = destinationService; &#125; @PostMapping(&quot;/save&quot;) public R&lt;?&gt; save(StrategyCatalog strategyCatalog) &#123; Destination destination = destinationService.getById(strategyCatalog.getDestId()); strategyCatalog.setDestName(destination.getName()); strategyCatalogService.save(strategyCatalog); return R.ok(); &#125;&#125; 更新攻略分类接口信息 值 路径地址 http://localhost:9000/article/strategies/catalogs/update 请求方式 POST 请求参数 StrategyCatalog 返回结果 Controller StrategyCatalogController@PostMapping(&quot;/update&quot;)public R&lt;?&gt; update(StrategyCatalog strategyCatalog) &#123; strategyCatalogService.updateById(strategyCatalog); return R.ok();&#125; 删除攻略分类接口信息 值 路径地址 http://localhost:9000/article/strategies/catalogs/delete/{id} 请求方式 POST 请求参数 id 返回结果 Controller StrategyCatalogController@PostMapping(&quot;/delete/&#123;id&#125;&quot;)public R&lt;?&gt; delete(@PathVariable Long id) &#123; strategyCatalogService.removeById(id); return R.ok();&#125; 分组查询类别 根据目的地分组查询类别 对应的前端页面如下：每个目的地下面都有对应的攻略类别 接口信息 值 路径地址 http://localhost:9000/article/strategies/catalogs/groups 请求方式 GET 请求参数 id 返回结果 Mapper找到：StrategyCatalogMapper，定义分组查询方法 StrategyCatalogMapperpublic interface StrategyCatalogMapper extends BaseMapper&lt;StrategyCatalog&gt; &#123; List&lt;StrategyCatalogGroup&gt; selectGroupList();&#125; 找到：StrategyCatalogMapper.xml，定义分组查询方法 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.article.mapper.StrategyCatalogMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.swx.article.domain.StrategyCatalog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;result property=&quot;destId&quot; column=&quot;dest_id&quot; /&gt; &lt;result property=&quot;destName&quot; column=&quot;dest_name&quot; /&gt; &lt;result property=&quot;seq&quot; column=&quot;seq&quot; /&gt; &lt;result property=&quot;state&quot; column=&quot;state&quot; /&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;CatalogGroupMap&quot; type=&quot;com.swx.article.vo.StrategyCatalogGroup&quot;&gt; &lt;id property=&quot;destId&quot; column=&quot;dest_id&quot; /&gt; &lt;result property=&quot;destName&quot; column=&quot;dest_name&quot; /&gt; &lt;collection property=&quot;catalogList&quot; resultMap=&quot;BaseResultMap&quot; columnPrefix=&quot;sc_&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectGroupList&quot; resultMap=&quot;CatalogGroupMap&quot;&gt; SELECT t.dest_id, t.dest_name, sc.id sc_id, sc.name sc_name, sc.seq sc_seq, sc.state sc_state FROM (SELECT dest_id, dest_name FROM strategy_catalog GROUP BY dest_id, dest_name) t JOIN strategy_catalog sc ON t.dest_id = sc.dest_id WHERE sc.state = 0 &lt;/select&gt;&lt;/mapper&gt; Service找到：StrategyCatalogService，定义分组查询方法 public interface StrategyCatalogService extends IService&lt;StrategyCatalog&gt; &#123; /** * 根据目的地分组查询类别 * @return 所有目的地类别分组 */ List&lt;StrategyCatalogGroup&gt; findGroupList();&#125; 找到：StrategyCatalogServiceImpl，实现上述方法 StrategyCatalogServiceImpl@Servicepublic class StrategyCatalogServiceImpl extends ServiceImpl&lt;StrategyCatalogMapper, StrategyCatalog&gt; implements StrategyCatalogService &#123; /** * 根据目的地分组查询类别 * * @return 所有目的地类别分组 */ @Override public List&lt;StrategyCatalogGroup&gt; findGroupList() &#123; return baseMapper.selectGroupList(); &#125;&#125; ControllerStrategyCatalogController@PostMapping(&quot;/delete/&#123;id&#125;&quot;)public R&lt;?&gt; delete(@PathVariable Long id) &#123; strategyCatalogService.removeById(id); return R.ok();&#125;"},{"title":"目的地服务","path":"/wiki/trip-cloud/06_article/destination.html","content":"图中红色框为区域模块，国内属于默认展示，其他的使用区域表存储，其对应的目的地可以有多个 图中黑色框为目的地模块，树型结构，数据库使用parent_id来维护关系。 数据库目的地服务分为两个模块：区域和目的地。区域和目的地是1对多，为了方便使用，这里关系交给1方来维护，打破了第一范式 国内区域设计为默认区域，即不存入数据库。 地区表 其中ref_ids用来存其关联的目的地 CREATE TABLE `region` ( `id` bigint NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `sn` varchar(255) DEFAULT NULL, `ishot` bit(1) DEFAULT NULL, `seq` int DEFAULT NULL, `info` varchar(255) DEFAULT NULL, `ref_ids` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC; 目的地表 目的地为树型结构，使用parent_id来关联关系 CREATE TABLE `destination` ( `id` bigint NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `english` varchar(255) DEFAULT NULL, `cover_url` varchar(255) DEFAULT NULL, `info` varchar(255) DEFAULT NULL, `parent_name` varchar(255) DEFAULT NULL, `parent_id` bigint DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=607 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC; 实体类找到模块：trip-article-api，找到包com.swx.article.domain，创建地区实体类 Region/** * 区域对象 */@Getter@Setter@TableName(&quot;region&quot;)public class Region implements Serializable &#123; public static final int STATE_HOT = 1; public static final int STATE_NORMAL = 0; @TableId(type = IdType.AUTO) private Long id; private String name; // 地区名 private String sn; // 地区编码 private String refIds; // 关联id，多个以，隔开 private Integer ishot = STATE_NORMAL; private Integer seq; // 序号 private String info; // 简介 /** * 解析子目的地 * * @return 子目的地 */ public List&lt;Long&gt; parseRefIds() &#123; ArrayList&lt;Long&gt; ids = new ArrayList&lt;&gt;(); if (StringUtils.hasLength(refIds)) &#123; String[] split = refIds.split(&quot;,&quot;); if (split.length &gt; 0) &#123; for (int i = 0; i &lt; split.length; i++) &#123; ids.add(Long.parseLong(split[i])); &#125; &#125; &#125; return ids; &#125;&#125; 目的地实体类 Destination/** * 目的地（行政地区：国家/省份/城市） */@Getter@Setter@TableName(&quot;destination&quot;)public class Destination &#123; @TableId(type = IdType.AUTO) private Long id; private String name; private String english; private Long parentId; private String parentName; private String info; private String coverUrl; @TableField(exist = false) private List&lt;Destination&gt; children = new ArrayList&lt;&gt;();&#125; 基础区域服务分页查询接口信息 值 路径地址 http://localhost:9000/article/regions 请求方式 GET 请求参数 Page 返回结果 Page Controller RegionController@RestController@RequestMapping(&quot;/regions&quot;)public class RegionController &#123; private final RegionService regionService; public RegionController(RegionService regionService) &#123; this.regionService = regionService; &#125; @GetMapping public R&lt;Page&lt;Region&gt;&gt; pageList(Page&lt;Region&gt; page) &#123; return R.ok(regionService.page(page)); &#125;&#125; 主键查询接口信息 值 路径地址 http://localhost:9000/article/regions/detail 请求方式 GET 请求参数 id 返回结果 Region Controller RegionController@GetMapping(&quot;/detail&quot;)public R&lt;Region&gt; getById(Long id) &#123; return R.ok(regionService.getById(id));&#125; 保存区域接口信息 值 路径地址 http://localhost:9000/article/regions/save 请求方式 POST 请求参数 Region 返回结果 Controller RegionController@PostMapping(&quot;/save&quot;)public R&lt;?&gt; save(Region region) &#123; regionService.save(region); return R.ok();&#125; 更新区域接口信息 值 路径地址 http://localhost:9000/article/regions/update 请求方式 POST 请求参数 Region 返回结果 Controller RegionController@PostMapping(&quot;/update&quot;)public R&lt;?&gt; update(Region region) &#123; regionService.updateById(region); return R.ok();&#125; 删除区域接口信息 值 路径地址 http://localhost:9000/article/regions/delete/{id} 请求方式 POST 请求参数 id 返回结果 Controller RegionController@PostMapping(&quot;/delete/&#123;id&#125;&quot;)public R&lt;?&gt; delete(@PathVariable Long id) &#123; regionService.removeById(id); return R.ok();&#125; 基础目的地服务查询所有接口信息 值 路径地址 http://localhost:9000/article/destinations/list 请求方式 GET 请求参数 返回结果 List Controller DestinationController@RestController@RequestMapping(&quot;/destinations&quot;)public class DestinationController &#123; private final DestinationService destinationService; public DestinationController(DestinationService destinationService) &#123; this.destinationService = destinationService; &#125; @GetMapping(&quot;/list&quot;) public R&lt;List&lt;Destination&gt;&gt; listAll() &#123; return R.ok(destinationService.list()); &#125;&#125; 主键查询接口信息 值 路径地址 http://localhost:9000/article/destinations/detail 请求方式 GET 请求参数 id 返回结果 Destination Controller DestinationController@GetMapping(&quot;/detail&quot;)public R&lt;Destination&gt; getById(Long id) &#123; return R.ok(destinationService.getById(id));&#125; 保存目的地接口信息 值 路径地址 http://localhost:9000/article/destinations/save 请求方式 POST 请求参数 Region 返回结果 Controller DestinationController@PostMapping(&quot;/save&quot;)public R&lt;?&gt; save(Destination dst) &#123; destinationService.save(dst); return R.ok();&#125; 更新目的地接口信息 值 路径地址 http://localhost:9000/article/destinations/update 请求方式 POST 请求参数 Destination 返回结果 Controller DestinationController@PostMapping(&quot;/update&quot;)public R&lt;?&gt; update(Destination dst) &#123; destinationService.updateById(dst); return R.ok();&#125; 删除目的地接口信息 值 路径地址 http://localhost:9000/article/destinations/delete/{id} 请求方式 POST 请求参数 id 返回结果 Controller DestinationController@PostMapping(&quot;/delete/&#123;id&#125;&quot;)public R&lt;?&gt; delete(@PathVariable Long id) &#123; destinationService.removeById(id); return R.ok();&#125; 热门区域查询前端对应页面如下图中的红色框： 接口信息 值 路径地址 http://localhost:9000/article/regions/hotList 请求方式 GET 请求参数 返回结果 List Service找到：RegionService，添加热门区域查询方法 RegionServicepublic interface RegionService extends IService&lt;Region&gt; &#123; /** * 热门区域查询 * @return 热门区域 */ List&lt;Region&gt; findHotList();&#125; 找到：RegionServiceImpl，实现上述方法 RegionServiceImpl@Servicepublic class RegionServiceImpl extends ServiceImpl&lt;RegionMapper, Region&gt; implements RegionService &#123; /** * 热门区域查询 * * @return 热门区域 */ @Override public List&lt;Region&gt; findHotList() &#123; return list(Wrappers.&lt;Region&gt;lambdaQuery() .eq(Region::getIshot, Region.STATE_HOT) .orderByAsc(Region::getSeq)); &#125;&#125; Controller找到：RegionController，添加热门区域查询方法 RegionController@GetMapping(&quot;/hotList&quot;)public R&lt;List&lt;Region&gt;&gt; hotList() &#123; return R.ok(regionService.findHotList());&#125; 热门区域目的地 根据热门区域ID查询区域目的地，包括目的地的子目的地 前端对应页面如下图中黑色框： 接口信息 值 路径地址 http://localhost:9000/article/destinations/hotList 请求方式 GET 请求参数 返回结果 List Mapper找到：DestinationMapper，添加查询方法： DestinationMapperpublic interface DestinationMapper extends BaseMapper&lt;Destination&gt; &#123; List&lt;Destination&gt; selectHotListByRid(@Param(&quot;rid&quot;) Long rid, @Param(&quot;ids&quot;) List&lt;Long&gt; ids);&#125; 找到：DestinationMapper.xml，实现实现上述方法 DestinationMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.article.mapper.DestinationMapper&quot;&gt; &lt;resultMap id=&quot;FullResultMap&quot; type=&quot;com.swx.article.domain.Destination&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;collection property=&quot;children&quot; ofType=&quot;com.swx.article.domain.Destination&quot; columnPrefix=&quot;c_&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectHotListByRid&quot; resultMap=&quot;FullResultMap&quot;&gt; SELECT province.id, province.name, city.id c_id, city.name c_name FROM destination province LEFT JOIN destination city ON province.id = city.parent_id &lt;where&gt; &lt;if test=&quot;rid == -1&quot;&gt; province.parent_id = 1 &lt;/if&gt; &lt;if test=&quot;rid &gt; 0&quot;&gt; province.id in &lt;foreach collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot; item=&quot;id&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; ORDER BY c_id &lt;/select&gt;&lt;/mapper&gt; Service找到：DestinationService，添加热门区域下目的地查询方法 DestinationService/** * 根据热门区域ID查询热门目的地 * @param rid 区域ID * @return 热门目的地 */List&lt;Destination&gt; findHotList(Long rid); 找到：DestinationServiceImpl，实现上述方法 这里使用了三种实现方式： 1、自连接查询2、循环查询，有N+1问题，即需要循环N次查询数据库3、循环查询，但是使用多线程方式 线程池配置类： @Configurationpublic class AppConfig &#123; @Bean public ThreadPoolExecutor bizThreadPoolExecutor() &#123; // 创建线程池的方式 /* 1. Executors 创建，不推荐， 默认创建的工作队列，使用的是 LinkedBlockingDeque 队列，且默认容量为 Integer 的最大值 工作队列的容量过大，会导致核心线程工作过载，对垒中任务数过多，且非核心线程无法参与处理，最终导致内存溢出 Executors.newCachedThreadPool(50); */ // 2. 直接new ThreadPoolExecutor 对象 推荐 return new ThreadPoolExecutor(10, 50, 10, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(100)); &#125;&#125; DestinationServiceImpl@Servicepublic class DestinationServiceImpl extends ServiceImpl&lt;DestinationMapper, Destination&gt; implements DestinationService &#123; private final RegionService regionService; private final ThreadPoolExecutor bizThreadPoolExecutor; public DestinationServiceImpl(RegionService regionService, ThreadPoolExecutor bizThreadPoolExecutor) &#123; this.regionService = regionService; this.bizThreadPoolExecutor = bizThreadPoolExecutor; &#125; /** * 根据热门区域ID查询热门目的地 * * @param rid 区域ID * @return 热门目的地 */ @Override public List&lt;Destination&gt; findHotList(Long rid) &#123; List&lt;Destination&gt; destinations = null; if (rid &lt; 0) &#123; destinations = this.baseMapper.selectHotListByRid(rid, null); &#125; else &#123; Region region = regionService.getById(rid); if (region == null) &#123; return Collections.emptyList(); &#125; List&lt;Long&gt; ids = region.parseRefIds(); destinations = this.baseMapper.selectHotListByRid(rid, ids); &#125; for (Destination destination : destinations) &#123; List&lt;Destination&gt; children = destination.getChildren(); if (children == null) &#123; continue; &#125; destination.setChildren(children.stream().limit(10).collect(Collectors.toList())); &#125; return destinations; &#125; /** * 使用代码循环方式，有N+1问题 * * @param rid 区域ID * @return 热门目的地 */ public List&lt;Destination&gt; findHostListFor(Long rid) &#123; List&lt;Destination&gt; destinations = null; LambdaQueryWrapper&lt;Destination&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); if (rid &lt; 0) &#123; destinations = list(wrapper.eq(Destination::getParentId, 1)); &#125; else &#123; destinations = this.getDestinationByRegionId(rid); &#125; for (Destination destination : destinations) &#123; // 清楚之前的条件 wrapper.clear(); List&lt;Destination&gt; children = list(wrapper.eq(Destination::getParentId, destination.getId()).last(&quot;limit 10&quot;)); destination.setChildren(children); &#125; return destinations; &#125; /** * 使用代码循环方式，有N+1问题 * 使用多线程，同时发查询请求 * * @param rid 区域ID * @return 热门目的地 */ public List&lt;Destination&gt; findHostListThread(Long rid) &#123; List&lt;Destination&gt; destinations = null; LambdaQueryWrapper&lt;Destination&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); if (rid &lt; 0) &#123; destinations = list(wrapper.eq(Destination::getParentId, 1)); &#125; else &#123; destinations = this.getDestinationByRegionId(rid); &#125; // 如何等待所有异步线程结束，主线程再执行 CountDownLatch latch = new CountDownLatch(destinations.size()); for (Destination destination : destinations) &#123; // submit有返回值，且支持Callable，execute没有返回值，只支持Runnable bizThreadPoolExecutor.execute(() -&gt; &#123; // 清楚之前的条件 List&lt;Destination&gt; children = list(Wrappers.&lt;Destination&gt;lambdaQuery().eq(Destination::getParentId, destination.getId()).last(&quot;limit 10&quot;)); destination.setChildren(children); // 倒计时数量-1 latch.countDown(); &#125;); &#125; // 返回结果前阻塞等待 try &#123; latch.await(10, TimeUnit.MINUTES); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return destinations; &#125;&#125; Controller找到：DestinationController，添加热门区域查询方法 DestinationController@GetMapping(&quot;/hotList&quot;)public R&lt;List&lt;Destination&gt;&gt; hotList(Long rid) &#123; return R.ok(destinationService.findHotList(rid));&#125; 查区域目的地 根据区域的ID获取其对应的目的地，父级目的地，不包含其子目的地 接口信息该接口输入后台管理接口 值 路径地址 http://localhost:9000/article/regions/{id}/destination 请求方式 GET 请求参数 id 返回结果 List Service找到：DestinationService，添加查区域目的地方法 public interface DestinationService extends IService&lt;Destination&gt; &#123; /** * 根据区域ID获取目的地 * * @param regionId 区域ID */ List&lt;Destination&gt; getDestinationByRegionId(Long regionId);&#125; 找到：DestinationServiceImpl，实现上述方法 DestinationService/** * 根据区域ID获取目的地 * * @param regionId 区域ID */@Overridepublic List&lt;Destination&gt; getDestinationByRegionId(Long regionId) &#123; Region region = regionService.getById(regionId); if (region == null) &#123; return Collections.emptyList(); &#125; List&lt;Long&gt; ids = region.parseRefIds(); if (ids.isEmpty()) &#123; return Collections.emptyList(); &#125; return listByIds(ids);&#125; Controller找到：RegionController，添加热门区域查询方法 RegionController@RestController@RequestMapping(&quot;/regions&quot;)public class RegionController &#123; private final RegionService regionService; private final DestinationService destinationService; public RegionController(RegionService regionService, DestinationService destinationService) &#123; this.regionService = regionService; this.destinationService = destinationService; &#125; @GetMapping(&quot;/&#123;id&#125;/destination&quot;) public R&lt;List&lt;Destination&gt;&gt; getDestination(@PathVariable Long id) &#123; return R.ok(destinationService.getDestinationByRegionId(id)); &#125;&#125; 分页查询目的地 根据目的地的父ID获取其对应的目的地，父ID为NULL，即查询所有父目的地 接口信息该接口输入后台管理接口 值 路径地址 http://localhost:9000/article/regions 请求方式 GET 请求参数 DestinationQuery 返回结果 Page 请求参数 请求参数除了基本参数，还包括分页参数，将公共的参数放到QueryObject中： 在 core 模块中创建包：com.swx.common.core.qo，该包下创建 QueryObject QueryObject@Getter@Setter@NoArgsConstructorpublic class QueryObject &#123; private String keyword; private Integer current = 1; private Integer size = 10; public QueryObject(Integer current, Integer size) &#123; this.current = current; this.size = size; &#125; public Integer getOffset() &#123; return (current - 1) * size; &#125;&#125; @Getter@Setterpublic class DestinationQuery extends QueryObject &#123; private Long parentId;&#125; Service找到：DestinationService，添加分页查询方法 DestinationService/** * 分页查询 * * @param query 查询参数 * @return 分页数据 */Page&lt;Destination&gt; pageList(DestinationQuery query); 找到：DestinationServiceImpl，实现上述方法 /** * 分页查询 * * @param query 查询参数 * @return 分页数据 */@Overridepublic Page&lt;Destination&gt; pageList(DestinationQuery query) &#123; LambdaQueryWrapper&lt;Destination&gt; wrapper = Wrappers.&lt;Destination&gt;lambdaQuery(); // parentId 为 null，查询所有 parent_id IS NULL 的数据 wrapper.isNull(query.getParentId() == null, Destination::getParentId); // parentId 不为 null，根据 parent_id 查询 wrapper.eq(query.getParentId() != null, Destination::getParentId, query.getParentId()); // 关键字查询 wrapper.like(StringUtils.hasText(query.getKeyword()), Destination::getName, query.getKeyword()); return super.page(new Page&lt;&gt;(query.getCurrent(), query.getSize()), wrapper);&#125; Controller找到：DestinationController，添加分页查询方法 DestinationController@GetMappingpublic R&lt;Page&lt;Destination&gt;&gt; pageList(DestinationQuery query) &#123; return R.ok(destinationService.pageList(query));&#125; 目的地吐司查询 根据当前目的地ID，往上查询其父目的地，当父目的地的parent_id为NULL时，停止查询。 前端对应页面如下图红色框： 接口信息 值 路径地址 http://localhost:9000/article/regions/toasts 请求方式 GET 请求参数 destId 返回结果 List Service找到：DestinationService，添加查询吐司方法 DestinationService/** * 根据当前ID查询面包屑 * @param destId 当前目的地ID * @return 面包屑 */List&lt;Destination&gt; toasts(Long destId); 找到：DestinationServiceImpl，实现上述方法 /** * 根据当前ID查询面包屑 * * @param destId 当前目的地ID */@Overridepublic List&lt;Destination&gt; toasts(Long destId) &#123; ArrayList&lt;Destination&gt; toasts = new ArrayList&lt;&gt;(); while (destId != null) &#123; Destination dest = super.getById(destId); if (dest == null) &#123; break; &#125; toasts.add(dest); destId = dest.getParentId(); &#125; // 逆序，方便前端展示 Collections.reverse(toasts); return toasts;&#125; Controller找到：DestinationController，添加分页查询方法 DestinationController@GetMapping(&quot;/toasts&quot;)public R&lt;List&lt;Destination&gt;&gt; toasts(Long destId) &#123; return R.ok(destinationService.toasts(destId));&#125;"},{"title":"初始化模块","path":"/wiki/trip-cloud/06_article/init.html","content":"API模块在trip_modules-api父模块下创建子模块trip-article-api，pom文件内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-modules-api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-article-api&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 只在编译和测试生效，运行时不生效，阻止依赖的传递性 --&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-users-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 微服务模块 API模块不需要启动类，在运行时不需要Mybatis Plus的依赖，但是开发时使用到了注解，所需使用scope限制只在编译和测试依赖，并且阻止依赖的传递性。而Server需要运行时依赖，所以不使用scope。 api和server都引入了依赖，但是使用scope限制api中依赖的传递。这样的好处是，当service不需要api中的依赖时，能避免因为引入依赖而没有配置导致项目启动失败。 在trip_modules父模块下创建子模块trip-article-server，pom文件内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-modules&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-article-server&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-article-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 安全模块，做登陆拦截 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 阿里云 OSS 对象存储 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- no more than 2.3.3--&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt; &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置文件：bootstrap.yaml，内容如下： spring: application: name: article-service cloud: nacos: server-addr: xxx.xxx.xxx.xxx:8848 config: file-extension: yaml namespace: trip_cloud_dev shared-configs: - data-id: redis-$&#123;spring.profiles.active&#125;.yaml refresh: true - data-id: jwt-$&#123;spring.profiles.active&#125;.yaml refresh: true profiles: active: dev Nacos配置文件 ID：article-service-dev.yaml Group：DEFAULT_GROUP 描述：文章微服务配置 配置内容： article-service-dev.yamlserver: port: 8092spring: cloud: nacos: server-addr: xxx.xxx.xxx.xxx:8848 discovery: namespace: $&#123;spring.cloud.nacos.config.namespace&#125; datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///trip-article?serverTimezone=GMT%2B8&amp;useSSL=false&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true username: root password: xxxxxxmybatis-plus: mapper-locations: classpath*:mapper/*.xml type-aliases-package: com.swx.article.domainaliyun: oss: endpoint: bucket-name: domain: accessKey: id: secret: 配置网关路由 ID：trip-gateway-dev.yaml Group：DEFAULT_GROUP 描述：旅游项目网关配置 配置内容： trip-gateway-dev.yaml- id: trip_article uri: lb://article-service predicates: - Path=/article/** filters: - StripPrefix=1 创建启动类：TripArticleApplication，首先创建com.swx.article包，在该包下创建。 TripArticleApplication@EnableFeignClients@SpringBootApplicationpublic class TripArticleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TripArticleApplication.class, args); &#125;&#125;"},{"title":"攻略主题服务","path":"/wiki/trip-cloud/06_article/theme.html","content":"数据库攻略主题表 CREATE TABLE `strategy_theme` ( `id` bigint NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `state` int DEFAULT NULL, `seq` int DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC; 实体类找到模块：trip-article-api，找到包com.swx.article.domain，创建攻略主题实体类 StrategyTheme@Getter@Setter@TableName(&quot;strategy_theme&quot;)public class StrategyTheme &#123; public static final int STATE_NORMAL = 1; public static final int STATE_DISABLE = 0; private Long id; private String name; // 主题名称 private Integer state = STATE_NORMAL; // 主题状态 private Integer seq; // 主题序号&#125; 分页查询接口信息 值 路径地址 http://localhost:9000/article/strategies/themes/query 请求方式 GET 请求参数 Page 返回结果 Page Controller StrategyThemeController@RestController@RequestMapping(&quot;/strategies/themes&quot;)public class StrategyThemeController &#123; private final StrategyThemeService strategyThemeService; public StrategyThemeController(StrategyThemeService strategyThemeService) &#123; this.strategyThemeService = strategyThemeService; &#125; @GetMapping(&quot;/query&quot;) public R&lt;Page&lt;StrategyTheme&gt;&gt; pageList(Page&lt;StrategyTheme&gt; page) &#123; return R.ok(strategyThemeService.page(page)); &#125;&#125; 查询所有接口信息 值 路径地址 http://localhost:9000/article/strategies/themes/list 请求方式 GET 请求参数 返回结果 List Controller StrategyThemeController@GetMapping(&quot;/list&quot;)public R&lt;List&lt;StrategyTheme&gt;&gt; listAll() &#123; return R.ok(strategyThemeService.list());&#125; 主键查询接口信息 值 路径地址 http://localhost:9000/article/strategies/theme/detail 请求方式 GET 请求参数 id 返回结果 StrategyCatalog Controller StrategyThemeController@GetMapping(&quot;/detail&quot;)public R&lt;StrategyTheme&gt; getById(Long id) &#123; return R.ok(strategyThemeService.getById(id));&#125; 保存攻略主题接口信息 值 路径地址 http://localhost:9000/article/strategies/themes/save 请求方式 POST 请求参数 StrategyTheme 返回结果 Controller StrategyThemeController@PostMapping(&quot;/save&quot;)public R&lt;?&gt; save(StrategyTheme strategyTheme) &#123; strategyThemeService.save(strategyTheme); return R.ok();&#125; 更新攻略主题接口信息 值 路径地址 http://localhost:9000/article/strategies/themes/update 请求方式 POST 请求参数 StrategyCatalog 返回结果 Controller StrategyThemeController@PostMapping(&quot;/update&quot;)public R&lt;?&gt; update(StrategyTheme strategyTheme) &#123; strategyThemeService.updateById(strategyTheme); return R.ok();&#125; 删除攻略分类接口信息 值 路径地址 http://localhost:9000/article/strategies/themes/delete/{id} 请求方式 POST 请求参数 id 返回结果 Controller StrategyThemeController@PostMapping(&quot;/delete/&#123;id&#125;&quot;)public R&lt;?&gt; delete(@PathVariable Long id) &#123; strategyThemeService.removeById(id); return R.ok();&#125;"},{"title":"游记服务","path":"/wiki/trip-cloud/06_article/travel.html","content":"游记服务的后台管理接口可以参考攻略服务 数据库游记表 CREATE TABLE `travel` ( `id` bigint NOT NULL AUTO_INCREMENT, `dest_id` bigint DEFAULT NULL, `dest_name` varchar(255) DEFAULT NULL, `author_id` bigint DEFAULT NULL, `title` varchar(255) DEFAULT NULL, `summary` varchar(255) DEFAULT NULL, `cover_url` varchar(255) DEFAULT NULL, `travel_time` datetime DEFAULT NULL, `avg_consume` int DEFAULT NULL, `day` int DEFAULT NULL, `person` int DEFAULT NULL, `create_time` datetime DEFAULT NULL, `release_time` datetime DEFAULT NULL, `last_update_time` datetime DEFAULT NULL, `ispublic` int DEFAULT NULL, `viewnum` int DEFAULT NULL, `replynum` int DEFAULT NULL, `favornum` int DEFAULT NULL, `sharenum` int DEFAULT NULL, `thumbsupnum` int DEFAULT NULL, `state` int DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC; 实体类找到模块：trip-article-api ，找到包com.swx.article.domain，创建游记实体类 Travel/** * 游记 */@Setter@Getter@TableName(&quot;travel&quot;)public class Travel implements Serializable &#123; public static final int STATE_NORMAL = 0; //草稿 public static final int STATE_WAITING = 1; //待发布(待审核) public static final int STATE_RELEASE = 2; //审核通过 public static final int STATE_REJECT = 3; //拒绝 public static final int ISPUBLIC_NO = 0; public static final int ISPUBLIC_YES = 1; @TableId(type = IdType.AUTO) private Long id; private Long destId; //目的地 private String destName; //目的地 private Long authorId; //作者id @TableField(exist = false) private UserInfoDTO author; private String title; //标题 private String summary;//概要 private String coverUrl; //封面 @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date travelTime; //旅游时间 private Integer avgConsume; //人均消费 private Integer day; //旅游天数 private Integer person; //和谁旅游 private Date createTime; //创建时间 private Date releaseTime; //发布时间 private Date lastUpdateTime; //最新更新时间内 private Integer ispublic = ISPUBLIC_NO; //是否发布 private Integer viewnum; //点击/阅读数 private Integer replynum; //回复数 private Integer favornum;//收藏数 private Integer sharenum;//分享数 private Integer thumbsupnum;//点赞数 private Integer state = STATE_NORMAL;//游记状态 @TableField(exist = false) private TravelContent content; //游记内容&#125; 基础服务主键查询接口信息 值 路径地址 http://localhost:9000/article/travels/detail 请求方式 GET 请求参数 id 返回结果 Travel Controller TravelController@RestController@RequestMapping(&quot;/travels&quot;)public class TravelController &#123; private final TravelService travelService; public TravelController(TravelService travelService) &#123; this.travelService = travelService; &#125; @GetMapping(&quot;/detail&quot;) public R&lt;Travel&gt; getById(Long id) &#123; return R.ok(travelService.getById(id)); &#125;&#125; 保存游记 在保存攻略类型时，需要填充其对应目的地的名称 接口信息 值 路径地址 http://localhost:9000/article/travels/save 请求方式 POST 请求参数 Travel 返回结果 Controller TravelController@PostMapping(&quot;/save&quot;)public R&lt;?&gt; save(Travel travel) &#123; travelService.save(travel); return R.ok();&#125; 更新游记接口信息 值 路径地址 http://localhost:9000/article/travels/update 请求方式 POST 请求参数 Travel 返回结果 Controller TravelController@PostMapping(&quot;/update&quot;)public R&lt;?&gt; update(Travel travel) &#123; travelService.updateById(travel); return R.ok();&#125; 删除游记接口信息 值 路径地址 http://localhost:9000/article/travels/delete/{id} 请求方式 POST 请求参数 id 返回结果 Controller TravelController@PostMapping(&quot;/delete/&#123;id&#125;&quot;)public R&lt;?&gt; delete(@PathVariable Long id) &#123; travelService.removeById(id); return R.ok();&#125; 复杂分页查询 根据目的地分组查询类别 对应的前端页面如下：可以根据：出发时间、人均花费、出行天数过滤，根据时间和浏览量排序 接口信息 值 路径地址 http://localhost:9000/article/travles/query 请求方式 GET 请求参数 TravelQuery 返回结果 R { code: “”, msg: “”, data:Page } 查询条件 使用了Map做映射，前端只需要传入序号，即可映射为过滤范围 找到模块：trip-article-api，创建包：com.swx.article.qo，包下创建查询类：TravelQuery TravelQuery@Getter@Setterpublic class TravelQuery extends QueryObject &#123; private final List&lt;String&gt; ALLOW_ORDER_BY_COLUMNS = Arrays.asList(&quot;viewnum&quot;, &quot;create_time&quot;); private final static Map&lt;Integer, TravelRange&gt; TRAVEL_TIME_MAP = new HashMap&lt;&gt;(); // 出发时间 private final static Map&lt;Integer, TravelRange&gt; COST_MAP = new HashMap&lt;&gt;(); // 人均花费 private final static Map&lt;Integer, TravelRange&gt; DAYS_MAP = new HashMap&lt;&gt;(); // 出行天数 static &#123; // 出发时间 TRAVEL_TIME_MAP.put(1, new TravelRange(1, 2)); TRAVEL_TIME_MAP.put(2, new TravelRange(3, 4)); TRAVEL_TIME_MAP.put(3, new TravelRange(5, 6)); TRAVEL_TIME_MAP.put(4, new TravelRange(7, 8)); TRAVEL_TIME_MAP.put(5, new TravelRange(9, 10)); TRAVEL_TIME_MAP.put(6, new TravelRange(11, 12)); // 人均花费 COST_MAP.put(1, new TravelRange(1, 999)); COST_MAP.put(2, new TravelRange(1000, 5999)); COST_MAP.put(3, new TravelRange(6000, 19999)); COST_MAP.put(4, new TravelRange(20000, Integer.MAX_VALUE)); // 出行天数 DAYS_MAP.put(1, new TravelRange(1, 3)); DAYS_MAP.put(2, new TravelRange(4, 7)); DAYS_MAP.put(3, new TravelRange(8, 14)); DAYS_MAP.put(4, new TravelRange(15, 365)); &#125; private Long destId; // 目的地ID private String orderBy; // 排序规则 private TravelRange travelTimeRange; private TravelRange costRange; private TravelRange dayRange; /** * 更改前端的 travelTimeType 参数设置逻辑 * @param travelTimeType 前端的参数 */ public void setTravelTimeType(Integer travelTimeType) &#123; this.travelTimeRange = TRAVEL_TIME_MAP.get(travelTimeType); &#125; /** * 更改前端的 consumeType 参数设置逻辑 * @param consumeType 前端的参数 */ public void setConsumeType(Integer consumeType) &#123; this.costRange = COST_MAP.get(consumeType); &#125; /** * 更改前端的 dayType 参数设置逻辑 * @param dayType 前端的参数 */ public void setDayType(Integer dayType) &#123; this.dayRange = DAYS_MAP.get(dayType); &#125; /** * 防止SQL注入 * @param orderBy 前端传过来的order by 字段 */ public void setOrderBy(String orderBy) &#123; if (ALLOW_ORDER_BY_COLUMNS.contains(orderBy)) &#123; this.orderBy = orderBy; &#125; &#125;&#125; Service找到：TravelService，定义分组查询方法 TravelServicepublic interface TravelService extends IService&lt;Travel&gt; &#123; /** * 条件分页查询游记 * * @param query 分页查询参数 * @return 游记 */ Page&lt;Travel&gt; pageList(TravelQuery query);&#125; 找到：TravelServiceImpl，实现上述方法 TravelServiceImpl@Slf4j@Servicepublic class TravelServiceImpl extends ServiceImpl&lt;TravelMapper, Travel&gt; implements TravelService &#123; private final UserInfoFeignService userInfoFeignService; private final ThreadPoolExecutor bizThreadPoolExecutor; private final TravelContentMapper travelContentMapper; public TravelServiceImpl(UserInfoFeignService userInfoFeignService, ThreadPoolExecutor bizThreadPoolExecutor, TravelContentMapper travelContentMapper) &#123; this.userInfoFeignService = userInfoFeignService; this.bizThreadPoolExecutor = bizThreadPoolExecutor; this.travelContentMapper = travelContentMapper; &#125; @Override public Travel getById(Serializable id) &#123; Travel travel = super.getById(id); if (travel == null) &#123; return null; &#125; // 获取游记内容 TravelContent content = travelContentMapper.selectById(id); travel.setContent(content); // 获取作者信息 R&lt;UserInfoDTO&gt; result = userInfoFeignService.getById(travel.getAuthorId()); UserInfoDTO author = result.checkAndGet(); travel.setAuthor(author); return travel; &#125; /** * 条件分页查询游记 * * @param query 分页查询参数 * @return 游记 */ @Override public Page&lt;Travel&gt; pageList(TravelQuery query) &#123; QueryWrapper&lt;Travel&gt; wrapper = Wrappers.&lt;Travel&gt;query() .eq(query.getDestId() != null, &quot;dest_id&quot;, query.getDestId()); // 旅行时间条件 if (query.getTravelTimeRange() != null) &#123; TravelRange timeRange = query.getTravelTimeRange(); wrapper.between(&quot;MONTH(travel_time)&quot;, timeRange.getMin(), timeRange.getMax()); &#125; // 人均花费条件 if (query.getCostRange() != null) &#123; TravelRange costRange = query.getCostRange(); wrapper.between(&quot;avg_consume&quot;, costRange.getMin(), costRange.getMax()); &#125; // 出行天数条件 if (query.getDayRange() != null) &#123; TravelRange dayRange = query.getDayRange(); wrapper.between(&quot;day&quot;, dayRange.getMin(), dayRange.getMax()); &#125; // 排序 wrapper.orderByDesc(query.getOrderBy() != null, query.getOrderBy()); LoginUser loginUser = AuthenticationUtil.getLoginUser(); if (loginUser == null) &#123; // 游客：只能浏览已发布的游记 wrapper.eq(&quot;ispublic&quot;, Travel.ISPUBLIC_YES) .eq(&quot;state&quot;, Travel.STATE_RELEASE); &#125; else &#123; // 用户：可以查看游客内容以及自己的游记 wrapper.and(w -&gt; w.eq(&quot;author_id&quot;, loginUser.getId()) .or(ww -&gt; ww.eq(&quot;ispublic&quot;, Travel.ISPUBLIC_YES).eq(&quot;state&quot;, Travel.STATE_RELEASE)) ); &#125; Page&lt;Travel&gt; page = super.page(new Page&lt;&gt;(query.getCurrent(), query.getSize()), wrapper); List&lt;Travel&gt; travels = page.getRecords(); // 计数器，等待 CountDownLatch latch = new CountDownLatch(travels.size()); for (Travel travel : travels) &#123; // 线程池，多线程执行 bizThreadPoolExecutor.execute(() -&gt; &#123; try &#123; R&lt;UserInfoDTO&gt; result = userInfoFeignService.getById(travel.getAuthorId()); if (result.getCode() != R.CODE_SUCCESS) &#123; log.warn(&quot;[游记服务] 查询用户作者失败，返回数据异常: &#123;&#125;&quot;, JSON.toJSONString(result)); return; &#125; travel.setAuthor(result.getData()); &#125; finally &#123; // 倒计时数量-1 latch.countDown(); &#125; &#125;); &#125; // 返回结果前阻塞等待 try &#123; latch.await(10, TimeUnit.MINUTES); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return page; &#125;&#125; Controller找到：TravelController，定义分页查询接口 TravelController@GetMapping(&quot;/query&quot;)public R&lt;Page&lt;Travel&gt;&gt; pageList(TravelQuery query) &#123; return R.ok(travelService.pageList(query));&#125; 查询浏览量前三的游记接口信息 值 路径地址 http://localhost:9000/article/travels/viewnumTop3 请求方式 GET 请求参数 destId 返回结果 R { code: “”, msg: “”, data:List } Service找到：TravelService，定义查询的方法 TravelService/** * 根据目的地ID，查询浏览量最高的前3篇游记 * * @param destId 目的地 * @return 浏览量最高的前3篇游记 */List&lt;Travel&gt; findViewnumTop3(Long destId); 找到：TravelServiceImpl，实现查询的方法 TravelServiceImpl/** * 根据目的地ID，查询浏览量最高的前3篇游记 * * @param destId 目的地 * @return 浏览量最高的前3篇游记 */@Overridepublic List&lt;Travel&gt; findViewnumTop3(Long destId) &#123; return super.list(Wrappers.&lt;Travel&gt;lambdaQuery() .eq(Travel::getDestId, destId) .orderByDesc(Travel::getViewnum) .last(&quot;limit 3&quot;) );&#125; Controller找到：TravelController，定义查询接口 TravelController@GetMapping(&quot;/viewnumTop3&quot;)public R&lt;List&lt;Travel&gt;&gt; viewnumTop3(Long destId) &#123; return R.ok(travelService.findViewnumTop3(destId));&#125;"},{"title":"始化模块","path":"/wiki/trip-cloud/07_comment/init.html","content":"API模块在trip_modules-api父模块下创建子模块trip-comment-api，pom文件内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-modules-api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-comment-api&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 微服务模块在trip_modules父模块下创建子模块trip-comment-server，pom文件内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-modules&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-comment-server&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-comment-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置文件：bootstrap.yaml，内容如下： spring: application: name: comment-service cloud: nacos: server-addr: xxx.xxx.xxx.xxx:8848 config: file-extension: yaml namespace: trip_cloud_dev shared-configs: - data-id: redis-$&#123;spring.profiles.active&#125;.yaml refresh: true - data-id: jwt-$&#123;spring.profiles.active&#125;.yaml refresh: true profiles: active: dev Nacos配置文件 ID：comment-service-dev.yaml Group：DEFAULT_GROUP 描述：评论微服务配置 配置内容： comment-service-dev.yamlserver: port: 8094spring: cloud: nacos: server-addr: xxx.xxx.xxx.xxx:8848 discovery: namespace: $&#123;spring.cloud.nacos.config.namespace&#125; data: mongodb: uri: mongodb://swcode:123456@xxx.xxx.xxx.xxx:27017/trip-comment 配置网关路由 ID：trip-gateway-dev.yaml Group：DEFAULT_GROUP 描述：旅游项目网关配置 配置内容： trip-gateway-dev.yaml- id: trip_comment uri: lb://comment-service predicates: - Path=/comment/** filters: - StripPrefix=1 创建启动类：TripCommentApplication，首先创建com.swx.comment包，在该包下创建。 TripCommentApplication@SpringBootApplicationpublic class TripCommentApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TripCommentApplication.class, args); &#125;&#125;"},{"title":"攻略服务","path":"/wiki/trip-cloud/06_article/strategy.html","content":"数据库表结构分析 字段类型与长度： 数字类型：长度最大20，数字类型 短整型：int 长整型：bigint 小数：decimal 金额类型的数组：看需求，需要小数点，使用 decimal，否则使用 int 单位为分 字符类型：统一使用varchart，字符长度通常设置为8的倍数 时间类型：不同公司规范不同，DATE&#x2F;DATETIME&#x2F;TIME，其他一般设置为 bigint 时间戳 攻略表 CREATE TABLE `strategy` ( `id` bigint NOT NULL AUTO_INCREMENT, `dest_id` bigint DEFAULT NULL, `dest_name` varchar(255) DEFAULT NULL, `theme_id` bigint DEFAULT NULL, `theme_name` varchar(255) DEFAULT NULL, `catalog_id` bigint DEFAULT NULL, `catalog_name` varchar(255) DEFAULT NULL, `title` varchar(255) DEFAULT NULL, `sub_title` varchar(255) DEFAULT NULL, `summary` varchar(255) DEFAULT NULL, `cover_url` varchar(255) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `isabroad` int DEFAULT NULL, `viewnum` int DEFAULT NULL, `replynum` int DEFAULT NULL, `favornum` int DEFAULT NULL, `sharenum` int DEFAULT NULL, `thumbsupnum` int DEFAULT NULL, `state` int DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC; 攻略内容表 CREATE TABLE `strategy_content` ( `id` bigint NOT NULL, `content` text, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC; 攻略排行表 CREATE TABLE `strategy_rank` ( `id` bigint NOT NULL AUTO_INCREMENT, `dest_id` bigint DEFAULT NULL, `dest_name` varchar(255) DEFAULT NULL, `strategy_id` bigint DEFAULT NULL, `strategy_title` varchar(255) DEFAULT NULL, `type` int DEFAULT NULL, `statis_time` datetime DEFAULT NULL, `statisnum` bigint DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=11321 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC; 实体类找到 trip-article-api 模块，创建包：com.swx.article.domain，在该包下创建如下的实体类。 攻略表实体类 Strategy/** * 攻略 */@Setter@Getter@TableName(&quot;strategy&quot;)public class Strategy implements Serializable &#123; public static final int ABROAD_NO = 0; //国内 public static final int ABROAD_YES = 1; //国外 public static final int STATE_NORMAL = 0; //带发布 public static final int STATE_PUBLISH = 1; //发布 @TableId(type = IdType.AUTO) private Long id; private Long destId; //关联的目的地 private String destName; private Long themeId; //关联主题 private String themeName; private Long catalogId; //关联的分类 private String catalogName; private String title; //标题 private String subTitle; //副标题 private String summary; //内容摘要 private String coverUrl; //封面 private Date createTime; //创建时间 private Integer isabroad; //是否是国外 private Integer viewnum; //点击数 private Integer replynum; //攻略评论数 private Integer favornum; //收藏数 private Integer sharenum; //分享数 private Integer thumbsupnum; //点赞个数 private Integer state; //状态 @TableField(exist = false) private boolean favorite; @TableField(exist = false) private StrategyContent content; //攻略内容&#125; 攻略内容实体类 StrategyContent@Setter@Getter@TableName(&quot;strategy_content&quot;)public class StrategyContent implements Serializable &#123; private Long id; private String content;&#125; 攻略排行实体类 StrategyRank/** * 攻略统计表 */@Setter@Getter@TableName(&quot;strategy_rank&quot;)public class StrategyRank &#123; public static final int TYPE_ABROAD = 1; //国外 public static final int TYPE_CHINA = 2; //国内 public static final int TYPE_HOT = 3; //热门 private Long id; private Long destId; //目的地id private String destName; //目的地名称 private Long strategyId; //攻略id private String strategyTitle; //攻略标题 private int type; //排行类型 private Date statisTime; //归档统计时间 private Long statisnum; //归档统计数&#125; 文件上传阿里云OSS 免费使用地址：https://free.aliyun.com/?crowd=personal 对象存储控制台：https://oss.console.aliyun.com/ 创建资源1、创建Bucket 控制台右侧找到 Bucket 列表，新建Bucket，读写权限选择公共读，其他默认即可 2、创建虚拟账号 阿里云的服务都需要AccessKey和AccessSecret才能访问，主账号拥有所有的权限，所以我们需要创建子账号，给子账号授予访问OSS的权限即可 RAM访问控制：https://ram.console.aliyun.com/overview 在RAM访问控制中右侧找到用户，创建用户，访问方式只勾选OpenAPI 调用访问 注意！创建成功后请立即保存 key 和 secret，不要离开页面，否则需要重新创建key和secret 3、给账号授权OSS 点击用户登录名称/显示名称，即用户表格的第一列，选中刚创建的新用户在下面的Tab栏中点击权限管理，新增授权 给整个云账号授权，权限搜索OSS，授予：AliyunOSSFullAccess，即所有OSS操作权限。 工具类1、阿里云OSS工具类 基础的配置信息从配置文件中获取，为此需要从 Spring 容器中拿到其他 Environment 对象 OssUtil/** * 阿里云OSS工具类 * * @author swcode * @since 2023/10/26 13:30 */public class OssUtil &#123; /** * 访问域名 */ private final static String ossAccessDomainUrl; /** * bucket 名称 */ private final static String ossBucketName; /** * 封装了 accessKeyId 和 accessKeySecret 的客户端对象 */ private final static OSSClient client; static &#123; // 面试题: 如何实现在一个非Spring容器管理的对象中, 从Spring容器中拿到其他Bean对象. // Environment 对象的作用就是管理 Spring 容器运行时的各种配置内容 Environment environment = SpringContextUtil.getBean(Environment.class); String endpointUrl = environment.getProperty(&quot;aliyun.oss.endpoint&quot;); ossBucketName = environment.getProperty(&quot;aliyun.oss.bucket-name&quot;); ossAccessDomainUrl = environment.getProperty(&quot;aliyun.oss.domain&quot;); String keyId = environment.getProperty(&quot;aliyun.accessKey.id&quot;); String keySecret = environment.getProperty(&quot;aliyun.accessKey.secret&quot;); client = new OSSClient(endpointUrl, CredentialsProviderFactory.newDefaultCredentialProvider(keyId, keySecret), new ClientConfiguration()); &#125; /** * @param fileName 用户文件名称 * @return 实际的cos上文件名称 */ private static String getRealFileName(String saveFolder, String fileName) &#123; return StringUtils.isNotEmpty(saveFolder) ? saveFolder + &quot;/&quot; + fileName : fileName; &#125; public static String upload(String saveFolder, String contentType, String fileName, InputStream input) &#123; if (StringUtils.isEmpty(fileName) || StringUtils.isEmpty(contentType) || null == input) &#123; return null; &#125; ObjectMetadata objectMeta = new ObjectMetadata(); objectMeta.setContentType(contentType); String filePath = getRealFileName(saveFolder, fileName); try &#123; client.putObject(ossBucketName, filePath, input, objectMeta); return ossAccessDomainUrl + filePath; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; finally &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static String upload(String saveFolder, String contentType, String fileName, long contentLength, InputStream input) &#123; if (StringUtils.isEmpty(fileName) || StringUtils.isEmpty(contentType) || contentLength &lt;= 0 || null == input) &#123; return null; &#125; ObjectMetadata objectMeta = new ObjectMetadata(); objectMeta.setContentLength(contentLength); objectMeta.setContentType(contentType); String filePath = getRealFileName(saveFolder, fileName); try &#123; client.putObject(ossBucketName, filePath, input, objectMeta); return ossAccessDomainUrl + filePath; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; finally &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static String upload(String saveFolder, String fileMainName, MultipartFile multipartFile) &#123; if (null != multipartFile &amp;&amp; !multipartFile.isEmpty()) &#123; try &#123; String filename = multipartFile.getOriginalFilename(); String extFileName; if (StringUtils.isNotEmpty(filename)) &#123; extFileName = filename.substring(filename.lastIndexOf(&quot;.&quot;)); &#125; else &#123; extFileName = &quot;.jpg&quot;; &#125; return upload(saveFolder, multipartFile.getContentType(), fileMainName + extFileName, multipartFile.getSize(), multipartFile.getInputStream()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; public static String upload4SpecialName(String saveFolder, String fileName, MultipartFile multipartFile) &#123; if (null != multipartFile &amp;&amp; !multipartFile.isEmpty()) &#123; try &#123; return upload(saveFolder, multipartFile.getContentType(), fileName, multipartFile.getSize(), multipartFile.getInputStream()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; public static String uploadImgByBase64(String saveFolder, String fileName, String base64ImgContent) &#123; if (StringUtils.isEmpty(fileName) || StringUtils.isEmpty(base64ImgContent)) &#123; return null; &#125; try &#123; Matcher matcher = Pattern.compile(&quot;^data.(.*?);base64,&quot;).matcher(base64ImgContent); if (matcher.find()) &#123; base64ImgContent = base64ImgContent.replace(matcher.group(), &quot;&quot;); &#125; byte[] bytes = Base64Utils.decodeFromString(base64ImgContent); return upload(saveFolder, &quot;image/jpg&quot;, fileName, bytes.length, new ByteArrayInputStream(bytes)); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; public static void delete(String fileUrl) &#123; if (StringUtils.isEmpty(fileUrl)) &#123; return; &#125; try &#123; fileUrl = fileUrl.replaceFirst(ossAccessDomainUrl, &quot;&quot;); client.deleteObject(ossBucketName, fileUrl); &#125; catch (OSSException | ClientException e) &#123; e.printStackTrace(); &#125; &#125; public static String getByFileName(String pathFile) &#123; return ossAccessDomainUrl + client.getObject(ossBucketName, pathFile).getKey(); &#125;&#125; 2、获取Spring上下文对象工具 SpringContextUtil/** * Spring工具类,获取Spring上下文对象等 * * @author swcode * @since 2023/10/26 13:31 */@Componentpublic class SpringContextUtil implements ApplicationContextAware &#123; private static ApplicationContext applicationContext = null; /** * 1. SpringContextUtil 被 JVM 加载时, applicationContext 作为静态属性, 就被初始化了, 但是此时是 null 值 * 2. 当 Spring 容器初始化以后, 会管理 SpringContextUtil Bean 对象 * 3. 当 Spring 创建 SpringContextUtil 实例对象时, * 在初始化阶段会自动调用实现了 ApplicationContextAware 的 setApplicationContext 方法, * 此时该类中原本静态容器属性就从 null 变成了容器对象 * 4. 当容器启动成功后, 其他业务代码通过该类的静态成员, 就可以直接的访问容器对象, 从容器对象中获取其他 Bean 对象 */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; if (SpringContextUtil.applicationContext == null) &#123; SpringContextUtil.applicationContext = applicationContext; System.out.println(&quot;----------&quot; + applicationContext); &#125; &#125; public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; public static Object getBean(String name) &#123; return getApplicationContext().getBean(name); &#125; public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(clazz); &#125; public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(name, clazz); &#125;&#125; 3、完善配置文件 进入桶的概览页面，找到 endpoint 和 domain 进入Nacos 后台，编辑article-service-dev.yaml配置文件，添加如下的配置信息 aliyun: oss: endpoint: bucket-name: domain: accessKey: id: secret: 接口信息 值 路径地址 http://localhost:9000/article/strategies/uploadImg 请求方式 POST 请求参数 MultipartFile upload 返回结果 { “uploaded”: 1, “fileName”: “”, “url”: “”}, {“uploaded”: 0, “error”: {“message”: “失败”}}} 上传Controller找到 StrategyController，定义上传方法： StrategyController@PostMapping(&quot;/uploadImg&quot;)public JSONObject uploadImg(MultipartFile upload) &#123; JSONObject result = new JSONObject(); if (upload == null) &#123; result.put(&quot;uploaded&quot;, 0); JSONObject error = new JSONObject(); error.put(&quot;message&quot;, &quot;请选择要上传的文件！&quot;); result.put(&quot;error&quot;, error); return result; &#125; String filename = upload.getOriginalFilename(); String mainFilename = &quot;&quot;; if (StringUtils.hasText(filename)) &#123; mainFilename = filename.substring(0, filename.lastIndexOf(&quot;.&quot;)) + &quot;_&quot; + System.currentTimeMillis(); &#125; else &#123; mainFilename = System.currentTimeMillis() + &quot;&quot;; &#125; // 返回阿里云可访问的地址 String url = OssUtil.upload(&quot;images&quot;, mainFilename, upload); result.put(&quot;uploaded&quot;, 1); result.put(&quot;fileName&quot;, upload.getOriginalFilename()); result.put(&quot;url&quot;, url); return result;&#125; 主键查询攻略 获取攻略时需要从 strategy_content 表中查询内容信息 接口信息 值 路径地址 http://localhost:9000/article/strategies/detail 请求方式 GET 请求参数 id 返回结果 Strategy Service 找到：StrategyServiceImpl，重写 getById 方法： @Servicepublic class StrategyServiceImpl extends ServiceImpl&lt;StrategyMapper, Strategy&gt; implements StrategyService &#123; private final StrategyContentMapper strategyContentMapper; public StrategyServiceImpl(StrategyContentMapper strategyContentMapper) &#123; this.strategyContentMapper = strategyContentMapper; &#125; @Override public Strategy getById(Serializable id) &#123; Strategy strategy = super.getById(id); StrategyContent strategyContent = strategyContentMapper.selectById(id); strategy.setContent(strategyContent); return strategy; &#125;&#125; Controller 找到：StrategyController，定义查询方法： StrategyController@GetMapping(&quot;/detail&quot;)public R&lt;Strategy&gt; getById(Long id) &#123; return R.ok(strategyService.getById(id));&#125; 筛选标签查询对应的前端页面如下： 接口信息 值 路径地址 http://localhost:9000/article/strategies/conditions 请求方式 GET 请求参数 返回结果 Map{“chinaCondition”, “abroadCondition”, “themeCondition”} Mapper 找到：StrategyMapper，定义查询筛选条件的方法： StrategyMapperpublic interface StrategyMapper extends BaseMapper&lt;Strategy&gt; &#123; List&lt;StrategyCondition&gt; selectDestCondition(@Param(&quot;abroad&quot;) int abroad); List&lt;StrategyCondition&gt; selectThemeCondition();&#125; 找到：StrategyMapper.xml，实现查询筛选条件的方法： StrategyMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.article.mapper.StrategyMapper&quot;&gt; &lt;select id=&quot;selectDestCondition&quot; resultType=&quot;com.swx.article.vo.StrategyCondition&quot;&gt; SELECT dest_id refid, dest_name name, count(*) total FROM strategy WHERE isabroad = #&#123;abroad&#125; GROUP BY dest_id, dest_name ORDER BY total DESC &lt;/select&gt; &lt;select id=&quot;selectThemeCondition&quot; resultType=&quot;com.swx.article.vo.StrategyCondition&quot;&gt; SELECT theme_id refid, theme_name name, count(*) total FROM strategy GROUP BY theme_id, theme_name ORDER BY total DESC &lt;/select&gt;&lt;/mapper&gt; Service 找到：StrategyService，定义查询筛选条件的方法 /** * 查询目的地过滤条件 * @param abroad 是否国内 * @return 过滤条件 */List&lt;StrategyCondition&gt; findDestCondition(int abroad);/** * 查询主题过滤条件 * @return 过滤条件 */List&lt;StrategyCondition&gt; findThemeCondition(); 找到：StrategyServiceImpl，实现查询筛选条件的方法 StrategyServiceImpl/** * 查询目的地过滤条件 * * @param abroad 是否国内 * @return 过滤条件 */@Overridepublic List&lt;StrategyCondition&gt; findDestCondition(int abroad) &#123; return getBaseMapper().selectDestCondition(abroad);&#125;/** * 查询主题过滤条件 * * @return 过滤条件 */@Overridepublic List&lt;StrategyCondition&gt; findThemeCondition() &#123; return getBaseMapper().selectThemeCondition();&#125; Controller @GetMapping(&quot;/conditions&quot;)public R&lt;Map&lt;String, List&lt;StrategyCondition&gt;&gt;&gt; getConditions() &#123; Map&lt;String, List&lt;StrategyCondition&gt;&gt; result = new HashMap&lt;&gt;(); List&lt;StrategyCondition&gt; chinaCondition = strategyService.findDestCondition(Strategy.ABROAD_NO); List&lt;StrategyCondition&gt; abroadCondition = strategyService.findDestCondition(Strategy.ABROAD_YES); List&lt;StrategyCondition&gt; themeCondition = strategyService.findThemeCondition(); result.put(&quot;chinaCondition&quot;, chinaCondition); result.put(&quot;abroadCondition&quot;, abroadCondition); result.put(&quot;themeCondition&quot;, themeCondition); return R.ok(result);&#125; 分页查询攻略对应的前端页面如下： 接口信息 值 路径地址 http://localhost:9000/article/strategies/query 请求方式 GET 请求参数 StrategyQuery 返回结果 Page 请求参数 请求参数除了基本参数，还包括分页参数，将公共的参数放到QueryObject中： 在 core 模块中创建包：com.swx.common.core.qo，该包下创建 QueryObject QueryObject@Getter@Setterpublic class QueryObject &#123;private String keyword;private Integer current = 1;private Integer size = 10;&#125; StrategyQuery@Getter@Setterpublic class StrategyQuery extends QueryObject &#123; public static final int CONDITION_THEME = 3; private Long destId; // 目的地ID private Long themeId; // 主题ID private Long refid; // 筛选条件ID =&gt; 目的地ID｜主题ID private Integer type; // 筛选条件类型 =&gt; 目的地｜主题 private String orderBy;&#125; Service 找到：DestinationService，添加分页查询方法 StrategyService/** * 条件分页查询攻略 * * @param query 查询条件 * @return 攻略 */Page&lt;Strategy&gt; pageStrategy(StrategyQuery query); 找到：StrategyServiceImpl，实现上述方法 StrategyServiceImpl/** * 条件分页查询攻略 * * @param query 查询条件 * @return 攻略 */@Overridepublic Page&lt;Strategy&gt; pageStrategy(StrategyQuery query) &#123; // 兼容标签查询 if ((query.getType() != null &amp;&amp; query.getType() != -1)&amp;&amp; (query.getRefid() != null &amp;&amp; query.getRefid() != -1)) &#123; // 多条件标签筛选，目的地或者主题查询 if (query.getType() == StrategyQuery.CONDITION_THEME) &#123; query.setThemeId(query.getRefid()); &#125; else &#123; query.setDestId(query.getRefid()); &#125; &#125; // 目的地和主题筛选 return super.page( new Page&lt;&gt;(query.getCurrent(), query.getSize()), Wrappers.&lt;Strategy&gt;lambdaQuery() .eq(query.getDestId() != null, Strategy::getDestId, query.getDestId()) .eq(!Objects.isNull(query.getThemeId()), Strategy::getThemeId, query.getThemeId()) .orderByDesc(query.getOrderBy() != null &amp;&amp; query.getOrderBy().equals(&quot;viewnum&quot;), Strategy::getViewnum) .orderByDesc(query.getOrderBy() != null &amp;&amp; query.getOrderBy().equals(&quot;create_time&quot;), Strategy::getCreateTime) );&#125; Controller 找到：StrategyController，添加分页查询方法 StrategyController@GetMapping(&quot;/query&quot;)public R&lt;Page&lt;Strategy&gt;&gt; pageList(StrategyQuery query) &#123; return R.ok(strategyService.pageStrategy(query));&#125; 保存更新攻略接口信息 保存攻略 值 路径地址 http://localhost:9000/article/strategies/save 请求方式 POST 请求参数 Strategy 返回结果 更新攻略 值 路径地址 http://localhost:9000/article/strategies/update 请求方式 POST 请求参数 Strategy 返回结果 Service 更新或者保存方法 @Servicepublic class StrategyServiceImpl extends ServiceImpl&lt;StrategyMapper, Strategy&gt; implements StrategyService &#123; private final StrategyCatalogService strategyCatalogService; private final DestinationService destinationService; private final StrategyThemeService strategyThemeService; private final StrategyContentMapper strategyContentMapper; public StrategyServiceImpl(StrategyCatalogService strategyCatalogService, DestinationService destinationService, StrategyThemeService strategyThemeService, StrategyContentMapper strategyContentMapper) &#123; this.strategyCatalogService = strategyCatalogService; this.destinationService = destinationService; this.strategyThemeService = strategyThemeService; this.strategyContentMapper = strategyContentMapper; &#125; private Boolean doSaveOrUpdate(Strategy strategy) &#123; // 有封面数据且是base64时才做上传处理 if (StringUtils.hasText(strategy.getCoverUrl()) &amp;&amp; !strategy.getCoverUrl().startsWith(&quot;http&quot;)) &#123; // 上传封面图片，得到URL后，重新设置到cover属性中 String fiilename = UUID.randomUUID().toString(); // 可以解析base64得到格式，这里直接写死 String url = OssUtil.uploadImgByBase64(&quot;images/strategies&quot;, fiilename + &quot;.jpg&quot;, strategy.getCoverUrl()); strategy.setCoverUrl(url); &#125; // 补充分类名称 StrategyCatalog catalog = strategyCatalogService.getById(strategy.getCatalogId()); if (catalog == null) &#123; throw new BizException(R.CODE_ERROR_PARAM, &quot;分类参数异常&quot;); &#125; strategy.setCatalogName(catalog.getName()); // 根据分类目的地id/名称，设置到目的地中 strategy.setDestId(catalog.getDestId()); strategy.setDestName(catalog.getDestName()); // 判断目的地是否是国外 List&lt;Destination&gt; toasts = destinationService.toasts(catalog.getDestId()); if (toasts.get(0).getId() == 1) &#123; strategy.setIsabroad(Strategy.ABROAD_NO); &#125; else &#123; strategy.setIsabroad(Strategy.ABROAD_YES); &#125; // 查询主题，填充主题名称 StrategyTheme theme = strategyThemeService.getById(strategy.getThemeId()); if (theme == null) &#123; throw new BizException(R.CODE_ERROR_PARAM, &quot;主题参数异常&quot;); &#125; strategy.setThemeName(theme.getName()); if (strategy.getId() == null) &#123; // 设置创建时间 strategy.setCreateTime(new Date()); // 设置各种数量为0 strategy.setViewnum(0); strategy.setSharenum(0); strategy.setThumbsupnum(0); strategy.setReplynum(0); strategy.setFavornum(0); // 重新设置状态 strategy.setState(Strategy.STATE_NORMAL); // 保存攻略对象，得到自增ID boolean save = super.save(strategy); // 将攻略ID设置到内容对象中，保存内容对象 StrategyContent content = strategy.getContent(); content.setId(strategy.getId()); return save &amp;&amp; strategyContentMapper.insert(content) &gt; 0; &#125; // 更新操作 boolean ret = super.updateById(strategy); StrategyContent content = strategy.getContent(); content.setId(strategy.getId()); int row = strategyContentMapper.updateById(content); return ret &amp;&amp; row &gt; 0; &#125;&#125; 重写保存方法 /** * 保存攻略 * * @param strategy 攻略参数对象 */@Transactional(rollbackFor = Exception.class)@Overridepublic boolean save(Strategy strategy) &#123; // 同一类，事务调用非事务，事务都生效 return doSaveOrUpdate(strategy);&#125; 重写更新方法 /** * 更新攻略 * * @param strategy 攻略参数对象 */@Transactional(rollbackFor = Exception.class)@Overridepublic boolean updateById(Strategy strategy) &#123; return doSaveOrUpdate(strategy);&#125; Controller 保存攻略 StrategyController@PostMapping(&quot;/save&quot;)public R&lt;?&gt; save(Strategy strategy) &#123; return R.ok(strategyService.save(strategy));&#125; 更新攻略 @PostMapping(&quot;/update&quot;)public R&lt;?&gt; update(Strategy strategy) &#123; strategyService.updateById(strategy); return R.ok();&#125; 查询攻略内容接口信息 值 路径地址 http://localhost:9000/article/strategies/content 请求方式 GET 请求参数 id 返回结果 StrategyContent Service 找到：DestinationService，添加分页查询方法 StrategyService/** * 根据攻略ID，返回攻略内容 * * @param id 攻略ID * @return 攻略内容 */StrategyContent getContentById(Long id); 找到：StrategyServiceImpl，实现上述方法 StrategyServiceImpl/** * 根据攻略ID，返回攻略内容 * * @param id 攻略ID * @return 攻略内容 */@Overridepublic StrategyContent getContentById(Long id) &#123; return strategyContentMapper.selectById(id);&#125; Controller 找到：StrategyController，添加查询方法 StrategyController@GetMapping(&quot;/content&quot;)public R&lt;StrategyContent&gt; getContentById(Long id) &#123; return R.ok(strategyService.getContentById(id));&#125; 分组查询攻略 根据攻略类别分组查询指定目的地下的攻略 对应的前端页面如下： 接口信息 值 路径地址 http://localhost:9000/article/strategies/groups 请求方式 GET 请求参数 返回结果 List Mapper 找到：StrategyMapper，定义分组查询的方法： StrategyMapperpublic interface StrategyMapper extends BaseMapper&lt;Strategy&gt; &#123; List&lt;StrategyCatalog&gt; selectGroupsByDestId(@Param(&quot;destId&quot;) Long destId);&#125; 找到：StrategyMapper.xml，实现分组查询的方法： StrategyMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.article.mapper.StrategyMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.swx.article.domain.Strategy&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;CatalogGroupMap&quot; type=&quot;com.swx.article.domain.StrategyCatalog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;catalog_id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;catalog_name&quot; /&gt; &lt;collection property=&quot;strategies&quot; resultMap=&quot;BaseResultMap&quot; columnPrefix=&quot;s_&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectGroupsByDestId&quot; resultMap=&quot;CatalogGroupMap&quot;&gt; SELECT t.catalog_id, t.catalog_name, s.id s_id, s.title s_title FROM (SELECT catalog_id, catalog_name FROM strategy WHERE dest_id = #&#123;destId&#125; GROUP BY catalog_id, catalog_name) t JOIN strategy s ON t.catalog_id = s.catalog_id &lt;/select&gt;&lt;/mapper&gt; Service 找到：StrategyService，定义分组查询的方法 StrategyService/** * 根据目的地ID，分组查询攻略分类下的攻略 * * @param destId 目的地ID * @return 分类及其下的攻略 */List&lt;StrategyCatalog&gt; findGroupsByDestId(Long destId); 找到：StrategyServiceImpl，实现查询筛选条件的方法 StrategyServiceImpl/** * 根据目的地ID，分组查询攻略分类下的攻略 * * @param destId 目的地ID * @return 分类及其下的攻略 */@Overridepublic List&lt;StrategyCatalog&gt; findGroupsByDestId(Long destId) &#123; return baseMapper.selectGroupsByDestId(destId);&#125; Controller StrategyController@GetMapping(&quot;/groups&quot;)public R&lt;List&lt;StrategyCatalog&gt;&gt; groupByCatalog(Long destId) &#123; return R.ok(strategyService.findGroupsByDestId(destId));&#125; 攻略排行榜 攻略排行榜采用收藏数+点赞数的方式，计算导致索引失效，查询效率变低。排行榜的实时性要求不高，因此设计strategy_rank表，用于保存排行榜信息，使用Spring Boot定时任务，每10分钟获取排行数据保存到strategy_rank表中，查询时从该表查询即可。 数据处理模块新建 trip-data-server 模块，pom依赖如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-modules&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-data-server&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-article-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 开启任务调度 /** * 启用 Spring 任务调度 */@EnableScheduling@MapperScan(&quot;com.swx.data.mapper&quot;)@SpringBootApplicationpublic class DataApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DataApplication.class, args); &#125;&#125; 在 trip-data-server 模块下创建 StrategyMapper 和 StrategyRankMapper 查询排行数据新建 StrategyMapper 文件 public interface StrategyMapper extends BaseMapper&lt;Strategy&gt; &#123; List&lt;StrategyRank&gt; selectStrategyRankByAbroad(@Param(&quot;abroad&quot;) Integer abroad); List&lt;StrategyRank&gt; selectStrategyRankHotList();&#125; 在 StrategyMapper.xml 中实现SQL StrategyMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.data.mapper.StrategyMapper&quot;&gt; &lt;select id=&quot;selectStrategyRankByAbroad&quot; resultMap=&quot;com.swx.data.mapper.StrategyRankMapper.BaseResultMap&quot;&gt; SELECT id strategy_id, title strategy_title, dest_id, dest_name, thumbsupnum + favornum statisnum FROM strategy WHERE isabroad = #&#123;abroad&#125; ORDER BY statisnum desc limit 10 &lt;/select&gt; &lt;select id=&quot;selectStrategyRankHotList&quot; resultMap=&quot;com.swx.data.mapper.StrategyRankMapper.BaseResultMap&quot;&gt; SELECT id strategy_id, title strategy_title, dest_id, dest_name, (viewnum * 0.2) + (replynum * 0.4) + (favornum * 0.4) statisnum FROM strategy ORDER BY statisnum desc limit 10 &lt;/select&gt;&lt;/mapper&gt; 批量插入排行数据新建 StrategyRankMapper 文件 StrategyRankMapperpublic interface StrategyRankMapper extends BaseMapper&lt;StrategyRank&gt; &#123; int batchInsert(@Param(&quot;strategyRanks&quot;) List&lt;StrategyRank&gt; strategyRanks);&#125; 在 StrategyRankMapper.xml 中实现SQL &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.swx.data.mapper.StrategyRankMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.swx.article.domain.StrategyRank&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;destId&quot; column=&quot;dest_id&quot;/&gt; &lt;result property=&quot;destName&quot; column=&quot;dest_name&quot;/&gt; &lt;result property=&quot;strategyId&quot; column=&quot;strategy_id&quot;/&gt; &lt;result property=&quot;strategyTitle&quot; column=&quot;strategy_title&quot;/&gt; &lt;result property=&quot;type&quot; column=&quot;type&quot;/&gt; &lt;result property=&quot;statisTime&quot; column=&quot;statis_time&quot;/&gt; &lt;result property=&quot;statisnum&quot; column=&quot;statisnum&quot;/&gt; &lt;/resultMap&gt; &lt;insert id=&quot;batchInsert&quot;&gt; INSERT INTO strategy_rank(dest_id, dest_name, strategy_id, strategy_title, type, statis_time, statisnum) values &lt;foreach collection=&quot;strategyRanks&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt; (#&#123;item.destId&#125;, #&#123;item.destName&#125;, #&#123;item.strategyId&#125;, #&#123;item.strategyTitle&#125;, #&#123;item.type&#125;, #&#123;item.statisTime&#125;, #&#123;item.statisnum&#125;) &lt;/foreach&gt; &lt;/insert&gt;&lt;/mapper&gt; 任务调度Service创建 StrategyRankStatisticJob /** * 攻略排行数据统计任务 */@Slf4j@Servicepublic class StrategyRankStatisticJob &#123; private final StrategyMapper strategyMapper; private final StrategyRankMapper strategyRankMapper; public StrategyRankStatisticJob(StrategyMapper strategyMapper, StrategyRankMapper strategyRankMapper) &#123; this.strategyMapper = strategyMapper; this.strategyRankMapper = strategyRankMapper; &#125; /** * 每10分钟执行统计任务 */ @Transactional(rollbackFor = Exception.class) // @Scheduled(cron = &quot;0 */10 * * * *&quot;) @Scheduled(cron = &quot;0 * * * * *&quot;) public void statisticRank() &#123; log.info(&quot;[攻略排行统计] 排行数据统计开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); Date now = new Date(); // 删除这一次之前的所有数据 strategyRankMapper.delete(Wrappers.&lt;StrategyRank&gt;lambdaQuery().lt(StrategyRank::getStatisTime, now)); log.info(&quot;[攻略排行统计] 删除旧的排行数据 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); // 统计国内 doStatistic(now, StrategyRank.TYPE_CHINA, () -&gt; strategyMapper.selectStrategyRankByAbroad(Strategy.ABROAD_NO)); // 统计国外 doStatistic(now, StrategyRank.TYPE_ABROAD, () -&gt; strategyMapper.selectStrategyRankByAbroad(Strategy.ABROAD_YES)); // 统计热门 doStatistic(now, StrategyRank.TYPE_HOT, strategyMapper::selectStrategyRankHotList); &#125; public void doStatistic(Date now, Integer type, Supplier&lt;List&lt;StrategyRank&gt;&gt; rankSupplier) &#123; List&lt;StrategyRank&gt; strategyRanks = rankSupplier.get(); log.info(&quot;[攻略排行统计] 排行数据统计：type=&#123;&#125;, ranks=&#123;&#125;&quot;, type, strategyRanks.size()); for (StrategyRank strategyRank : strategyRanks) &#123; strategyRank.setType(type); strategyRank.setStatisTime(now); &#125; // 保存到排名表中 strategyRankMapper.batchInsert(strategyRanks); &#125;&#125; 查询排行榜接口信息 值 路径地址 http://localhost:9000/article/strategies/ranks 请求方式 GET 请求参数 返回结果 Map{“abroadRank”, “chinaRank”, “hotRank”} Service 新建 StrategyRankService，定义获取排行方法 StrategyRankServicepublic interface StrategyRankService extends IService&lt;StrategyRank&gt; &#123; /** * 根据类型获取排名 * * @param type 类型 * @return 排名 */ List&lt;StrategyRank&gt; selectLastRanksByType(int type);&#125; 实现上述方法 StrategyRankServiceImpl@Servicepublic class StrategyRankServiceImpl extends ServiceImpl&lt;StrategyRankMapper, StrategyRank&gt; implements StrategyRankService &#123; @Override public List&lt;StrategyRank&gt; selectLastRanksByType(int type) &#123; return list(Wrappers.&lt;StrategyRank&gt;lambdaQuery() .eq(StrategyRank::getType, type) .orderByDesc(StrategyRank::getStatisTime) .last(&quot;limit 10&quot;) ); &#125;&#125; Controller StrategyController@RestController@RequestMapping(&quot;/strategies&quot;)public class StrategyController &#123; private final StrategyRankService strategyRankService; public StrategyController(StrategyRankService strategyRankService) &#123; this.strategyRankService = strategyRankService; &#125;\t@GetMapping(&quot;/ranks&quot;) public R&lt;JSONObject&gt; ranks() &#123; List&lt;StrategyRank&gt; chinaRank = strategyRankService.selectLastRanksByType(StrategyRank.TYPE_CHINA); List&lt;StrategyRank&gt; abroadRank = strategyRankService.selectLastRanksByType(StrategyRank.TYPE_CHINA); List&lt;StrategyRank&gt; hotRank = strategyRankService.selectLastRanksByType(StrategyRank.TYPE_HOT); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;abroadRank&quot;, abroadRank); jsonObject.put(&quot;chinaRank&quot;, chinaRank); jsonObject.put(&quot;hotRank&quot;, hotRank); return R.ok(jsonObject); &#125;&#125; 删除攻略接口信息 值 路径地址 http://localhost:9000/article/strategies/delete/{id} 请求方式 POST 请求参数 id 返回结果 Controller StrategyController@PostMapping(&quot;/delete/&#123;id&#125;&quot;)public R&lt;?&gt; delete(@PathVariable Long id) &#123; strategyService.removeById(id); return R.ok();&#125; 查询浏览量前三的攻略接口信息 值 路径地址 http://localhost:9000/article/strategies/viewnumTop3 请求方式 GET 请求参数 destId 返回结果 List Service 找到：StrategyService，定义查询的方法 StrategyService/** * 根据目的地ID，查询浏览量最高的前3篇攻略 * * @param destId 目的地 * @return 浏览量最高的前3篇攻略 */List&lt;Strategy&gt; findViewnumTop3(Long destId); 找到：StrategyServiceImpl，实现查询的方法 StrategyServiceImpl/** * 根据目的地ID，查询浏览量最高的前3篇攻略 * * @param destId 目的地 * @return 浏览量最高的前3篇攻略 */@Overridepublic List&lt;Strategy&gt; findViewnumTop3(Long destId) &#123; return super.list(Wrappers.&lt;Strategy&gt;lambdaQuery() .eq(Strategy::getDestId, destId) .orderByDesc(Strategy::getViewnum) .last(&quot;limit 3&quot;) );&#125; Controller StrategyController@GetMapping(&quot;/viewnumTop3&quot;)public R&lt;List&lt;Strategy&gt;&gt; viewnumTop3(Long destId) &#123; return R.ok(strategyService.findViewnumTop3(destId));&#125;"},{"title":"安装MongoDB","path":"/wiki/trip-cloud/07_comment/mongodb.html","content":"评论微服务引入新的数据库：MongoDB，攻略和游记的评论信息都存放到MongoDB中。 docker安装mongodb docker pull mongo:latest 启动mongodb容器 docker run -itd --name mongo -p 27017:27017 mongo --auth 接着使用以下命令添加用户和设置密码，并且尝试连接。 $ docker exec -it mongo mongo admin# 创建一个名为 admin，密码为 123456 的用户。&gt; db.createUser(&#123; user:&#x27;admin&#x27;,pwd:&#x27;123456&#x27;,roles:[ &#123; role:&#x27;userAdminAnyDatabase&#x27;, db: &#x27;admin&#x27;&#125;,&quot;readWriteAnyDatabase&quot;]&#125;);# 尝试使用上面创建的用户信息进行连接。&gt; db.auth(&#x27;swcode&#x27;, &#x27;123456&#x27;) 创建评论数据库 $ use trip-comment# 创建一个名为 swcode，密码为 123456 的用户。&gt; db.createUser(&#123; user:&#x27;swcode&#x27;,pwd:&#x27;123456&#x27;,roles:[ &#123; role:&#x27;readWrite&#x27;, db: &#x27;trip-comment&#x27;&#125;]&#125;); 使用IDEA连接"},{"title":"攻略评论","path":"/wiki/trip-cloud/07_comment/strategy.html","content":"对应的前端页面如下，攻略模块的评论只能对攻略评论，不能回复其他评论。 文档类找到模块：trip-comment-api，找到包com.swx.comment.domain，创建攻略评论文档实体类 StrategyComment/** * 攻略评论 */@Setter@Getter@Document(&quot;strategy_comment&quot;)@ToStringpublic class StrategyComment implements Serializable &#123; @Id private String id; private Long strategyId; //攻略(明细)id private String strategyTitle; //攻略标题 private Long userId; //用户id private String nickname; //用户名 private String city; private int level; private String headImgUrl; //头像 private Date createTime; //创建时间 private String content; //评论内容 private int thumbupnum; //点赞数 private List&lt;Long&gt; thumbuplist = new ArrayList&lt;&gt;();&#125; 初始化 找到模块：trip-comment-server 创建包：com.swx.comment.repository，创建接口：StrategyCommentRepository StrategyCommentRepository/** * 攻略评论 Repository */public interface StrategyCommentRepository extends MongoRepository&lt;StrategyComment, String&gt; &#123;&#125; 创建包：com.swx.comment.service，创建接口：StrategyCommentService StrategyCommentServicepublic interface StrategyCommentService &#123; &#125; 创建包：com.swx.comment.service.impl，创建类：StrategyCommentServiceImpl StrategyCommentServiceImpl@Slf4j@Servicepublic class StrategyCommentServiceImpl implements StrategyCommentService &#123; private final StrategyCommentRepository strategyCommentRepository; private final MongoTemplate mongoTemplate; public StrategyCommentServiceImpl(StrategyCommentRepository strategyCommentRepository, MongoTemplate mongoTemplate) &#123; this.strategyCommentRepository = strategyCommentRepository; this.mongoTemplate = mongoTemplate; &#125;&#125; 创建包：com.swx.comment.controller，创建类：StrategyCommentController StrategyCommentController@RestController@RequestMapping(&quot;/strategies/comments&quot;)public class StrategyCommentController &#123; private final StrategyCommentService strategyCommentService; public StrategyCommentController(StrategyCommentService strategyCommentService) &#123; this.strategyCommentService = strategyCommentService; &#125;&#125; 分页查询评论接口信息 值 路径地址 http://localhost:9000/comment/strategies/comments/query 请求方式 GET 请求参数 CommentQuery 返回结果 R { code: “”, msg: “”, data:Page } 查询条件找到模块：trip-comment-api，创建包：com.swx.comment.qo，包下创建查询类：CommentQuery CommentQuery@Getter@Setterpublic class CommentQuery extends QueryObject &#123; private Long articleId;&#125; Service找到：StrategyCommentService，定义分组查询方法 StrategyCommentService/** * 分页查询 * @param qo 分页参数 * @return 评论 */Page&lt;StrategyComment&gt; page(CommentQuery qo); 找到：StrategyCommentServiceImpl，实现上述方法 StrategyCommentServiceImpl/** * 分页查询 * * @param qo 分页参数 * @return 评论 */@Overridepublic Page&lt;StrategyComment&gt; page(CommentQuery qo) &#123; // 拼接查询条件 Criteria criteria = Criteria.where(&quot;strategyId&quot;).is(qo.getArticleId()); // 创建查询对象，关联条件 Query query = new Query(); query.addCriteria(criteria); // 统计总数 long total = mongoTemplate.count(query, StrategyComment.class); if (total == 0) &#123; return Page.empty(); &#125; // 设置分页参数 PageRequest request = PageRequest.of(qo.getCurrent() - 1, qo.getSize()); query.skip(request.getOffset()).limit(request.getPageSize()); // 按照时间排序 query.with(Sort.by(Sort.Direction.DESC, &quot;createTime&quot;)); // 查询数据 List&lt;StrategyComment&gt; records = mongoTemplate.find(query, StrategyComment.class); return new PageImpl&lt;&gt;(records, request, total);&#125; Controller找到：StrategyCommentController，定义分页查询接口 StrategyCommentController@GetMapping(&quot;/query&quot;)public R&lt;Page&lt;StrategyComment&gt;&gt; saveComment(CommentQuery query) &#123; return R.ok(strategyCommentService.page(query));&#125; 保存评论接口信息 值 路径地址 http://localhost:9000/comment/strategies/comments/save 请求方式 GET 请求参数 strategyId，strategyTitle 返回结果 R { code: “”, msg: “”, data: } Service找到：StrategyCommentService，定义保存方法 StrategyCommentService/** * 保存评论 * * @param comment 攻略评论 */void save(StrategyComment comment); 找到：StrategyCommentServiceImpl，实现上述方法 StrategyCommentServiceImpl/** * 保存评论 * * @param comment 攻略评论 */@Overridepublic void save(StrategyComment comment) &#123; // 获取当前登陆用户 LoginUser loginUser = AuthenticationUtil.getLoginUser(); if (loginUser == null) &#123; log.error(&quot;[攻略评论模块] 获取登陆用户信息错误&quot;); throw new BizException(&quot;获取登陆用户信息错误&quot;); &#125; comment.setUserId(loginUser.getId()); comment.setNickname(loginUser.getNickname()); comment.setCity(loginUser.getCity()); comment.setLevel(loginUser.getLevel()); comment.setHeadImgUrl(loginUser.getHeadImgUrl()); comment.setCreateTime(new Date()); // 保存到 mongodb strategyCommentRepository.save(comment);&#125; Controller找到：StrategyCommentController，定义保存接口 该接口需要登陆才能访问 StrategyCommentController@RequireLogin@PostMapping(&quot;/save&quot;)public R&lt;?&gt; saveComment(StrategyComment comment) &#123; strategyCommentService.save(comment); return R.ok();&#125; 点赞评论 取消点赞也是该方法 接口信息 值 路径地址 http://localhost:9000/comment/strategies/comments/likes 请求方式 GET 请求参数 cid 返回结果 R { code: “”, msg: “”, data: } Service找到：StrategyCommentService，定义点赞方法 StrategyCommentService/** * 点赞和取消点赞 * @param cid 评论ID */void doLike(String cid); 找到：StrategyCommentServiceImpl，实现上述方法 StrategyCommentServiceImpl/** * 点赞和取消点赞 * * @param cid 评论ID */@Overridepublic void doLike(String cid) &#123; // 基于 cid 查询评论对象 Optional&lt;StrategyComment&gt; optional = strategyCommentRepository.findById(cid); if (optional.isPresent()) &#123; StrategyComment strategyComment = optional.get(); // 获取当前登陆用户对象 LoginUser loginUser = AuthenticationUtil.getLoginUser(); // 判断当前用户是否点赞 if (strategyComment.getThumbuplist().contains(loginUser.getId())) &#123; // 如果点赞：点赞数-1，将用户 id 从集合中删除 strategyComment.setThumbupnum(strategyComment.getThumbupnum() - 1); strategyComment.getThumbuplist().remove(loginUser.getId()); &#125; else &#123; // 如果没点赞：点赞数+1， 将用户 id 添加到集合中 strategyComment.setThumbupnum(strategyComment.getThumbupnum() + 1); strategyComment.getThumbuplist().add(loginUser.getId()); &#125; // 重新将对象保存到 mongodb strategyCommentRepository.save(strategyComment); &#125;&#125; Controller找到：StrategyCommentController，定义点赞接口 该接口需要登陆才能访问 StrategyCommentController@RequireLogin@PostMapping(&quot;/likes&quot;)public R&lt;?&gt; likes(String cid) &#123; strategyCommentService.doLike(cid); return R.ok();&#125;"},{"title":"游记评论","path":"/wiki/trip-cloud/07_comment/travel.html","content":"对应的前端页面如下，游记模块的评论即可对游记评论，也能回复其他评论。 文档类找到模块：trip-comment-api，找到包com.swx.comment.domain，创建游记评论文档实体类 TravelComment/** * 游记评论 */@Setter@Getter@Document(&quot;travel_comment&quot;)public class TravelComment implements Serializable &#123; public static final int TRAVLE_COMMENT_TYPE_COMMENT = 0; //普通评论 public static final int TRAVLE_COMMENT_TYPE = 1; //评论的评论 @Id private String id; //id private Long travelId; //游记id private String travelTitle; //游记标题 private Long userId; //用户id private String nickname; //用户名 private String city; private Integer level; private String headImgUrl; // 用户头像 private Integer type; //评论类别 private Date createTime; //创建时间 private String content; //评论内容 private TravelComment refComment; //关联的评论&#125; 初始化 找到模块：trip-comment-server 创建包：com.swx.comment.repository，创建接口：TravelCommentRepository TravelCommentRepository/** * 游记评论 Repository */public interface TravelCommentRepository extends MongoRepository&lt;TravelComment, String&gt; &#123;&#125; 创建包：com.swx.comment.service，创建接口：TravelCommentService TravelCommentServicepublic interface TravelCommentService &#123; &#125; 创建包：com.swx.comment.service.impl，创建类：TravelCommentServiceImpl TravelCommentServiceImpl@Slf4j@Servicepublic class TravelCommentServiceImpl implements TravelCommentService &#123; private final TravelCommentRepository travelCommentRepository; private final MongoTemplate mongoTemplate; public TravelCommentServiceImpl(TravelCommentRepository travelCommentRepository, MongoTemplate mongoTemplate) &#123; this.travelCommentRepository = travelCommentRepository; this.mongoTemplate = mongoTemplate; &#125;&#125; 创建包：com.swx.comment.controller，创建类：TravelCommentController TravelCommentController@RestController@RequestMapping(&quot;/travels/comments&quot;)public class TravelCommentController &#123; private final TravelCommentService travelCommentService; public TravelCommentController(TravelCommentService travelCommentService) &#123; this.travelCommentService = travelCommentService; &#125;&#125; 查询评论接口信息 值 路径地址 http://localhost:9000/comment/travels/comments/query 请求方式 GET 请求参数 travelId 返回结果 R { code: “”, msg: “”, data:List } Service找到：TravelCommentService，定义查询方法 TravelCommentService/** * 获取游记的评论 * @param travelId 游记ID * @return 所有评论 */List&lt;TravelComment&gt; findList(Long travelId); 找到：TravelCommentServiceImpl，实现上述方法 TravelCommentServiceImpl/** * 获取游记的评论 * * @param travelId 游记ID * @return 所有评论 */@Overridepublic List&lt;TravelComment&gt; findList(Long travelId) &#123; Query query = new Query() .with(Sort.by(Sort.Direction.DESC, &quot;createTime&quot;)) .addCriteria(Criteria.where(&quot;travelId&quot;).is(travelId)); List&lt;TravelComment&gt; travelComments = mongoTemplate.find(query, TravelComment.class); for (TravelComment travelComment : travelComments) &#123; TravelComment refComment = travelComment.getRefComment(); if (refComment != null &amp;&amp; refComment.getId() != null) &#123; Optional&lt;TravelComment&gt; refCommentOptional = travelCommentRepository.findById(refComment.getId()); travelComment.setRefComment(refCommentOptional.orElse(null)); &#125; &#125; return travelComments;&#125; Controller找到：TravelCommentController，定义查询接口 TravelCommentController@GetMapping(&quot;/query&quot;)public R&lt;List&lt;TravelComment&gt;&gt; findList(Long travelId) &#123; return R.ok(travelCommentService.findList(travelId));&#125; 保存评论接口信息 值 路径地址 http://localhost:9000/comment/travels/comments/save 请求方式 GET 请求参数 TravelComment 返回结果 R { code: “”, msg: “”, data: } Service找到：TravelCommentService，定义保存方法 TravelCommentService/** * 保存游记评论 * @param comment 评论信息 */void save(TravelComment comment); 找到：TravelCommentServiceImpl，实现上述方法 TravelCommentServiceImpl/** * 保存游记评论 * * @param comment 评论信息 */@Overridepublic void save(TravelComment comment) &#123; // 获取当前登陆用户 LoginUser loginUser = AuthenticationUtil.getLoginUser(); if (loginUser == null) &#123; log.error(&quot;[游记评论模块] 获取登陆用户信息错误&quot;); throw new BizException(&quot;获取登陆用户信息错误&quot;); &#125; comment.setUserId(loginUser.getId()); comment.setNickname(loginUser.getNickname()); comment.setCity(loginUser.getCity()); comment.setLevel(loginUser.getLevel()); comment.setHeadImgUrl(loginUser.getHeadImgUrl()); comment.setCreateTime(new Date()); if (comment.getRefComment() != null &amp;&amp; StringUtils.hasLength(comment.getRefComment().getId())) &#123; // 评论的评论 comment.setType(TravelComment.TRAVLE_COMMENT_TYPE); &#125; else &#123; // 普通评论 comment.setType(TravelComment.TRAVLE_COMMENT_TYPE_COMMENT); &#125; travelCommentRepository.save(comment);&#125; Controller找到：TravelCommentController，定义保存接口 该接口需要登陆才能访问 TravelCommentController@RequireLogin@PostMapping(&quot;/save&quot;)public R&lt;?&gt; queryComment(TravelComment comment) &#123; travelCommentService.save(comment); return R.ok();&#125;"},{"title":"初始化统计数据","path":"/wiki/trip-cloud/08_statdata/datainit.html","content":"前面我们实现了用户进入页面增加浏览量，评论时增加评论数等操作，但是当项目第一次启动时，Redis中没有统计数据，导致查询攻略时拿到的统计数据（从Redis中获取）和数据库不一致。因此，在项目启动时，从数据库中查询文章的统计数据，将其写入Redis中。 我们需要在项目初始化完成后，执行统计数据初始化操作，可以通过继承 ApplicationListener 监听器实现 ApplicationEvent以及Listener是Spring为我们提供的一个事件监听、订阅的实现，内部实现原理是观察者设计模式，设计初衷也是为了系统业务逻辑之间的解耦，提高可扩展性以及可维护性。 在模块：trip-article-server中新建com.swx.article.listener包，创建 RedisStatDataInitListener 类，实现ApplicationListener 接口，重写其中的 onApplicationEvent 方法，当上下文event.getApplicationContext()为AnnotationConfigServletWebServerApplicationContext时，Spring容器启动完成，这个时候可以开始我们的数据初始化工作。 当数据量过大时，可以考虑分批次查询，每批次交给一个线程去异步执行 也可以写一个初始化的接口，url可以设置为一个随机字符串，防止接口被滥用，为保证初始化接口只能使用一次，可以将状态保存到 Redis 中，当 Redis 存在该状态时，表面已经初始化过，直接返回404. RedisStatDataInitListener@Componentpublic class RedisStatDataInitListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; private final StrategyService strategyService; private final RedisService redisService; public RedisStatDataInitListener(StrategyService strategyService, RedisService redisService) &#123; this.strategyService = strategyService; this.redisService = redisService; &#125; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; ApplicationContext ctx = event.getApplicationContext(); System.out.println(ctx.getClass()); if (AnnotationConfigServletWebServerApplicationContext.class == ctx.getClass()) &#123; System.out.println(&quot;-------------- 容器启动完成，执行初始化数据 --------------&quot;); // 查询所有攻略数据 // TODO: 不能一次加载所有数据 List&lt;Strategy&gt; strategies = strategyService.list(); System.out.println(&quot;[攻略统计数据初始化]&quot;); System.out.println(&quot;攻略数：&quot; + strategies.size()); int count = 0; for (Strategy strategy : strategies) &#123; String fullKey = StrategyRedisKeyPrefix.STRATEGIES_STAT_DATA_MAP.fullKey(strategy.getId() + &quot;&quot;); Boolean exists = redisService.hasKey(fullKey); if (!exists) &#123; // 不存在，将数据存入 Redis HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;viewnum&quot;, strategy.getViewnum()); map.put(&quot;thumbsupnum&quot;, strategy.getThumbsupnum()); map.put(&quot;replynum&quot;, strategy.getReplynum()); map.put(&quot;favornum&quot;, strategy.getFavornum()); map.put(&quot;sharenum&quot;, strategy.getSharenum()); redisService.setCacheMap(fullKey, map); count++; &#125; &#125; System.out.println(&quot;初始化：&quot; + count); // 遍历攻略列表，判断当前对象在 Redis 中是否存在 System.out.println(&quot;-------------- 数据初始化完成 --------------&quot;); &#125; &#125;&#125; 这里容器启动时会导致循环依赖，需要修改 StrategyServiceImpl 类，在 UserInfoFeignService 前添加@Lazy注解。 StrategyServiceImplpublic StrategyServiceImpl(@Lazy UserInfoFeignService userInfoFeignService) &#123; this.userInfoFeignService = userInfoFeignService;&#125;"},{"title":"数据同步方案","path":"/wiki/trip-cloud/08_statdata/datasync.html","content":"Redis 中的统计数据最终要写回到数据库中，这样才能保证数据的一致性。 思考？哪些数据需要同步？，是否一次性将所有数据同步到MySQL？ 当数据没有变动时，这样的数据无需更新 当 Redis 数据量过大时，全部查出来做同步操作对性能有影响 解决方案： 使用 Redis 的 ZSet，ZSet 可以设置分数，根据分数范围查询数据 当文章被浏览，置顶等操作时，将该文章添加到ZSet中，同时增加分数 使用定时任务，每次从 ZSet 中查询给定分数范围的数据，将其同步到数据库中。 同步完成删除该范围的数据，即清除 ZSet 中已同步的数据 统计文章分数打开模块：trip-article-server，找到：StrategyServiceImpl，修改statDataIncr方法，增加统计文章分数方法 RedisService 中加入该方法，当文章不存在时会新增一个 /** * 针对 zset 成员进行增加分数 * * @param prefix 前缀 * @param increment 增加的值 * @param member 成员 */public void zsetIncrement(KeyPrefix prefix, double increment, Object member, String... suffix) &#123; redisTemplate.opsForZSet().incrementScore(prefix.fullKey(suffix), member, increment);&#125; StrategyServiceImpl/** * hashKey 对应的 value 自增 * @param hashKey hash key * @param sid 攻略id */private void statDataIncr(String hashKey, Long sid) &#123; redisService.hashIncrement(StrategyRedisKeyPrefix.STRATEGIES_STAT_DATA_MAP, hashKey, 1, sid + &quot;&quot;); redisService.zsetIncrement(StrategyRedisKeyPrefix.STRATEGIES_STAT_DATA_MAP, 1, sid + &quot;&quot;);&#125; 数据同步定时任务打开模块：trip-data-server，在com.swx.data.job包下创建 StrategyStatDataPersistenceJob StrategyStatDataPersistenceJob/** * 攻略统计数据持久化 */@Slf4j@Componentpublic class StrategyStatDataPersistenceJob &#123; private final RedisService redisService; private final StrategyService strategyService; public StrategyStatDataPersistenceJob(RedisService redisService, StrategyService strategyService) &#123; this.redisService = redisService; this.strategyService = strategyService; &#125; /** * 每10分钟执行一次 */ @Scheduled(cron = &quot;0 */10 * * * *&quot;) public void task() &#123; log.info(&quot;[攻略数据持久化] ---------------- 持久化数据开始 ----------------&quot;); // 根据分数范围获取指定的成员 Set&lt;Integer&gt; list = redisService.zsetRerange(StrategyRedisKeyPrefix.STRATEGIES_STAT_COUNT_RANK_ZSET, 0, Integer.MAX_VALUE); if (list != null &amp;&amp; !list.isEmpty()) &#123; // 根据成员id，拼接key 取出统计数据 List&lt;Strategy&gt; updateList = new ArrayList&lt;&gt;(); for (Integer id : list) &#123; Map&lt;String, Object&gt; map = redisService.getCacheMap(StrategyRedisKeyPrefix.STRATEGIES_STAT_DATA_MAP.fullKey(id + &quot;&quot;)); // 将数据封装为攻略对象，将对象存入待更新的集合 Strategy strategy = new Strategy(); strategy.setViewnum((Integer) map.get(&quot;viewnum&quot;)); strategy.setReplynum((Integer) map.get(&quot;replynum&quot;)); strategy.setFavornum((Integer) map.get(&quot;favornum&quot;)); strategy.setSharenum((Integer) map.get(&quot;sharenum&quot;)); strategy.setThumbsupnum((Integer) map.get(&quot;thumbsupnum&quot;)); strategy.setId(id.longValue()); updateList.add(strategy); &#125; // 批量更新到数据库 strategyService.updateBatchById(updateList); // 删除已经更新过的成员 redisService.zsetRemoveRange(StrategyRedisKeyPrefix.STRATEGIES_STAT_COUNT_RANK_ZSET, 0, Integer.MAX_VALUE); log.info(&quot;[攻略数据持久化] 持久化数量：&#123;&#125;&quot;, list.size()); &#125; log.info(&quot;[攻略数据持久化] ---------------- 持久化数据结束 ----------------&quot;); &#125;&#125; 这里感觉有点问题，如果在同步时，有用户更新了文章的分数，那么按照范围删除数据不导致不同步吧？"},{"title":"Redis Key","path":"/wiki/trip-cloud/08_statdata/redis-key.html","content":"文章模块下的Redis Key 应该遵循设计规范，因此创建类： StrategyRedisKeyPrefix，继承 BaseKeyPrefix 在模块trip-article-api中创建包：com.swx.article.redis.key，在该包下创建类：StrategyRedisKeyPrefix UserRedisKeyPrefixpublic class StrategyRedisKeyPrefix extends BaseKeyPrefix &#123; public static final StrategyRedisKeyPrefix STRATEGIES_STAT_DATA_MAP = new StrategyRedisKeyPrefix(&quot;STRATEGIES:STAT:DATA&quot;); public static final StrategyRedisKeyPrefix STRATEGIES_STAT_COUNT_RANK_ZSET = new StrategyRedisKeyPrefix(&quot;STRATEGIES:STAT:COUNT:RANK&quot;); public static final StrategyRedisKeyPrefix STRATEGIES_TOP_MAP = new StrategyRedisKeyPrefix(&quot;STRATEGIES:TOP&quot;); public StrategyRedisKeyPrefix(String prefix) &#123; super(prefix); &#125; public StrategyRedisKeyPrefix(String prefix, Long timeout, TimeUnit unit) &#123; super(prefix, timeout, unit); &#125;&#125;"},{"title":"攻略统计数据","path":"/wiki/trip-cloud/08_statdata/strategy.html","content":"前端对应页面，从左至右依次为：评论数、收藏数、分享数、置顶&#x2F;点赞数： 攻略浏览量打开模块：trip-article-server，找到：StrategyController，修改其中的/detail接口，添加增加浏览量的方法 StrategyController@GetMapping(&quot;/detail&quot;)public R&lt;Strategy&gt; detail(Long id) &#123; strategyService.viewnumIncr(id); return R.ok(strategyService.getById(id));&#125; 在 StrategyService 接口中定义该方法 StrategyService/** * 增加阅读量 * * @param id 攻略id */void viewnumIncr(Long id); 在 StrategyServiceImpl 类中实现该方法 这里需要在RedisService中添加hash的值增加方法 /** * 针对 hash key 进行 increment * * @param prefix 前缀 * @param hashKey hash key * @param increment 自增量 * @param suffix 后缀 */public void hashIncrement(KeyPrefix prefix, String hashKey, int increment, String... suffix) &#123; redisTemplate.opsForHash().increment(prefix.fullKey(suffix), hashKey, 1);&#125; StrategyServiceImpl@Servicepublic class StrategyServiceImpl extends ServiceImpl&lt;StrategyMapper, Strategy&gt; implements StrategyService &#123; private final RedisService redisService; public StrategyServiceImpl(RedisService redisService) &#123; this.redisService = redisService; &#125;\t/** * 增加阅读量 * * @param id 攻略id */ @Override public void viewnumIncr(Long id) &#123; this.statDataIncr(&quot;viewnum&quot;, id); &#125; /** * hashKey 对应的 value 自增 * @param hashKey hash key * @param sid 攻略id */ private void statDataIncr(String hashKey, Long sid) &#123; redisService.hashIncrement(StrategyRedisKeyPrefix.STRATEGIES_STAT_DATA_MAP, hashKey, 1, sid + &quot;&quot;); &#125;&#125; 攻略点赞&#x2F;置顶对于一篇攻略文章来说，每个用户每天只能顶一次，且无法取消置顶，当时间过了23:59:59，用户可再次顶。 为此需要维护一个状态，用来判断用户当天是否顶过，同时维护过期时间，实现方案： 使用Redis 的 Map 来存储，以文章ID为 Map 的 key ，其中 hash key 为顶过攻略的用户的ID。 Redis Key：STRATEGIES:TOP:sid，sid为该篇攻略的ID，hash key：用户的ID。 当用户顶该篇攻略时，刷新 map 的过期时间（当前时间到23:59:59的时间间隔）。 修改 RedisService 的 hashIncrement 方法 RedisService/** * 针对 hash key 进行 increment * * @param prefix 前缀 * @param hashKey hash key * @param increment 自增量 * @param suffix 后缀 */public void hashIncrement(KeyPrefix prefix, String hashKey, int increment, String... suffix) &#123; Long ret = redisTemplate.opsForHash().increment(prefix.fullKey(suffix), hashKey, 1); if (prefix.getTimeout() != null &amp;&amp; prefix.getTimeout() &gt; 0 &amp;&amp; ret == 1) &#123; // 有过期时间，且第一次则设置过期时间，给map设置过期时间 expire(prefix.fullKey(suffix), prefix.getTimeout(), prefix.getUnit()); &#125;&#125; 注意，这里当一个用户第一次置顶时 ret 为1，可以设置过期时间， 但是每个用户第一次置顶时都会更新该篇攻略 map 的过期时间，无所谓，只要时间没到23:59:59，map 就不会过期，顶过的用户就不能再顶。 接口信息 值 路径地址 http://localhost:9000/article/strategies/thumbnumIncr 请求方式 GET 请求参数 sid 返回结果 R { code:””, msg: “”, data: Boolean } Controller打开模块：trip-article-server，找到：StrategyController，添加点赞&#x2F;置顶方法 StrategyController@RequireLogin@GetMapping(&quot;/thumbnumIncr&quot;)public R&lt;Boolean&gt; thumbnumIncr(Long sid) &#123; return R.ok(strategyService.thumbnumIncr(sid));&#125; Service找到：StrategyService 接口，定义点赞&#x2F;置顶方法 StrategyService/** * 攻略置顶，一个用户一天只能置顶一篇攻略 * * @param sid 攻略ID * @return 置顶状态 */Boolean thumbnumIncr(Long sid); 找到：StrategyServiceImpl 类，实现点赞&#x2F;置顶方法 获取当前时间到23:59:59时间间隔的方法， DateUtilspublic class DateUtils &#123; public static long getLastMillisSeconds() &#123; LocalDateTime now = LocalDateTime.now(); LocalDateTime lastSeconds = LocalDateTime.of(now.getYear(), now.getMonth(), now.getDayOfMonth(), 23, 59, 59); return Duration.between(now, lastSeconds).toMillis(); &#125; public static Long getLastMillisSecondsOld() &#123; Calendar instance = Calendar.getInstance(); instance.set(Calendar.HOUR_OF_DAY, 23); instance.set(Calendar.MINUTE, 59); instance.set(Calendar.SECOND, 29); long lastMillis = instance.getTimeInMillis(); return lastMillis - System.currentTimeMillis(); &#125;&#125; StrategyServiceImpl@Servicepublic class StrategyServiceImpl extends ServiceImpl&lt;StrategyMapper, Strategy&gt; implements StrategyService &#123; private final RedisService redisService; public StrategyServiceImpl(RedisService redisService) &#123; this.redisService = redisService; &#125;\t/** * 攻略置顶，一个用户一天只能置顶一篇攻略 * * @param sid 攻略ID * @return 置顶状态 */ @Override public Boolean thumbnumIncr(Long sid) &#123; LoginUser loginUser = AuthenticationUtil.getLoginUser(); StrategyRedisKeyPrefix keyPrefix = StrategyRedisKeyPrefix.STRATEGIES_TOP_MAP; String key = keyPrefix.fullKey(sid + &quot;&quot;); String hashKey = loginUser.getId() + &quot;&quot;; // TODO: 并发问题，查询和增加不是原子操作，锁 或者 lua 脚本 Integer count = redisService.getCacheMapValue(key, hashKey); if (count != null &amp;&amp; count &gt; 0) &#123; return false; &#125; // 记录用户的置顶，向攻略map中添加该用户的置顶，并设置攻略置顶map的过期时间 keyPrefix.setTimeout(DateUtils.getLastMillisSeconds()); keyPrefix.setUnit(TimeUnit.MILLISECONDS); redisService.hashIncrement(keyPrefix, hashKey, 1, sid + &quot;&quot;); // 置顶数+1 this.statDataIncr(&quot;thumbsupnum&quot;, sid); return true; &#125; /** * hashKey 对应的 value 自增 * @param hashKey hash key * @param sid 攻略id */ private void statDataIncr(String hashKey, Long sid) &#123; redisService.hashIncrement(StrategyRedisKeyPrefix.STRATEGIES_STAT_DATA_MAP, hashKey, 1, sid + &quot;&quot;); &#125;&#125; 攻略收藏量数据库攻略的收藏属于用户模块的功能，用户可以查看自己收藏的攻略，因此在trip-user数据库中增加表user_favor_strategies user_favor_strategiesCREATE TABLE `user_favor_strategies` ( `user_id` bigint NOT NULL, `strategy_id` bigint NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3; Redis Key找到模块：trip-user-api 中的com.swx.user.redis.key包下的 UserRedisKeyPrefix，添加一个 key public static final UserRedisKeyPrefix STRATEGIES_STAT_DATA_MAP = new UserRedisKeyPrefix(&quot;STRATEGIES:STAT:DATA&quot;); 接口信息获取用户收藏的攻略 值 路径地址 http://localhost:9000/u/users/favor/strategies 请求方式 GET 请求参数 userId 返回结果 R { code:””, msg: “”, data: List } 添加或者删除攻略收藏 值 路径地址 http://localhost:9000/u/users/favor/strategies 请求方式 GET 请求参数 sid 返回结果 R { code:””, msg: “”, data: Boolean } Controller打开模块：trip-user-server，找到：UserInfoController，添加收藏方法 UserInfoController@GetMapping(&quot;/favor/strategies&quot;)R&lt;List&lt;Long&gt;&gt; getFavorStrategyIdList(@RequestParam Long userId) &#123; return R.ok(userInfoService.getFavorStrategyIdList(userId));&#125;@RequireLogin@PostMapping(&quot;/favor/strategies&quot;)public R&lt;Boolean&gt; favoriteStrategy(Long sid) &#123; return R.ok(userInfoService.favoriteStrategy(sid));&#125; Service找到：StrategyService 接口，定义获取和添加收藏攻略方法 StrategyService/** * 获取用户收藏攻略 * * @param userId 用户ID * @return 收藏攻略 */List&lt;Long&gt; getFavorStrategyIdList(Long userId);/** * 收藏攻略 * * @param sid 攻略ID * @return 收藏状态 */Boolean favoriteStrategy(Long sid); 找到：StrategyServiceImpl 类，实现获取和添加收藏攻略方法 UserServiceImpl@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt; implements UserInfoService &#123; private final RedisService redisService; public UserServiceImpl(RedisService redisService, TokenService tokenService) &#123; this.redisService = redisService; &#125; /** * 获取用户收藏攻略 * * @param userId 用户ID * @return 收藏攻略 */ @Override public List&lt;Long&gt; getFavorStrategyIdList(Long userId) &#123; return getBaseMapper().getFavorStrategyIdList(userId); &#125; /** * 收藏攻略 * * @param sid 攻略ID * @return 收藏状态 */ @Override public Boolean favoriteStrategy(Long sid) &#123; LoginUser loginUser = AuthenticationUtil.getLoginUser(); List&lt;Long&gt; ids = this.getFavorStrategyIdList(loginUser.getId()); if (ids.contains(sid)) &#123; redisService.hashIncrement(UserRedisKeyPrefix.STRATEGIES_STAT_DATA_MAP, &quot;favornum&quot;, -1, sid + &quot;&quot;); return getBaseMapper().deleteFavorStrategy(loginUser.getId(), sid); &#125; redisService.hashIncrement(UserRedisKeyPrefix.STRATEGIES_STAT_DATA_MAP, &quot;favornum&quot;, 1, sid + &quot;&quot;); return getBaseMapper().insertFavorStrategy(loginUser.getId(), sid); &#125;&#125; 攻略评论数量Controller打开模块：trip-comment-server，找到：StrategyCommentController，修改/save方法，添加增加评论数量方法 StrategyCommentController@RequireLogin@PostMapping(&quot;/save&quot;)public R&lt;?&gt; saveComment(Long strategyId, String strategyTitle) &#123; strategyCommentService.save(strategyId, strategyTitle); // 评论数+1 strategyCommentService.replyNumIncr(strategyId); return R.ok();&#125; Service找到：StrategyCommentService 接口，定义增加评论数量方法 StrategyCommentService/** * 评论数+1 * * @param strategyId 攻略ID */void replyNumIncr(Long strategyId); 找到：StrategyCommentServiceImpl 类，实现增加评论数量方法 StrategyCommentServiceImpl@Slf4j@Servicepublic class StrategyCommentServiceImpl implements StrategyCommentService &#123; private final RedisService redisService; public StrategyCommentServiceImpl(RedisService redisService) &#123; this.redisService = redisService; &#125; /** * 评论数+1 * * @param strategyId 攻略ID */ @Override public void replyNumIncr(Long strategyId) &#123; redisService.hashIncrement(CommentRedisKeyPrefix.STRATEGIES_STAT_DATA_MAP, &quot;replynum&quot;, 1, strategyId + &quot;&quot;); &#125;&#125;"},{"title":"ES数据查询","path":"/wiki/trip-cloud/09_search/essearch.html","content":"接口信息 值 路径地址 http://localhost:9000/search/q 请求方式 GET 请求参数 SearchQueryObject 返回结果 R { code:””, msg: “”, data: List } 请求&#x2F;返回参数请求参数 SearchQueryObject SearchQueryObject@Getter@Setterpublic class SearchQueryObject extends QueryObject &#123; private Integer type = -1;&#125; 返回结果 SearchResult SearchResult@Getter@Setterpublic class SearchResult &#123; private List&lt;DestinationDTO&gt; dests = new ArrayList&lt;&gt;(); private List&lt;StrategyDTO&gt; strategies = new ArrayList&lt;&gt;(); private List&lt;TravelDTO&gt; travels = new ArrayList&lt;&gt;(); private List&lt;UserInfoDTO&gt; users = new ArrayList&lt;&gt;(); private Long total = 0L;&#125; ControllerSearchController@RestController@RequestMapping(&quot;/q&quot;)public class SearchController &#123; private final ArticleFeignService articleFeignService; private final UserInfoFeignService userInfoFeignService; private final ElasticsearchService elasticsearchService; public SearchController(ArticleFeignService articleFeignService, UserInfoFeignService userInfoFeignService, ElasticsearchService elasticsearchService) &#123; this.articleFeignService = articleFeignService; this.userInfoFeignService = userInfoFeignService; this.elasticsearchService = elasticsearchService; &#125; @GetMapping public R&lt;?&gt; search(SearchQueryObject qo) &#123; qo.setKeyword(URLDecoder.decode(qo.getKeyword(), StandardCharsets.UTF_8)); // 请求分发器 switch (qo.getType()) &#123; case 0: // 目的地 return this.searchForDest(qo); case 1: // 攻略 return this.searchForStrategy(qo); case 2: // 游记 return this.searchForTravel(qo); case 3: // 用户 return this.searchForUserInfo(qo); default: // 所有 return this.searchForAll(qo); &#125; &#125; private R&lt;?&gt; searchForUserInfo(SearchQueryObject qo) &#123; return R.ok(); &#125; private R&lt;?&gt; searchForAll(SearchQueryObject qo) &#123; return R.ok(); &#125; private R&lt;?&gt; searchForTravel(SearchQueryObject qo) &#123; return R.ok(); &#125; private R&lt;?&gt; searchForDest(SearchQueryObject qo) &#123; return R.ok(); &#125;&#125; 搜索目的地目的地的查询是精确查询，直接从数据库中查询 远程查询目的地 找到 trip-article-server 模块，在 DestinationController 添加查询方法。 DestinationController@GetMapping(&quot;/getByName&quot;)public R&lt;Destination&gt; getDestByName(@RequestParam String name) &#123; return R.ok(destinationService.getOne(Wrappers.&lt;Destination&gt;lambdaQuery().eq(Destination::getName, name)));&#125; ArticleFeignService@GetMapping(&quot;/destinations/getByName&quot;)public R&lt;DestinationDTO&gt; getDestByName(@RequestParam String name); 远程查询攻略 找到 trip-article-server 模块，在 StrategyController 添加查询方法。 StrategyController@GetMapping(&quot;/findByDestName&quot;)public R&lt;List&lt;Strategy&gt;&gt; findStrategyByDestName(@RequestParam String destName) &#123; return R.ok(strategyService.list(Wrappers.&lt;Strategy&gt;lambdaQuery() .eq(Strategy::getDestName, destName) .eq(Strategy::getState, Strategy.STATE_PUBLISH)));&#125; ArticleFeignService@GetMapping(&quot;/strategies/findByDestName&quot;)public R&lt;List&lt;StrategyDTO&gt;&gt; findStrategyByDestName(@RequestParam String destName); 远程查询游记 找到 trip-article-server 模块，在 TravelController 添加查询方法。 TravelController@GetMapping(&quot;/findByDestName&quot;)public R&lt;List&lt;Travel&gt;&gt; findTravelByDestName(@RequestParam String destName) &#123; return R.ok(travelService.list(Wrappers.&lt;Travel&gt;lambdaQuery() .eq(Travel::getDestName, destName) .eq(Travel::getState, Travel.STATE_RELEASE)));&#125; ArticleFeignService@GetMapping(&quot;/travels/findByDestName&quot;)public R&lt;List&lt;TravelDTO&gt;&gt; findTravelByDestName(@RequestParam String destName); 远程查询用户 找到 trip-article-server 模块，在 UserInfoController 添加查询方法。 UserInfoController@GetMapping(&quot;/findByDestName&quot;)public R&lt;List&lt;UserInfo&gt;&gt; findUserByDestName(@RequestParam String destName) &#123; return R.ok(userInfoService.list(Wrappers.&lt;UserInfo&gt;lambdaQuery() .eq(UserInfo::getCity, destName) .eq(UserInfo::getState, UserInfo.STATE_NORMAL)));&#125; UserInfoFeignService@GetMapping(&quot;/users/findByDestName&quot;)public R&lt;List&lt;UserInfoDTO&gt;&gt; findUserByDestName(@RequestParam String destName); 完成根据目的地搜索 SearchControllerprivate R&lt;?&gt; searchForDest(SearchQueryObject qo) &#123; SearchResult result = new SearchResult(); // 远程调用目的地模块，根据名称查询目的地 R&lt;DestinationDTO&gt; destResult = articleFeignService.getDestByName(qo.getKeyword()); DestinationDTO dest = destResult.checkAndGet(); if (dest != null) &#123; result.setTotal(1L); // 查询攻略 R&lt;List&lt;StrategyDTO&gt;&gt; strategyResult = articleFeignService.findStrategyByDestName(qo.getKeyword()); List&lt;StrategyDTO&gt; strategyDTOS = strategyResult.checkAndGet(); result.setStrategies(strategyDTOS); result.setTotal(result.getTotal() + strategyDTOS.size()); // 查询游记 R&lt;List&lt;TravelDTO&gt;&gt; travelResult = articleFeignService.findTravelByDestName(qo.getKeyword()); List&lt;TravelDTO&gt; travelDTOS = travelResult.checkAndGet(); result.setTravels(travelDTOS); result.setTotal(result.getTotal() + travelDTOS.size()); // 查询用户 R&lt;List&lt;UserInfoDTO&gt;&gt; userResult = userInfoFeignService.findUserByDestName(qo.getKeyword()); List&lt;UserInfoDTO&gt; userInfoDTOS = userResult.checkAndGet(); result.setUsers(userInfoDTOS); result.setTotal(result.getTotal() + userInfoDTOS.size()); &#125; JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;qo&quot;, qo); jsonObject.put(&quot;result&quot;, result); jsonObject.put(&quot;dest&quot;, dest); return R.ok(jsonObject);&#125; 搜索攻略攻略搜索结果有高亮显示，是从ES中查询的，搜索字段为 title, subtitle, summary 远程查询攻略 找到 trip-article-server 模块，在 StrategyController 添加查询方法。 StrategyController@GetMapping(&quot;/getById&quot;)public Strategy getById(Long id) &#123; return strategyService.getOne(Wrappers.&lt;Strategy&gt;lambdaQuery().eq(Strategy::getId, id));&#125; ArticleFeignService@GetMapping(&quot;/strategies/getById&quot;)public StrategyDTO getStrategyById(@RequestParam String id); 完成攻略搜索 ES查询时，需要远程调用根据ID查询攻略，填充游记的其他信息 SearchControllerprivate R&lt;?&gt; searchForStrategy(SearchQueryObject qo) &#123; Page&lt;StrategyDTO&gt; page = elasticsearchService.searchWithHighlight(StrategyEs.class, StrategyDTO.class, qo, (clazz, id) -&gt; articleFeignService.getStrategyById(id), &quot;title&quot;, &quot;subtitle&quot;, &quot;summary&quot;); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;qo&quot;, qo); jsonObject.put(&quot;page&quot;, page); return R.ok(jsonObject);&#125; 查询游记 远程查询游记 找到 trip-article-server 模块，在 TravelController 添加查询方法。 TravelController@GetMapping(&quot;/getById&quot;)public R&lt;Travel&gt; getById(Long id) &#123; return R.ok(travelService.getOne(Wrappers.&lt;Travel&gt;lambdaQuery().eq(Travel::getId, id)));&#125; ArticleFeignService@GetMapping(&quot;/travels/getById&quot;)R&lt;TravelDTO&gt; getTravelById(@RequestParam String id); 完成攻略搜索 ES查询时，需要远程调用根据ID查询游记，填充游记的其他信息 SearchControllerprivate R&lt;?&gt; searchForTravel(SearchQueryObject qo) &#123; Page&lt;TravelDTO&gt; page = elasticsearchService.searchWithHighlight(TravelEs.class, TravelDTO.class, qo, (clazz, id) -&gt; articleFeignService.getTravelById(id).checkAndGet(), &quot;title&quot;, &quot;summary&quot;); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;qo&quot;, qo); jsonObject.put(&quot;page&quot;, page); return R.ok(jsonObject);&#125; 查询用户 远程查询游记 找到 trip-article-server 模块，在 TravelController 添加查询方法。 TravelController@GetMapping(&quot;/getById&quot;)public R&lt;UserInfoDTO&gt; getById(Long id) &#123; return R.ok(userInfoService.getDtoById(id));&#125; ArticleFeignService@GetMapping(&quot;/users/getById&quot;)R&lt;UserInfoDTO&gt; getById(@RequestParam String id); 完成搜索用户 SearchControllerprivate R&lt;?&gt; searchForUserInfo(SearchQueryObject qo) &#123; Page&lt;UserInfoDTO&gt; page = elasticsearchService.searchWithHighlight(UserInfoEs.class, UserInfoDTO.class, qo, (clazz, id) -&gt; userInfoFeignService.getById(id).checkAndGet(), &quot;city&quot;, &quot;info&quot;); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;qo&quot;, qo); jsonObject.put(&quot;page&quot;, page); return R.ok(jsonObject);&#125; 查询全部 完成查询全部 SearchControllerprivate R&lt;?&gt; searchForAll(SearchQueryObject qo) &#123; SearchResult result = new SearchResult(); Page&lt;UserInfoDTO&gt; userPage = elasticsearchService.searchWithHighlight(UserInfoEs.class, UserInfoDTO.class, qo, (clazz, id) -&gt; userInfoFeignService.getById(id).checkAndGet(), &quot;city&quot;, &quot;info&quot;); result.setUsers(userPage.getContent()); result.setTotal(userPage.getTotalElements()); Page&lt;TravelDTO&gt; travelPage = elasticsearchService.searchWithHighlight(TravelEs.class, TravelDTO.class, qo, (clazz, id) -&gt; articleFeignService.getTravelById(id).checkAndGet(), &quot;title&quot;, &quot;summary&quot;); result.setTravels(travelPage.getContent()); result.setTotal(result.getTotal() + travelPage.getTotalElements()); Page&lt;StrategyDTO&gt; strategyPage = elasticsearchService.searchWithHighlight(StrategyEs.class, StrategyDTO.class, qo, (clazz, id) -&gt; articleFeignService.getStrategyById(id), &quot;title&quot;, &quot;subtitle&quot;, &quot;summary&quot;); result.setStrategies(strategyPage.getContent()); result.setTotal(result.getTotal() + strategyPage.getTotalElements()); Page&lt;DestinationDTO&gt; destPage = elasticsearchService.searchWithHighlight(DestinationEs.class, DestinationDTO.class, qo, (clazz, id) -&gt; articleFeignService.getDestById(id), &quot;name&quot;, &quot;info&quot;); result.setDests(destPage.getContent()); result.setTotal(result.getTotal() + destPage.getTotalElements()); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;result&quot;, result); jsonObject.put(&quot;qo&quot;, qo); return R.ok(jsonObject);&#125;"},{"title":"初始化模块","path":"/wiki/trip-cloud/09_search/init.html","content":"前端对应的页面如下，可以查询全部，目的地，攻略，游记，用户。 API模块在trip_modules-api父模块下创建子模块trip-search-api，pom文件内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-modules-api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-search-api&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 文档实体类创建ES文档实体类：DestinationEs，首先创建com.swx.search.domain包，在该包下创建文档实体类。 DestinationEs/** * 目的地搜索对象 */@Getter@Setter@Document(indexName = DestinationEs.INDEX_NAME)public class DestinationEs implements Serializable &#123; public static final String INDEX_NAME = &quot;destination&quot;; @Id //@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ） @Field(type = FieldType.Long) private Long id; //目的地id @Field(type = FieldType.Keyword) private String name; @Field(analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_max_word&quot;, type = FieldType.Text) private String info;&#125; 创建攻略搜索对象 StrategyEs/** * 攻略搜索对象 */@Getter@Setter@Document(indexName = StrategyEs.INDEX_NAME)public class StrategyEs implements Serializable &#123; public static final String INDEX_NAME = &quot;strategy&quot;; //@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ） @Id @Field(type = FieldType.Long) private Long id; //攻略id @Field(analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_max_word&quot;, type = FieldType.Text) private String title; //攻略标题 @Field(analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_max_word&quot;, type = FieldType.Text) private String subTitle; //攻略标题 @Field(analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_max_word&quot;, type = FieldType.Text) private String summary; //攻略简介&#125; 创建游记搜索对象 TravelEs/** * 游记搜索对象 */@Getter@Setter@Document(indexName = TravelEs.INDEX_NAME)public class TravelEs implements Serializable &#123; public static final String INDEX_NAME = &quot;travel&quot;; //@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ） @Id @Field(type = FieldType.Long) private Long id; //游记id @Field(analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_max_word&quot;, type = FieldType.Text) private String title; //游记标题 @Field(analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_max_word&quot;, type = FieldType.Text) private String summary; //游记简介&#125; 创建用户搜索对象 UserInfoEs/** * 用户搜索对象 */@Getter@Setter@Document(indexName = UserInfoEs.INDEX_NAME)public class UserInfoEs implements Serializable &#123; public static final String INDEX_NAME = &quot;userinfo&quot;; @Id //@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ） @Field(type = FieldType.Long) private Long id; //用户id @Field(type = FieldType.Keyword) private String city; @Field(analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_max_word&quot;, type = FieldType.Text) private String info;&#125; 微服务模块在trip_modules父模块下创建子模块trip-search-server，pom文件内容如下： pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-modules&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;trip-search-service&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-search-api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-common-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-users-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.swx&lt;/groupId&gt; &lt;artifactId&gt;trip-article-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置文件：bootstrap.yaml，内容如下： spring: application: name: search-service cloud: nacos: server-addr: 124.221.23.47:8848 config: file-extension: yaml namespace: trip_cloud_dev shared-configs: - data-id: redis-$&#123;spring.profiles.active&#125;.yaml refresh: true profiles: active: dev Nacos配置文件 ID：search-service-dev.yaml Group：DEFAULT_GROUP 描述：搜索微服务配置文件 配置内容： search-service-dev.yamlserver: port: 8095spring: cloud: nacos: server-addr: xxx.xxx.xxx.xxx:8848 discovery: namespace: $&#123;spring.cloud.nacos.config.namespace&#125; elasticsearch: rest: uris: http://xxx.xxx.xxx.xxx:9200 配置网关路由 ID：trip-gateway-dev.yaml Group：DEFAULT_GROUP 描述：旅游项目网关配置 配置内容： trip-gateway-dev.yaml- id: trip_search uri: lb://search-service predicates: - Path=/search/** filters: - StripPrefix=1 创建启动类：TripSearchApplication，首先创建com.swx.search包，在该包下创建。 TripSearchApplication@EnableFeignClients@SpringBootApplicationpublic class TripSearchApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TripSearchApplication.class, args); &#125;&#125; ElasticsearchService在包com.swx.search.parser下创建 ElasticsearchTypeParser 传入一个函数，该函数会根据 id 查询数据库，返回一个实体对象 /** * ES 搜索类型解析器 * 函数式接口: 这个接口必须有一个抽象方法, 并且只能有一个抽象方法 * 使用 lambda 实现函数是接口, 这个 lambda 就可以理解为这个函数式接口的实现类 === 匿名内部类 */@FunctionalInterfacepublic interface ElasticsearchTypeParser&lt;T&gt; &#123; T parse(Class&lt;T&gt; clazz, String id);&#125; 在包com.swx.search.utils下创建 BeanUtils public abstract class BeanUtils &#123; public static void copyProperties(Object source, Object target) throws BeansException &#123; copyProperties(source, target, (Class) null, (String[]) null); &#125; public static void copyProperties(Object source, Object target, @Nullable Class&lt;?&gt; editable, @Nullable String... ignoreProperties) throws BeansException &#123; Assert.notNull(source, &quot;Source must not be null&quot;); Assert.notNull(target, &quot;Target must not be null&quot;); Class&lt;?&gt; actualEditable = target.getClass(); if (editable != null) &#123; if (!editable.isInstance(target)) &#123; throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() + &quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;); &#125; actualEditable = editable; &#125; PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable); List&lt;String&gt; ignoreList = ignoreProperties != null ? Arrays.asList(ignoreProperties) : null; PropertyDescriptor[] var7 = targetPds; int var8 = targetPds.length; for (int var9 = 0; var9 &lt; var8; ++var9) &#123; PropertyDescriptor targetPd = var7[var9]; Method writeMethod = targetPd.getWriteMethod(); if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) &#123; PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName()); if (sourcePd != null) &#123; Method readMethod = sourcePd.getReadMethod(); if (readMethod != null &amp;&amp; ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) &#123; try &#123; if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123; readMethod.setAccessible(true); &#125; Object value = readMethod.invoke(source); if (value == null) &#123; continue; &#125; if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123; writeMethod.setAccessible(true); &#125; writeMethod.invoke(target, value); &#125; catch (Throwable var15) &#123; throw new FatalBeanException(&quot;Could not copy property &#x27;&quot; + targetPd.getName() + &quot;&#x27; from source to target&quot;, var15); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 在包com.swx.search.service下创建 ElasticsearchService ElasticsearchServiceimport com.swx.common.core.qo.QueryObject;import com.swx.search.parser.ElasticsearchTypeParser;import org.springframework.data.domain.Page;public interface ElasticsearchService &#123; /** * 新增方法 * @param entity ES 实体对象 */ public void save(Object entity); /** * 批量新增方法 * @param iterable ES 实体对象集合 */ public void save(Iterable&lt;?&gt; iterable); /** * 删除方法 * @param id 主键 * @param clazz 实体类型 */ public void deleteById(String id, Class&lt;?&gt; clazz); /** * 通用的高亮分页搜索接口 * * @param esclz ES 模型字段字节码对象 =&gt; ES 查询的对象 * @param dtoclz domain 字节码对象 =&gt; 最终希望返回的对象 * @param qo 查询对象 =&gt; 封装分页参数 * @param parser 解析器对象 =&gt; 利用 ES 对象中的 id 属性，从数据库中查到对应完整的模型对象，返回最终结果 * @param fields 需要进行高亮查询的字段 * @param &lt;T&gt; * @return 高亮分页数据对象 */ &lt;T&gt; Page&lt;T&gt; searchWithHighlight(Class&lt;?&gt; esclz, Class&lt;T&gt; dtoclz, QueryObject qo, ElasticsearchTypeParser&lt;T&gt; parser, String... fields);&#125; 在包com.swx.search.service.impl下创建 ElasticsearchServiceImpl import com.alibaba.fastjson2.JSON;import com.swx.common.core.qo.QueryObject;import com.swx.search.parser.ElasticsearchTypeParser;import com.swx.search.service.ElasticsearchService;import com.swx.search.utils.BeanUtils;import org.elasticsearch.index.query.MultiMatchQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.*;import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;import org.springframework.data.elasticsearch.core.SearchHit;import org.springframework.data.elasticsearch.core.SearchHits;import org.springframework.data.elasticsearch.core.query.NativeSearchQuery;import org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@Servicepublic class ElasticsearchServiceImpl implements ElasticsearchService &#123; public static final Logger log = LoggerFactory.getLogger(ElasticsearchServiceImpl.class); @Autowired private ElasticsearchRestTemplate template; @Override public void save(Object entity) &#123; template.save(entity); &#125; @Override public void save(Iterable&lt;?&gt; iterable) &#123; template.save(iterable); &#125; @Override public void deleteById(String id, Class&lt;?&gt; clazz) &#123; template.delete(id, clazz); &#125; @Override public &lt;T&gt; Page&lt;T&gt; searchWithHighlight(Class&lt;?&gt; esclz, Class&lt;T&gt; dtoclz, QueryObject qo, ElasticsearchTypeParser&lt;T&gt; parser, String... fields) &#123; //高亮显示 /*&quot;query&quot;:&#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;广州&quot;, &quot;fields&quot;: [&quot;title&quot;,&quot;subTitle&quot;,&quot;summary&quot;] &#125; &#125;,*/ MultiMatchQueryBuilder queryBuilder = QueryBuilders.multiMatchQuery(qo.getKeyword(), fields); HighlightBuilder highlightBuilder = new HighlightBuilder(); // 生成高亮查询器 for (String field : fields) &#123; highlightBuilder.field(field);// 高亮查询字段 &#125; highlightBuilder.requireFieldMatch(false); // 如果要多个字段高亮,这项要为false highlightBuilder.preTags(&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;); // 高亮设置 highlightBuilder.postTags(&quot;&lt;/span&gt;&quot;); highlightBuilder.fragmentSize(800000); // 最大高亮分片数 highlightBuilder.numOfFragments(0); // 从第一个分片获取高亮片段 /** &quot;from&quot;: 0, &quot;size&quot;:3, */ Pageable pageable = PageRequest.of(qo.getCurrent() - 1, qo.getSize(), Sort.Direction.ASC, &quot;_id&quot;);// 设置分页参数 NativeSearchQuery searchQuery = new NativeSearchQueryBuilder() .withQuery(queryBuilder) // match查询 .withPageable(pageable) .withHighlightBuilder(highlightBuilder) // 设置高亮 .build(); // 高亮查询, 得到命中的数据 SearchHits&lt;?&gt; searchHits = template.search(searchQuery, esclz); // 最终返回的 list 对象 List&lt;T&gt; list = new ArrayList&lt;&gt;(); for (SearchHit&lt;?&gt; searchHit : searchHits) &#123; // 获取搜索到的数据 // 具体解析操作: 交给外部调用者去实现 T target = parser.parse(dtoclz, searchHit.getId()); // 处理高亮 Map&lt;String, String&gt; map = highlightFieldsCopy(searchHit.getHighlightFields(), fields); //1：spring 框架中 BeanUtils 类，如果是map集合是无法进行属性复制 // copyProperties(源， 目标) //2: apache BeanUtils 类 可以进map集合属性复制 // copyProperties(目标， 源) try &#123; T highlight = JSON.parseObject(JSON.toJSONString(map), dtoclz); BeanUtils.copyProperties(highlight, target); &#125; catch (Exception e) &#123; log.warn(&quot;[高亮搜索] 拷贝属性失败&quot;, e); &#125; list.add(target); &#125; return new PageImpl&lt;&gt;(list, pageable, searchHits.getTotalHits()); &#125; //fields: title subTitle summary private Map&lt;String, String&gt; highlightFieldsCopy(Map&lt;String, List&lt;String&gt;&gt; map, String... fields) &#123; Map&lt;String, String&gt; mm = new HashMap&lt;&gt;(); //title: &quot;有娃必看，&lt;span style=&#x27;color:red;&#x27;&gt;广州&lt;/span&gt;长隆野生动物园全攻略&quot; //subTitle: &quot;&lt;span style=&#x27;color:red;&#x27;&gt;广州&lt;/span&gt;长隆野生动物园&quot; //summary: &quot;如果要说动物园，楼主强烈推荐带娃去&lt;span style=&#x27;color:red;&#x27;&gt;广州&lt;/span&gt;长隆野生动物园 //title subTitle summary for (String field : fields) &#123; List&lt;String&gt; hfs = map.get(field); if (hfs != null &amp;&amp; !hfs.isEmpty()) &#123; //获取高亮显示字段值, 因为是一个数组, 所有使用string拼接 StringBuilder sb = new StringBuilder(); for (String hf : hfs) &#123; sb.append(hf); &#125; mm.put(field, sb.toString()); //使用map对象将所有能替换字段先缓存, 后续统一替换 &#125; &#125; return mm; &#125;&#125;"},{"title":"初始化数据到ES","path":"/wiki/trip-cloud/09_search/inites.html","content":"将初始化操作设计为一次性接口，需要初始化时，访问接口并传入不同的参数，达到初始化不同数据到Elasticsearch 找到模块：trip-search-service，在包：com.swx.search.controller下创建类：ElasticsearchDataInitController 使用策略模式实现不用type参数，访问不同的方法，完成不同数据的初始化到ES的操作。 为了保证接口的安全，将url参数配置到配置文件中 使用 Redis 保证该接口只能被访问一次，使用 SET NX 保证幂等性。 ElasticsearchDataInitController@Slf4j@RestController@RequestMapping(&quot;/init&quot;)@RefreshScopepublic class ElasticsearchDataInitController &#123; public static final String INIT_USER = &quot;user&quot;; public static final String INIT_TRAVEL = &quot;travel&quot;; public static final String INIT_STRATEGY = &quot;strategy&quot;; public static final String INIT_DESTINATION = &quot;destination&quot;; public static final Integer BATCH_COUNT = 200; private final Map&lt;String, EsDataInitStrategy&gt; DATA_HANDLER_STRATEGY_MAP = new HashMap&lt;&gt;(); @Value(&quot;$&#123;es.init.key&#125;&quot;) private String initKey; private final RedisService redisService; private final UserInfoFeignService userInfoFeignService; private final ArticleFeignService articleFeignService; private final ElasticsearchService elasticsearchService; public ElasticsearchDataInitController(RedisService redisService, UserInfoFeignService userInfoFeignService, ArticleFeignService articleFeignService, ElasticsearchService elasticsearchService) &#123; this.redisService = redisService; this.userInfoFeignService = userInfoFeignService; this.articleFeignService = articleFeignService; this.elasticsearchService = elasticsearchService; &#125; @Getter @Setter static class EsDataInitStrategy &#123; private Function&lt;QueryObject, R&lt;List&lt;Object&gt;&gt;&gt; function; private Class&lt;?&gt; clazz; public EsDataInitStrategy(Function&lt;QueryObject, R&lt;List&lt;Object&gt;&gt;&gt; function, Class&lt;?&gt; clazz) &#123; this.function = function; this.clazz = clazz; &#125; &#125; @PostConstruct public void postConstruct() &#123; // 用户初始化 EsDataInitStrategy userInit = new EsDataInitStrategy((qo) -&gt; userInfoFeignService.findList(qo.getCurrent(), qo.getSize()), UserInfoEs.class); DATA_HANDLER_STRATEGY_MAP.put(INIT_USER, userInit); // 攻略文章初始化 EsDataInitStrategy strategyInit = new EsDataInitStrategy(articleFeignService::strategySearch, StrategyEs.class); DATA_HANDLER_STRATEGY_MAP.put(INIT_STRATEGY, strategyInit); // 游记文章初始化 EsDataInitStrategy travelInit = new EsDataInitStrategy(articleFeignService::travelSearch, TravelEs.class); DATA_HANDLER_STRATEGY_MAP.put(INIT_TRAVEL, travelInit); // 目的地初始化 EsDataInitStrategy destinationInit = new EsDataInitStrategy(articleFeignService::destinationSearch, DestinationEs.class); DATA_HANDLER_STRATEGY_MAP.put(INIT_DESTINATION, destinationInit); &#125; @GetMapping(&quot;/&#123;key&#125;/&#123;type&#125;&quot;) public ResponseEntity&lt;?&gt; init(@PathVariable(&quot;key&quot;) String key, @PathVariable(&quot;type&quot;) String type) &#123; log.info(&quot;[ES 数据初始化] -------------------- 数据初始化开始 --------------------&quot;); if (StringUtils.isEmpty(key) || !initKey.equals(key)) &#123; log.warn(&quot;[ES 数据初始化] 非法操作，请求参数有误 key=&#123;&#125;, type=&#123;&#125;, initKey=&#123;&#125;&quot;, key, type, initKey); return ResponseEntity.status(HttpStatus.FORBIDDEN).build(); &#125; // 用户访问过，就不允许再访问了 String redisKey = &quot;es:init:&quot; + key + type; Boolean ret = redisService.setnx(redisKey, &quot;initialized&quot;); if (ret == null || !ret) &#123; log.warn(&quot;[ES 数据初始化] 非法操作，已初始化过, redisKey=&#123;&#125;, ret=&#123;&#125;&quot;, redisKey, ret); return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); &#125; // 开始初始化数据 this.doInit(type); log.info(&quot;[ES 数据初始化] -------------------- 数据初始化完成 --------------------&quot;); return ResponseEntity.ok().body(&quot;init success&quot;); &#125; private void doInit(String type) &#123; int current = 1; do &#123; List&lt;Object&gt; list = handleRemoteDataList(current++, type); if (list == null || list.isEmpty()) &#123; log.info(&quot;[ES 数据初始化] 数据初始化完成.&quot;); return; &#125; elasticsearchService.save(list); &#125; while (true); &#125; /** * 获取并处理远程数据 */ private List&lt;Object&gt; handleRemoteDataList(Integer current, String type) &#123; EsDataInitStrategy strategy = DATA_HANDLER_STRATEGY_MAP.get(type); if (strategy == null) &#123; throw new BizException(&quot;初始化参数类型错误&quot;); &#125; R&lt;List&lt;Object&gt;&gt; ret = strategy.getFunction().apply(new QueryObject(current, BATCH_COUNT)); log.info(&quot;[ES 数据初始化] 初始化开始，查询&#123;&#125;数据 data=&#123;&#125;&quot;, type, JSON.toJSONString(ret)); List&lt;Object&gt; list = ret.checkAndGet(); if (list == null || list.isEmpty()) &#123; return list; &#125; List&lt;Object&gt; dataList = new ArrayList&lt;&gt;(list.size()); try &#123; Class&lt;?&gt; clazz = strategy.getClazz(); for (Object dto : list) &#123; Object es = clazz.getDeclaredConstructor().newInstance(); BeanUtils.copyProperties(es, dto); dataList.add(es); &#125; return dataList; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; Nacos配置 在 Nacos 配置中心中找到 search-service-dev.yaml，添加如下配置 es: init: key: hg345f67gfdh5yth34g56 远程调用 创建包：com.swx.search.feign，创建远程调用 文章微服务 的接口: ArticleFeignService 找到 trip-article-server 模块，在 DestinationController 添加查询方法。 DestinationController@PostMapping(&quot;/search&quot;)public R&lt;List&lt;Destination&gt;&gt; forSearchService(@RequestBody QueryObject qo) &#123; return R.ok(destinationService.list(Wrappers.&lt;Destination&gt;query().last(&quot;limit &quot; + qo.getOffset() + &quot;, &quot; + qo.getSize())));&#125; 找到 trip-article-server 模块，在 StrategyController 添加查询方法。 StrategyController@PostMapping(&quot;/search&quot;)public R&lt;List&lt;Strategy&gt;&gt; forSearchService(@RequestBody QueryObject qo) &#123; return R.ok(strategyService.list(Wrappers.&lt;Strategy&gt;query().last(&quot;limit &quot; + qo.getOffset() + &quot;, &quot; + qo.getSize())));&#125; 找到 trip-article-server 模块，在 TravelController 添加查询方法。 TravelController@PostMapping(&quot;/search&quot;)public R&lt;List&lt;Travel&gt;&gt; forSearchService(@RequestBody QueryObject qo) &#123; return R.ok(travelService.list(Wrappers.&lt;Travel&gt;query().last(&quot;limit &quot; + qo.getOffset() + &quot;, &quot; + qo.getSize())));&#125; @FeignClient(&quot;article-service&quot;)public interface ArticleFeignService &#123; @GetMapping(&quot;/destinations/search&quot;) public R&lt;List&lt;Object&gt;&gt; destinationSearch(@RequestBody QueryObject qo); @PostMapping(&quot;/strategies/search&quot;) public R&lt;List&lt;Object&gt;&gt; strategySearch(@RequestBody QueryObject qo); @PostMapping(&quot;/travels/search&quot;) public R&lt;List&lt;Object&gt;&gt; travelSearch(@RequestBody QueryObject qo);&#125; 创建远程调用 用户微服务 的接口: UserInfoFeignService 找到 trip-user-server 模块，在 UserInfoController 添加查询方法。 UserInfoController&gt;@GetMapping&gt;public R&lt;List&lt;UserInfoDTO&gt;&gt; findList(Integer current, Integer limit) &#123; int offset = (current - 1) * limit; List&lt;UserInfo&gt; list = userInfoService.list(Wrappers.&lt;UserInfo&gt;query().last(&quot;limit &quot; + offset + &quot;, &quot; + limit)); List&lt;UserInfoDTO&gt; dtoList = list.stream().map(UserInfo::toDto).collect(Collectors.toList()); return R.ok(dtoList);&gt;&#125; UserInfoFeignService@FeignClient(&quot;user-service&quot;)public interface UserInfoFeignService &#123; /** * 如果 Feign 发起远程调用后，接收的类型没有明确具体类型是什么 * Feign 会将返回的 JSON 结构转换为 LinkedHashMap 对象 */ @GetMapping(&quot;/users/&quot;) R&lt;List&lt;Object&gt;&gt; findList(@RequestParam Integer current, @RequestParam Integer limit);&#125; 远程调用时接收的类型为Object时，Feign 会将返回的 JSON 结构转换为 LinkedHashMap 对象，在进行属性拷贝时使用了 BeanUtils，但是org.springframework.beans.BeanUtils不支持map到对象的拷贝 for (Object dto : list) &#123; Object es = clazz.getDeclaredConstructor().newInstance(); BeanUtils.copyProperties(es, dto); dataList.add(es);&#125; 这里使用 apache 提供的 BeanUtils &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 其在拷贝时做了判断 if (orig instanceof DynaBean) &#123;\t....;&#125; else if (orig instanceof Map) &#123;\t....;&#125; else &#123; ....;&#125; 现在访问如下接口，完成数据的初始化操作：建立索引，导入数据 GEThttp://localhost:9000/search/init/hg345f67gfdh5yth34g56/destinationhttp://localhost:9000/search/init/hg345f67gfdh5yth34g56/userhttp://localhost:9000/search/init/hg345f67gfdh5yth34g56/travelhttp://localhost:9000/search/init/hg345f67gfdh5yth34g56/strategy"},{"title":"笔记简介","path":"/wiki/pyqgis-sd/01_intr/index.html","content":"随着GIS应用在国内的逐渐增多，越来越多的行业会需要使用GIS软件进行处理。目前国内的GIS软件基本为ArcGIS，ESRI作为GIS行业的龙头老大，依靠着ArcGIS基本占据着GIS软件的全部江山，其功能丰富强大，且社区最为活跃，但随着近期的俄乌战争，ESRI制裁俄罗斯的事件，还是可以感受到闭源软件的不可控性。 QGIS是一个开源、免费、轻量级的GIS软件，虽然在国内的普及程度不高，但不妨碍其软件的优秀程度。QGIS的软件功能及其丰富，并且还有海量的插件库供不同方向的GIS人员选择，是一个充满活力的开源社区。QGIS是一个使用C++语言开发的软件，其二次开发难度较大，且需要经历复杂的编译、源码理解，需要较高的门槛。 值得庆幸的是，QGIS支持python语言进行二次开发， python作为一个较易上手的胶水语言，在GIS社区较为活跃，例如：GDAL、Shapely、Fiona、RTree、pyproj、GeoPandas、rasterio、GeoDjango等开源框架都可以在python上使用，python语言是一个特别适合GIS领域的语言，更不用说现在火热的机器学习、深度学习都与python密切相关。QGIS的提供的PYQGIS的接口与C++ QGIS的接口基本保持一致，学习PyQGIS也能基本熟悉c++的QGIS，方便后续继续进行深入研究，作为想要入门QGIS二次开发的人员来说再为合适不过了。 本系列的教程将会从二次开发环境配置、pycharm配置、pyqgis语法、qtDesigner使用教程、插件设计等方面，结合笔者在项目中的实践一一展开叙述，希望最后，能在所有的系列教程结束后，让跟着系列做的读者都可以开发出一个属于自己的GIS界面。 界面预览 参考文章 yoyi - PyQGIS二次开发教程（一）：准备工作 yoyi - PyQGIS二次开发教程（二）：加载影像与矢量：准备工作 yoyi - PyQGIS二次开发教程（六）：状态栏与属性表实现"},{"title":"Hello QGIS","path":"/wiki/pyqgis-sd/02_env/hello_qgis.html","content":"在根目录创建入口文件main.py，写入如下代码： if __name__ == &#x27;__main__&#x27;: # 第二个参数为是否启用 GUI qgs = QgsApplication([], False) # 初始化 QGIS qgs.initQgis() print(QgsApplication.prefixPath()) print(&#x27;Hello Qgis!&#x27;) 运行后，控制台输出如下： D:/PROGRA~2/QGIS33~1.0/apps/qgisHello Qgis!"},{"title":"PyCharm环境配置","path":"/wiki/pyqgis-sd/02_env/pycharm.html","content":"新建项目pyqgis-se，在System Interpreter中选择 QGIS 安装目录下的bin\\python-qgis.bat 效果如下： 环境选择好之后，创建项目"},{"title":"安装PyQGIS","path":"/wiki/pyqgis-sd/02_env/qgis.html","content":"下载PyQGIS大家可以在Index of &#x2F;downloads (qgis.org)中找到自己的开发环境，笔者选择了 windows 下的 QGIS 3.30.0，点击msi进行安装。目录结构如下： .├── apps├── bin├── doc├── etc├── lib├── share├── var├── main.spec ├── OSGeo4W.bat├── OSGeo4W.ico└── start_up.bat 验证安装在 Win 中搜索 QGIS，或者找到bin目录下的qgis-bin.exe打开 QGIS 桌面软件，输入Ctrl + Alt + P，打开Python控制台，我们尝试输入一下代码： from qgis.core import QgsRasterLayer 若没有提示报错，说明我们的安装成功了。"},{"title":"样式美化","path":"/wiki/pyqgis-sd/05_perfect/beautify.html","content":"QSS文件加载工具类，在utils包中创建文件qss_loader.py qss_loader.pyfrom PyQt5.QtCore import QFileclass QSSLoader: def __init__(self, path: str) -&gt; None: self._path = path def load(self) -&gt; str: f = QFile(self._path) f.open(QFile.ReadOnly | QFile.Text) stylesheet = f.readAll() return stylesheet.data().decode(&quot;utf-8&quot;) 单一主题样式主题文件写入到qss文件中，qss类似早期版本的css，创建ui/style/light.qss目录及文件。 在main.py中新增load_qss()方法 main.pyfrom utils import QSSLoaderclass PyQgisSEApp(QMainWindow, Ui_MainWindow): def __init__(self, app: QgsApplication): super(PyQgisSEApp, self).__init__() self.app = app self.ui = Ui_MainWindow() self.ui.setupUi(self) # 装载模块 GUI.GUIPreview.load_preview(self) # 加载主题文件 self.load_qss() def load_qss(self): # 切换主题文件 qss = QSSLoader(f&quot;&#123;os.path.dirname(sys.argv[0])&#125;/ui/style/light.qss&quot;).load() self.ui.centralwidget.setStyleSheet(qss) 主题文件light.qss内容如下： QWidget, QFrame &#123; background-color: #fff; border: none;&#125;QTabWidget, QLabel, QToolButton, QPushButton, QLineEdit, QRadioButton &#123; font-family: &#x27;Microsoft YaHei&#x27;, &#x27;PingFang SC&#x27;,&#x27;SimSun&#x27;,&#x27;Arial&#x27;, sans-serif;&#125;/* 输入框 */QLineEdit &#123; border-style:none; padding:2px; border-radius: 3px; border: 1px solid rgb(224, 224, 230);&#125;QLineEdit:focus &#123; border: 1px solid #36ad6a;&#125;/* Tab样式 */QTabWidget#tabWidget &#123; background-color: white;&#125;QTabBar &#123; font-size: 9.5pt; qproperty-drawBase: 0;&#125;QTabBar::tab &#123; border: none; margin: 3px 10px 0px 10px; width: 66px; padding: 5px 0px; border-bottom: 2px solid #FFFFFF;&#125;QTabBar::tab:selected, QTabBar::tab:hover &#123; background-color:#FFFFFF;&#125;QTabBar::tab:selected &#123; border-color: #18a058; font-weight: 500;&#125;/* 顶部工具栏样式 */QFrame#frame_prev_top &#123; border-top: 1px solid rgba(228,228,228,1);&#125;QFrame#frame_prev_top &#123; padding: 2px; background-color: rgb(255, 255, 255); border-bottom: 1px solid rgba(228,228,228,1);&#125;QFrame#frame_prev_tools &#123; padding-left: 6px;&#125;/* 工具按钮 */QToolButton:hover &#123;\tbackground-color: rgba(46, 51, 56, 0.09);&#125;QToolButton:checked &#123;\tbackground-color: rgba(46, 51, 56, 0.09);&#125;QToolButton:pressed &#123;\tbackground-color: rgba(46, 51, 56, 0.13);&#125;QToolButton &#123;\tpadding: 2px;\tborder-radius: 4px;\tmargin-right: 4px;\tmargin-top: 2px;\tmargin-bottom: 2px;&#125;/* 中间区域左侧样式 *//* 图层管理上方 */QFrame#frame_prev_layers_mgr, QFrame#frame_prev_layers_mgr QToolButton &#123; background-color: #F7F8FA;&#125;QFrame#frame_prev_layers_mgr &#123; border: 0px solid; border-bottom-width: 1px; border-bottom-color: #EBECF0;&#125;QFrame#frame_prev_layers &#123; border: 0px solid; border-right-width: 1px; border-right-color: #EBECF0;&#125;/* 图层管理上方按钮样式 */QFrame#frame_prev_layers_mgr QToolButton &#123; margin: 4px 0px; margin-right: 4px;&#125;QFrame#frame_prev_layers_mgr QToolButton:hover &#123; background-color: #EBECF0;&#125;QFrame#frame_prev_layers_mgr QLabel &#123; font-size: 9pt; margin-left: 4px; background-color: #F7F8FA;&#125;/* 中间区域右侧样式 */QFrame#frame_prev_map_mgr &#123; border: 0px solid; border-bottom-width: 1px; border-bottom-color: #EBECF0; padding-left: 4px;&#125;/* 底部区域样式 */QFrame#frame_prev_bottom &#123; border: 0px solid #EBECF0; border-top-width: 1px; background-color: white; padding: 1px 10px; border-bottom: none;&#125;QLineEdit#edit_coords_value, QLineEdit#edit_coords_value_inversion &#123; width: 100px; margin: 2px 0px;&#125;QLineEdit#edit_coords_value, QLineEdit#edit_coords_value_inversion &#123; width: 140px; margin: 2px 0px;&#125; 最终效果如下： 夜间模式创建ui/style/light/theme.qss和ui/style/dark/theme.qss两个文件，分别存放白天和夜间主题。 修改main.py代码 main.pyclass PyQgisSEApp(QMainWindow, Ui_MainWindow): def __init__(self, app: QgsApplication): super(PyQgisSEApp, self).__init__() self.app = app self.ui = Ui_MainWindow() self.ui.setupUi(self) # 装载模块 GUI.GUIPreview.load_preview(self) # 加载主题文件 self.settings = QSettings(&#x27;PyQgisSEApp&#x27;) self.theme = &#x27;light&#x27; self.load_qss() def load_qss(self): # 从配置中加载主题选项 self.theme = self.settings.value(&#x27;theme&#x27;, &#x27;light&#x27;) self.switch_theme() def slot_switch_theme(self): &quot;&quot;&quot; 切换主题插槽，用于绑定按钮 &quot;&quot;&quot; self.theme = &#x27;dark&#x27; if self.theme == &#x27;light&#x27; else &#x27;light&#x27; # 写入配置 self.settings.setValue(&#x27;theme&#x27;, self.theme) self.switch_theme() def switch_theme(self): # 切换主题文件 file = f&quot;&#123;os.path.dirname(sys.argv[0])&#125;/ui/style/&#123;self.theme&#125;/theme.qss&quot; qss = QSSLoader(file).load() self.ui.centralwidget.setStyleSheet(qss) # 数据预览页面主题切换 GUI.GUIPreview.switch_theme(self, self.theme) 预览页面添加如下代码，部分组件样式需要代码更改，资源文件自行添加 preview.pydef switch_theme(main, theme): canvas_color = Qt.white if main.theme == &#x27;light&#x27; else QColor(30, 31, 34) main.preview_canvas.setCanvasColor(canvas_color) if &#x27;dark&#x27; == theme: main.layerTreeView.setStyleSheet(&quot;background-color: rgb(30, 31, 34)&quot;) main.ui.button_prev_clear.setIcon(QIcon(&quot;:/icon/action_trash_dark&quot;)) main.ui.button_prev_remove.setIcon(QIcon(&quot;:/icon/action_remove_dark&quot;)) else: main.layerTreeView.setStyleSheet(&quot;background-color: white&quot;) main.ui.button_prev_clear.setIcon(QIcon(&quot;:/icon/action_trash_light&quot;)) main.ui.button_prev_remove.setIcon(QIcon(&quot;:/icon/action_remove_light&quot;)) 主题文件dark/theme.qss内容如下： QWidget, QFrame &#123; background-color: #2B2D30; border: none;&#125;QTabWidget, QLabel, QToolButton, QPushButton, QLineEdit, QRadioButton &#123; font-family: &#x27;Microsoft YaHei&#x27;, &#x27;PingFang SC&#x27;,&#x27;SimSun&#x27;,&#x27;Arial&#x27;, sans-serif; color: #FFF;&#125;QSplitter &#123; background-color: #1E1F22;&#125;/* 输入框 */QLineEdit &#123; border-style:none; padding:2px; border-radius: 3px; color: white; border: 1px solid rgb(224, 224, 230); background-color: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.1);&#125;QLineEdit:focus &#123; border: 1px solid #36ad6a;&#125;/* Tab样式 */QTabWidget#tabWidget &#123; background-color: #2B2D30; border: none;&#125;QTabBar &#123; font-size: 9.5pt; qproperty-drawBase: 0;&#125;QTabBar::tab &#123; border: none; margin: 3px 10px 0px 10px; width: 66px; padding: 5px 0px; color: #FFF; border-bottom: 2px solid #2B2D30;&#125;QTabBar::tab:selected, QTabBar::tab:hover &#123; background-color:#2B2D30;&#125;QTabBar::tab:selected &#123; border-color: #18a058; font-weight: 500;&#125;/* 顶部工具栏样式 */QFrame#frame_prev_top &#123; border-top: 1px solid #1E1F22;&#125;QFrame#frame_prev_top &#123; padding: 2px; background-color: #2B2D30; border-bottom: 1px solid #1E1F22;&#125;QFrame#frame_prev_tools &#123; padding-left: 6px;&#125;/* 工具按钮 */QToolButton:hover &#123;\tbackground-color: #4E5157;&#125;QToolButton:checked &#123;\tbackground-color: #4E5157;&#125;QToolButton:pressed &#123;\tbackground-color: #4E5157;&#125;QToolButton &#123;\tpadding: 2px;\tborder-radius: 4px;\tmargin-right: 4px;\tmargin-top: 2px;\tmargin-bottom: 2px;&#125;/* 中间区域左侧样式 *//* 图层管理上方 */QFrame#frame_prev_layers &#123; background-color: #1E1F22;&#125;QFrame#frame_prev_layers_mgr, QFrame#frame_prev_layers_mgr QToolButton &#123; background-color: #2B2D30;&#125;QFrame#frame_prev_layers_mgr &#123; border: 0px solid #1E1F22; border-right-width: 1px; border-right-color: #1E1F22; border-bottom-width: 1px; border-bottom-color: #1E1F22;&#125;/* 图层管理上方按钮样式 */QFrame#frame_prev_layers_mgr QToolButton &#123; margin: 4px 0px; margin-right: 4px;&#125;QFrame#frame_prev_layers_mgr QToolButton:hover &#123; background-color: #4E5157;&#125;QFrame#frame_prev_layers_mgr QLabel &#123; font-size: 9pt; margin-left: 4px; background-color: #2B2D30;&#125;/* 中间区域右侧样式 */QFrame#frame_prev_map_mgr &#123; border: 0px solid; border-bottom-width: 1px; border-bottom-color: #1E1F22; padding-left: 4px;&#125;/* 底部区域样式 */QFrame#frame_prev_bottom &#123; border: 0px solid #1E1F22; border-top-width: 1px; background-color: #2B2D30; padding: 1px 10px; border-bottom: none;&#125;QLineEdit#edit_coords_value, QLineEdit#edit_coords_value_inversion &#123; width: 100px; margin: 2px 0px;&#125;QLineEdit#edit_coords_value, QLineEdit#edit_coords_value_inversion &#123; width: 140px; margin: 2px 0px;&#125; 夜间模式效果如下："},{"title":"帮助文档","path":"/wiki/pyqgis-sd/05_perfect/help.html","content":"软件内置帮助文档，原理是加载本地html文件，加载到QDialog中展示 帮助界面在utils中创建help_dialog.py文件，内容如下： import osimport sysfrom PyQt5.QtCore import QUrlfrom PyQt5.QtGui import QDesktopServicesfrom PyQt5.QtWebKitWidgets import QWebView, QWebPagefrom PyQt5.QtWidgets import QDialog, QVBoxLayoutclass CustomHelpDialog(QDialog): def __init__(self, parent=None): super().__init__(parent) def set_theme(self, theme, bg_color): self.setStyleSheet(bg_color) def set_title(self, title): self.setWindowTitle(title)class CustomWebView(QWebView): def __init__(self, parent=None): super().__init__(parent) self.setStyleSheet(&#x27;font-family: Microsoft YaHei&#x27;) self.page().setLinkDelegationPolicy(QWebPage.DelegateAllLinks) self.page().linkClicked.connect(self.linkClicked) def linkClicked(self, url): QDesktopServices.openUrl(url)def refresh_help_dialog(help_dialog, theme, name=None): if help_dialog is None: return bg_color = &#x27;background: white&#x27; if theme == &#x27;light&#x27; else &#x27;background: #2B2D30&#x27; help_dialog.set_theme(theme, bg_color) web_view: QWebView = help_dialog.layout().itemAt(0).widget() web_view.setStyleSheet(bg_color) if name is not None: url = QUrl.fromLocalFile(f&#x27;&#123;os.path.dirname(sys.argv[0])&#125;/markdown/&#123;name&#125;.html&#x27;) web_view.load(url) else: web_view.reload()def show_help_dialog(main, name, title): bg_color = &#x27;background: white&#x27; if main.theme == &#x27;light&#x27; else &#x27;background: #2B2D30&#x27; if main.help_dialog is None: main.help_dialog = CustomHelpDialog(main) main.help_dialog.set_title(f&#x27;&#123;title&#125;—帮助文档&#x27;) # add a label to dialog web_view = CustomWebView() web_view.setStyleSheet(bg_color) main.help_dialog.set_theme(main.theme, bg_color) layout = QVBoxLayout() layout.setContentsMargins(4, 34, 4, 0) layout.addWidget(web_view) main.help_dialog.setLayout(layout) url = QUrl.fromLocalFile(f&#x27;&#123;os.path.dirname(sys.argv[0])&#125;/markdown/&#123;name&#125;.html&#x27;) web_view.load(url) main.help_dialog.resize(820, 700) else: main.help_dialog.set_title(f&#x27;&#123;title&#125;—帮助文档&#x27;) # 主题由js从文件中获取，需要刷新 refresh_help_dialog(main.help_dialog, main.theme, name) main.help_dialog.show() 按钮设计使用Qt Designer在UI中添加帮助文档按钮，找到prev_tools_teach，内部添加QToolButton组件，并设置layoutLeftMargin设置为4，其他 Margin 设置为0，Spacing 设置为2。按钮设置如下图。 按钮绑定在preview.py文件的bind_func方法中添加绑定代码 preview.pyfrom utils.help_dialog import show_help_dialogdef bind_func(main): _ui = main.ui ... _ui.button_help.clicked.connect(lambda self: show_help_dialog(main, &#x27;preview&#x27;, &#x27;数据预览&#x27;)) 文档编写在根目录创建目录markdown，目录下存放具体的文档，格式是.html。其内容有要求，具体是从目录的them.json文件中读取主题信息，然后读取对应css样式文件，css文件放在markdown/css/目录下。 &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#x27;UTF-8&#x27;&gt;&lt;meta name=&#x27;viewport&#x27; content=&#x27;width=device-width initial-scale=1&#x27;&gt; &lt;title&gt;preview&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; rev=&quot;stylesheet&quot; id=&quot;style&quot; type=&quot;text/css&quot; media=&quot;all&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;theme.json&quot;&gt;&lt;/script&gt; &lt;script&gt; (function change_skin()&#123; path = &#x27;css/&#x27; + theme + &#x27;.css&#x27; document.getElementById(&quot;style&quot;).href=path; &#125;)() &lt;/script&gt;&lt;/head&gt;&lt;body class=&#x27;typora-export os-windows&#x27;&gt;&lt;div class=&#x27;typora-export-content&#x27;&gt; &lt;div id=&#x27;write&#x27; class=&#x27;&#x27;&gt;&lt;h2 id=&#x27;添加栅格影像&#x27;&gt;&lt;span&gt;添加栅格影像&lt;/span&gt;&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 样式文件下载地址： 蓝奏云 - css.ziphttps://www.lanzouw.com/iQSxF1wm305e 写入主题到theme.json文件中，在切换主题时写入到文件，并刷新dialog main.pyclass PyQgisSEApp(QMainWindow, Ui_MainWindow): def __init__(self, app: QgsApplication): ... self.help_dialog = None # 帮助Dialog ... def switch_theme(self): ... # 写入主题信息到文件 self.save_theme_file() # 刷新帮助Dialog refresh_help_dialog(self.help_dialog, self.theme) ... def save_theme_file(self): try: path = f&#x27;&#123;os.path.dirname(sys.argv[0])&#125;/markdown/theme.json&#x27; f = open(path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) f.write(f&quot;theme=&#x27;&#123;self.theme&#125;&#x27;&quot;) f.close() except Exception as e: print(e) 效果预览效果如下："},{"title":"画布工具","path":"/wiki/pyqgis-sd/04_prev/canva_tools.html","content":"这里我发现之前放大和缩小搞反了，请自行更改资源文件和UI文件，重新生成对应的py文件。 zoom_in：是缩小 zoom_out：是放大 实现画布上方的放大、缩小、刷新功能，并绑定到对应按钮。在btn_func.py，添加更改绘图工具和刷新画布代码如下： btn_func.pydef slot_set_gis_tool(canvas: QgsMapCanvas, tool): canvas.setMapTool(tool)def slot_refresh_canvas(canvas: QgsMapCanvas): &quot;&quot;&quot; 刷新画布 :param canvas: :return: &quot;&quot;&quot; for layer in canvas.layers(): canvas.setExtent(layer.extent()) canvas.setDestinationCrs(layer.crs()) break canvas.refreshAllLayers() 在preview.py的bind_func方法中添加如下代码： preview.oy# 绑定工具方法_ui.button_move.clicked.connect(lambda self: slot_set_gis_tool(main.preview_canvas, main.preview_tool_pan))_ui.button_zoom_in.clicked.connect(lambda self: slot_set_gis_tool(main.preview_canvas, main.preview_tool_zoom_in))_ui.button_zoom_out.clicked.connect(lambda self: slot_set_gis_tool(main.preview_canvas, main.preview_tool_zoom_out))_ui.button_refresh.clicked.connect(lambda self: slot_refresh_canvas(main.preview_canvas))"},{"title":"画布与图层管理器","path":"/wiki/pyqgis-sd/04_prev/canvas_layers.html","content":"QGIS为我们提供了默认的图层管理器，我们需要绑定图层树和画布，然后向图层树中添加图层，画布和图层视图都会显示添加的数据。 为此，先删除之前设计界面时添加的 List View，找到frame_prev_layers删除其中的list_view，并修改其layoutName为layout_prev_layers，稍后会向该布局中添加图层视图。 修改init_qgis_map方法，添加如下代码 def init_qgis_map(main): # 初始化画布 main.preview_canvas = QgsMapCanvas() main.preview_canvas.setDestinationCrs(QgsCoordinateReferenceSystem(&quot;EPSG:4326&quot;)) main.preview_canvas.setCanvasColor(Qt.white) main.preview_canvas.enableAntiAliasing(True) main.preview_canvas.setFocus() main.preview_canvas.setParallelRenderingEnabled(True) # 添加到布局中 main.ui.preview_qgis_map.addWidget(main.preview_canvas) # 初始化工具 main.preview_tool_pan = QgsMapToolPan(main.preview_canvas) main.preview_tool_zoom_in = QgsMapToolZoom(main.preview_canvas, False) main.preview_tool_zoom_out = QgsMapToolZoom(main.preview_canvas, True) # 默认使用移动工具 main.preview_canvas.setMapTool(main.preview_tool_pan) # 初始化图层管理器 # 创建图层树视图，然后添加到界面中 main.layerTreeView = QgsLayerTreeView(main) main.ui.layout_prev_layers.addWidget(main.layerTreeView) # 树节点 main.model = QgsLayerTreeModel(QgsProject.instance().layerTreeRoot(), main) main.model.setFlag(QgsLayerTreeModel.AllowNodeRename) # 允许图层节点重命名 main.model.setFlag(QgsLayerTreeModel.AllowNodeReorder) # 允许图层拖拽排序 main.model.setFlag(QgsLayerTreeModel.AllowNodeChangeVisibility) # 允许改变图层节点可视性 main.model.setFlag(QgsLayerTreeModel.ShowLegendAsTree) # 展示图例 main.model.setAutoCollapseLegendNodes(10) # 当节点数大于等于10时自动折叠 main.layerTreeView.setModel(main.model) # 4 建立图层树与地图画布的桥接 main.layerTreeBridge = QgsLayerTreeMapCanvasBridge(QgsProject.instance().layerTreeRoot(), main.preview_canvas, main) 界面运行效果如下："},{"title":"初始化模块","path":"/wiki/pyqgis-sd/04_prev/init.html","content":"在根目录创建gui包，包下会生成一个__init__.py文件，然后在该包下创建目录preview，并在目录中创建preview.py，内容如下： ui/preview/preview.pydef load_preview(main): &quot;&quot;&quot; 装载预览界面 :param main: :return: &quot;&quot;&quot; # 初始化界面变量 declaring_variable(main) # 初始化界面布局 init_preview(main) # 初始化 QGIS init_qgis_map(main) # 绑定方法 bind_func(main) def declaring_variable(main): main.preview_canvas = None # 图层显示器 main.preview_tool_pan = None main.preview_tool_zoom_in = None main.preview_tool_zoom_out = Nonedef init_preview(main): # 设置splitter缩放因子 main.ui.splitter.setStretchFactor(0, 3) main.ui.splitter.setStretchFactor(1, 5)def init_qgis_map(main): passdef bind_func(main): pass 在ui的__init__.py文件中写入下面代码 ui/__init__.pyimport gui.preview.preview as GUIPreview 在main.py中装载 preview 模块 main.pyimport gui as GUIclass PyQgisSEApp(QMainWindow, Ui_MainWindow): def __init__(self, app: QgsApplication): super(PyQgisSEApp, self).__init__() self.app = app self.ui = Ui_MainWindow() self.ui.setupUi(self) # 装载模块 GUI.GUIPreview.load_preview(self)"},{"title":"加载栅格数据","path":"/wiki/pyqgis-sd/04_prev/load_raster.html","content":"文件选择选中本地文件方法，在根目录创建utils包，包内创建fileUtil.py，内容如下： 该方法会根据last_dir_key记录本次打开的目录，每次选择会打开上次的目录 fileUtil.pyimport osfrom PyQt5.QtCore import QSettings, QDirfrom PyQt5.QtWidgets import QFileDialogdef select_single_file(weight, suffix_filter: str, last_dir_key: str): &quot;&quot;&quot; 打开单个文件 :param weight: :param suffix_filter: :param last_dir_key: :return: &quot;&quot;&quot; # 历史目录 settings = QSettings(&#x27;PyQgisSEAPP&#x27;) last_dir = settings.value(last_dir_key, QDir().homePath()) file_dialog = QFileDialog(weight) file_dialog.setWindowTitle(&#x27;文件选择&#x27;) file_dialog.setNameFilter(suffix_filter) file_dialog.setDirectory(last_dir) file_dialog.setFileMode(QFileDialog.FileMode.ExistingFile) file_dialog.setViewMode(QFileDialog.ViewMode.Detail) if file_dialog.exec(): filenames = file_dialog.selectedFiles() filepath = filenames[0] # 记录历史目录 settings.setValue(last_dir_key, os.path.dirname(filepath)) return filepath return &#x27;&#x27; 打开栅格数据在preview目录创建functions包，并在包内创建btn_func.py，添加栅格数据代码如下： btn_func.pyfrom os.path import basenamefrom qgis._core import QgsRasterLayer, QgsProjectfrom qgis._gui import QgsMapCanvasimport utils.fileUtil as FileUtildef open_raster_file(main): &quot;&quot;&quot; 打开栅格文件 :param main: :return: &quot;&quot;&quot; # 选择文件 filepath = FileUtil.select_single_file(main, &#x27;GeoTiff(*.tif;*tiff;*TIF;*TIFF)&#x27;, &#x27;last_dir_raster&#x27;) if filepath == &#x27;&#x27;: return canvas: QgsMapCanvas = main.preview_canvas # 添加图层 layer: QgsRasterLayer = QgsRasterLayer(filepath, basename(filepath), &#x27;gdal&#x27;) layer.dataProvider().setNoDataValue(1, 0) # 检查图层合法性 if not layer.isValid(): return False QgsProject.instance().addMapLayer(layer) # 渲染栅格图像，渲染到最上层 is_first_add_layer = len(canvas.layers()) == 0 canvas.setLayers([layer] + canvas.layers()) if is_first_add_layer: canvas.setExtent(layer.extent()) canvas.setDestinationCrs(layer.crs()) canvas.freeze(False) canvas.setVisible(True) canvas.refresh() 绑定方法，回到preview.py，给按钮绑定方法 preview.pyfrom gui.preview.functions import open_raster_filedef bind_func(main): _ui = main.ui _ui.button_add_raster.clicked.connect(lambda self: open_raster_file(main)) 运行效果如下： 示例数据下载地址： 蓝奏云 - image_quanfudao.ziphttps://www.lanzouw.com/iyJJq1wllzkb"},{"title":"加载矢量数据","path":"/wiki/pyqgis-sd/04_prev/load_vector.html","content":"在preview目录创建functions包，并在包内创建btn_func.py，添加矢量数据代码如下： btn_func.pyfrom os.path import basenamefrom PyQt5.QtGui import QFont, QColorfrom osgeo import gdalfrom qgis._core import QgsRasterLayer, QgsProject, QgsVectorLayer, QgsPalLayerSettings, QgsTextFormat, Qgis, \\ QgsVectorLayerSimpleLabelingfrom qgis._gui import QgsMapCanvasimport utils.fileUtil as FileUtildef open_shp_file(main): filepath = FileUtil.select_single_file(main, &#x27;等深线数据(*.shp)&#x27;, &#x27;last_dir_contour_shp&#x27;) if filepath == &#x27;&#x27; or not filepath.endswith(&#x27;.shp&#x27;): return gdal.SetConfigOption(&#x27;SHAPE_RESTORE_SHX&#x27;, &#x27;YES&#x27;) layer = QgsVectorLayer(filepath, basename(filepath), &#x27;ogr&#x27;) if not layer.isValid(): return False # 设置标注 layer_setting = QgsPalLayerSettings() layer_setting.drawLabels = True layer_setting.fieldName = layer.fields()[1].name() # 文本样式设置 text_format = QgsTextFormat() text_format.setFont(QFont(&quot;Arial&quot;, 12)) text_format.setColor(QColor(255, 255, 255)) layer_setting.setFormat(text_format) layer_setting.placement = Qgis.LabelPlacement.Line layer_setting.placementFlags = QgsPalLayerSettings.AboveLine layer.setLabelsEnabled(True) layer.setLabeling(QgsVectorLayerSimpleLabeling(layer_setting)) layer.triggerRepaint(True) canvas: QgsMapCanvas = main.preview_canvas QgsProject.instance().addMapLayer(layer) canvas.setLayers([layer] + canvas.layers()) canvas.setDestinationCrs(layer.crs()) canvas.setExtent(layer.extent()) canvas.refresh() 绑定方法，回到preview.py，给按钮绑定方法 preview.pyfrom gui.preview.functions import open_raster_file, open_shp_filedef bind_func(main): _ui = main.ui # 添加栅格数据按钮绑定方法 _ui.button_add_raster.clicked.connect(lambda self: open_raster_file(main)) # 添加矢量数据按钮绑定方法 _ui.button_add_shp.clicked.connect(lambda self: open_shp_file(main)) 运行效果如下： 示例数据下载地址： 蓝奏云 - contour_shp.ziphttps://www.lanzouw.com/iQMc41wllvwj"},{"title":"状态栏信息显示","path":"/wiki/pyqgis-sd/04_prev/status.html","content":"状态栏显示信息逻辑如下： 监听画布鼠标移动事件 将点坐标绘制在状态组件中 显示坐标参考系统找到init_qgis_map方法，在初始化画布的时候，设置状态栏的坐标参考系统 # 设置状态栏set_status_crs(main.ui.label_crs, main.preview_canvas) main.ui.label_crs：为QLabel控件 设置代码如下： def set_status_crs(label: QLabel, canvas: QgsMapCanvas): canvas.mapSettings().destinationCrs().description() map_setting: QgsMapSettings = canvas.mapSettings() label.setText(f&quot;坐标系: &#123;map_setting.destinationCrs().description()&#125;-&#123;map_setting.destinationCrs().authid()&#125;&quot;) 监听鼠标移动QGIS的画布已经提供该监听方法， main.preview_canvas.xyCoordinates.connect(lambda point: set_status_xy( _ui.edit_coords_default_value, _ui.edit_coords_value, main.preview_canvas, point)) point：即为监听方法传递的坐标信息，对应的是鼠标此刻位置 set_status_xy为显示的方法，其接受参数如下 _ui.edit_coords_default_value：控件，显示默认坐标系坐标 _ui.edit_coords_value：控件，显示转换的坐标&#96; main.preview_canvas：当前画布 point：当前点 显示坐标def set_status_xy(label_origin, label_latlon, canvas: QgsMapCanvas, point: QgsPointXY): label_origin.setText(f&#x27;&#123;point.x():.0f&#125;, &#123;point.y():.0f&#125;&#x27;) convert_point = convert_to_wgs84(QgsCoordinateReferenceSystem(canvas.mapSettings().destinationCrs().authid()), point) label_latlon.setText(f&#x27;&#123;convert_point.y():.5f&#125;°, &#123;convert_point.x():.5f&#125;°&#x27;) label_latlon.setCursorPosition(0) 坐标转换方法 from qgis._core import QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsCoordinateTransformContext, QgsPointXYdef convert_to_wgs84(src_crs, point: QgsPointXY): &quot;&quot;&quot; 转换到 EPSG:4326 坐标系 :param src_crs: 原始坐标系 :param point: :return: &quot;&quot;&quot; dest_crs = QgsCoordinateReferenceSystem(&quot;EPSG:4326&quot;) crs_tras = QgsCoordinateTransform(src_crs, dest_crs, QgsCoordinateTransformContext()) return crs_tras.transform(point)"},{"title":"代码编写","path":"/wiki/pyqgis-sd/03_code/code.html","content":"转换工具pyuic工具我们在打开File &gt; Settings &gt; Tools &gt; External Tools后，点击左上角的+号，进行配置填写： Name输入pyuic， Programs输入 你自己的qgis应用地址&#x2F;bin&#x2F;python-qgis.bat， Argument输入 -m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$win.py , Working directory输入 $FileDir$ 然后通过右键ui/main.ui，选择exterl-tools，pyuic pyrcc工具我们在打开File &gt; Settings &gt; Tools &gt; External Tools后，点击左上角的+号，进行配置填写： Name输入pyrcc， Programs输入 你自己的qgis应用地址&#x2F;bin&#x2F;python-qgis.bat， Argument输入 -m PyQt5.pyrcc_main $FileName$ -o $FileNameWithoutExtension$_rc.py Working directory输入 $FileDir$ 然后通过右键resources/rc.qrc，选择exterl-tools，pyrcc,我们会在resources文件夹生成rc_rc.py,我们将其移到根目录下，并且右键项目，将其设为Source Root 启动项目目前为止，目录结构如下 .├── resources # 资源文件夹│ ├── icon # 图标文件│ └── rc.qrc # 资源文件├── ui # 主目录│ ├── main.ui # ui布局文件│ └── mainwin.py # ui转py布局文件├── main.py # 入口文件└── rc_rc.py # 资源py文件 在main.py中写入下面代码，运行后显示界面代表成功。 from PyQt5.QtWidgets import QMainWindowfrom qgis._core import QgsApplicationfrom ui.mainwin import Ui_MainWindowclass PyQgisSEApp(QMainWindow, Ui_MainWindow): def __init__(self, app: QgsApplication): super(PyQgisSEApp, self).__init__() self.app = app self.ui = Ui_MainWindow() self.ui.setupUi(self)if __name__ == &#x27;__main__&#x27;: # 第二个参数为是否启用 GUI qgs = QgsApplication([], False) # 初始化 QGIS qgs.initQgis() app = PyQgisSEApp(qgs) app.show() qgs.exec_() qgs.exitQgis()"},{"title":"图标资源","path":"/wiki/pyqgis-sd/03_code/qrc.html","content":"笔者图标包下载地址： 蓝奏云 - icon.ziphttps://www.lanzouw.com/ieHSY1wmjt7g 在项目pyqgis-se的根目录创建resources\\icon目录，并将图标放入该目录。 在Qt Designer右下角找到资源浏览器，点击资源编辑按钮 在弹出的窗口中，点击左下角的新建资源文件rc.qrc，放在项目pyqgis-se的resources目录。然后点击右侧左下角的添加前缀命名为icon。此时就可以添加图标资源了，点击添加文件按钮，找到resources\\icon目录下的图标文件。"},{"title":"Qt Designer","path":"/wiki/pyqgis-sd/03_code/qt_designer.html","content":"Qt Designer是官方提供的 GUI 设计器，通过拖拽的方式完成界面设计。在 Win 中搜索 Qt Designer或者运行 QGIS 安装目录的bin\\qgis-designer.bat打开Qt Designer"},{"title":"界面设计","path":"/wiki/pyqgis-sd/03_code/ui.html","content":"我们选择Main Window模板创建，点击下方的Create后，将创建空白窗口。在右侧对象检查器中删除menubar，在左侧的 Containers 中找到TabWidget，拖动到空白窗口中。在空白窗口中右键，选择MainWindow的布局为垂直布局，在属性编辑器中找到currentTabText可修改Tab的文字。完成后保存到ui目录下，效果如下图： 整体布局我们将界面划分为三大部分：操作区、展示区、信息区，采用垂直布局。其中展示区划分为：图层管理区和数据展示区，采用水平布局。 具体操作：选中数据预览 Tab，依次拖入 Frame、Widget、Frame，右键数据预览 Tab，布局设置为垂直布局。 操作区布局修改最上面的 Frame 的 objectName 为 frame_prev_top，其布局为：操作区、填充区，采用水平布局。操作区的按钮是成组出现的，例如：添加栅格数据、添加光子数据、添加等深线数据为一组，组间水平布局，组内水平布局。 在frame_prev_top中拖入两个 Frame。在右侧对象检查器中选中frame_prev_top，右键将布局设置为水平布局，在属性编辑器中将frame_prev_top所有 Margin 设置为 0 添加两组操作，修改frame_prev_top中位于左边的 Frame 的 objectName 为 frame_prev_tools，向其中添加两个 Frame ，布局为水平布局，Margin 和 Spacing 为 0。 添加操作按钮，向prev_tools_add中添加两个QToolButton，并将prev_tools_add布局修改为水平布局，其Margin 为 0，Spacing 为 2。设置按钮，按照下图设置QToolButton，字体设置为Microsoft YaHei 将frame_prev_tools的水平策略和垂直策略设置为Fixed，将frame_prev_top的垂直策略设置为Fixed。最终效果如下图。 展示区布局展示区分为：图层管理、数据展示，布局为水平布局。其中图层管理分为：图层操作、图层展示，布局为垂直布局。其中数据展示分为：图层操作、图层展示，布局为垂直布局。 找到widget_middle，向其中添加两个 Frame，按住 Ctrl 依次选中两个 Frame，右键设置布局为使用拆分器水平布局，同时设置widget_middle布局为水平布局，Margin 和 Spacing 为 0。设置 splitter 的 handleWidth为2，布局详情如下图。 图层管理找到frame_prev_layers，向其中依次添加 Frame、List View，设置frame_prev_layers的布局为垂直布局，Margin 和 Spacing 为 0，布局详情如下图。 找到frame_prev_layers_mgr，按照下图添加组件，设置frame_prev_layers_mgr的布局为水平布局，Margin 和 Spacing 为 0。设置label的内容为图层管理，frame_prev_layers_mgr策略和高度如下图。 清空和删除图层按钮，首先是在资源浏览器中添加对应的图标，然后按照下图设置按钮样式，同时勾选autoRaise让按钮背景透明。 最终的效果如图： 数据展示找到frame_prev_map，向其中添加两个 Frame，设置frame_prev_map的布局为垂直布局，Margin 和 Spacing 为 0，布局详情如下图。 找到frame_prev_map_mgr，按照下图添加组件，设置frame_prev_map_mgr的布局为垂直布局，Margin 和 Spacing 为 0。frame_prev_map_mgr策略和高度如下图。 prev_map_tools的水平策略设置为Fixed，布局为水平布局，Margin 为 0，Spacing 为 6。 设置按钮，首先是在资源浏览器中添加对应的按钮，然后按照下图设置按钮样式，同时勾选autoRaise让按钮背景透明。第一个按钮勾选checked，代表默认选中，其他按钮不勾选。 在frame_prev_map_show中随便添加一个组件，设置布局为垂直布局，Margin 和 Spacing 为 0。并将布局名称设置为preview_qgis_map，代码中将绑定canvas，然后删除刚添加的组件。 最终的效果如图： 信息显示区设置frame_prev_bottom的minimumSize和maximumSize的高度为34，并向其中添加如图组件。将frame_prev_bottom设置布局为水平布局，Margin 和 Spacing 为 0。label_tips_prev组件用来显示提示信息 向frame_coords中依次添加 Label 命名为 label_coords_name Line Edit 命名为edit_coords_value，styleSheet为padding-left: 1px; padding-right: 1px; Label 命名为 label_coords_default_name，styleSheet为padding: 0px; margin-left: 5px Line Edit 命名为label_coords_default_value，styleSheet为padding-left: 1px; padding-right: 1px; Label 命名为 label_crs，sizePolicy的水平策略设置为 Fixed frame_coords设置布局为水平布局，水平策略设置为Fixed，Margin 和 Spacing 为 0。 最后调整 勾选tabWidget的 documentMode 修改centralwidget的 Margin 和 Spacing 为 0。 修改tab_data_preview的 Margin 和 Spacing 为 0。 修改MainWindow的 minimumSize 的宽度为1200，高度为850 修改frame_prev_layers的 minimumSize 的宽度为200，修改frame_prev_map的 minimumSize 的宽度为400 最终效果如下图："},{"title":"PyInstaller打包","path":"/wiki/pyqgis-sd/06_package/pyinstaller.html","content":"为了方便用户使用，需要对项目进行打包，这里选用了经典的 PyInstaller 来进行打包。 打包脚本如下： install.bat&quot;D:\\Program Files\\QGIS 3.30.0\\bin\\python-qgis.bat&quot; -m PyInstaller -w ^--icon=ui/resources/icon/logo.ico ^--hidden-import xlsxwriter ^--collect-binaries=tables ^--add-data=&quot;D:\\Program Files\\QGIS 3.30.0\\apps\\qgis\\plugins;qgis\\plugins&quot; ^--add-data=&quot;D:\\Program Files\\QGIS 3.30.0\\apps\\Python39\\Lib\\site-packages\\PyQt5\\*.pyd;PyQt5&quot; ^--add-data=&quot;D:\\Program Files\\QGIS 3.30.0\\apps\\qt5\\plugins\\styles;PyQt5\\Qt\\plugins\\styles&quot; ^--add-data=&quot;D:\\Program Files\\QGIS 3.30.0\\apps\\qt5\\plugins\\iconengines;PyQt5\\Qt\\plugins\\iconengines&quot; ^--add-data=&quot;D:\\Program Files\\QGIS 3.30.0\\apps\\qt5\\plugins\\imageformats;PyQt5\\Qt\\plugins\\imageformats&quot; ^--add-data=&quot;D:\\Program Files\\QGIS 3.30.0\\apps\\qt5\\plugins\\platforms;PyQt5\\Qt\\plugins\\platforms&quot; ^--add-data=&quot;D:\\Program Files\\QGIS 3.30.0\\apps\\qt5\\plugins\\platformthemes;PyQt5\\Qt\\plugins\\platformthemes&quot; ^--add-data=&quot;proj;proj&quot; ^--add-data=&quot;ui\\resources\\icon;ui\\resources\\icon&quot; ^--add-data=&quot;ui\\resources\\shadow_10px.png;ui\\resources&quot; ^--add-data=&quot;ui\\style;ui\\style&quot; ^--add-data=&quot;res;res&quot; ^--add-data=&quot;locales\\en-us.qm;locales&quot; ^main.py 说明： D:\\Program Files\\QGIS 3.30.0\\是QGIS的安装目录 --hidden-import:xlsxwriter：动态加载库xlsxwriter，如果你的项目没有用到xlsx表格的读写，请忽略。 --collect-binaries table：收集指定包table或模块的所有二进制文件，没有请忽略。 --add-data=&quot;proj;proj&quot;：如果你使用GDAL库，在打包之后代码可能无法正确执行。该参数将根目录下的proj/proj.db拷贝到打包目录的proj/proj.db位置。请在根目录下创建proj文件，并放入proj.db文件。该文件的位置参考：https://zhuanlan.zhihu.com/p/653522235 ERROR 1: PROJ: proj_create_from_database: Cannot find proj.db 该部分是添加一些静态资源文件源路径;打包之后路径 --add-data=&quot;ui\\resources\\icon;ui\\resources\\icon&quot; ^--add-data=&quot;ui\\resources\\shadow_10px.png;ui\\resources&quot; ^--add-data=&quot;ui\\style;ui\\style&quot; ^--add-data=&quot;res;res&quot; ^--add-data=&quot;locales\\en-us.qm;locales&quot; ^ main.py：程序主入口，请将该脚本文件放到main.py同级目录。 在PyCharm的控制台直接输入install.bat即可执行打包脚本，打包输出目录为dist install.bat 打包完成之后，在dist/main/目录中找到main.exe双击即可运行。 之后可以使用工具将其打包为安装包文件，或者直接压缩为绿色解压版本。"},{"title":"安装包制作","path":"/wiki/pyqgis-sd/06_package/setup.html","content":"敬请期待"},{"title":"生存题材","path":"/wiki/recommend/games/survival/index.html","content":"饥荒联机版Steam好评如潮，支持多人联机 left right Don’t Starve Together在绝不妥协的荒野生存游戏《饥荒》的多人联机版中一起战斗、耕种、建设和探索吧。 标签：探索 开放世界生存制作 生存 沙盒 制作 2D"},{"title":"丧尸题材","path":"/wiki/recommend/games/zombie/index.html","content":"腐烂国度2Steam特别好评，支持多人联机 left right State of Decay 2: Juggernaut Edition丧尸崛起，文明陷落。在这个动作策略模拟游戏中，您的一小队幸存者将不得不前往开放世界搜刮资源，并建立可以抵挡丧尸群攻击的基地。 标签：生存 开放世界 僵尸 基地建设 多人 合作 七日杀Steam特别好评，支持多人联机 left right 7 Days to Die《7 Days》是一款开放世界游戏，独具特色地融合了第一人称射击、生存恐怖、塔防和角色扮演等多种游戏的特征。快来体验这款具有开创性的终极丧尸生存沙盒角色扮演游戏吧。纳维戈恩在等着你！ 标签：生存 僵尸 体素 开放世界 开放世界生存制作 求生之路2Steam好评如潮，支持多人联机 left right Left 4 Dead 2《求生之路2》游玩时玩家将扮演四名新生还者中的一名，装备有种类繁多、数量惊人的经典及先进武器。 和伙伴们从大量的丧尸以及特感中达到暂时安全的安全屋，在最终战役中死守等待救援到来… 标签：僵尸 合作 第一人称射击 多人 动作"},{"title":"视频网站","path":"/wiki/recommend/website/01_video/index.html","content":"免费外剧 国内影视 缘觉影视（简称YJYS）缘觉影视（简称YJYS），热门电影，最新电影，最新电视剧，免费下载，迅雷下载，磁力下载，电驴下载，免费在线观看 影视导航 不求人@影视不求人导航@影视 | 专业影视资源导航"},{"title":"软件下载","path":"/wiki/recommend/website/02_software/index.html","content":"Mac软件下载 MacBL马可菠萝 - 分享你喜欢的MAC应用 佛系软件佛系软件 - 精品Windows，macOS破解软件下载 AppStorrentAppStorrent - Игры и программы для macOS Windows软件下载 佛系软件佛系软件 - 精品Windows，macOS破解软件下载"},{"title":"微信公众号","path":"/wiki/recommend/website/05_wechat/index.html","content":"敬请期待"},{"title":"图片处理","path":"/wiki/recommend/website/03_image/index.html","content":"在线PS PhotopeaPhotopea Online Photo Editor lets you edit photos, apply effects, filters, add text, crop or resize pictures. Do Online Photo Editing in your browser for free! WebPS软件网页版，ps在线图片处理工具-图片编辑器WebPS,在线PS照片处理、在线PS照片合成、抠图、裁切、添加文字、添加特效、美化照片、调整大小工能，是一部深受广大网友青睐的在线ps图片处理软件，软件中强大的PS在线图片编辑器让我们随时随地在线编辑各种图片，满足各种图片的需要。在线Photoshop软件无需下载。 图片压缩 CAESIUM Image CompressorCaesium is a free, open source, online compression tool for photos and images (JPG, PNG), supporting batch, preview and many more. Caesium saves space and makes uploads faster."},{"title":"在云服上搭建服务器","path":"/wiki/server/DSTServer/server/cloud-server.html","content":"敬请期待"},{"title":"在本地搭建服务器","path":"/wiki/server/DSTServer/server/local-server.html","content":"本地服务器未必能解决和小伙伴联机卡顿问题，但可搭配内网穿透缓解网络卡顿问题 下载服务器文件 打开steam，进入库界面，将工具勾选上 我们找到Don&#39;t Starve Toghter Dedicated Server，点击下载，等待完成即可。 下载完成后可以取消勾选工具，等需要更新时再次勾选。 修改启动脚本 我们来到饥荒服务器所在目录，例如我的是 E:\\SteamLibrary\\steamapps\\common\\Don&#x27;t Starve Together Dedicated Server 不知道的可以在Steam种右键服务器，管理，浏览本地文件。 进入bin\\scripts目录。Win10及以下直接右键编辑，Win11右键，显示更多选项，编辑。 @ECHO OFFset SteamAppId=322330set SteamGameId=322330cd /D &quot;E:\\SteamLibrary\\steamapps\\common\\Don&#x27;t Starve Together Dedicated Server\\bin&quot;start &quot;Don&#x27;t Starve Together Overworld&quot; /D &quot;%~dp0..&quot; &quot;%~dp0..\\dontstarve_dedicated_server_nullrenderer.exe&quot; -cluster Cluster_1 -console -shard Master -consolestart &quot;Don&#x27;t Starve Together Caves&quot; /D &quot;%~dp0..&quot; &quot;%~dp0..\\dontstarve_dedicated_server_nullrenderer.exe&quot; -cluster Cluster_1 -console -shard Caves -console 复制上述脚本覆盖文件内容，其中需要修改两项 cd /D &quot;这里填写自己的目录&quot;：其实就是服务器所在目录+\\bin -cluster 存档名称：比如我的存档目录名是Cluster_1 创建存档 打开游戏，创建好存档（各种设置，添加洞穴，添加mod等等），点击创建世界，在选角色界面我们就可以断开连接了。 之后我们来到存档所在目录，例如我的在 D:\\Users\\sw-code\\Documents\\Klei\\DoNotStarveTogether\\405215769 不知道的可以在首界面，找到存档，点一下存档右边的扳手，打开世界文件。 我们将存档复制到上一个目录，例如我的 D:\\Users\\sw-code\\Documents\\Klei\\DoNotStarveTogether 注意我这里的存档名称是Cluster_7，必须与脚本中的存档名称一致 添加token 服务器会根据token判断哪个玩家是服主，服主默认具有使用控制台和T键的能力，当然也可通过添加管理员赋予其他玩家该权限。 再次打开游戏，在主界面左下角点击账户信息，在弹出页面的上面找到游戏。 再点击《饥荒：联机版》的游戏服务器，给服务器起个名字之后，点击添加新服务器。 我们复制生成的token 来到存档的目录，新建TXT文件cluster_token，将刚复制的token粘贴到文件中。 添加mod mod的添加方式有两种，这里直接推荐第二种： 复制客户端mod到服务端，客户端的mod位置有两个位置，稍后会说明。 在文件中使用ServerModSetup(&quot;&quot;)或者ServerModCollectionSetup(&quot;&quot;)，服务器启动时会自动下载和更新。 在操作开始前，我们先来了解以下mod配置文件 存档的mod配置文件中会有这个存档所需的mod代码ID，我们到存档文件中找到这个文件:modoverrides.lua 打开它，我们就能看到所有的mod配置信息 手动复制modmod的位置一共有两个: 饥荒客户端根目录的mods文件夹，可以注意到这里的mod有workshop-的前缀 点击查看示例 另一个需要从Steam库目录开始找，例如我的：E:\\SteamLibrary\\steamapps\\workshop\\content\\322330 点击查看示例 这两个文件夹中的mod的ID可能有一样的，但只有一个是正确的。辨别方法就是进入mod文件夹，如果里面是空的或者只有一个文件，那它是错误的。 好了，到这里我们就可以复制到服务器根目录的mods中了，但这里也有两种方式 全部复制，这会将客户端mod和服务器mod无差别的复制过去。 只复制自己存档开启的，可对照mod配置文件中的ID，一个一个的复制过去 但无论哪种方式，我们都需要在ID前加上workshop-前缀，例如：workshop-2831613121，已有的不用加。 点击查看示例 ServerModSetup(“”)首先来到饥荒服务器的根目录的mods文件夹中，打开dedicated_server_mods_setup.lua文件，在文件末尾加入 ServerModSetup(&quot;1185229307&quot;)ServerModSetup(&quot;1207269058&quot;)ServerModSetup(&quot;1216718131&quot;) 或者 ServerModCollectionSetup(&quot;1185229307&quot;)ServerModCollectionSetup(&quot;1207269058&quot;)ServerModCollectionSetup(&quot;1216718131&quot;) 区别在于ServerModSetup是下载单个mod的，ServerModCollectionSetup是下载合集mod的。 引号中的数字ID在存档的mod配置文件modoverrides.lua，属于按需引入。 点击查看示例 left ServerModSetup right ServerModCollectionSetup 启动服务器 我们再次来到饥荒服务器的目录，并进入bin\\scripts，比如我的 E:\\SteamLibrary\\steamapps\\common\\Don&#x27;t Starve Together Dedicated Server\\bin\\scripts 双击launch_preconfigured_servers.bat启动服务器，只要注意到Sim paused就说明启动成功。 left 地上启动成功 right 洞穴启动成功 停止服务器 注意不要直接点击X关闭窗口，会导致存档进度丢失的 正确的方法是使用命令： 点击查看使用示例 总结 步骤如下： 安装饥荒服务器 修改启动脚本，注意根据自己实际情况 创建存档，注意存档名一致问题 添加mod，使用ServerModCollectionSetup(&quot;&quot;)，会自动下载更新。但需要我们找到mod配置文件modoverrides.lua，正确将数字ID，写入文件。 启动服务器 停止服务器，注意使用代码而不是点击X 可能出现的问题 如果你出现图片中的问题，可能有下面三个原因： 没有token 启动脚本有问题，请复制我提供的脚本代码，并正确修改参数 存档名称不一致，检查和脚本中的存档名是否一致 请仔细检查并对照上面的教程修改。"},{"title":"mod问题","path":"/wiki/server/DSTServer/question/mod.html","content":"mod位置 由于官方原因，饥荒的mod会在两个位置出现 饥荒客户端根目录的mods文件夹，可以注意到这里的mod有workshop-的前缀 点击查看示例 另一个需要从Steam库目录开始找，例如我的：E:\\SteamLibrary\\steamapps\\workshop\\content\\322330 点击查看示例 这两个文件夹中的mod的ID可能有一样的，但只有一个是正确的。辨别方法就是进入mod文件夹，如果里面是空的或者只有一个文件，那它是错误的。 mod添加方式 mod的添加方式有两种，这里直接推荐第二种： 复制客户端mod到服务端，客户端的mod位置有两个位置，稍后会说明。 在文件中使用ServerModSetup(&quot;&quot;)或者ServerModCollectionSetup(&quot;&quot;)，服务器启动时会自动下载和更新。 在操作开始前，我们先来了解以下mod配置文件 存档的mod配置文件中会有这个存档所需的mod代码ID，我们到存档文件中找到这个文件:modoverrides.lua 打开它，我们就能看到所有的mod配置信息 手动复制modmod的位置一共有两个: 饥荒客户端根目录的mods文件夹，可以注意到这里的mod有workshop-的前缀 点击查看示例 另一个需要从Steam库目录开始找，例如我的：E:\\SteamLibrary\\steamapps\\workshop\\content\\322330 点击查看示例 这两个文件夹中的mod的ID可能有一样的，但只有一个是正确的。辨别方法就是进入mod文件夹，如果里面是空的或者只有一个文件，那它是错误的。 好了，到这里我们就可以复制到服务器根目录的mods中了，但这里也有两种方式 全部复制，这会将客户端mod和服务器mod无差别的复制过去。 只复制自己存档开启的，可对照mod配置文件中的ID，一个一个的复制过去 但无论哪种方式，我们都需要在ID前加上workshop-前缀，例如：workshop-2831613121，已有的不用加。 点击查看示例 ServerModSetup(“”)首先来到饥荒服务器的根目录的mods文件夹中，打开dedicated_server_mods_setup.lua文件，在文件末尾加入 ServerModSetup(&quot;1185229307&quot;)ServerModSetup(&quot;1207269058&quot;)ServerModSetup(&quot;1216718131&quot;) 或者 ServerModCollectionSetup(&quot;1185229307&quot;)ServerModCollectionSetup(&quot;1207269058&quot;)ServerModCollectionSetup(&quot;1216718131&quot;) 区别在于ServerModSetup是下载单个mod的，ServerModCollectionSetup是下载合集mod的。 引号中的数字ID在存档的mod配置文件modoverrides.lua，属于按需引入。 点击查看示例 left ServerModSetup right ServerModCollectionSetup mod更新问题 如果使用的是手动复制方式，你需要在客户端把mod更新完后，再将更新后的mod复制到饥荒服务器的mods中，重复手动复制mod过程 如果采用的是第二种方式，只需要关闭服务器，然后再次启动即可。 mod消失问题"},{"title":"网络卡顿问题","path":"/wiki/server/DSTServer/question/network.html","content":"如果是云服务搭建则没有网络问题，主要针对本地服务搭建 内网穿透解决 参考链接： 【饥荒联机】联机卡顿？详解如何不买云服务器，低成本的享受流畅的饥荒联机体验——本地服务器搭建+内网穿透_单机游戏热门视频https://www.bilibili.com/video/BV1PR4y197SC/ 异地组网解决 配置太高😂"},{"title":"项目打包","path":"/wiki/adminpro/03_advanced_operation/08_build.html","content":"前面的流程完成后就可以开发项目了，项目开发完成后需要使用npm run build命令打包，为了正常运行需要稍做修改。 修改Build配置找到package.json文件，修改build命令 package.json&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build &amp;&amp; esno ./build/scripts/postBuild.js&quot;, &quot;preview&quot;: &quot;vite preview&quot;&#125;, 创建build/script/postBuild.js文件，内容如下： build/script/postBuild.js// #!/usr/bin/env nodeimport &#123; runBuildConfig &#125; from &#x27;./buildConf&#x27;;import chalk from &#x27;chalk&#x27;;import pkg from &#x27;../../package.json&#x27;;export const runBuild = async () =&gt; &#123; try &#123; const argvList = process.argv.splice(2); // Generate configuration file if (!argvList.includes(&#x27;disabled-config&#x27;)) &#123; await runBuildConfig(); &#125; console.log(`✨ $&#123;chalk.cyan(`[$&#123;pkg.name&#125;]`)&#125;` + &#x27; - build successfully!&#x27;); &#125; catch (error) &#123; console.log(chalk.red(&#x27;vite build error: &#x27; + error)); process.exit(1); &#125;&#125;;runBuild(); 创建build/script/buildConf.js文件，内容如下： build/script/buildConf.js/** * Generate additional configuration files when used for packaging. The file can be configured with some global variables, so that it can be changed directly externally without repackaging */import &#123; GLOB_CONFIG_FILE_NAME, OUTPUT_DIR &#125; from &#x27;../constant&#x27;;// import &#123; writeFileSync &#125; from &#x27;fs-extra&#x27;;import fs from &#x27;fs-extra&#x27;;import &#123; createRequire &#125; from &#x27;module&#x27;;const require = createRequire(import.meta.url);const fsa = require(&#x27;fs&#x27;);import chalk from &#x27;chalk&#x27;;import &#123; getRootPath, getEnvConfig &#125; from &#x27;../utils&#x27;;import &#123; getConfigFileName &#125; from &#x27;../getConfigFileName&#x27;;import pkg from &#x27;../../package.json&#x27;;function createConfig( &#123; configName, config, configFileName = GLOB_CONFIG_FILE_NAME, &#125; = &#123; configName: &#x27;&#x27;, config: &#123;&#125; &#125;) &#123; try &#123; const windowConf = `window.$&#123;configName&#125;`; // Ensure that the variable will not be modified const configStr = `$&#123;windowConf&#125;=$&#123;JSON.stringify(config)&#125;; Object.freeze($&#123;windowConf&#125;); Object.defineProperty(window, &quot;$&#123;configName&#125;&quot;, &#123; configurable: false, writable: false, &#125;); `.replace(/\\s/g, &#x27;&#x27;); fs.mkdirp(getRootPath(OUTPUT_DIR)); fsa.writeFileSync(getRootPath(`$&#123;OUTPUT_DIR&#125;/$&#123;configFileName&#125;`), configStr); console.log(chalk.cyan(`✨ [$&#123;pkg.name&#125;]`) + ` - configuration file is build successfully:`); console.log(chalk.gray(OUTPUT_DIR + &#x27;/&#x27; + chalk.green(configFileName)) + &#x27; &#x27;); &#125; catch (error) &#123; console.log(chalk.red(&#x27;configuration file configuration file failed to package: &#x27; + error)); &#125;&#125;export function runBuildConfig() &#123; const config = getEnvConfig(); const configFileName = getConfigFileName(config); createConfig(&#123; config, configName: configFileName &#125;);&#125; 创建build/constant.js文件，内容如下： build/constant.js/** * The name of the configuration file entered in the production environment */export const GLOB_CONFIG_FILE_NAME = &#x27;app.config.js&#x27;;export const OUTPUT_DIR = &#x27;dist&#x27;; 创建build/vite/plugin/compress.js文件，内容如下： build/vite/plugin/compress.js/** * Used to package and output gzip. Note that this does not work properly in Vite, the specific reason is still being investigated * https://github.com/anncwb/vite-plugin-compression */import compressPlugin from &#x27;vite-plugin-compression&#x27;;export function configCompressPlugin( compress, deleteOriginFile = false) &#123; const compressList = compress.split(&#x27;,&#x27;); const plugins = []; if (compressList.includes(&#x27;gzip&#x27;)) &#123; plugins.push( compressPlugin(&#123; ext: &#x27;.gz&#x27;, deleteOriginFile, &#125;) ); &#125; if (compressList.includes(&#x27;brotli&#x27;)) &#123; plugins.push( compressPlugin(&#123; ext: &#x27;.br&#x27;, algorithm: &#x27;brotliCompress&#x27;, deleteOriginFile, &#125;) ); &#125; return plugins;&#125; 创建build/vite/plugin/html.js文件，内容如下： build/vite/plugin/html.js/** * Plugin to minimize and use ejs template syntax in index.html. * https://github.com/anncwb/vite-plugin-html */import &#123; createHtmlPlugin &#125; from &#x27;vite-plugin-html&#x27;;import pkg from &#x27;../../../package.json&#x27;;import &#123; GLOB_CONFIG_FILE_NAME &#125; from &#x27;../../constant&#x27;;export function configHtmlPlugin(env, isBuild) &#123; const &#123; VITE_GLOB_APP_TITLE, VITE_PUBLIC_PATH &#125; = env; const path = VITE_PUBLIC_PATH.endsWith(&#x27;/&#x27;) ? VITE_PUBLIC_PATH : `$&#123;VITE_PUBLIC_PATH&#125;/`; const getAppConfigSrc = () =&gt; &#123; return `$&#123;path || &#x27;/&#x27;&#125;$&#123;GLOB_CONFIG_FILE_NAME&#125;?v=$&#123;pkg.version&#125;-$&#123;new Date().getTime()&#125;`; &#125;; const htmlPlugin = createHtmlPlugin(&#123; minify: isBuild, inject: &#123; // Inject data into ejs template data: &#123; title: VITE_GLOB_APP_TITLE, &#125;, // Embed the generated app.config.js file tags: isBuild ? [ &#123; tag: &#x27;script&#x27;, attrs: &#123; src: getAppConfigSrc(), &#125;, &#125;, ] : [], &#125;, &#125;); return htmlPlugin;&#125; 创建build/vite/plugin/mock.js文件，内容如下： build/vite/plugin/mock.js/** * Mock plugin for development and production. * https://github.com/anncwb/vite-plugin-mock */ import &#123; viteMockServe &#125; from &#x27;vite-plugin-mock&#x27;;export function configMockPlugin(isBuild, prodMock) &#123; return viteMockServe(&#123; ignore: /^\\_/, mockPath: &#x27;mock&#x27;, localEnabled: !isBuild, prodEnabled: isBuild &amp;&amp; prodMock, injectCode: ` import &#123; setupProdMockServer &#125; from &#x27;../mock/_createProductionServer&#x27;; setupProdMockServer(); `, &#125;);&#125; 创建build/vite/plugin/index.js文件，内容如下： build/vite/plugin/index.jsimport Components from &#x27;unplugin-vue-components/vite&#x27;;import &#123; NaiveUiResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;import vueJsx from &#x27;@vitejs/plugin-vue-jsx&#x27;;import &#123; configHtmlPlugin &#125; from &#x27;./html&#x27;;import &#123; configMockPlugin &#125; from &#x27;./mock&#x27;;import &#123; configCompressPlugin &#125; from &#x27;./compress&#x27;;export function createVitePlugins(viteEnv, isBuild, prodMock) &#123; const &#123; VITE_USE_MOCK, VITE_BUILD_COMPRESS, VITE_BUILD_COMPRESS_DELETE_ORIGIN_FILE &#125; = viteEnv; const vitePlugins = [ // have to vue(), // have to vueJsx(), // 按需引入NaiveUi且自动创建组件声明 Components(&#123; dts: true, resolvers: [NaiveUiResolver()], &#125;), ]; // vite-plugin-html vitePlugins.push(configHtmlPlugin(viteEnv, isBuild)); // vite-plugin-mock VITE_USE_MOCK &amp;&amp; vitePlugins.push(configMockPlugin(isBuild, prodMock)); if (isBuild) &#123; // rollup-plugin-gzip vitePlugins.push( configCompressPlugin(VITE_BUILD_COMPRESS, VITE_BUILD_COMPRESS_DELETE_ORIGIN_FILE) ); &#125; return vitePlugins;&#125; 修改Vite配置找到vite.config.js文件，修改如下： vite.config.jsimport &#123; loadEnv &#125; from &#x27;vite&#x27;import &#123; resolve &#125; from &#x27;path&#x27;import &#123; wrapperEnv &#125; from &#x27;./build/utils&#x27;import &#123; createProxy &#125; from &#x27;./build/vite/proxy&#x27;import &#123; createVitePlugins &#125; from &#x27;./build/vite/plugin&#x27;function pathResolve(dir) &#123; return resolve(process.cwd(), &#x27;.&#x27;, dir)&#125;export default (&#123; command, mode &#125;) =&gt; &#123; const root = process.cwd(); const env = loadEnv(mode, root); const viteEnv = wrapperEnv(env); const &#123; VITE_PUBLIC_PATH, VITE_PORT, VITE_PROXY, VITE_GLOB_PROD_MOCK &#125; = viteEnv; const prodMock = VITE_GLOB_PROD_MOCK; const isBuild = command === &#x27;build&#x27;; return &#123; base: VITE_PUBLIC_PATH, resolve: &#123; alias: [ &#123; find: /\\/#\\//, replacement: pathResolve(&#x27;types&#x27;) + &#x27;/&#x27;, &#125;, &#123; find: &#x27;@&#x27;, replacement: pathResolve(&#x27;src&#x27;) + &#x27;/&#x27;, &#125;, ], dedupe: [&#x27;vue&#x27;], &#125;, plugins: createVitePlugins(viteEnv, isBuild, prodMock), server: &#123; host: true, port: VITE_PORT, proxy: createProxy(VITE_PROXY) &#125; &#125;&#125; 修改.env.production，内容如下： .env.production# 网站根目录，Nginx二级目录需要修改此处VITE_PUBLIC_PATH = /# 网站前缀VITE_BASE_URL = /# API 接口地址VITE_GLOB_API_URL =# 是否启用gzip压缩或brotli压缩# 可选: gzip | brotli | none# 如果你需要多种形式，你可以用&#x27;,&#x27;来分隔VITE_BUILD_COMPRESS = &#x27;none&#x27;# 图片上传地址VITE_GLOB_UPLOAD_URL=# 图片前缀地址VITE_GLOB_IMG_URL=# 接口前缀VITE_GLOB_API_URL_PREFIX = /api 安装依赖1、esno sudo npm i -g esno 2、unplugin-vue-components npm i unplugin-vue-components -D 3、@vitejs&#x2F;plugin-vue-jsx npm i @vitejs/plugin-vue-jsx -D 4、vite-plugin-html npm i vite-plugin-html -D 5、vite-plugin-mock npm i vite-plugin-mock -D 6、vite-plugin-compression npm i vite-plugin-compression -D 7、fs-extra npm i fs-extra @types/fs-extra -D 8、chalk npm i chalk -D 构建项目% npm run build&gt; hospital-web-admin@0.0.0 build&gt; vite build &amp;&amp; esno ./build/script/postBuild.jsvite v4.5.0 building for production... 17:32:55 WARN &lt;script src=&quot;/app.config.js?v=0.0.0-1716802375423&quot;&gt; in &quot;/index.html&quot; can&#x27;t be bundled without type=&quot;module&quot; attribute 17:32:55✓ 3458 modules transformed. 17:33:01dist/index.html 0.45 kB │ gzip: 0.31 kB .... WARN 17:33:01(!) Some chunks are larger than 500 kBs after minification. Consider:- Using dynamic import() to code-split the application- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.✓ built in 6.25s 17:33:01✨ [hospital-web-admin] - configuration file is build successfully:dist/app.config.js✨ [hospital-web-admin] - build successfully! 测试serve -d dist 出问题如果你在Windows或者其他环境下出现下图错误： 更换使用 node 命令来执行 js 代码，更改文件如下： 1、修改package.json文件，内容如下： &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build &amp;&amp; node ./build/scripts/postBuild.js&quot;, &quot;preview&quot;: &quot;vite preview&quot;&#125;, 2、修改build/script/postBuild.js文件，内容如下： // #!/usr/bin/env nodeimport &#123; runBuildConfig &#125; from &#x27;./buildConf.js&#x27;;import chalk from &#x27;chalk&#x27;;import pkg from &#x27;../../package.json&#x27; assert &#123; type: &quot;json&quot;&#125;;export const runBuild = async () =&gt; &#123; try &#123; const argvList = process.argv.splice(2); // Generate configuration file if (!argvList.includes(&#x27;disabled-config&#x27;)) &#123; await runBuildConfig(); &#125; console.log(`✨ $&#123;chalk.cyan(`[$&#123;pkg.name&#125;]`)&#125;` + &#x27; - build successfully!&#x27;); &#125; catch (error) &#123; console.log(chalk.red(&#x27;vite build error: &#x27; + error)); process.exit(1); &#125;&#125;;runBuild(); 3、修改build/script/buildConf.js文件，内容如下： /** * Generate additional configuration files when used for packaging. The file can be configured with some global variables, so that it can be changed directly externally without repackaging */import &#123; GLOB_CONFIG_FILE_NAME, OUTPUT_DIR &#125; from &#x27;../constant.js&#x27;;// import &#123; writeFileSync &#125; from &#x27;fs-extra&#x27;;import fs from &#x27;fs-extra&#x27;;import &#123; createRequire &#125; from &#x27;module&#x27;;const require = createRequire(import.meta.url);const fsa = require(&#x27;fs&#x27;);import chalk from &#x27;chalk&#x27;;import &#123; getRootPath, getEnvConfig &#125; from &#x27;../utils.js&#x27;;import &#123; getConfigFileName &#125; from &#x27;../getConfigFileName.js&#x27;;import pkg from &#x27;../../package.json&#x27; assert &#123; type: &quot;json&quot; &#125;;function createConfig( &#123; configName, config, configFileName = GLOB_CONFIG_FILE_NAME, &#125; = &#123; configName: &#x27;&#x27;, config: &#123;&#125; &#125;) &#123; try &#123; const windowConf = `window.$&#123;configName&#125;`; // Ensure that the variable will not be modified const configStr = `$&#123;windowConf&#125;=$&#123;JSON.stringify(config)&#125;; Object.freeze($&#123;windowConf&#125;); Object.defineProperty(window, &quot;$&#123;configName&#125;&quot;, &#123; configurable: false, writable: false, &#125;); `.replace(/\\s/g, &#x27;&#x27;); fs.mkdirp(getRootPath(OUTPUT_DIR)); fsa.writeFileSync(getRootPath(`$&#123;OUTPUT_DIR&#125;/$&#123;configFileName&#125;`), configStr); console.log(chalk.cyan(`✨ [$&#123;pkg.name&#125;]`) + ` - configuration file is build successfully:`); console.log(chalk.gray(OUTPUT_DIR + &#x27;/&#x27; + chalk.green(configFileName)) + &#x27; &#x27;); &#125; catch (error) &#123; console.log(chalk.red(&#x27;configuration file configuration file failed to package: &#x27; + error)); &#125;&#125;export function runBuildConfig() &#123; const config = getEnvConfig(); const configFileName = getConfigFileName(config); createConfig(&#123; config, configName: configFileName &#125;);&#125; 4、执行npm run build命令重新打包，或者单独执行下面命令生成app.config.js node ./build/scripts/postBuild.js"},{"title":"数据库","path":"/wiki/trip-cloud/05_user/user-mysql.html","content":"创建数据库trip-user，并创建表userinfo CREATE TABLE `userinfo` ( `id` bigint NOT NULL AUTO_INCREMENT, `nickname` varchar(255) DEFAULT NULL, `phone` varchar(255) DEFAULT NULL, `email` varchar(255) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `gender` int DEFAULT NULL, `level` int DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `head_img_url` varchar(255) DEFAULT NULL, `info` varchar(255) DEFAULT NULL, `state` int DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE, UNIQUE KEY `phone` (`phone`,`state`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;"},{"title":"创建项目","path":"/wiki/ebook/init/create.html","content":"创建项目使用下面命令创建一个flutter项目 flutter create e_book_clone 组件抽取抽取文件home.dart 创建 lib/pages/home 文件夹 抽取home.dart文件 home/main.dartimport &#x27;package:flutter/material.dart&#x27;;class HomePage extends StatefulWidget &#123; const HomePage(&#123;super.key&#125;); @override State&lt;HomePage&gt; createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( elevation: 0, toolbarHeight: 0, backgroundColor: Theme.of(context).colorScheme.surface, ), body: const Center(child: Text(&#x27;Home&#x27;)), ); &#125;&#125; 抽取文件app.dart app.dartimport &#x27;package:e_book_clone/pges/home/home.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;class MyApp extends StatelessWidget &#123; const MyApp(&#123;super.key&#125;); @override Widget build(BuildContext context) &#123; return MaterialApp( theme: ThemeData( useMaterial3: true, ), home: const HomePage(), ); &#125;&#125; 抽取文件main.dart main.dartimport &#x27;package:e_book_clone/app.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;void main() &#123; runApp(const MyAPP());&#125;"},{"title":"持续更新中","path":"/wiki/ebook/widget/continue.html","content":"项目中还有很多东西可以整理，等我…"},{"title":"底部导航栏全局跳转","path":"/wiki/ebook/widget/global_bottomnav.html","content":"想要在任意页面跳转到指定的底部导航栏，需要用到Provider。 将下标存放到 Provider 中， 将page 和 BottomNavigationBar的 index 绑定Provider.of(context).currentIndex， 在onTap(index)方法中使用Provider.of(context).currentIndex = index实现点击底部导航栏切换。 在其他页面使用Provider.of(context).currentIndex = 1，跳转到指定页面。 需要的插件如下： flutter pub add provider BottomNavigationBarProvider bottom_nav_provider.dartimport &#x27;package:flutter/material.dart&#x27;;class BottomNavProvider with ChangeNotifier &#123; int _currentIndex = 0; int get currentIndex =&gt; _currentIndex; set currentIndex(int currentIndex) &#123; _currentIndex = currentIndex; notifyListeners(); &#125; void setIndex(int index) &#123; currentIndex = index; &#125;&#125; 在main.dart中添加providers main.dartimport &#x27;package:e_book_clone/app.dart&#x27;;import &#x27;package:e_book_clone/pages/bottom_nav_provider.dart&#x27;;import &#x27;package:e_book_clone/theme/theme_provider.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:provider/provider.dart&#x27;;void main() &#123; runApp( MultiProvider(providers: [ // 主题 ChangeNotifierProvider(create: (context) =&gt; ThemeProvider()), // BottomNavigationBar ChangeNotifierProvider(create: (context) =&gt; BottomNavProvider()), ], child: const MyAPP()), );&#125; RootPage import &#x27;package:e_book_clone/json/root_app_json.dart&#x27;;import &#x27;package:e_book_clone/pages/douban_read/douban_read_page.dart&#x27;;import &#x27;package:e_book_clone/pages/home/home_page.dart&#x27;;import &#x27;package:e_book_clone/pages/my_book/my_book_page.dart&#x27;;import &#x27;package:e_book_clone/pages/ebook_store/store_page.dart&#x27;;import &#x27;package:e_book_clone/pages/bottom_nav_provider.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_lazy_indexed_stack/flutter_lazy_indexed_stack.dart&#x27;;import &#x27;package:provider/provider.dart&#x27;;import &#x27;package:salomon_bottom_bar/salomon_bottom_bar.dart&#x27;;class RootPage extends StatelessWidget &#123; const RootPage(&#123;super.key&#125;); @override Widget build(BuildContext context) &#123; var bg = Theme.of(context).colorScheme.surface; return Scaffold( appBar: AppBar( elevation: 0, toolbarHeight: 0, backgroundColor: bg, surfaceTintColor: bg), backgroundColor: bg, bottomNavigationBar: _getBottomNavigator(context), body: LazyIndexedStack( index: Provider.of&lt;BottomNavProvider&gt;(context).currentIndex, children: const [ HomePage(), DoubanReadPage(), StorePage(), MyBookPage(), ], ), ); &#125; Widget _getBottomNavigator(BuildContext context) &#123; return SalomonBottomBar( currentIndex: Provider.of&lt;BottomNavProvider&gt;(context).currentIndex, onTap: (index) &#123; // setState(() &#123; // pageIndex = index; // &#125;); Provider.of&lt;BottomNavProvider&gt;(context, listen: false).currentIndex = index; &#125;, items: List.generate( rootAppJson.length, (index) &#123; return SalomonBottomBarItem( selectedColor: Theme.of(context).colorScheme.onSurface, unselectedColor: Theme.of(context).colorScheme.inversePrimary, icon: Icon(rootAppJson[index][&#x27;icon&#x27;]), title: Text(rootAppJson[index][&#x27;text&#x27;]), ); &#125;, ), ); &#125;&#125;"},{"title":"项目概述","path":"/wiki/ebook/index.html","content":"介绍 EBook - 电子书城是一个集成豆瓣读书和豆瓣阅读商城和电子书阅读器的Flutter构建的手机APP。你可以在商城中浏览书籍，查看书籍评分、字数、价格、书评等相关信息。登录豆瓣阅读之后，你可以将电子书加入书架，查看书架、阅读电子书等操作。总之，你的豆瓣阅读不一定是豆瓣阅读，也可能是电子书城。 数据来源： 豆瓣读书 豆瓣阅读 — 出版 Android体验地址 https://www.lanzouw.com/tp/ihZRf22at3na 项目预览 页面展示"},{"title":"搜索界面","path":"/wiki/ebook/widget/search_page.html","content":"搜索界面使用Flutter自带的SearchDelegate组件实现，通过魔改实现如下效果： 搜素建议 搜索结果，支持刷新和加载更多 IOS中文输入拼音问题 界面预览 拷贝源码将SearchDelegate的源码拷贝一份，修改内容如下： import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter/services.dart&#x27;;/// 修改此处为 showMySearchFuture&lt;T?&gt; showMySearch&lt;T&gt;(&#123; required BuildContext context, required MySearchDelegate&lt;T&gt; delegate, String? query = &#x27;&#x27;, bool useRootNavigator = false,&#125;) &#123; delegate.query = query ?? delegate.query; delegate._currentBody = _SearchBody.suggestions; return Navigator.of(context, rootNavigator: useRootNavigator) .push(_SearchPageRoute&lt;T&gt;( delegate: delegate, ));&#125;/// https://juejin.cn/post/7090374603951833118abstract class MySearchDelegate&lt;T&gt; &#123; MySearchDelegate(&#123; this.searchFieldLabel, this.searchFieldStyle, this.searchFieldDecorationTheme, this.keyboardType, this.textInputAction = TextInputAction.search, &#125;) : assert(searchFieldStyle == null || searchFieldDecorationTheme == null); Widget buildSuggestions(BuildContext context); Widget buildResults(BuildContext context); Widget? buildLeading(BuildContext context); bool? automaticallyImplyLeading; double? leadingWidth; List&lt;Widget&gt;? buildActions(BuildContext context); PreferredSizeWidget? buildBottom(BuildContext context) =&gt; null; Widget? buildFlexibleSpace(BuildContext context) =&gt; null; ThemeData appBarTheme(BuildContext context) &#123; final ThemeData theme = Theme.of(context); final ColorScheme colorScheme = theme.colorScheme; return theme.copyWith( appBarTheme: AppBarTheme( systemOverlayStyle: colorScheme.brightness == Brightness.dark ? SystemUiOverlayStyle.light : SystemUiOverlayStyle.dark, backgroundColor: colorScheme.brightness == Brightness.dark ? Colors.grey[900] : Colors.white, iconTheme: theme.primaryIconTheme.copyWith(color: Colors.grey), titleTextStyle: theme.textTheme.titleLarge, toolbarTextStyle: theme.textTheme.bodyMedium, ), inputDecorationTheme: searchFieldDecorationTheme ?? InputDecorationTheme( hintStyle: searchFieldStyle ?? theme.inputDecorationTheme.hintStyle, border: InputBorder.none, ), ); &#125; String get query =&gt; _queryTextController.completeText; set query(String value) &#123; _queryTextController.completeText = value; // 更新实际搜索内容 _queryTextController.text = value; // 更新输入框内容 if (_queryTextController.text.isNotEmpty) &#123; _queryTextController.selection = TextSelection.fromPosition( TextPosition(offset: _queryTextController.text.length)); &#125; &#125; void showResults(BuildContext context) &#123; _focusNode?.unfocus(); _currentBody = _SearchBody.results; &#125; void showSuggestions(BuildContext context) &#123; assert(_focusNode != null, &#x27;_focusNode must be set by route before showSuggestions is called.&#x27;); _focusNode!.requestFocus(); _currentBody = _SearchBody.suggestions; &#125; void close(BuildContext context, T result) &#123; _currentBody = null; _focusNode?.unfocus(); Navigator.of(context) ..popUntil((Route&lt;dynamic&gt; route) =&gt; route == _route) ..pop(result); &#125; final String? searchFieldLabel; final TextStyle? searchFieldStyle; final InputDecorationTheme? searchFieldDecorationTheme; final TextInputType? keyboardType; final TextInputAction textInputAction; Animation&lt;double&gt; get transitionAnimation =&gt; _proxyAnimation; FocusNode? _focusNode; final ChinaTextEditController _queryTextController = ChinaTextEditController(); final ProxyAnimation _proxyAnimation = ProxyAnimation(kAlwaysDismissedAnimation); final ValueNotifier&lt;_SearchBody?&gt; _currentBodyNotifier = ValueNotifier&lt;_SearchBody?&gt;(null); _SearchBody? get _currentBody =&gt; _currentBodyNotifier.value; set _currentBody(_SearchBody? value) &#123; _currentBodyNotifier.value = value; &#125; _SearchPageRoute&lt;T&gt;? _route; /// Releases the resources. @mustCallSuper void dispose() &#123; _currentBodyNotifier.dispose(); _focusNode?.dispose(); _queryTextController.dispose(); _proxyAnimation.parent = null; &#125;&#125;/// search page.enum _SearchBody &#123; suggestions, results,&#125;class _SearchPageRoute&lt;T&gt; extends PageRoute&lt;T&gt; &#123; _SearchPageRoute(&#123; required this.delegate, &#125;) &#123; assert( delegate._route == null, &#x27;The $&#123;delegate.runtimeType&#125; instance is currently used by another active &#x27; &#x27;search. Please close that search by calling close() on the MySearchDelegate &#x27; &#x27;before opening another search with the same delegate instance.&#x27;, ); delegate._route = this; &#125; final MySearchDelegate&lt;T&gt; delegate; @override Color? get barrierColor =&gt; null; @override String? get barrierLabel =&gt; null; @override Duration get transitionDuration =&gt; const Duration(milliseconds: 300); @override bool get maintainState =&gt; false; @override Widget buildTransitions( BuildContext context, Animation&lt;double&gt; animation, Animation&lt;double&gt; secondaryAnimation, Widget child, ) &#123; return FadeTransition( opacity: animation, child: child, ); &#125; @override Animation&lt;double&gt; createAnimation() &#123; final Animation&lt;double&gt; animation = super.createAnimation(); delegate._proxyAnimation.parent = animation; return animation; &#125; @override Widget buildPage( BuildContext context, Animation&lt;double&gt; animation, Animation&lt;double&gt; secondaryAnimation, ) &#123; return _SearchPage&lt;T&gt;( delegate: delegate, animation: animation, ); &#125; @override void didComplete(T? result) &#123; super.didComplete(result); assert(delegate._route == this); delegate._route = null; delegate._currentBody = null; &#125;&#125;class _SearchPage&lt;T&gt; extends StatefulWidget &#123; const _SearchPage(&#123; required this.delegate, required this.animation, &#125;); final MySearchDelegate&lt;T&gt; delegate; final Animation&lt;double&gt; animation; @override State&lt;StatefulWidget&gt; createState() =&gt; _SearchPageState&lt;T&gt;();&#125;class _SearchPageState&lt;T&gt; extends State&lt;_SearchPage&lt;T&gt;&gt; &#123; // This node is owned, but not hosted by, the search page. Hosting is done by // the text field. FocusNode focusNode = FocusNode(); @override void initState() &#123; super.initState(); widget.delegate._queryTextController.addListener(_onQueryChanged); widget.animation.addStatusListener(_onAnimationStatusChanged); widget.delegate._currentBodyNotifier.addListener(_onSearchBodyChanged); focusNode.addListener(_onFocusChanged); widget.delegate._focusNode = focusNode; &#125; @override void dispose() &#123; super.dispose(); widget.delegate._queryTextController.removeListener(_onQueryChanged); widget.animation.removeStatusListener(_onAnimationStatusChanged); widget.delegate._currentBodyNotifier.removeListener(_onSearchBodyChanged); widget.delegate._focusNode = null; focusNode.dispose(); &#125; void _onAnimationStatusChanged(AnimationStatus status) &#123; if (status != AnimationStatus.completed) &#123; return; &#125; widget.animation.removeStatusListener(_onAnimationStatusChanged); if (widget.delegate._currentBody == _SearchBody.suggestions) &#123; focusNode.requestFocus(); &#125; &#125; @override void didUpdateWidget(_SearchPage&lt;T&gt; oldWidget) &#123; super.didUpdateWidget(oldWidget); if (widget.delegate != oldWidget.delegate) &#123; oldWidget.delegate._queryTextController.removeListener(_onQueryChanged); widget.delegate._queryTextController.addListener(_onQueryChanged); oldWidget.delegate._currentBodyNotifier .removeListener(_onSearchBodyChanged); widget.delegate._currentBodyNotifier.addListener(_onSearchBodyChanged); oldWidget.delegate._focusNode = null; widget.delegate._focusNode = focusNode; &#125; &#125; void _onFocusChanged() &#123; if (focusNode.hasFocus &amp;&amp; widget.delegate._currentBody != _SearchBody.suggestions) &#123; widget.delegate.showSuggestions(context); &#125; &#125; void _onQueryChanged() &#123; setState(() &#123; // rebuild ourselves because query changed. &#125;); &#125; void _onSearchBodyChanged() &#123; setState(() &#123; // rebuild ourselves because search body changed. &#125;); &#125; @override Widget build(BuildContext context) &#123; assert(debugCheckHasMaterialLocalizations(context)); final ThemeData theme = widget.delegate.appBarTheme(context); final String searchFieldLabel = widget.delegate.searchFieldLabel ?? MaterialLocalizations.of(context).searchFieldLabel; Widget? body; switch (widget.delegate._currentBody) &#123; case _SearchBody.suggestions: body = KeyedSubtree( key: const ValueKey&lt;_SearchBody&gt;(_SearchBody.suggestions), child: widget.delegate.buildSuggestions(context), ); case _SearchBody.results: body = KeyedSubtree( key: const ValueKey&lt;_SearchBody&gt;(_SearchBody.results), child: widget.delegate.buildResults(context), ); case null: break; &#125; late final String routeName; switch (theme.platform) &#123; case TargetPlatform.iOS: case TargetPlatform.macOS: routeName = &#x27;&#x27;; case TargetPlatform.android: case TargetPlatform.fuchsia: case TargetPlatform.linux: case TargetPlatform.windows: routeName = searchFieldLabel; &#125; return Semantics( explicitChildNodes: true, scopesRoute: true, namesRoute: true, label: routeName, child: Theme( data: theme, child: Scaffold( appBar: AppBar( leadingWidth: widget.delegate.leadingWidth, automaticallyImplyLeading: widget.delegate.automaticallyImplyLeading ?? true, leading: widget.delegate.buildLeading(context), title: TextField( controller: widget.delegate._queryTextController, focusNode: focusNode, style: widget.delegate.searchFieldStyle ?? theme.textTheme.titleLarge, textInputAction: widget.delegate.textInputAction, keyboardType: widget.delegate.keyboardType, onSubmitted: (String _) =&gt; widget.delegate.showResults(context), decoration: InputDecoration(hintText: searchFieldLabel), ), flexibleSpace: widget.delegate.buildFlexibleSpace(context), actions: widget.delegate.buildActions(context), bottom: widget.delegate.buildBottom(context), ), body: AnimatedSwitcher( duration: const Duration(milliseconds: 300), child: body, ), ), ), ); &#125;&#125;class ChinaTextEditController extends TextEditingController &#123; ///拼音输入完成后的文字 var completeText = &#x27;&#x27;; @override TextSpan buildTextSpan( &#123;required BuildContext context, TextStyle? style, required bool withComposing&#125;) &#123; ///拼音输入完成 if (!value.composing.isValid || !withComposing) &#123; if (completeText != value.text) &#123; completeText = value.text; WidgetsBinding.instance.addPostFrameCallback((_) &#123; notifyListeners(); &#125;); &#125; return TextSpan(style: style, text: text); &#125; ///返回输入样式，可自定义样式 final TextStyle composingStyle = style?.merge( const TextStyle(decoration: TextDecoration.underline), ) ?? const TextStyle(decoration: TextDecoration.underline); return TextSpan(style: style, children: &lt;TextSpan&gt;[ TextSpan(text: value.composing.textBefore(value.text)), TextSpan( style: composingStyle, text: value.composing.isValid &amp;&amp; !value.composing.isCollapsed ? value.composing.textInside(value.text) : &quot;&quot;, ), TextSpan(text: value.composing.textAfter(value.text)), ]); &#125;&#125; 实现搜索创建SearchPage继承MySearchDelegate，修改样式，实现页面。需要重写下面5个方法 appBarTheme：修改搜索样式 buildActions：搜索框右侧的方法 buildLeading：搜索框左侧的返回按钮 buildResults：搜索结果 buildSuggestions：搜索建议 import &#x27;package:e_book_clone/pages/search/MySearchDelegate.dart&#x27;;import &#x27;package:flutter/src/material/theme_data.dart&#x27;;import &#x27;package:flutter/src/widgets/framework.dart&#x27;;class Demo extends MySearchDelegate &#123; @override ThemeData appBarTheme(BuildContext context) &#123; // TODO: implement appBarTheme return super.appBarTheme(context); &#125; @override List&lt;Widget&gt;? buildActions(BuildContext context) &#123; // TODO: implement buildActions throw UnimplementedError(); &#125; @override Widget? buildLeading(BuildContext context) &#123; // TODO: implement buildLeading throw UnimplementedError(); &#125; @override Widget buildResults(BuildContext context) &#123; // TODO: implement buildResults throw UnimplementedError(); &#125; @override Widget buildSuggestions(BuildContext context) &#123; // TODO: implement buildSuggestions throw UnimplementedError(); &#125;&#125; 修改样式 search_page.dart@overrideThemeData appBarTheme(BuildContext context) &#123; final ThemeData theme = Theme.of(context); final ColorScheme colorScheme = theme.colorScheme; return theme.copyWith( // 使用copyWith，适配全局主题 appBarTheme: AppBarTheme( // AppBar样式修改 systemOverlayStyle: colorScheme.brightness == Brightness.dark ? SystemUiOverlayStyle.light : SystemUiOverlayStyle.dark, surfaceTintColor: Theme.of(context).colorScheme.surface, titleSpacing: 0, // textfield前面的间距 elevation: 0, // 阴影 ), inputDecorationTheme: InputDecorationTheme( isCollapsed: true, hintStyle: TextStyle( // 提示文字颜色 color: Theme.of(ToastUtils.context).colorScheme.inversePrimary), filled: true, // 填充颜色 contentPadding: EdgeInsets.symmetric(vertical: 10.h, horizontal: 15.w), fillColor: Theme.of(context).colorScheme.secondary, // 填充颜色，需要配合 filled enabledBorder: OutlineInputBorder( // testified 边框 borderRadius: BorderRadius.circular(12.r), borderSide: BorderSide( color: Theme.of(context).colorScheme.surface, ), ), focusedBorder: OutlineInputBorder( // testified 边框 borderRadius: BorderRadius.circular(12.r), borderSide: BorderSide( color: Theme.of(context).colorScheme.surface, ), ), ), );&#125;@overrideTextStyle? get searchFieldStyle =&gt; TextStyle(fontSize: 14.sp); // 字体大小设置，主要是覆盖默认样式 按钮功能左侧返回按钮，右侧就放了一个搜索文本，点击之后显示搜索结果 search_page.dart@overrideWidget? buildLeading(BuildContext context) &#123; return IconButton( onPressed: () &#123; close(context, null); &#125;, icon: Icon( color: Theme.of(context).colorScheme.onSurface, Icons.arrow_back_ios_new, size: 20.r, ), );&#125;@overrideList&lt;Widget&gt;? buildActions(BuildContext context) &#123; return [ Padding( padding: EdgeInsets.only(right: 15.w, left: 15.w), child: GestureDetector( onTap: () &#123; showResults(context); &#125;, child: Text( &#x27;搜索&#x27;, style: TextStyle( color: Theme.of(context).colorScheme.primary, fontSize: 15.sp), ), ), ) ];&#125; 搜索建议当 TextField 输入变化时，就会调用buildSuggestions方法，刷新布局，因此考虑使用FlutterBuilder管理页面和数据。 final SearchViewModel _viewModel = SearchViewModel();@overrideWidget buildSuggestions(BuildContext context) &#123; if (query.isEmpty) &#123; // 这里可以展示热门搜索等，有搜索建议时，热门搜索会被替换成搜索建议 return const SizedBox(); &#125; return FutureBuilder( future: _viewModel.getSuggest(query), builder: (BuildContext context, AsyncSnapshot&lt;List&lt;Suggest&gt;&gt; snapshot) &#123; if (snapshot.connectionState == ConnectionState.waiting) &#123; // 数据加载中 return const Center(child: CircularProgressIndicator()); &#125; else if (snapshot.hasError) &#123; // 数据加载错误 return Center(child: Text(&#x27;Error: $&#123;snapshot.error&#125;&#x27;)); &#125; else if (snapshot.hasData) &#123; // 数据加载成功，展示结果 final List&lt;Suggest&gt; searchResults = snapshot.data ?? []; return ListView.builder( padding: EdgeInsets.all(15.r), itemCount: searchResults.length, itemBuilder: (context, index) &#123; return GestureDetector( onTap: () &#123; // 更新输入框 query = searchResults[index].text ?? query; showResults(context); &#125;, child: Container( padding: EdgeInsets.symmetric(vertical: 10.h), decoration: BoxDecoration( border: BorderDirectional( bottom: BorderSide( width: 0.6, color: Theme.of(context).colorScheme.surfaceContainer, ), ), ), child: Text(&#x27;$&#123;searchResults[index].text&#125;&#x27;), ), ); &#125;); &#125; else &#123; // 数据为空 return const Center(child: Text(&#x27;No results found&#x27;)); &#125; &#125;, );&#125; 实体类代码如下： suggest.dartclass Suggest &#123; Suggest(&#123; this.id, this.url, this.text, this.isHot, this.hotLevel, &#125;); Suggest.fromJson(dynamic json) &#123; id = json[&#x27;id&#x27;]; url = json[&#x27;url&#x27;]; text = json[&#x27;text&#x27;]; isHot = json[&#x27;is_hot&#x27;]; hotLevel = json[&#x27;hot_level&#x27;]; &#125; String? id; String? url; String? text; bool? isHot; int? hotLevel;&#125; ViewModel代码如下： search_vm.dartclass SearchViewModel &#123; Future&lt;List&lt;Suggest&gt;&gt; getSuggest(String keyword) async &#123; if (keyword.isEmpty) &#123; return []; &#125; return await JsonApi.instance().fetchSuggestV3(keyword); &#125;&#125; 搜索结果我们需要搜索结果页面支持加载更多，这里用到了 SmartRefrsh 组件 flutter pub add pull_to_refresh buildResults方法是通过调用showResults(context);方法刷新页面，因此为了方便数据动态变化，新建search_result_page.dart页面 search_result_page.dartimport &#x27;package:e_book_clone/components/book_tile/book_tile_vertical/my_book_tile_vertical_item.dart&#x27;;import &#x27;package:e_book_clone/components/book_tile/book_tile_vertical/my_book_tile_vertical_item_skeleton.dart&#x27;;import &#x27;package:e_book_clone/components/my_smart_refresh.dart&#x27;;import &#x27;package:e_book_clone/models/book.dart&#x27;;import &#x27;package:e_book_clone/models/types.dart&#x27;;import &#x27;package:e_book_clone/pages/search/search_vm.dart&#x27;;import &#x27;package:e_book_clone/utils/navigator_utils.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_screenutil/flutter_screenutil.dart&#x27;;import &#x27;package:provider/provider.dart&#x27;;import &#x27;package:pull_to_refresh/pull_to_refresh.dart&#x27;;class SearchResultPage extends StatefulWidget &#123; final String query; // 请求参数 const SearchResultPage(&#123;super.key, required this.query&#125;); @override State&lt;SearchResultPage&gt; createState() =&gt; _SearchResultPageState();&#125;class _SearchResultPageState extends State&lt;SearchResultPage&gt; &#123; final RefreshController _refreshController = RefreshController(); final SearchViewModel _viewModel = SearchViewModel(); void loadOrRefresh(bool loadMore) &#123; _viewModel.getResults(widget.query, loadMore).then((_) &#123; if (loadMore) &#123; _refreshController.loadComplete(); &#125; else &#123; _refreshController.refreshCompleted(); &#125; &#125;); &#125; @override void initState() &#123; super.initState(); loadOrRefresh(false); &#125; @override void dispose() &#123; _viewModel.isDispose = true; _refreshController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return ChangeNotifierProvider&lt;SearchViewModel&gt;.value( value: _viewModel, builder: (context, child) &#123; return Consumer&lt;SearchViewModel&gt;( builder: (context, vm, child) &#123; List&lt;Book&gt;? searchResult = vm.searchResult; // 下拉刷新和上拉加载组件 return MySmartRefresh( enablePullDown: false, onLoading: () &#123; loadOrRefresh(true); &#125;, controller: _refreshController, child: ListView.builder( padding: EdgeInsets.only(left: 15.w, right: 15.w, top: 15.h), itemCount: searchResult?.length ?? 10, itemBuilder: (context, index) &#123; if (searchResult == null) &#123; // 骨架屏 return MyBookTileVerticalItemSkeleton( width: 80.w, height: 120.h); &#125; // 结果渲染组件 return MyBookTileVerticalItem( book: searchResult[index], width: 80.w, height: 120.h, onTap: (id) &#123; NavigatorUtils.nav2Detail( context, DetailPageType.ebook, searchResult[index]); &#125;, ); &#125;, ), ); &#125;, ); &#125;, ); &#125;&#125; MySmartRefresh组件代码如下，主要是对SmartRefresher做了进一步的封装 import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:pull_to_refresh/pull_to_refresh.dart&#x27;;class MySmartRefresh extends StatelessWidget &#123; // 启用下拉 final bool? enablePullDown; // 启用上拉 final bool? enablePullUp; // 头布局 final Widget? header; // 尾布局 final Widget? footer; // 刷新事件 final VoidCallback? onRefresh; // 加载事件 final VoidCallback? onLoading; // 刷新组件控制器 final RefreshController controller; final ScrollController? scrollController; // 被刷新的子组件 final Widget child; const MySmartRefresh(&#123; super.key, this.enablePullDown, this.enablePullUp, this.header, this.footer, this.onLoading, this.onRefresh, required this.controller, required this.child, this.scrollController, &#125;); @override Widget build(BuildContext context) &#123; return _refreshView(); &#125; Widget _refreshView() &#123; return SmartRefresher( scrollController: scrollController, controller: controller, enablePullDown: enablePullDown ?? true, enablePullUp: enablePullUp ?? true, header: header ?? const ClassicHeader(), footer: footer ?? const ClassicFooter(), onRefresh: onRefresh, onLoading: onLoading, child: child, ); &#125;&#125; SearchViewModel 代码如下： import &#x27;package:e_book_clone/http/spider/json_api.dart&#x27;;import &#x27;package:e_book_clone/models/book.dart&#x27;;import &#x27;package:e_book_clone/models/query_param.dart&#x27;;import &#x27;package:e_book_clone/models/suggest.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;class SearchViewModel extends ChangeNotifier &#123; int _currPage = 2; bool isDispose = false; List&lt;Book&gt;? _searchResult; List&lt;Book&gt;? get searchResult =&gt; _searchResult; Future&lt;List&lt;Suggest&gt;&gt; getSuggest(String keyword) async &#123; if (keyword.isEmpty) &#123; return []; &#125; return await JsonApi.instance().fetchSuggestV3(keyword); &#125; Future getResults(String keyword, bool loadMore, &#123;VoidCallback? callback&#125;) async &#123; if (loadMore) &#123; _currPage++; &#125; else &#123; _currPage = 1; _searchResult?.clear(); &#125; // 请求参数 SearchParam param = SearchParam( page: _currPage, rootKind: null, q: keyword, sort: &quot;defalut&quot;, query: SearchParam.ebookSearch, ); // 请求结果 List&lt;Book&gt; res = await JsonApi.instance().fetchEbookSearch(param); // 加载更多，使用addAll if (_searchResult == null) &#123; _searchResult = res; &#125; else &#123; _searchResult!.addAll(res); &#125; if (res.isEmpty &amp;&amp; _currPage &gt; 0) &#123; _currPage--; &#125; // 防止Provider被销毁，数据延迟请求去通知报错 if (isDispose) return; notifyListeners(); &#125;&#125; buildResults方法如下： @overrideWidget buildResults(BuildContext context) &#123; if (query.isEmpty) &#123; return const SizedBox(); &#125; return SearchResultPage(query: query);&#125; 显示搜索界面注意调用的是我们自己拷贝修改的MySearchDelegate中的方法 onTap: () &#123; showMySearch(context: context, delegate: SearchPage());&#125;,"},{"title":"主题切换","path":"/wiki/ebook/widget/theme_switch.html","content":"主题切换，跟随系统。当开启跟随系统之后，主题切换将失效。因此，如果跟随系统时切换主题，应该提醒用户先关闭跟随系统，再切换主题样式。"},{"title":"懒加载导航页","path":"/wiki/ebook/init/lazystack.html","content":"底部导航使用 LazyLoadIndexedStack 配合 BottomNavigationBar实现程序的导航页 flutter pub add lazy_load_indexed_stack 创建root_page.dart维护导航页 root_page.dartimport &#x27;package:e_book_clone/pges/home/home.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:lazy_load_indexed_stack/lazy_load_indexed_stack.dart&#x27;;class RootPage extends StatefulWidget &#123; const RootPage(&#123;super.key&#125;); @override State&lt;RootPage&gt; createState() =&gt; _RootPageState();&#125;class _RootPageState extends State&lt;RootPage&gt; &#123; int _currentIndex = 0; @override Widget build(BuildContext context) &#123; var bg = Theme.of(context).colorScheme.surface; return Scaffold( appBar: AppBar( elevation: 0, toolbarHeight: 0, backgroundColor: bg, surfaceTintColor: bg, ), backgroundColor: bg, bottomNavigationBar: _getBottomNavigator(context), body: LazyLoadIndexedStack( index: _currentIndex, children: const [ HomePage(), Center(child: Text(&#x27;1&#x27;)), Center(child: Text(&#x27;2&#x27;)), Center(child: Text(&#x27;3&#x27;)), ], ), ); &#125; Widget _getBottomNavigator(BuildContext context) &#123; return BottomNavigationBar( currentIndex: _currentIndex, onTap: (index) &#123; setState(() &#123; _currentIndex = index; &#125;); &#125;, items: List.generate( 4, (index) &#123; return BottomNavigationBarItem( label: &#x27;$index&#x27;, icon: const Icon(Icons.abc), ); &#125;, ), ); &#125;&#125; 导航页刷新方案使用全局状态来管理切换的下标，如果在当前页面点击跳转到当前页面的底部导航按钮，代表刷新页面。 状态管理使用Provider维护底部导航栏页下标，创建bottom_nav_provider.dart文件 bottom_nav_provider.dartclass BottomNavProvider with ChangeNotifier &#123; int _currentIndex = 0; Map&lt;int, Function()?&gt; refreshFuncs = &#123;&#125;; int get currentIndex =&gt; _currentIndex; set currentIndex(int currentIndex) &#123; _currentIndex = currentIndex; notifyListeners(); &#125; void refresh(int index) &#123; refreshFuncs[index]?.call(); &#125; void setIndex(int index) &#123; currentIndex = index; &#125;&#125; 修改导航页面，监听下标，同时判断是否是二次点击页面，即已经在当前页面时，再次点击导航到当前页面。 代码中用到的底部导航组件 flutter pub add salomon_bottom_bar import &#x27;package:e_book_clone/json/root_app_json.dart&#x27;;import &#x27;package:e_book_clone/pages/douban_read/douban_read_page.dart&#x27;;import &#x27;package:e_book_clone/pages/home/home_page.dart&#x27;;import &#x27;package:e_book_clone/pages/my_book/my_book_page.dart&#x27;;import &#x27;package:e_book_clone/pages/ebook_store/store_page.dart&#x27;;import &#x27;package:e_book_clone/pages/bottom_nav_provider.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:lazy_load_indexed_stack/lazy_load_indexed_stack.dart&#x27;;import &#x27;package:provider/provider.dart&#x27;;import &#x27;package:salomon_bottom_bar/salomon_bottom_bar.dart&#x27;;class RootPage extends StatelessWidget &#123; const RootPage(&#123;super.key&#125;); @override Widget build(BuildContext context) &#123; var bg = Theme.of(context).colorScheme.surface; return Scaffold( appBar: AppBar( elevation: 0, toolbarHeight: 0, backgroundColor: bg, surfaceTintColor: bg, ), backgroundColor: bg, bottomNavigationBar: _getBottomNavigator(context), body: LazyLoadIndexedStack( index: Provider.of&lt;BottomNavProvider&gt;(context).currentIndex, children: const [ HomePage(pageIndex: 0), DoubanReadPage(pageIndex: 1), StorePage(pageIndex: 2), MyBookPage(pageIndex: 3), ], ), ); &#125; Widget _getBottomNavigator(BuildContext context) &#123; var bottomNavProvider = Provider.of&lt;BottomNavProvider&gt;(context, listen: false); return SalomonBottomBar( currentIndex: Provider.of&lt;BottomNavProvider&gt;(context).currentIndex, onTap: (index) &#123; if (bottomNavProvider.currentIndex == index) &#123; // 两次点击同一个页面，刷新当前页面数据 bottomNavProvider.refresh(index); &#125; else &#123; bottomNavProvider.currentIndex = index; &#125; &#125;, items: List.generate( rootAppJson.length, (index) &#123; return SalomonBottomBarItem( selectedColor: Theme.of(context).colorScheme.onSurface, unselectedColor: Theme.of(context).colorScheme.inversePrimary, icon: Icon(rootAppJson[index][&#x27;icon&#x27;]), title: Text(rootAppJson[index][&#x27;text&#x27;]), ); &#125;, ), ); &#125;&#125; 初始化刷新方法当再次点击时，调用了刷新方法，该方法接受一个下标，即页面下标。执行对应页面的刷新方法，所以我们需要在页面初始化时将刷新方法添加到refreshFuncs中。 Map&lt;int, Function()?&gt; refreshFuncs = &#123;&#125;;void refresh(int index) &#123; refreshFuncs[index]?.call();&#125; 以HomePage为案例，代码如下 home/home_page.dartimport &#x27;package:flutter/material.dart&#x27;;import &#x27;package:provider/provider.dart&#x27;;import &#x27;package:e_book_clone/pages/home/home_vm.dart&#x27;;class HomePage extends StatefulWidget &#123; final int pageIndex; const HomePage(&#123;super.key, required this.pageIndex&#125;); @override State&lt;HomePage&gt; createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; final HomeViewModel _viewmodel = HomeViewModel(); @override void initState() &#123; super.initState(); // 进入页面时，请求一次数据 refreshPage(); // 初始化刷新方法，异步方式 Future.microtask(() &#123; Provider.of&lt;BottomNavProvider&gt;(context, listen: false) .refreshFuncs[widget.pageIndex] = refreshPage; &#125;); &#125; void refreshPage() &#123; // 请求数据 _viewmodel.getPageData(); &#125; @override Widget build(BuildContext context) &#123; return ChangeNotifierProvider&lt;HomeViewModel&gt;.value( value: _viewmodel, child: Scaffold( backgroundColor: Theme.of(context).colorScheme.surface, body: _getBody(), ), ); &#125; Widget _getBody() &#123; return const Center(child: Text(&#x27;HomePage&#x27;)); &#125;&#125;"},{"title":"屏幕适配","path":"/wiki/ebook/init/screenutil.html","content":"屏幕适配之后，为不同设备的DPI提供相同的大小，需要用到 flutter_screenutil 插件 flutter pub add flutter_screenutil 修改app.dart app.dartimport &#x27;package:e_book_clone/pges/home.dart&#x27;;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_screenutil/flutter_screenutil.dart&#x27;;Size get designSize &#123; final firstView = WidgetsBinding.instance.platformDispatcher.views.first; // 逻辑短边 final logicalShortestSide = firstView.physicalSize.shortestSide / firstView.devicePixelRatio; // 逻辑长边 final logicalLongestSide = firstView.physicalSize.longestSide / firstView.devicePixelRatio; // 缩放比例 designSize越小，元素越大 const scaleFactor = 0.95; return Size( logicalShortestSide * scaleFactor, logicalLongestSide * scaleFactor);&#125;class MyApp extends StatelessWidget &#123; const MyApp(&#123;super.key&#125;); @override Widget build(BuildContext context) &#123; return ScreenUtilInit( designSize: designSize, builder: (context, child) &#123; return MaterialApp( theme: ThemeData( useMaterial3: true, ), home: const HomePage(), ); &#125;, ); &#125;&#125; 使用案例 import &#x27;package:flutter_screenutil/flutter_screenutil.dart&#x27;;TextStyle(fontSize: 18.sp),Container( width: 15.w, height: 15.h, padding: EdgeInsets.all(15.r), margin: EdgeInsets.only(left: 15.w, right: 15.w, top: 15.h, bottom: 15.h), decoration: BoxDecoration(borderRadius: BorderRadius.circular(12.r)),)"},{"title":"主题适配","path":"/wiki/ebook/init/theme.html","content":"主题适配最好在新建项目时就考虑到 主题适配涉及到动态切换，需要用到状态管理。本项目用的是Provider flutter pub add provider 创建主题文件首先，创建 lib/pages/theme 文件夹 定义白天主题样式，创建light_theme.dart theme/light_theme.dartimport &#x27;package:flutter/material.dart&#x27;;ThemeData lightMode = ThemeData( useMaterial3: true, appBarTheme: const AppBarTheme( systemOverlayStyle: SystemUiOverlayStyle( statusBarColor: Colors.transparent, // 去除状态栏遮罩 statusBarIconBrightness: Brightness.dark, // 状态栏图标字体颜色 systemNavigationBarColor: Colors.white, // 底部导航栏颜色 ) ), colorScheme: ColorScheme.light( primary: Colors.lightBlue, onPrimary: Colors.white, secondary: Colors.grey.withOpacity(0.25), tertiary: const Color(0xFFEE4667), inversePrimary: Colors.grey.shade600, inverseSurface: Colors.grey.shade200, onInverseSurface: Colors.grey.shade100, surfaceContainer: Colors.grey.shade300, ),); 定义夜间主题样式，创建dark_theme.dart theme/dark_theme.dartimport &#x27;package:flutter/material.dart&#x27;;ThemeData darkMode = ThemeData( useMaterial3: true, appBarTheme: const AppBarTheme( systemOverlayStyle: SystemUiOverlayStyle( statusBarColor: Colors.transparent, statusBarIconBrightness: Brightness.light, systemNavigationBarColor: Color(0xff121212), // 和主背景surface保持一致 ) ), colorScheme: ColorScheme.dark( primary: Colors.blueAccent, onPrimary: Colors.white, secondary: Colors.grey.withOpacity(0.25), tertiary: const Color(0xFFEE4667), inversePrimary: Colors.grey.shade600, inverseSurface: Colors.black87, onInverseSurface: Colors.black26, surfaceContainer: Colors.grey.shade300, ),); 状态管理创建theme_provider.dart文件 theme/theme_provider.dartimport &#x27;package:flutter/material.dart&#x27;;import &#x27;package:e_book_demo/themes/dark_theme.dart&#x27;;import &#x27;package:e_book_demo/themes/light_theme.dart&#x27;;import &#x27;package:e_book_demo/utils/constants.dart&#x27;;import &#x27;package:e_book_demo/utils/shared_prefs_utils.dart&#x27;;class ThemeProvider with ChangeNotifier &#123; ThemeMode _themeMode = ThemeMode.system; ThemeData get darkTheme =&gt; darkMode; ThemeData get lightTheme =&gt; lightMode; ThemeMode get themeMode =&gt; _themeMode; set themeMode(ThemeMode themeMode) &#123; _themeMode = themeMode; notifyListeners(); &#125; init() async &#123; String tmpThemeMode = await SharedPrefsUtils.getString(Constants.keyThemeMode, &quot;system&quot;); changeTheme(tmpThemeMode, notify: false); &#125; void changeTheme(String themeName, &#123;bool notify = true&#125;) &#123; if (themeName == &quot;dark&quot;) &#123; themeMode = ThemeMode.dark; &#125; else if (themeName == &quot;system&quot;) &#123; themeMode = ThemeMode.system; &#125; else &#123; themeMode = ThemeMode.light; &#125; if (notify) &#123; notifyListeners(); &#125; &#125;&#125; 注册全局状态，修改main.dart main.dartimport &#x27;package:flutter/material.dart&#x27;;import &#x27;package:e_book_demo/app.dart&#x27;;import &#x27;package:e_book_demo/themes/theme_provider.dart&#x27;;import &#x27;package:provider/provider.dart&#x27;;void main() &#123; WidgetsFlutterBinding.ensureInitialized(); ThemeProvider theme = ThemeProvider()..init(); runApp( MultiProvider( providers: [ // 主题 ChangeNotifierProvider&lt;ThemeProvider&gt;.value(value: theme) ], child: const MyApp(), ), );&#125; 注册主题，修改app.dart 注意，增加darkTheme后，主题会跟随系统，这时theme不再生效 app.dart...@overrideWidget build(BuildContext context) &#123; return ScreenUtilInit( designSize: designSize, builder: (context, child) &#123; return MaterialApp( title: &#x27;Flutter Demo&#x27;, theme: Provider.of&lt;ThemeProvider&gt;(context).lightTheme, darkTheme: Provider.of&lt;ThemeProvider&gt;(context).darkTheme, themeMode: Provider.of&lt;ThemeProvider&gt;(context).themeMode, debugShowCheckedModeBanner: false, home: const RootScreen(), ); &#125;, );&#125; 使用颜色代码主题配置好之后如何使用呢？ 通过Theme.of(context).colorScheme.来指定颜色 import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_screenutil/flutter_screenutil.dart&#x27;;class HomePage extends StatefulWidget &#123; const HomePage(&#123;super.key&#125;); @override State&lt;HomePage&gt; createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( elevation: 0, toolbarHeight: 0, backgroundColor: Theme.of(context).colorScheme.surface, surfaceTintColor: Theme.of(context).colorScheme.surface, ), body: Center( child: Text( &#x27;Home&#x27;, style: TextStyle( color: Theme.of(context).colorScheme.onSurface, fontSize: 18.r, ), )), ); &#125;&#125;"},{"title":"修改应用名称","path":"/wiki/flutter-dev/windows/name.html","content":"打开windows/runner/main.cpp文件，修改内容如下： int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev, _In_ wchar_t *command_line, _In_ int show_command) &#123; // ... FlutterWindow window(project); Win32Window::Point origin(10, 10); Win32Window::Size size(1280, 720); // 这里修改软件名，例如：AFAN if (!window.Create(L&quot;AFAN&quot;, origin, size)) &#123; return EXIT_FAILURE; &#125; window.SetQuitOnClose(true); // ...&#125; 说明：如果中文显示乱码，那么就使用VS Code编辑main.cpp文件并以utf-8-with BOM编码保存。"},{"title":"修改应用图标","path":"/wiki/flutter-dev/windows/icon.html","content":"Windows应用图标设计指南 Windows应用需要一个48x48像素的.ico图标 1、设计图标使用任意设计软件制作图标，例如使用稿定设计创建一个256x256尺寸，底色为透明的画布，在其中放入图标 如果带背景色，充满画布即可 如果单图标，尽可能铺满整个画布 2、生成图标Windows需要一个.ico格式的图标，我们使用在线工具生成一个48*48的透明背景图标。 3、覆盖图标 进入项目/windows/runner/resources，删除其中的app_icon.ico文件； 复制我们生成的图标，命名为app_icon.ico； 重新调试项目，即可看到效果。"},{"title":"修改应用名称","path":"/wiki/flutter-dev/mac/name.html","content":"打开macos/Runner/Configs/AppInfo.xcconfig文件，修改内容如下： PRODUCT_NAME：应用名称 PRODUCT_BUNDLE_IDENTIFIER：应用包名 // Application-level settings for the Runner target.//// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the// future. If not, the values below would default to using the project name when this becomes a// &#x27;flutter create&#x27; template.// The application&#x27;s name. By default this is also the title of the Flutter window.PRODUCT_NAME = 软件名称// The application&#x27;s bundle identifierPRODUCT_BUNDLE_IDENTIFIER = com.swx.video// The copyright displayed in application informationPRODUCT_COPYRIGHT = Copyright © 2024 com.swx.video. All rights reserved."},{"title":"定制标题栏","path":"/wiki/flutter-dev/windows/title.html","content":"1、隐藏系统标题栏在使用window_manager之后，会隐藏系统的标题栏，我们无法移动窗口，没有Widnows右上角的三个按钮。 main.dartvoid main() async &#123; WindowOptions windowOptions = const WindowOptions( size: Size(1080, 780), // 基础尺寸 minimumSize: Size(1080, 780), // 最小尺寸 center: false, backgroundColor: Colors.transparent, skipTaskbar: false, titleBarStyle: TitleBarStyle.hidden, // 隐藏系统标题栏 ); windowManager.waitUntilReadyToShow(windowOptions, () async &#123; await windowManager.show(); await windowManager.focus(); &#125;);&#125; 2、自定义标题栏使用下面的代码生成可拖拽区域和三个功能按钮 具体的布局请根据实际情况自定义。 代码生成的三个按钮没有Windows 11的snap layout功能。 Row( children: [ // 拖动区域 Expanded( child: const DragToMoveArea( child: SizedBox(height: 76, width: double.infinity), ), ), SizedBox( height: kWindowCaptionHeight, width: 138, child: WindowCaption( brightness: Theme.of(context).brightness, backgroundColor: Colors.transparent, ), ) ],),"},{"title":"修改应用图标","path":"/wiki/flutter-dev/mac/icon.html","content":"Mac应用图标设计指南 1、下载设计资源下载MacOS的设计资源文件：Production Templates，下载完成双击.dmg解压。 2、设计图标使用即时设计打开其中的Template - Icon - App.sketch文件 在设计好所有尺寸的图标之后，可以选中，在右下角导出png 3、编排图标我们按照要求规范文件命名，创建AppIcon.appiconset文件夹，文件如下： AppIcon.appiconset├── Contents.json├── icon-16.png├── icon-16@2x.png├── icon-32.png├── icon-32@2x.png├── icon-128.png├── icon-128@2x.png├── icon-256.png├── icon-256@2x.png├── icon-512.png└── icon-512@2x.png 其中Contents.json内容如下： &#123; &quot;images&quot;: [ &#123; &quot;size&quot;: &quot;16x16&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-16.png&quot;, &quot;scale&quot;: &quot;1x&quot; &#125;, &#123; &quot;size&quot;: &quot;16x16&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-16@2x.png&quot;, &quot;scale&quot;: &quot;2x&quot; &#125;, &#123; &quot;size&quot;: &quot;32x32&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-32.png&quot;, &quot;scale&quot;: &quot;1x&quot; &#125;, &#123; &quot;size&quot;: &quot;32x32&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-32@2x.png&quot;, &quot;scale&quot;: &quot;2x&quot; &#125;, &#123; &quot;size&quot;: &quot;128x128&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-128.png&quot;, &quot;scale&quot;: &quot;1x&quot; &#125;, &#123; &quot;size&quot;: &quot;128x128&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-128@2x.png&quot;, &quot;scale&quot;: &quot;2x&quot; &#125;, &#123; &quot;size&quot;: &quot;256x256&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-256.png&quot;, &quot;scale&quot;: &quot;1x&quot; &#125;, &#123; &quot;size&quot;: &quot;256x256&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-256@2x.png&quot;, &quot;scale&quot;: &quot;2x&quot; &#125;, &#123; &quot;size&quot;: &quot;512x512&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-512.png&quot;, &quot;scale&quot;: &quot;1x&quot; &#125;, &#123; &quot;size&quot;: &quot;512x512&quot;, &quot;idiom&quot;: &quot;mac&quot;, &quot;filename&quot;: &quot;icon-512@2x.png&quot;, &quot;scale&quot;: &quot;2x&quot; &#125; ], &quot;info&quot;: &#123; &quot;version&quot;: 1, &quot;author&quot;: &quot;icon.wuruihong.com&quot; &#125;&#125; 4、覆盖图标 进入项目/macos/Runner/Assets.xcassets，删除其中的AppIcon.appiconset目录； 复制我们创建的AppIcon.appiconset目录； 重新调试项目，即可看到效果。"},{"title":"系统菜单栏","path":"/wiki/flutter-dev/mac/menu.html","content":"保留部分原生菜单添加插件使用我修改过的插件，该插件能够保留window、help两个Mac原生菜单。 macos_menu: git: url: https://github.com/SX-Code/macos_menu.git ref: main 插件原作者: https://github.com/intonarumori/macos_menu.git 使用插件1、生成自定义的菜单 // 枚举，便于循环enum VideoClass &#123; home(&#x27;首页&#x27;), movie(&quot;电影&quot;), skits(&quot;短剧&quot;), drama(&quot;电视剧&quot;), anime(&quot;动漫&quot;), documentary(&quot;综艺&quot;), variety(&quot;纪录片&quot;); const VideoClass(this.name); final String name;&#125;// 生成自定义菜单，并绑定快捷按键List&lt;MacosMenuItem&gt; _buildMenuItem() &#123; List&lt;MacosMenuItem&gt; res = []; List&lt;VideoClass&gt; enums = VideoClass.values; int i = 0; for (i = 0; i &lt; enums.length; i++) &#123; int index = i; // 需要这样写 res.add( MacosMenuItem( label: enums[i].name, shortcut: CharacterActivator(&#x27;$index&#x27;, meta: true), onSelected: () &#123; // 使用Provider跳转指定的页面 Provider.of&lt;RootProvider&gt;( NavigatorProvider.navigatorKey.currentState!.context, listen: false, ).index = index; &#125;, ), ); &#125; res.add(MacosMenuItem( label: &quot;片单&quot;, shortcut: CharacterActivator(&#x27;$&#123;i + 1&#125;&#x27;, meta: true), onSelected: () &#123; Provider.of&lt;RootProvider&gt;( NavigatorProvider.navigatorKey.currentState!.context, listen: false, ).index = i; &#125;, )); return res;&#125; 2、定义顶级菜单选项 List&lt;MacosMenuItem&gt; _buildTopLevelMenus() &#123; return [ MacosMenu(label: &quot;Main&quot;, menus: [ MacosMenuItemGroup(members: [ if (MacosPlatformProvidedMenuItem.hasMenu( MacosPlatformProvidedMenuItemType.about)) ...[ const MacosPlatformProvidedMenuItem( type: MacosPlatformProvidedMenuItemType.about) ], ]), MacosMenuItem( label: &quot;设置&quot;, onSelected: () &#123; Provider.of&lt;RootProvider&gt;( NavigatorProvider.navigatorKey.currentState!.context, listen: false, ).index = 8; &#125;, ), MacosMenuItemGroup(members: [ if (MacosPlatformProvidedMenuItem.hasMenu( MacosPlatformProvidedMenuItemType.servicesSubmenu)) ...[ const MacosPlatformProvidedMenuItem( type: MacosPlatformProvidedMenuItemType.servicesSubmenu) ], ]), if (MacosPlatformProvidedMenuItem.hasMenu( MacosPlatformProvidedMenuItemType.quit)) ...[ const MacosPlatformProvidedMenuItem( type: MacosPlatformProvidedMenuItemType.quit) ], ]), // 自定义菜单项 MacosMenu(label: &quot;影视&quot;, menus: _buildMenuItem()), ];&#125; 3、定义帮助菜单选项 var helpItems = [ MacosMenuItem( label: &#x27;Visit Website&#x27;, shortcut: const CharacterActivator(&quot;w&quot;, meta: true), onSelected: () &#123;&#125;, ),]; 4、设置菜单 void main(List&lt;String&gt; args) async &#123; WidgetsFlutterBinding.ensureInitialized(); // 设置菜单项, 只针对MacOS MacosMenuBinding.instance.delegate.setMenus(_buildTopLevelMenus(), helpItems); runApp(child: const MyApp());&#125; 代码解释 下面的代码中使用了插件provider，其属性index绑定了stack的 index 属性，当给index赋值时，会通知 stack 切换页面。 class RootProvider extends ChangeNotifier &#123;int _index = 0;int get index =&gt; _index;set index(int index) &#123; _index = index; notifyListeners(); // 通知组件更新&#125;&#125; NavigatorProvider.navigatorKey.currentState!.context，该context在此刻并未被赋值，当页面出现时，才会被赋值。 MaterialApp(navigatorKey: NavigatorProvider.navigatorKey,) Provider.of&lt;RootProvider&gt;( NavigatorProvider.navigatorKey.currentState!.context, listen: false,).index = 8; 菜单汉化使用Xcode打开项目中的macos，在Runner-&gt;Info-&gt;Localozations中添加简体中文汉化，会帮我们生成汉化文件。 打开生成的文件：macos/Runner/zh-Hans.lproj/MainMenu.strings，根据需要汉化内容，案例如下： /* Class = &quot;NSMenuItem&quot;; title = &quot;APP_NAME&quot;; ObjectID = &quot;1Xt-HY-uBw&quot;; */&quot;1Xt-HY-uBw.title&quot; = &quot;APP_NAME&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Find&quot;; ObjectID = &quot;1b7-l0-nxx&quot;; */&quot;1b7-l0-nxx.title&quot; = &quot;查找&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Transformations&quot;; ObjectID = &quot;2oI-Rn-ZJC&quot;; */&quot;2oI-Rn-ZJC.title&quot; = &quot;Transformations&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Spelling&quot;; ObjectID = &quot;3IN-sU-3Bg&quot;; */&quot;3IN-sU-3Bg.title&quot; = &quot;Spelling&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Speech&quot;; ObjectID = &quot;3rS-ZA-NoH&quot;; */&quot;3rS-ZA-NoH.title&quot; = &quot;Speech&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Find&quot;; ObjectID = &quot;4EN-yA-p0u&quot;; */&quot;4EN-yA-p0u.title&quot; = &quot;查找&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Enter Full Screen&quot;; ObjectID = &quot;4J7-dP-txa&quot;; */&quot;4J7-dP-txa.title&quot; = &quot;进入全屏&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Quit APP_NAME&quot;; ObjectID = &quot;4sb-4s-VLi&quot;; */&quot;4sb-4s-VLi.title&quot; = &quot;退出 APP_NAME&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Edit&quot;; ObjectID = &quot;5QF-Oa-p0T&quot;; */&quot;5QF-Oa-p0T.title&quot; = &quot;编辑&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;About APP_NAME&quot;; ObjectID = &quot;5kV-Vb-QxS&quot;; */&quot;5kV-Vb-QxS.title&quot; = &quot;关于 APP_NAME&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Redo&quot;; ObjectID = &quot;6dh-zS-Vam&quot;; */&quot;6dh-zS-Vam.title&quot; = &quot;Redo&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Correct Spelling Automatically&quot;; ObjectID = &quot;78Y-hA-62v&quot;; */&quot;78Y-hA-62v.title&quot; = &quot;Correct Spelling Automatically&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Substitutions&quot;; ObjectID = &quot;9ic-FL-obx&quot;; */&quot;9ic-FL-obx.title&quot; = &quot;Substitutions&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Smart Copy/Paste&quot;; ObjectID = &quot;9yt-4B-nSM&quot;; */&quot;9yt-4B-nSM.title&quot; = &quot;Smart Copy/Paste&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Main Menu&quot;; ObjectID = &quot;AYu-sK-qS6&quot;; */&quot;AYu-sK-qS6.title&quot; = &quot;Main Menu&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Preferences…&quot;; ObjectID = &quot;BOF-NM-1cW&quot;; */&quot;BOF-NM-1cW.title&quot; = &quot;Preferences…&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Spelling and Grammar&quot;; ObjectID = &quot;Dv1-io-Yv7&quot;; */&quot;Dv1-io-Yv7.title&quot; = &quot;Spelling and Grammar&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Help&quot;; ObjectID = &quot;EPT-qC-fAb&quot;; */&quot;EPT-qC-fAb.title&quot; = &quot;帮助&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Substitutions&quot;; ObjectID = &quot;FeM-D8-WVr&quot;; */&quot;FeM-D8-WVr.title&quot; = &quot;Substitutions&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;View&quot;; ObjectID = &quot;H8h-7b-M4v&quot;; */&quot;H8h-7b-M4v.title&quot; = &quot;View&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Text Replacement&quot;; ObjectID = &quot;HFQ-gK-NFA&quot;; */&quot;HFQ-gK-NFA.title&quot; = &quot;Text Replacement&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Show Spelling and Grammar&quot;; ObjectID = &quot;HFo-cy-zxI&quot;; */&quot;HFo-cy-zxI.title&quot; = &quot;Show Spelling and Grammar&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;View&quot;; ObjectID = &quot;HyV-fh-RgO&quot;; */&quot;HyV-fh-RgO.title&quot; = &quot;View&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Show All&quot;; ObjectID = &quot;Kd2-mp-pUS&quot;; */&quot;Kd2-mp-pUS.title&quot; = &quot;Show All&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Bring All to Front&quot;; ObjectID = &quot;LE2-aR-0XJ&quot;; */&quot;LE2-aR-0XJ.title&quot; = &quot;全部置于顶层&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Services&quot;; ObjectID = &quot;NMo-om-nkz&quot;; */&quot;NMo-om-nkz.title&quot; = &quot;服务&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Minimize&quot;; ObjectID = &quot;OY7-WF-poV&quot;; */&quot;OY7-WF-poV.title&quot; = &quot;最小化&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Hide APP_NAME&quot;; ObjectID = &quot;Olw-nP-bQN&quot;; */&quot;Olw-nP-bQN.title&quot; = &quot;隐藏 APP_NAME&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Find Previous&quot;; ObjectID = &quot;OwM-mh-QMV&quot;; */&quot;OwM-mh-QMV.title&quot; = &quot;Find Previous&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Stop Speaking&quot;; ObjectID = &quot;Oyz-dy-DGm&quot;; */&quot;Oyz-dy-DGm.title&quot; = &quot;Stop Speaking&quot;;/* Class = &quot;NSWindow&quot;; title = &quot;APP_NAME&quot;; ObjectID = &quot;QvC-M9-y7g&quot;; */&quot;QvC-M9-y7g.title&quot; = &quot;APP_NAME&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Zoom&quot;; ObjectID = &quot;R4o-n2-Eq4&quot;; */&quot;R4o-n2-Eq4.title&quot; = &quot;缩放&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Select All&quot;; ObjectID = &quot;Ruw-6m-B2m&quot;; */&quot;Ruw-6m-B2m.title&quot; = &quot;Select All&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Jump to Selection&quot;; ObjectID = &quot;S0p-oC-mLd&quot;; */&quot;S0p-oC-mLd.title&quot; = &quot;Jump to Selection&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Window&quot;; ObjectID = &quot;Td7-aD-5lo&quot;; */&quot;Td7-aD-5lo.title&quot; = &quot;窗口&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Capitalize&quot;; ObjectID = &quot;UEZ-Bs-lqG&quot;; */&quot;UEZ-Bs-lqG.title&quot; = &quot;Capitalize&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Hide Others&quot;; ObjectID = &quot;Vdr-fp-XzO&quot;; */&quot;Vdr-fp-XzO.title&quot; = &quot;Hide Others&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Edit&quot;; ObjectID = &quot;W48-6f-4Dl&quot;; */&quot;W48-6f-4Dl.title&quot; = &quot;编辑&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Paste and Match Style&quot;; ObjectID = &quot;WeT-3V-zwk&quot;; */&quot;WeT-3V-zwk.title&quot; = &quot;Paste and Match Style&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Find…&quot;; ObjectID = &quot;Xz5-n4-O0W&quot;; */&quot;Xz5-n4-O0W.title&quot; = &quot;Find…&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Find and Replace…&quot;; ObjectID = &quot;YEy-JH-Tfz&quot;; */&quot;YEy-JH-Tfz.title&quot; = &quot;Find and Replace…&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Start Speaking&quot;; ObjectID = &quot;Ynk-f8-cLZ&quot;; */&quot;Ynk-f8-cLZ.title&quot; = &quot;Start Speaking&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Window&quot;; ObjectID = &quot;aUF-d1-5bR&quot;; */&quot;aUF-d1-5bR.title&quot; = &quot;Window&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Use Selection for Find&quot;; ObjectID = &quot;buJ-ug-pKt&quot;; */&quot;buJ-ug-pKt.title&quot; = &quot;Use Selection for Find&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Transformations&quot;; ObjectID = &quot;c8a-y6-VQd&quot;; */&quot;c8a-y6-VQd.title&quot; = &quot;Transformations&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Smart Links&quot;; ObjectID = &quot;cwL-P1-jid&quot;; */&quot;cwL-P1-jid.title&quot; = &quot;Smart Links&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Make Lower Case&quot;; ObjectID = &quot;d9M-CD-aMd&quot;; */&quot;d9M-CD-aMd.title&quot; = &quot;Make Lower Case&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Undo&quot;; ObjectID = &quot;dRJ-4n-Yzg&quot;; */&quot;dRJ-4n-Yzg.title&quot; = &quot;Undo&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Paste&quot;; ObjectID = &quot;gVA-U4-sdL&quot;; */&quot;gVA-U4-sdL.title&quot; = &quot;Paste&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Smart Quotes&quot;; ObjectID = &quot;hQb-2v-fYv&quot;; */&quot;hQb-2v-fYv.title&quot; = &quot;Smart Quotes&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Check Document Now&quot;; ObjectID = &quot;hz2-CU-CR7&quot;; */&quot;hz2-CU-CR7.title&quot; = &quot;Check Document Now&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Services&quot;; ObjectID = &quot;hz9-B4-Xy5&quot;; */&quot;hz9-B4-Xy5.title&quot; = &quot;服务&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Check Grammar With Spelling&quot;; ObjectID = &quot;mK6-2p-4JG&quot;; */&quot;mK6-2p-4JG.title&quot; = &quot;Check Grammar With Spelling&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Delete&quot;; ObjectID = &quot;pa3-QI-u2k&quot;; */&quot;pa3-QI-u2k.title&quot; = &quot;Delete&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Find Next&quot;; ObjectID = &quot;q09-fT-Sye&quot;; */&quot;q09-fT-Sye.title&quot; = &quot;Find Next&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;Help&quot;; ObjectID = &quot;rJ0-wn-3NY&quot;; */&quot;rJ0-wn-3NY.title&quot; = &quot;帮助&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Check Spelling While Typing&quot;; ObjectID = &quot;rbD-Rh-wIN&quot;; */&quot;rbD-Rh-wIN.title&quot; = &quot;Check Spelling While Typing&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Smart Dashes&quot;; ObjectID = &quot;rgM-f4-ycn&quot;; */&quot;rgM-f4-ycn.title&quot; = &quot;Smart Dashes&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Data Detectors&quot;; ObjectID = &quot;tRr-pd-1PS&quot;; */&quot;tRr-pd-1PS.title&quot; = &quot;Data Detectors&quot;;/* Class = &quot;NSMenu&quot;; title = &quot;APP_NAME&quot;; ObjectID = &quot;uQy-DD-JDr&quot;; */&quot;uQy-DD-JDr.title&quot; = &quot;APP_NAME&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Cut&quot;; ObjectID = &quot;uRl-iY-unG&quot;; */&quot;uRl-iY-unG.title&quot; = &quot;Cut&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Make Upper Case&quot;; ObjectID = &quot;vmV-6d-7jI&quot;; */&quot;vmV-6d-7jI.title&quot; = &quot;Make Upper Case&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Copy&quot;; ObjectID = &quot;x3v-GG-iWU&quot;; */&quot;x3v-GG-iWU.title&quot; = &quot;Copy&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Speech&quot;; ObjectID = &quot;xrE-MZ-jX0&quot;; */&quot;xrE-MZ-jX0.title&quot; = &quot;Speech&quot;;/* Class = &quot;NSMenuItem&quot;; title = &quot;Show Substitutions&quot;; ObjectID = &quot;z6F-FW-3nz&quot;; */&quot;z6F-FW-3nz.title&quot; = &quot;Show Substitutions&quot;;"},{"title":"定制标题栏","path":"/wiki/flutter-dev/mac/title.html","content":"在使用window_manager之后，会隐藏系统的标题栏，在应用的左上角显示Mac原生的蓝绿灯，无法调整其位置。 main.dartvoid main() async &#123; WindowOptions windowOptions = const WindowOptions( size: Size(1080, 780), // 基础尺寸 minimumSize: Size(1080, 780), // 最小尺寸 center: false, backgroundColor: Colors.transparent, skipTaskbar: false, titleBarStyle: TitleBarStyle.hidden, // 隐藏系统标题栏 ); windowManager.waitUntilReadyToShow(windowOptions, () async &#123; await windowManager.show(); await windowManager.focus(); &#125;);&#125;"},{"title":"项目预览","path":"/wiki/oneread/preview.html","content":"部分界面预览"},{"title":"源规则","path":"/wiki/oneread/source_rule.html","content":"ONE阅读书源规则说明 作者：swcode 更新时间：2025-03-04 描述：本说明适用于ONE阅读APP。 语法说明基础说明1、类名：class.className调用的方法： // 用于获取多个标签node.getElementsByClassName(&quot;className&quot;); 2、元素：tag.a调用的方法： // 用于获取多个标签node.getElementsByTagName(&quot;a&quot;); 3、ID：id.nextPage调用的方法： // 用于获取一个标签node.getElementById(&quot;nextPage&quot;); 4、子元素：children // 用于获取多个标签node.children; 5、元素：text.下一页 if (element.innerText == &#x27;下一页&#x27;) &#123; // 当且仅当内容等于指定时返回标签 return element; &#125; 6、元素：name.下一页 if (element.getAttribute(&#x27;name&#x27;) == &#x27;下一页&#x27;) &#123; // 当且仅当name属性等于指定时返回标签 return element; &#125; 7、文本：text、textNode、textNodes textNode和textNodes，通常用于元素内既有标签也有文本的情况，其中textNodes用于获取多行文本。 // 用于获取标签内部文本，通常元素内容只是文本element.innerText 8、属性：href、src // 用于获取标签的属性element.getAttribute(&#x27;href&#x27;) 符号说明1、规则分隔符：@，用于分割多个规则。规则层级对应标签层级，通常用于获取最后一段规则对应的数据 // 先获取id为nextPage的标签，再获取其中的第一个a标签，最后获取a标签的hrefid.nextPage@tag.a.0@href 2、或连接符：||，从连接的第一个规则开始获取数据，如果获取到数据则停止获取 当同一类页面出现HTML标签不同、或者列表数据的第一个展示方式不同 // 先获取class.main@tag.li规则对应的数据，如果没获取到再获取class.mainPage@tag.li对应的数据class.main@tag.li||class.mainPage@tag.li// 先尝试获取当前标签内第一个a标签的href属性，如果获取不到，直接获取当前标签的href属性tag.a.0@href||href 3、且连接符：&amp;&amp;，合并所有规则获取到的数据，可以是文本或者多个标签 多用于获取资源详情页的kind数据 // 将class.sort@tag.span@text获取的文本和id.book_detail@tag.li.2@text获取的文本合并class.sort@tag.span@text&amp;&amp;id.book_detail@tag.li.2@text 4、选择符号：.0，用于选择多个标签中的一个，当规则只能获取到一个标签时可省略选择符号 序号从0开始，-1表示最后一个 选择当前标签中的第一个a标签，若tag.a只能获取到一个标签，则可省略.0 tag.a.0 选择当前标签中的第二个p标签 tag.p.2 5、排除符号：!0:-1，用于排除列表中的第一个和最后一个。正数从前面数、负数从后面数。 只作用于列表 // 先获取id为sectionList的标签，再获取其中所有的p标签，最后排除第一个和最后一个id.sectionList@tag.p!0:-1 6、倒序符号：-，将列表倒序 只作用于章节列表的获取 // 将p标签列表倒序-id.sectionList@tag.p 正则表达式 正则在线测试网站：https://www.jyshare.com/front-end/854/ 用于消除某些文本或者生成指定内容 ##正则表达式##替换内容// 或者##正则表达式##替换内容### 替换&#x2F;消除 // 第一段：将第三个p标签的文本中的“作者：”替换为空白，即消除“作者：”// 第二段：消除标签的文本内容中的“/”，使用textNode意味着当前标签内同时包含文本和标签// 上述两段使用 || 连接符，只有规则段匹配到数据时才会执行对应段的正则表达式tag.p.2@text##作者：###||textNode##/ 生成指定内容 // 使用正则：/s/(\\\\d+)(\\\\d&#123;3&#125;).html，匹配img标签的src属性// 使用匹配到的内容生成/files/article/image/$1/$1$2/$1$2s.jpgtag.img@src##/s/(\\\\d+)(\\\\d&#123;3&#125;).html##/files/article/image/$1/$1$2/$1$2s.jpg### 对于上述规则的实际应用说明： &lt;img src=&quot;/s/57679.html&quot;&gt;&lt;/img&gt;&lt;!-- 使用 /s/(\\\\d+)(\\\\d&#123;3&#125;).html 匹配的结果 $1=57，$2=679 --&gt;&lt;!-- 生成的结果 /files/article/image/57/57679/57679s.jpg --&gt; 可使用正则表达式在线测试网站进行测试，注意测试时将\\\\d+改为\\d+，在编制书源时需要将\\d+写为\\\\d+。 书源字段说明基本字段字段说明： 字段名 含义 必要性 说明 sourceName 源名称 必填 用于辨识源 sourceGroup 源分组 选填 用于过滤源 sourceUrl 源URL 必填 唯一标识，不可重复 sourceType 源类型 必填 0:书籍、1:漫画、2:听书、3:视频 charset 编码 选填 默认为utf-8，乱码时使用GBK order 排序 选填 自定义排序 enabled 启用 必填 是否启用源 header 网络请求头 选填 软件默认设置了User-Agent，如无需要，建议删除该字段 字段JSON数据 &#123; &quot;sourceName&quot;: &quot;源名称&quot;, &quot;sourceGroup&quot;: &quot;源分组&quot;, &quot;sourceUrl&quot;: &quot;https://源URL&quot;, &quot;sourceType&quot;: 1, &quot;charset&quot;: &quot;GBK&quot;, &quot;order&quot;: 1, &quot;enabled&quot;: true, &quot;header&quot;: &#123; &quot;User-Aget&quot;: &quot;XXX&quot; &#125;&#125; 发布页字段(rulePublishPage)字段说明，可根据页面显示数据和必要性填写： 字段名 含义 必要性 说明 url 发布页链接规则 选填 当网站拥有发布页时，可填写 list 网址列表规则 选填 一个或多个链接 customList 自定义网页链接 选填 手动置顶多个链接地址 字段JSON数据 &quot;rulePublishPage&quot;: &#123; &quot;url&quot;: &quot;https://&quot;, &quot;list&quot;: &quot;tag.li||class.block&quot;, &quot;customList&quot;: &quot;https://aa.com,https://bb.com&quot;&#125;, 首页字段(ruleHome)字段说明，可根据页面显示数据和必要性填写： 字段名 含义 必要性 说明 tileList 分组列表规则 必填 对应首页多个分组规则 customTitles 自定义分组名称 选填 当无法通过规则获取分组名称时指定，必须和分组长度对应 title 分组名称规则 必填 每个分组的标题规则 list 资源列表规则 必填 每个分组内的资源列表规则 name 资源名称规则 必填 资源列表中资源的名称规则 author 资源作者规则 必填 资源列表中资源的作者规则 url 资源URL规则 必填 资源列表中资源的URL规则 coverUrl 资源封面规则 必填 资源列表中资源的封面规则 score 资源分数&#x2F;热度规则 选填 用于显示资源评分规则 字段JSON数据 &quot;ruleHome&quot;: &#123; &quot;tileList&quot;: &quot;class.article&quot;, &quot;customTitles&quot;: &quot;最新电影,最新剧集,国产剧集,港台剧集,动漫,欧美剧集,日韩剧集&quot;, &quot;list&quot;: &quot;tag.li||class.block&quot;, &quot;title&quot;: &quot;class.title@tag.span@text&quot;, &quot;author&quot;: &quot;tag.p.2@text##作者：###||textNode##/&quot;, &quot;name&quot;: &quot;tag.h2@text||tag.a.0@text&quot;, &quot;coverUrl&quot;: &quot;tag.img@src@href##/s/(\\\\d+)(\\\\d&#123;3&#125;).html##/image/$1/$1$2/$1$2s.jpg###&quot;, &quot;url&quot;: &quot;tag.a.0@href&quot;&#125;, 搜索字段(ruleSearch)搜索链接字段说明： 字段名 含义 必要性 说明 searchUrl 搜索链接 必填 对应首页多个分组 1、GET请求:搜索关键词使用&#123;&#123;key&#125;&#125;占位 &quot;/book.php?action=search&amp;searchtype=novelname&amp;searchkey=&#123;&#123;key&#125;&#125;&quot; 2、POST请求：搜索关键词使用&#123;&#123;key&#125;&#125;占位，多个参数使用&amp;链接 逗号后的内容会被解析为JSON，其中body为formdata中的一个字段 &#123;&quot;method&quot;: &quot;POST&quot;, &quot;body&quot;: &#123; &quot;searchkey&quot;: &quot;剑来&quot;, &quot;submit&quot;: &quot;&quot; &#125;&#125; &quot;/search.php,&#123; \\&quot;method\\&quot; :\\&quot;POST\\&quot;, \\&quot;body\\&quot;: \\&quot;searchkey=&#123;&#123;key&#125;&#125;&amp;submit=\\&quot;&#125;&quot; 搜索结果字段说明，可根据页面显示数据和必要性填写： 字段名 含义 必要性 说明 list 资源列表规则 必填 资源列表 name 资源名称规则 必填 资源列表中资源的名称规则 author 资源作者规则 必填 资源列表中资源的作者规则 url 资源URL规则 必填 资源列表中资源的URL规则 coverUrl 资源封面规则 必填 资源列表中资源的封面规则 intro 资源简介规则 选填 资源列表中资源的简介规则 lastSection 最新章节规则 必填 资源列表中资源的最新章节规则 kind 分类规则 选填 资源列表中资源的分类规则 wordCount 字数规则 选填 资源列表中资源的字数规则 字段JSON数据 &quot;searchUrl&quot;: &quot;wap.xshuquge.net/search.php?searchkey=&#123;&#123;key&#125;&#125;&amp;submit=&quot;,&quot;ruleSearch&quot;: &#123; &quot;list&quot;: &quot;class.bookbox&quot;, &quot;name&quot;: &quot;tag.a.1@text&quot;, &quot;author&quot;: &quot;class.author@text##作者：&quot;, &quot;url&quot;: &quot;tag.a.0@href&quot;, &quot;coverUrl&quot;: &quot;tag.img@src&quot;, &quot;intro&quot;: &quot;class.intro_line@textNode&quot;, &quot;lastSection&quot;: &quot;tag.a.2@text&quot;, &quot;kind&quot;: &quot;&quot;, &quot;wordCount&quot;: &quot;&quot;&#125;, 探索字段(ruleExplore)探索字段说明： 字段名 含义 必要性 说明 exploreUrl 探索属性 必填 对应首页的探索列表 字段JSON数据 &quot;exploreUrl&quot;: &#123; &quot;分类&quot;: &#123; &quot;玄幻奇幻&quot;: &quot;/qihuan/&#123;&#123;page&#125;&#125;.html&quot;, &quot;仙侠修真&quot;: &quot;/xiuzhen/&#123;&#123;page&#125;&#125;.html&quot;, &quot;都市现代&quot;: &quot;/xiandai/&#123;&#123;page&#125;&#125;.html&quot;, &quot;青春校园&quot;: &quot;/qingchun/&#123;&#123;page&#125;&#125;.html&quot;, &quot;言情总裁&quot;: &quot;/yanqing/&#123;&#123;page&#125;&#125;.html&quot;, &quot;科幻未来&quot;: &quot;/weilai/&#123;&#123;page&#125;&#125;.html&quot;, &quot;网游竞技&quot;: &quot;/wangyou/&#123;&#123;page&#125;&#125;.html&quot;, &quot;军事历史&quot;: &quot;/junshi/&#123;&#123;page&#125;&#125;.html&quot;, &quot;恐怖悬疑&quot;: &quot;/xuanyi/&#123;&#123;page&#125;&#125;.html&quot;, &quot;穿越重生&quot;: &quot;/chuanyue/&#123;&#123;page&#125;&#125;.html&quot; &#125;, &quot;点击榜单&quot;: &#123; &quot;总点击榜&quot;: &quot;/novel/allvisit.html&quot;, &quot;月点击榜&quot;: &quot;/novel/monthvisit.html&quot;, &quot;周点击榜&quot;: &quot;/novel/weekvisit.html&quot; &#125;, &quot;推荐榜单&quot;: &#123; &quot;总推荐榜&quot;: &quot;/novel/allvote.html&quot;, &quot;月推荐榜&quot;: &quot;/novel/monthvote.html&quot;, &quot;周推荐榜&quot;: &quot;/novel/weekvote.html&quot; &#125;, &quot;其他榜单&quot;: &#123; &quot;总收藏榜&quot;: &quot;/novel/marknum.html&quot;, &quot;总字数榜&quot;: &quot;/novel/fontsize.html&quot;, &quot;评分人数&quot;: &quot;/novel/starnum.html&quot;, &quot;打赏人数&quot;: &quot;/novel/rewardnum.html&quot;, &quot;评分&quot;: &quot;/novel/star.html&quot;, &quot;打赏&quot;: &quot;/novel/reward.html&quot; &#125;, &quot;最新&quot;: &#123; &quot;新书入库&quot;: &quot;/novel/postdate.html&quot;, &quot;最近更新&quot;: &quot;/novel/lastupdate.html&quot; &#125;&#125;, 1、分页说明：链接中使用&#123;&#123;page&#125;&#125;占位 2、层级说明：最多为2层。下面的层级为3层，不被支持。 &#123; &quot;分类&quot;: &#123; &quot;玄幻奇幻&quot;: &#123; &quot;玄幻奇幻1&quot;: &quot;/qihuan/&#123;&#123;page&#125;&#125;.html&quot; &#125; &#125;&#125; 搜索结果字段说明，可根据页面显示数据和必要性填写： 字段名 含义 必要性 说明 list 资源列表规则 必填 资源列表 name 资源名称规则 必填 资源列表中资源的名称规则 author 资源作者规则 必填 资源列表中资源的作者规则 url 资源URL规则 必填 资源列表中资源的URL规则 coverUrl 资源封面规则 必填 资源列表中资源的封面规则 intro 资源简介规则 选填 资源列表中资源的简介规则 lastSection 最新章节规则 选填 资源列表中资源的最新章节规则 kind 分类规则规则 选填 资源列表中资源的分类规则 wordCount 字数规则规则 选填 资源列表中资源的字数规则 字段JSON数据 &quot;ruleExplore&quot;: &#123; &quot;list&quot;: &quot;id.newscontent@class.l@tag.li||class.novelslist2@tag.li!0&quot;, &quot;name&quot;: &quot;tag.a.0@text&quot;, &quot;author&quot;: &quot;class.s4@text||class.s5@text&quot;, &quot;url&quot;: &quot;tag.a.0@href&quot;, &quot;coverUrl&quot;: &quot;tag.img.0@href&quot;, &quot;intro&quot;: &quot;&quot;, &quot;lastSection&quot;: &quot;&quot;, &quot;kind&quot;: &quot;&quot;, &quot;wordCount&quot;: &quot;&quot;&#125;, 详情字段(ruleInfo)字段说明，可根据页面显示数据和必要性填写： 字段名 含义 必要性 说明 name 资源名称规则 选填 资源的名称规则 author 资源作者规则 选填 资源的作者规则 coverUrl 资源封面规则 选填 资源的封面规则 intro 资源简介规则 必填 资源详情页的简介规则 kind 资源分类规则 必填 资源详情页的标签规则，通常为多个使用&amp;&amp;拼接 lastSection 资源最新章节规则 选填 作为标签显示，可以直接使用&amp;&amp;拼接到kind sectionUrl 章节列表URL规则 必填 所有章节列表的链接地址规则，可以是本页面URL 字段JSON数据 &quot;ruleInfo&quot;: &#123; &quot;name&quot;: &quot;class.block_txt2@tag.a.1@text&quot;, &quot;author&quot;: &quot;class.block_txt2@tag.p.2@text##作者：&quot;, &quot;coverUrl&quot;: &quot;class.block_img2@tag.img@src&quot;, &quot;intro&quot;: &quot;class.intro_info@text&quot;, &quot;kind&quot;: &quot;class.block_txt2@tag.a.2@text&amp;&amp;class.block_txt2@tag.p.4@text&quot;, &quot;lastSection&quot;: &quot;class.block_txt2@tag.p.6@tag.a@text&quot;, &quot;sectionUrl&quot;: &quot;class.block_txt2@tag.a.0@href&quot;&#125;, 目录字段(ruleToc)字段说明，可根据页面显示数据和必要性填写： 字段名 含义 必要性 说明 lineList 线路列表规则 选填 多线路规则，一般用于视频源 sectionList 小节列表规则 必填 资源目录&#x2F;视频剧集小节列表规则，APP需要的是倒序，根据实际情况使用-将列表倒置 sectionName 小节名称规则 必填 小节的名称规则 sectionUrl 章节URL规则 必填 小节的URL规则，用于获取资源内容 nextTocUrl 下一部分目录URL规则 选填 当小节需要分页跳转时，填写；页面已经显示了全部小节，不填 字段JSON数据 &quot;ruleToc&quot;: &#123; &quot;lineList&quot;: &quot;class.module-play-list&quot;, &quot;sectionList&quot;: &quot;class.chapter.1@tag.a||class.chapter@tag.a&quot;, &quot;sectionName&quot;: &quot;text&quot;, &quot;sectionUrl&quot;: &quot;href&quot;, &quot;nextTocUrl&quot;: &quot;class.right@class.onclick@href&quot;&#125;, 正文字段(ruleContent)字段说明，可根据页面显示数据和必要性填写： 字段名 含义 必要性 说明 content 内容规则 必填 章节的内容规则 nextContentUrl 下一页的URL规则 必填 网站将章节分页时，填写 purifyRule 净化正则规则 必填 净化规则，使用列表，效率高 enabledSniff 是否开启嗅探 选填 只有视频资源时可用。如果是视频源，建议直接开启嗅探 字段JSON数据 &quot;ruleContent&quot;: &#123; &quot;content&quot;: &quot;id.nr1@textNodes&quot;, &quot;nextContentUrl&quot;: &quot;id.pb_next@text.下一页@href&quot;, &quot;enabledSniff&quot;: false, &quot;purifyRule&quot;: [ &quot;.+第.*页&quot;, &quot;.+下一页继续阅读.+&quot; ]&#125;, 书源案例空书源&#123; &quot;sourceName&quot;: &quot;源名称&quot;, &quot;sourceGroup&quot;: &quot;源分组&quot;, &quot;sourceUrl&quot;: &quot;https://源URL&quot;, &quot;sourceType&quot;: 1, &quot;charset&quot;: &quot;网页编码，乱码填GBK，否则删除该字段&quot;, &quot;order&quot;: 1, &quot;enabled&quot;: true, &quot;rulePublishPage&quot;: &#123; &quot;url&quot;: &quot;发布页网址&quot;, &quot;list&quot;: &quot;网址列表规则&quot;, &quot;customList&quot;: &quot;自定义网址, 英文逗号分隔&quot; &#125;, &quot;ruleHome&quot;: &#123; &quot;tileList&quot;: &quot;组列表规则&quot;, &quot;customTitles&quot;: &quot;自定义组标题, 英文逗号分隔&quot;, &quot;title&quot;: &quot;组标题规则&quot;, &quot;list&quot;: &quot;资源列表规则&quot;, &quot;name&quot;: &quot;资源名称规则&quot;, &quot;author&quot;: &quot;资源作者规则&quot;, &quot;coverUrl&quot;: &quot;资源封面规则&quot;, &quot;url&quot;: &quot;资源网址规则&quot; &#125;, &quot;ruleInfo&quot;: &#123; &quot;name&quot;: &quot;资源名称规则&quot;, &quot;author&quot;: &quot;资源作者规则&quot;, &quot;coverUrl&quot;: &quot;资源封面规则&quot;, &quot;intro&quot;: &quot;资源简介规则&quot;, &quot;kind&quot;: &quot;资源分类规则&quot;, &quot;lastSection&quot;: &quot;最新节规则，不填，或者使用&amp;&amp;和kind合并&quot;, &quot;sectionUrl&quot;: &quot;小节网址规则，缺省表示本书籍网址&quot; &#125;, &quot;ruleToc&quot;: &#123; &quot;lineList&quot;: &quot;线路列表源，用于视频源&quot;, &quot;sectionList&quot;: &quot;小节列表规则&quot;, &quot;sectionName&quot;: &quot;小节名称&quot;, &quot;sectionUrl&quot;: &quot;小节网址&quot;, &quot;nextTocUrl&quot;: &quot;下一部分目录网址，没有可不填&quot; &#125;, &quot;exploreUrl&quot;: &#123; &quot;类别&quot;: &#123; &quot;名称&quot;: &quot;网址&quot; &#125;, &quot;名称&quot;: &quot;网址&quot; &#125;, &quot;ruleExplore&quot;: &#123; &quot;list&quot;: &quot;资源列表规则&quot;, &quot;name&quot;: &quot;资源名称规则&quot;, &quot;author&quot;: &quot;资源作者规则&quot;, &quot;coverUrl&quot;: &quot;资源封面规则&quot;, &quot;url&quot;: &quot;资源网址规则&quot;, &quot;intro&quot;: &quot;资源简介规则&quot;, &quot;lastSection&quot;: &quot;最新节规则&quot;, &quot;kind&quot;: &quot;资源分类规则&quot;, &quot;wordCount&quot;: &quot;资源字体规则&quot; &#125;, &quot;searchUrl&quot;: &quot;搜素网址&quot;, &quot;ruleSearch&quot;: &#123; &quot;list&quot;: &quot;资源列表规则&quot;, &quot;name&quot;: &quot;资源名称规则&quot;, &quot;author&quot;: &quot;资源作者规则&quot;, &quot;coverUrl&quot;: &quot;资源封面规则&quot;, &quot;url&quot;: &quot;资源网址规则&quot;, &quot;intro&quot;: &quot;资源简介规则&quot;, &quot;lastSection&quot;: &quot;最新节规则&quot;, &quot;kind&quot;: &quot;资源分类规则&quot;, &quot;wordCount&quot;: &quot;资源字体规则&quot; &#125;, &quot;ruleContent&quot;: &#123; &quot;content&quot;: &quot;资源正文&quot;, &quot;nextContentUrl&quot;: &quot;下一部分正文规则，适用于章节被分页显示&quot;, &quot;enabledSniff&quot;: false, &quot;purifyRule&quot;: [&quot;正则&quot;, &quot;净化&quot;, &quot;规则&quot;] &#125;&#125;"},{"title":"项目介绍","path":"/wiki/oneread/index.html","content":"介绍 OneRead - ONE阅读是一个使用Flutter构建的集书籍、漫画、听书和视频资源为一体的手机APP。使用自定义源来解析对应的资源，以舒适的UI来展示数据。你可以在APP中阅读书籍，阅读漫画、听书以及观看视频；使用APP导入、查看、编辑源等。ONE阅读，不只阅读。 开发进度 支持视频源、小说源和漫画源，支持导入、创建、修改源 支持本地和在线小说阅读，支持本地小说导入，格式为txt 支持本地电子书的导入和阅读，支持格式如下：epub &#x2F; mobi &#x2F; azw3 &#x2F; fb2 &#x2F; cbz &#x2F; pdf 支持在线漫画阅读 支持在线视频播放，包括两种播放器：原生播放器和网页播放器，两种播放器的UI基本一致。网页播放器基本支持所有视频网站 支持将在线资源收藏到本地，并进行管理和更新 IPhone&#x2F;Android版本支持制作追番表 Mac&#x2F;Windows版本基本开发完成，已同步上述大部分功能 Mac&#x2F;Windows端支持两种小说阅读布局，优雅和沉浸布局 体验 Android: Android体验版下载 IPhone:IPhone体验版下载-需自签名 Mac: MacOS体验版下载 Windows: B站视频 敬请期待！ 群聊 如有问题和建议进群QQ：361777353"}]